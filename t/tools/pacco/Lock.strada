/*
 Strada Package Manager - Lock file handling

 Generates and parses Strada.lock files for reproducible builds.
*/

package Pacco::Lock;

# Parse a Strada.lock file
func parse(str $path) scalar {
    if (sys::file_exists($path) == 0) {
        return undef;
    }

    my str $content = slurp($path);
    return Pacco::Lock::parse_string($content);
}

# Parse lock file content
func parse_string(str $content) scalar {
    my hash %packages = ();
    my array @lines = split("\n", $content);

    my str $current_name = "";
    my hash %current_pkg = ();

    foreach my str $line (@lines) {
        # Skip comments
        if (length($line) > 0 && substr($line, 0, 1) eq "#") {
            next;
        }

        # Package block start
        if ($line eq "[[package]]") {
            # Save previous package if exists
            if ($current_name ne "") {
                $packages{$current_name} = \%current_pkg;
            }
            $current_name = "";
            %current_pkg = ();
            next;
        }

        # Key = value
        my int $eq_pos = index($line, "=");
        if ($eq_pos > 0) {
            my str $key = Pacco::Manifest::trim(substr($line, 0, $eq_pos));
            my str $value = Pacco::Manifest::trim(substr($line, $eq_pos + 1, length($line) - $eq_pos - 1));

            # Remove quotes from string values
            if (length($value) >= 2) {
                if (substr($value, 0, 1) eq "\"" && substr($value, length($value) - 1, 1) eq "\"") {
                    $value = substr($value, 1, length($value) - 2);
                }
            }

            if ($key eq "name") {
                $current_name = $value;
            }
            $current_pkg{$key} = $value;
        }
    }

    # Save last package
    if ($current_name ne "") {
        $packages{$current_name} = \%current_pkg;
    }

    return \%packages;
}

# Generate lock file content from resolved dependencies
func generate(scalar $resolved) str {
    my str $output = "# Strada.lock\n";
    $output = $output . "# This file is auto-generated by pacco. Do not edit.\n";
    $output = $output . "# To update, run: pacco update\n";
    $output = $output . "\n";

    # Sort package names for consistent output
    my array @names = keys(%{$resolved});
    @names = Pacco::Lock::sort_strings(@names);

    foreach my str $name (@names) {
        my scalar $pkg = $resolved->{$name};

        $output = $output . "[[package]]\n";
        $output = $output . "name = \"" . $name . "\"\n";

        if (defined($pkg->{"version"})) {
            $output = $output . "version = \"" . $pkg->{"version"} . "\"\n";
        }

        if (defined($pkg->{"source"})) {
            $output = $output . "source = \"" . $pkg->{"source"} . "\"\n";
        }

        if (defined($pkg->{"checksum"})) {
            $output = $output . "checksum = \"" . $pkg->{"checksum"} . "\"\n";
        }

        if (defined($pkg->{"git"})) {
            $output = $output . "git = \"" . $pkg->{"git"} . "\"\n";
        }

        if (defined($pkg->{"rev"})) {
            $output = $output . "rev = \"" . $pkg->{"rev"} . "\"\n";
        }

        # Dependencies
        if (defined($pkg->{"dependencies"})) {
            my scalar $deps = $pkg->{"dependencies"};
            my array @dep_names = keys(%{$deps});
            if (scalar(@dep_names) > 0) {
                $output = $output . "dependencies = [";
                my int $first = 1;
                foreach my str $dep (@dep_names) {
                    if ($first == 0) {
                        $output = $output . ", ";
                    }
                    $output = $output . "\"" . $dep . "\"";
                    $first = 0;
                }
                $output = $output . "]\n";
            }
        }

        $output = $output . "\n";
    }

    return $output;
}

# Write lock file to disk
func write(str $path, scalar $resolved) int {
    my str $content = Pacco::Lock::generate($resolved);
    spew($path, $content);
    return 1;
}

# Check if lock file is up to date with manifest
func is_current(scalar $lock, scalar $manifest) int {
    if (!defined($lock)) {
        return 0;
    }

    my scalar $deps = Pacco::Manifest::get_dependencies($manifest);

    # Check all manifest deps are in lock
    foreach my str $name (keys(%{$deps})) {
        if (!defined($lock->{$name})) {
            return 0;
        }

        # Check version satisfies constraint
        my str $constraint = $deps->{$name};
        my str $locked_version = $lock->{$name}->{"version"};

        if (defined($locked_version)) {
            if (Pacco::SemVer::satisfies($locked_version, $constraint) == 0) {
                return 0;
            }
        }
    }

    return 1;
}

# Get locked version for a package
func get_version(scalar $lock, str $name) str {
    if (defined($lock) && defined($lock->{$name}) && defined($lock->{$name}->{"version"})) {
        return $lock->{$name}->{"version"};
    }
    return "";
}

# Simple alphabetical sort for strings
func sort_strings(array @arr) array {
    my int $n = scalar(@arr);

    # Bubble sort (simple, works for small arrays)
    for (my int $i = 0; $i < $n - 1; $i++) {
        for (my int $j = 0; $j < $n - $i - 1; $j++) {
            if ($arr[$j] gt $arr[$j + 1]) {
                my str $temp = $arr[$j];
                $arr[$j] = $arr[$j + 1];
                $arr[$j + 1] = $temp;
            }
        }
    }

    return @arr;
}
