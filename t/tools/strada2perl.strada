/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

# strada2perl - Convert Strada code to Perl
#
# Usage: ./strada2perl input.strada [output.pl]
#
# This converter transforms Strada code to equivalent Perl 5 code.
# Type annotations are removed, and Strada-specific constructs are
# converted to Perl equivalents.

# Convert a single line of Strada to Perl
func convert_line(str $line) str {
    my str $result = $line;
    my str $trimmed = $line;
    $trimmed =~ s/^\s+//;
    $trimmed =~ s/\s+$//;

    # Skip empty lines and pure comments
    if ($trimmed eq "" || match($trimmed, "^#")) {
        return $result;
    }

    # Convert class definitions: class Name { -> package Name;
    if (match($trimmed, "^class\\s+")) {
        $result = replace($result, "\\bclass\\s+", "package ");
        $result = replace($result, "\\s+extends\\s+\\w+", "");
        $result = replace($result, "\\s*\\{\\s*$", ";");
        return $result;
    }

    # Convert function definitions: func name(...) type { -> sub name {
    if (match($trimmed, "^func\\s+")) {
        $result = replace($result, "func ", "sub ");
        # Remove type annotations from parameters
        $result = replace_all($result, "int ", "");
        $result = replace_all($result, "num ", "");
        $result = replace_all($result, "str ", "");
        $result = replace_all($result, "scalar ", "");
        $result = replace_all($result, "bool ", "");
        $result = replace_all($result, "array ", "");
        $result = replace_all($result, "hash ", "");
        # Remove return type before {
        $result = replace($result, "\\)\\s+\\w+\\s*\\{", ") {");
        return $result;
    }

    # Convert method definitions: method name(...) type { -> sub name {
    if (match($trimmed, "^method\\s+")) {
        $result = replace($result, "method ", "sub ");
        # Remove type annotations from parameters
        $result = replace_all($result, "int ", "");
        $result = replace_all($result, "num ", "");
        $result = replace_all($result, "str ", "");
        $result = replace_all($result, "scalar ", "");
        $result = replace_all($result, "bool ", "");
        $result = replace_all($result, "array ", "");
        $result = replace_all($result, "hash ", "");
        # Remove return type before {
        $result = replace($result, "\\)\\s+\\w+\\s*\\{", ") {");
        return $result;
    }

    # Remove type annotations from declarations
    $result = replace($result, "my int ", "my ");
    $result = replace($result, "my num ", "my ");
    $result = replace($result, "my str ", "my ");
    $result = replace($result, "my scalar ", "my ");
    $result = replace($result, "my bool ", "my ");
    $result = replace($result, "my array ", "my ");
    $result = replace($result, "my hash ", "my ");

    # Convert size() to scalar() for arrays
    $result = replace_all($result, "\\bsize\\s*\\(\\s*@", "scalar(@");

    # Convert size() to scalar(keys()) for hashes
    if (match($result, "\\bsize\\s*\\(\\s*%")) {
        $result = replace($result, "\\bsize\\s*\\(\\s*%", "scalar(keys %");
    }

    # Convert const to use constant
    if (match($result, "^\\s*const\\s+")) {
        $result = replace($result, "const\\s+", "use constant ");
        $result = replace($result, "\\s*=\\s*", " => ");
    }

    return $result;
}

# Add Perl header
func add_header(str $source_file) str {
    my str $header = "#!/usr/bin/env perl\n";
    $header = $header . "# Converted from Strada: " . $source_file . "\n";
    $header = $header . "# Generated by strada2perl\n";
    $header = $header . "#\n";
    $header = $header . "use strict;\n";
    $header = $header . "use warnings;\n";
    $header = $header . "use feature 'say';\n";
    $header = $header . "\n";
    return $header;
}

# Main conversion function
func convert_file(str $input_path, str $output_path) int {
    my str $content = sys::slurp($input_path);
    if (length($content) == 0) {
        say("Error: Cannot read or empty file: " . $input_path);
        return 1;
    }

    my array @lines = split($content, "\n");
    my str $output = add_header($input_path);
    my int $in_main = 0;
    my int $brace_depth = 0;
    my int $in_class = 0;
    my int $class_depth = 0;

    my int $i = 0;
    while ($i < size(@lines)) {
        my str $ln = $lines[$i];
        my str $trimmed = $ln;
        $trimmed =~ s/^\s+//;
        $trimmed =~ s/\s+$//;

        # Handle func main() int { specially - unwrap it
        if (match($trimmed, "^func\\s+main\\s*\\(")) {
            $in_main = 1;
            $brace_depth = 1;
            $output = $output . "# Main\n";
            $i = $i + 1;
            next;
        }

        # Track class blocks to drop the trailing class brace
        if ($in_class) {
            my int $opens = 0;
            my int $closes = 0;
            my str $tmp = $ln;
            while (match($tmp, "\\{")) {
                $opens = $opens + 1;
                $tmp = replace($tmp, "\\{", "");
            }
            $tmp = $ln;
            while (match($tmp, "\\}")) {
                $closes = $closes + 1;
                $tmp = replace($tmp, "\\}", "");
            }
            my int $next_depth = $class_depth + $opens - $closes;

            if ($trimmed eq "}" && $next_depth <= 0) {
                $in_class = 0;
                $class_depth = 0;
                $i = $i + 1;
                next;
            }
            $class_depth = $next_depth;
        }

        # Track braces while in main
        if ($in_main) {
            my int $opens = 0;
            my int $closes = 0;
            my str $tmp = $ln;
            while (match($tmp, "\\{")) {
                $opens = $opens + 1;
                $tmp = replace($tmp, "\\{", "");
            }
            $tmp = $ln;
            while (match($tmp, "\\}")) {
                $closes = $closes + 1;
                $tmp = replace($tmp, "\\}", "");
            }
            $brace_depth = $brace_depth + $opens - $closes;

            # Skip closing brace of main
            if ($trimmed eq "}" && $brace_depth <= 0) {
                $in_main = 0;
                $i = $i + 1;
                next;
            }

            # Skip return 0; at end of main
            if (match($trimmed, "^return\\s+0\\s*;")) {
                $i = $i + 1;
                next;
            }
        }

        my str $converted = convert_line($ln);
        if (match($trimmed, "^class\\s+")) {
            $in_class = 1;
            $class_depth = 1;
        }
        $output = $output . $converted . "\n";
        $i = $i + 1;
    }

    sys::spew($output_path, $output);
    say("Converted: " . $input_path . " -> " . $output_path);
    return 0;
}

func main(int $argc, array @argv) int {
    if ($argc < 2) {
        say("Usage: strada2perl input.strada [output.pl]");
        say("");
        say("Converts Strada code to Perl 5 code.");
        say("If output file is not specified, uses input.pl");
        return 1;
    }

    my str $input = $argv[1];
    my str $output = "";

    if ($argc >= 3) {
        $output = $argv[2];
    } else {
        $output = $input;
        $output = replace($output, "\\.strada$", ".pl");
        if ($output eq $input) {
            $output = $input . ".pl";
        }
    }

    my int $status = convert_file($input, $output);
    exit($status);
    return 0;
}
