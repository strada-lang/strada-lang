# Test: map with fat arrow creates flattened pairs
func main() int {
    # Test 1: Fat arrow creates 2-element array
    my str $k = "key";
    my array @pair = $k => "value";
    if (scalar(@pair) != 2) { say("FAIL: pair should have 2 elements"); return 1; }
    if ($pair[0] ne "key") { say("FAIL: pair[0] should be 'key'"); return 1; }
    if ($pair[1] ne "value") { say("FAIL: pair[1] should be 'value'"); return 1; }

    # Test 2: map { $_ => 1 } flattens pairs
    my array @items = ("a", "b", "c");
    my array @flat = map { $_ => 1 } @items;
    if (scalar(@flat) != 6) { say("FAIL: flat should have 6 elements, got " . scalar(@flat)); return 1; }
    if ($flat[0] ne "a") { say("FAIL: flat[0]"); return 1; }
    if ($flat[1] ne "1") { say("FAIL: flat[1]"); return 1; }
    if ($flat[2] ne "b") { say("FAIL: flat[2]"); return 1; }
    if ($flat[3] ne "1") { say("FAIL: flat[3]"); return 1; }

    # Test 3: Variable key in hash literal
    my str $dyn = "dynamic";
    my hash %h = { $dyn => "val1", "static" => "val2" };
    if ($h{"dynamic"} ne "val1") { say("FAIL: dynamic key"); return 1; }
    if ($h{"static"} ne "val2") { say("FAIL: static key"); return 1; }

    # Test 4: Build hash from flat pairs
    my hash %lookup = ();
    my int $i = 0;
    while ($i < scalar(@flat)) {
        $lookup{$flat[$i]} = $flat[$i + 1];
        $i = $i + 2;
    }
    if (!exists($lookup{"a"})) { say("FAIL: a not in lookup"); return 1; }
    if (!exists($lookup{"b"})) { say("FAIL: b not in lookup"); return 1; }
    if (!exists($lookup{"c"})) { say("FAIL: c not in lookup"); return 1; }

    say("All tests passed!");
    return 0;
}
