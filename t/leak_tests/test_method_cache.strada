#!/usr/bin/env strada
# Test method dispatch cache for memory leaks
# Method lookups are cached for fast repeated dispatch
# Run: valgrind --leak-check=full ./test_method_cache

package Animal;
has ro str $species (required);
has rw int $energy = 100;

func speak(scalar $self) str {
    return "I am a " . $self->species();
}

func eat(scalar $self, int $amount) void {
    $self->set_energy($self->energy() + $amount);
}

package Dog;
extends Animal;
has ro str $name (required);

func bark(scalar $self) str {
    return $self->name() . " says woof!";
}

func fetch(scalar $self, str $item) str {
    return $self->name() . " fetches " . $item;
}

package main;

func main() int {
    say("Testing method dispatch cache for memory leaks...");
    my int $iterations = 100;

    # Test repeated method calls (cache hits)
    say("  Repeated method calls...");
    my int $i = 0;
    while ($i < $iterations) {
        my scalar $dog = Dog::new("name", "Rex", "species", "canine");
        my str $bark = $dog->bark();
        if ($bark ne "Rex says woof!") {
            say("    FAIL: bark mismatch");
            return 1;
        }
        my str $speak = $dog->speak();
        if ($speak ne "I am a canine") {
            say("    FAIL: speak mismatch");
            return 1;
        }
        $i = $i + 1;
    }
    say("    PASS");

    # Test method with arguments
    say("  Method calls with arguments...");
    $i = 0;
    while ($i < $iterations) {
        my scalar $dog = Dog::new("name", "Buddy", "species", "dog");
        $dog->eat(50);
        if ($dog->energy() != 150) {
            say("    FAIL: energy mismatch");
            return 1;
        }
        my str $result = $dog->fetch("ball");
        if ($result ne "Buddy fetches ball") {
            say("    FAIL: fetch mismatch");
            return 1;
        }
        $i = $i + 1;
    }
    say("    PASS");

    # Test isa() calls (UNIVERSAL method)
    say("  isa() calls...");
    $i = 0;
    while ($i < $iterations) {
        my scalar $dog = Dog::new("name", "Spot", "species", "dog");
        if (!$dog->isa("Dog")) {
            say("    FAIL: isa Dog");
            return 1;
        }
        if (!$dog->isa("Animal")) {
            say("    FAIL: isa Animal");
            return 1;
        }
        $i = $i + 1;
    }
    say("    PASS");

    # Test multiple objects with same class (cache reuse)
    say("  Multiple objects same class...");
    $i = 0;
    while ($i < $iterations) {
        my scalar $d1 = Dog::new("name", "A", "species", "dog");
        my scalar $d2 = Dog::new("name", "B", "species", "dog");
        my scalar $d3 = Dog::new("name", "C", "species", "dog");
        my str $r1 = $d1->bark();
        my str $r2 = $d2->bark();
        my str $r3 = $d3->bark();
        if ($r1 ne "A says woof!" || $r2 ne "B says woof!" || $r3 ne "C says woof!") {
            say("    FAIL: multi-object dispatch");
            return 1;
        }
        $i = $i + 1;
    }
    say("    PASS");

    say("All method cache tests passed!");
    return 0;
}
