/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

# CodeGen.strada - C Code Generator for self-hosting Strada compiler
# Transforms AST into C source code

# ============================================================
# Code Generator State
# ============================================================

# Sanitize function names for C (replace :: with _)
func sanitize_name(str $name) str {
    my str $result = "";
    my int $i = 0;
    my int $len = length($name);
    while ($i < $len) {
        my str $ch = substr($name, $i, 1);
        if ($ch eq ":") {
            # Check for :: sequence and replace with single _
            if ($i + 1 < $len && substr($name, $i + 1, 1) eq ":") {
                $result = $result . "_";
                $i = $i + 1;  # Skip the second colon
            } else {
                $result = $result . "_";
            }
        } else {
            $result = $result . $ch;
        }
        $i = $i + 1;
    }
    return $result;
}

# Escape C keywords used as variable names by prefixing with v_
func escape_c_keyword(str $name) str {
    # C keywords that conflict with Strada variable names
    if ($name eq "for") { return "v_for"; }
    if ($name eq "while") { return "v_while"; }
    if ($name eq "if") { return "v_if"; }
    if ($name eq "else") { return "v_else"; }
    if ($name eq "switch") { return "v_switch"; }
    if ($name eq "case") { return "v_case"; }
    if ($name eq "default") { return "v_default"; }
    if ($name eq "break") { return "v_break"; }
    if ($name eq "continue") { return "v_continue"; }
    if ($name eq "return") { return "v_return"; }
    if ($name eq "goto") { return "v_goto"; }
    if ($name eq "do") { return "v_do"; }
    if ($name eq "int") { return "v_int"; }
    if ($name eq "char") { return "v_char"; }
    if ($name eq "float") { return "v_float"; }
    if ($name eq "double") { return "v_double"; }
    if ($name eq "void") { return "v_void"; }
    if ($name eq "long") { return "v_long"; }
    if ($name eq "short") { return "v_short"; }
    if ($name eq "unsigned") { return "v_unsigned"; }
    if ($name eq "signed") { return "v_signed"; }
    if ($name eq "const") { return "v_const"; }
    if ($name eq "static") { return "v_static"; }
    if ($name eq "extern") { return "v_extern"; }
    if ($name eq "register") { return "v_register"; }
    if ($name eq "volatile") { return "v_volatile"; }
    if ($name eq "auto") { return "v_auto"; }
    if ($name eq "struct") { return "v_struct"; }
    if ($name eq "union") { return "v_union"; }
    if ($name eq "enum") { return "v_enum"; }
    if ($name eq "typedef") { return "v_typedef"; }
    if ($name eq "sizeof") { return "v_sizeof"; }
    # C99/C11 keywords
    if ($name eq "inline") { return "v_inline"; }
    if ($name eq "restrict") { return "v_restrict"; }
    if ($name eq "_Bool") { return "v_Bool"; }
    if ($name eq "_Complex") { return "v_Complex"; }
    if ($name eq "_Imaginary") { return "v_Imaginary"; }
    return $name;
}

func codegen_new(str $filename, int $debug_info, int $enable_profiling, int $enable_stack_trace) scalar {
    my hash %cg = ();
    # StringBuilder for O(1) amortized append (no O(n^2) string concat)
    $cg{"output_sb"} = sb_new();
    $cg{"preamble_content"} = "";  # Saved preamble when doing multi-phase
    $cg{"funcs_content"} = "";     # Saved funcs when doing multi-phase
    $cg{"oop_fwd_decls"} = "";     # OOP init forward declarations (generated after methods tracked)
    $cg{"indent"} = 0;
    $cg{"debug_info"} = $debug_info;  # Emit #line directives for debugging
    $cg{"enable_profiling"} = $enable_profiling;  # Emit function profiling code
    $cg{"enable_stack_trace"} = $enable_stack_trace;  # Emit stack trace push/pop calls
    $cg{"last_line"} = 0;  # Track last emitted line to avoid duplicates
    $cg{"functions"} = {};  # Map function name -> function info
    $cg{"in_extern"} = 0;   # Track if we're inside an extern function
    $cg{"extern_params"} = {};  # Map param name -> type for extern functions
    $cg{"in_main"} = 0;     # Track if we're inside main function
    $cg{"package"} = "";    # Current package name
    $cg{"filename"} = $filename;  # Source file name for __FILE__
    $cg{"map_counter"} = 0;     # Counter for unique map variable names
    $cg{"sort_counter"} = 0;    # Counter for unique sort variable names
    $cg{"grep_counter"} = 0;    # Counter for unique grep variable names
    $cg{"foreach_counter"} = 0; # Counter for unique foreach variable names
    $cg{"redo_counter"} = 0;    # Counter for unique redo labels
    $cg{"current_redo_label"} = ""; # Current innermost redo label for unlabeled redo
    $cg{"call_context"} = 0;   # Call context for dynamic functions (0=scalar, 1=array, 2=hash)
    $cg{"in_map_block"} = 0;  # Track if inside map block (for $_)
    $cg{"in_sort_block"} = 0; # Track if inside sort block (for $a, $b)
    $cg{"in_grep_block"} = 0; # Track if inside grep block (for $_)
    $cg{"anon_func_counter"} = 0;  # Counter for unique anonymous function names
    $cg{"anon_func_decls"} = "";   # Forward declarations for anonymous functions
    $cg{"anon_func_defs"} = "";    # Function definitions for anonymous functions
    $cg{"in_anon_func"} = 0;       # Track if inside anonymous function
    $cg{"anon_param_str"} = "";    # Comma-separated param names
    $cg{"anon_local_str"} = "";    # Comma-separated local names
    $cg{"anon_capture_str"} = "";  # Comma-separated capture names
    $cg{"anon_capture_count"} = 0; # Number of captures
    $cg{"current_func_name"} = ""; # Current function name for profiling
    $cg{"global_count"} = 0;       # Number of global variables
    my array @empty_globals = ();
    $cg{"globals"} = \@empty_globals;  # Array of global variable declarations
    $cg{"switch_counter"} = 0;     # Counter for unique switch variable names
    # OOP method registration - per-package tracking
    my hash %empty_pkg_methods = ();
    $cg{"pkg_methods"} = \%empty_pkg_methods;  # Hash: package -> array of method info
    my array @empty_pkg_list = ();
    $cg{"pkg_list"} = \@empty_pkg_list;        # Array of package names (to avoid keys())
    $cg{"pkg_count"} = 0;                      # Number of packages
    $cg{"pkg_seen"} = "|";                     # String of seen package names (for fast lookup)
    $cg{"method_wrappers"} = "";   # Generated wrapper functions
    # Scope tracking for memory management (using string-encoded var lists for bootstrap compat)
    # Each scope is stored as "var1,var2,var3" string (bootstrap doesn't support scalar(@arr))
    my array @scope_vars = ();   # Array of scope strings
    my array @scope_counts = (); # Parallel array of counts
    $cg{"scope_vars"} = \@scope_vars;
    $cg{"scope_counts"} = \@scope_counts;
    $cg{"scope_depth"} = 0;
    $cg{"cleanup_enabled"} = 1;  # Enable scope-based memory cleanup
    $cg{"try_depth"} = 0;        # Track nesting depth in try blocks (for proper cleanup on return)
    $cg{"catch_cleanup_count"} = 0;  # Track catch vars on cleanup stack (for proper cleanup on throw)
    $cg{"func_has_try"} = 0;     # Track if current function contains any try blocks (for volatile vars)
    # Track label-to-scope-depth for proper cleanup on labeled break/continue
    my hash %label_depths = ();
    $cg{"label_depths"} = \%label_depths;
    # Track loop body scope depth for unlabeled last/next cleanup
    $cg{"loop_break_depth"} = 0;
    # Track 'our' variables: maps C variable name -> "package::varname" registry key
    my hash %our_vars = ();
    $cg{"our_vars"} = \%our_vars;
    # Operator overloading (set from program node in gen_program)
    $cg{"has_overloads"} = 0;
    my hash %empty_overloads = ();
    $cg{"overloads"} = \%empty_overloads;
    my hash %empty_overloaded_ops = ();
    $cg{"overloaded_ops"} = \%empty_overloaded_ops;
    return \%cg;
}

# Push a new scope onto the scope stack
func scope_push(scalar $cg) void {
    my int $enabled = $cg->{"cleanup_enabled"};
    if ($enabled == 0) {
        return;
    }
    my scalar $vars = $cg->{"scope_vars"};
    my scalar $counts = $cg->{"scope_counts"};
    my int $depth = $cg->{"scope_depth"};
    push($vars, "");  # Empty scope
    push($counts, 0);
    $cg->{"scope_depth"} = $depth + 1;
}

# Track a variable in the current scope
func scope_track_var(scalar $cg, str $name) void {
    my int $enabled = $cg->{"cleanup_enabled"};
    if ($enabled == 0) {
        return;
    }
    my int $depth = $cg->{"scope_depth"};
    if ($depth == 0) {
        return;
    }
    my scalar $vars = $cg->{"scope_vars"};
    my scalar $counts = $cg->{"scope_counts"};
    my str $current = $vars->[$depth - 1];
    my int $count = $counts->[$depth - 1];
    if ($count == 0) {
        $vars->[$depth - 1] = $name;
    } else {
        $vars->[$depth - 1] = $current . "," . $name;
    }
    $counts->[$depth - 1] = $count + 1;
}

# Emit cleanup for current scope and pop it
func scope_pop(scalar $cg) void {
    my int $enabled = $cg->{"cleanup_enabled"};
    if ($enabled == 0) {
        return;
    }
    my int $depth = $cg->{"scope_depth"};
    if ($depth == 0) {
        return;
    }
    my scalar $vars = $cg->{"scope_vars"};
    my scalar $counts = $cg->{"scope_counts"};
    my str $scope_str = $vars->[$depth - 1];
    my int $count = $counts->[$depth - 1];

    emit_scope_decref($cg, $scope_str, $count);

    pop($vars);
    pop($counts);
    $cg->{"scope_depth"} = $depth - 1;
}

# Check if a variable name is in a comma-separated string
func is_var_in_list(str $var, str $list) int {
    if (length($list) == 0) { return 0; }
    my int $pos = 0;
    my int $len = length($list);
    my str $cur = "";
    while ($pos <= $len) {
        if ($pos == $len) {
            if ($cur eq $var) { return 1; }
            $pos = $pos + 1;
        } else {
            my str $ch = substr($list, $pos, 1);
            if ($ch eq ",") {
                if ($cur eq $var) { return 1; }
                $cur = "";
            } else {
                $cur = $cur . $ch;
            }
            $pos = $pos + 1;
        }
    }
    return 0;
}

# Helper to emit decref for vars in a scope, skipping already-cleaned names
# Returns updated cleaned list (comma-separated) with this scope's vars added
func emit_scope_decref_skip(scalar $cg, str $scope_str, int $count, str $cleaned) str {
    if ($count == 0 || length($scope_str) == 0) {
        return $cleaned;
    }
    my int $in_anon = $cg->{"in_anon_func"};
    my str $capture_str = $cg->{"anon_capture_str"};

    my int $pos = 0;
    my int $len = length($scope_str);
    my str $var_name = "";
    while ($pos <= $len) {
        if ($pos == $len) {
            if (length($var_name) > 0) {
                if ($in_anon == 0 || is_var_in_list($var_name, $capture_str) == 0) {
                    if (is_var_in_list($var_name, $cleaned) == 0) {
                        emit_indent($cg);
                        emit($cg, "strada_decref(" . $var_name . ");\n");
                    }
                }
                if (length($cleaned) == 0) {
                    $cleaned = "" . $var_name;
                } else {
                    $cleaned = $cleaned . "," . $var_name;
                }
            }
            $pos = $pos + 1;
        } else {
            my str $ch = substr($scope_str, $pos, 1);
            if ($ch eq ",") {
                if (length($var_name) > 0) {
                    if ($in_anon == 0 || is_var_in_list($var_name, $capture_str) == 0) {
                        if (is_var_in_list($var_name, $cleaned) == 0) {
                            emit_indent($cg);
                            emit($cg, "strada_decref(" . $var_name . ");\n");
                        }
                    }
                    if (length($cleaned) == 0) {
                        $cleaned = $var_name;
                    } else {
                        $cleaned = $cleaned . "," . $var_name;
                    }
                }
                $var_name = "";
            } else {
                $var_name = $var_name . $ch;
            }
            $pos = $pos + 1;
        }
    }
    return $cleaned;
}

# Helper to emit decref for all vars in a scope string
func emit_scope_decref(scalar $cg, str $scope_str, int $count) void {
    if ($count == 0 || length($scope_str) == 0) {
        return;
    }
    # Get capture list to skip captured variables in closures
    my int $in_anon = $cg->{"in_anon_func"};
    my str $capture_str = $cg->{"anon_capture_str"};

    my int $pos = 0;
    my int $len = length($scope_str);
    my str $var_name = "";
    while ($pos <= $len) {
        if ($pos == $len) {
            if (length($var_name) > 0) {
                # Skip captured variables - they're accessed via __captures, not local vars
                if ($in_anon == 0 || is_var_in_list($var_name, $capture_str) == 0) {
                    emit_indent($cg);
                    emit($cg, "strada_decref(" . $var_name . ");\n");
                }
            }
            $pos = $pos + 1;
        } else {
            my str $ch = substr($scope_str, $pos, 1);
            if ($ch eq ",") {
                if (length($var_name) > 0) {
                    # Skip captured variables
                    if ($in_anon == 0 || is_var_in_list($var_name, $capture_str) == 0) {
                        emit_indent($cg);
                        emit($cg, "strada_decref(" . $var_name . ");\n");
                    }
                }
                $var_name = "";
            } else {
                $var_name = $var_name . $ch;
            }
            $pos = $pos + 1;
        }
    }
}

# Emit cleanup for current scope without popping (for early returns)
func scope_emit_cleanup(scalar $cg) void {
    my int $enabled = $cg->{"cleanup_enabled"};
    if ($enabled == 0) {
        return;
    }
    my int $depth = $cg->{"scope_depth"};
    if ($depth == 0) {
        return;
    }
    my scalar $vars = $cg->{"scope_vars"};
    my scalar $counts = $cg->{"scope_counts"};
    my str $scope_str = $vars->[$depth - 1];
    my int $count = $counts->[$depth - 1];
    emit_scope_decref($cg, $scope_str, $count);
}

# Emit cleanup for all scopes (for return statements)
func scope_emit_all_cleanup(scalar $cg) void {
    my int $enabled = $cg->{"cleanup_enabled"};
    if ($enabled == 0) {
        return;
    }
    my int $depth = $cg->{"scope_depth"};
    my scalar $vars = $cg->{"scope_vars"};
    my scalar $counts = $cg->{"scope_counts"};

    # Track already-cleaned variable names to avoid double-free when
    # inner scopes shadow outer variables with the same name
    my str $cleaned = "";

    # Emit cleanup from innermost to outermost scope
    my int $d = $depth;
    while ($d > 0) {
        my str $scope_str = $vars->[$d - 1];
        my int $count = $counts->[$d - 1];
        $cleaned = emit_scope_decref_skip($cg, $scope_str, $count, $cleaned);

        $d = $d - 1;
    }

    # Pop catch variables from cleanup stack (already decref'd by scope cleanup above)
    # This is needed for proper cleanup order when throwing from inside a catch block
    my int $ccc = $cg->{"catch_cleanup_count"} + 0;
    while ($ccc > 0) {
        emit_indent($cg);
        emit($cg, "strada_cleanup_pop();\n");
        $ccc = $ccc - 1;
    }

    # Also pop and decref function parameters (we incref'd and pushed them at function entry)
    my int $pn_count = $cg->{"func_param_count"} + 0;
    if ($pn_count > 0) {
        my scalar $param_names = $cg->{"func_param_names"};
        my int $pn_i = 0;
        while ($pn_i < $pn_count) {
            emit_indent($cg);
            emit($cg, "strada_cleanup_pop();\n");
            emit_indent($cg);
            my str $pname = $param_names->[$pn_i];
            emit($cg, "strada_decref(" . $pname . ");\n");
            $pn_i = $pn_i + 1;
        }
    }
}

# Emit cleanup for scopes from current depth down to (but not including) target_depth
# Used for labeled break/continue to clean up intermediate scopes
func scope_emit_cleanup_to_depth(scalar $cg, int $target_depth) void {
    my int $enabled = $cg->{"cleanup_enabled"};
    if ($enabled == 0) {
        return;
    }
    my int $depth = $cg->{"scope_depth"};
    my scalar $vars = $cg->{"scope_vars"};
    my scalar $counts = $cg->{"scope_counts"};

    # Emit cleanup from innermost scope down to (but not including) target_depth
    # Track already-cleaned names to avoid double-free from variable shadowing
    my str $cleaned = "";
    my int $d = $depth;
    while ($d > $target_depth) {
        my str $scope_str = $vars->[$d - 1];
        my int $count = $counts->[$d - 1];
        $cleaned = emit_scope_decref_skip($cg, $scope_str, $count, $cleaned);

        $d = $d - 1;
    }
}

# Emit STRADA_TRY_POP() for each active try block (for early returns in try blocks)
func emit_try_cleanup(scalar $cg) void {
    my int $try_depth = $cg->{"try_depth"};
    while ($try_depth > 0) {
        emit_indent($cg);
        emit($cg, "STRADA_TRY_POP();\n");
        $try_depth = $try_depth - 1;
    }
}

# Register a function with its parameters for default arg handling
func codegen_register_function(scalar $cg, scalar $fn) void {
    my str $name = sanitize_name($fn->{"name"});
    my hash %info = ();
    $info{"param_count"} = $fn->{"param_count"};
    $info{"params"} = $fn->{"params"};
    $info{"return_type"} = $fn->{"return_type"};
    # Track if this is an extern function for call site conversion
    if ($fn->{"type"} == NODE_EXTERN_FUNC()) {
        $info{"is_extern"} = 1;
        # Track if this is a C-style extern (raw C types, direct calls)
        if ($fn->{"is_c_extern"} == 1) {
            $info{"is_c_extern"} = 1;
        } else {
            $info{"is_c_extern"} = 0;
        }
    } else {
        $info{"is_extern"} = 0;
        $info{"is_c_extern"} = 0;
    }

    # Track variadic function info
    $info{"is_variadic"} = $fn->{"is_variadic"};
    $info{"variadic_param_idx"} = -1;
    if ($fn->{"is_variadic"} == 1) {
        my scalar $params = $fn->{"params"};
        my int $pc = $fn->{"param_count"};
        for (my int $i = 0; $i < $pc; $i = $i + 1) {
            if ($params->[$i]->{"is_variadic"} == 1) {
                $info{"variadic_param_idx"} = $i;
            }
        }
    }

    $cg->{"functions"}->{$name} = \%info;
}

# Helper to get arg from packed args array
func gen_oop_helper_decl(scalar $sb) void {
    sb_append($sb, "/* OOP method dispatch helper */\n");
    sb_append($sb, "static StradaValue* __strada_get_arg(StradaValue* args, int idx) {\n");
    sb_append($sb, "    if (!args || args->type != STRADA_ARRAY) return NULL;\n");
    sb_append($sb, "    if ((size_t)idx >= args->value.av->size) return NULL;\n");
    sb_append($sb, "    return args->value.av->elements[idx];\n");
    sb_append($sb, "}\n\n");
}

# Track a method for OOP registration (per-package)
func codegen_track_method(scalar $cg, scalar $fn, str $pkg) void {
    my str $name = sanitize_name($fn->{"name"});

    # Skip main, extern functions, and functions starting with underscore
    if ($name eq "main") { return; }
    if ($fn->{"type"} == NODE_EXTERN_FUNC()) { return; }
    if (substr($name, 0, 1) eq "_") { return; }

    # Methods must have at least one parameter (self)
    # Functions with 0 params are class init functions, not methods
    my int $param_count = $fn->{"param_count"};
    if ($param_count == 0) { return; }

    # Check if function name starts with package prefix (e.g., Cannoli_)
    # Sanitize package name for packages with :: (e.g., Nesso::Record -> Nesso_Record)
    my str $prefix = sanitize_name($pkg) . "_";
    my int $prefix_len = length($prefix);
    if (length($name) <= $prefix_len) { return; }
    if (substr($name, 0, $prefix_len) ne $prefix) { return; }

    # Get method name without prefix
    my str $method = substr($name, $prefix_len, length($name) - $prefix_len);

    # Track method info
    my hash %minfo = ();
    $minfo{"func_name"} = $name;
    $minfo{"method_name"} = $method;
    $minfo{"param_count"} = $fn->{"param_count"};
    $minfo{"params"} = $fn->{"params"};
    $minfo{"return_type"} = $fn->{"return_type"};
    $minfo{"package"} = $pkg;
    $minfo{"is_variadic"} = $fn->{"is_variadic"};
    # Find variadic param index
    my int $variadic_idx = -1;
    if ($fn->{"is_variadic"} == 1) {
        my scalar $params = $fn->{"params"};
        my int $pc = $fn->{"param_count"};
        for (my int $vi = 0; $vi < $pc; $vi = $vi + 1) {
            if ($params->[$vi]->{"is_variadic"} == 1) {
                $variadic_idx = $vi;
            }
        }
    }
    $minfo{"variadic_param_idx"} = $variadic_idx;

    # Get or create the methods info for this package
    # Use string index check instead of exists() for bootstrap compatibility
    my str $pkg_marker = "|" . $pkg . "|";
    my str $seen = $cg->{"pkg_seen"};
    my int $found_idx = index($seen, $pkg_marker);
    if ($found_idx < 0) {
        # New package - initialize it
        my hash %pkg_info = ();
        my array @new_arr = ();
        $pkg_info{"methods"} = \@new_arr;
        $pkg_info{"count"} = 0;
        my scalar $pkg_methods = $cg->{"pkg_methods"};
        $pkg_methods->{$pkg} = \%pkg_info;
        # Also track package name in the list
        my int $pkg_idx = $cg->{"pkg_count"};
        $cg->{"pkg_list"}->[$pkg_idx] = $pkg;
        $cg->{"pkg_count"} = $pkg_idx + 1;
        # Mark as seen
        $cg->{"pkg_seen"} = $seen . $pkg . "|";
    }
    my scalar $pkg_methods = $cg->{"pkg_methods"};
    my scalar $pkg_info = $pkg_methods->{$pkg};
    my int $idx = $pkg_info->{"count"};
    $pkg_info->{"methods"}->[$idx] = \%minfo;
    $pkg_info->{"count"} = $idx + 1;
}

# Helper: emit strada_overload_register for a single operator if it's in the overload hash
func gen_overload_reg_if(scalar $sb, str $pkg, scalar $pkg_ol, scalar $methods, int $method_count, str $op) void {
    my str $method_name = "" . $pkg_ol->{$op};
    if (length($method_name) == 0) { return; }
    # Find the wrapper function for this method
    my int $i = 0;
    while ($i < $method_count) {
        my scalar $m = $methods->[$i];
        if ($m->{"method_name"} eq $method_name) {
            sb_append($sb, "    strada_overload_register(\"" . $pkg . "\", \"" . $op . "\", __wrap_" . $m->{"func_name"} . ");\n");
            return;
        }
        $i = $i + 1;
    }
}

# Helper: emit strada_overload_register for stringify ("") operator
func gen_overload_reg_stringify(scalar $sb, str $pkg, scalar $pkg_ol, scalar $methods, int $method_count) void {
    my str $method_name = "" . $pkg_ol->{"\"\""};
    if (length($method_name) == 0) { return; }
    # Find the wrapper function for this method
    my int $i = 0;
    while ($i < $method_count) {
        my scalar $m = $methods->[$i];
        if ($m->{"method_name"} eq $method_name) {
            sb_append($sb, "    strada_overload_register(\"" . $pkg . "\", \"\\\"\\\"\", __wrap_" . $m->{"func_name"} . ");\n");
            return;
        }
        $i = $i + 1;
    }
}

# Generate method wrapper functions for a single package
# $pkg_info is a hash with "methods" array and "count" int
func gen_method_wrappers_for_pkg(scalar $sb, str $pkg, scalar $pkg_info, int $has_overloads, scalar $overloads, scalar $method_modifiers, int $method_modifier_count) void {
    my int $method_count = $pkg_info->{"count"};
    my scalar $methods = $pkg_info->{"methods"};
    if ($method_count == 0) { return; }

    sb_append($sb, "/* OOP method wrappers for package " . $pkg . " */\n");

    my int $i = 0;
    while ($i < $method_count) {
        my scalar $m = $methods->[$i];
        my str $func_name = $m->{"func_name"};
        my int $param_count = $m->{"param_count"};
        my int $ret_type = $m->{"return_type"};
        my int $is_void = $ret_type == TYPE_VOID();

        # Generate wrapper: __wrap_FuncName(self, args) { ... }
        sb_append($sb, "static StradaValue* __wrap_" . $func_name . "(StradaValue* self, StradaValue* args) {\n");

        if ($param_count <= 1) {
            # 0 or 1 param (just self)
            sb_append($sb, "    (void)args;\n");
            if ($is_void == 1) {
                sb_append($sb, "    " . $func_name . "(self);\n");
                sb_append($sb, "    return strada_undef_static();\n");
            } else {
                sb_append($sb, "    return " . $func_name . "(self);\n");
            }
        } else {
            # Multiple params - unpack from args
            my int $is_variadic = $m->{"is_variadic"};
            my int $variadic_idx = $m->{"variadic_param_idx"};

            if ($is_variadic == 1) {
                if ($variadic_idx == 1) {
                    if ($is_void == 1) {
                        sb_append($sb, "    " . $func_name . "(self, args);\n");
                        sb_append($sb, "    return strada_undef_static();\n");
                    } else {
                        sb_append($sb, "    return " . $func_name . "(self, args);\n");
                    }
                } else {
                    sb_append($sb, "    StradaArray *__args = strada_deref_array(args);\n");
                    sb_append($sb, "    StradaValue *__va_arr = strada_new_array();\n");
                    my int $var_start = $variadic_idx - 1;
                    sb_append($sb, "    for (size_t __i = " . $var_start . "; __i < __args->size; __i++) {\n");
                    sb_append($sb, "        strada_array_push(strada_deref_array(__va_arr), __args->elements[__i]);\n");
                    sb_append($sb, "    }\n");
                    if ($is_void == 1) {
                        sb_append($sb, "    " . $func_name . "(self");
                    } else {
                        sb_append($sb, "    StradaValue *__va_result = " . $func_name . "(self");
                    }
                    my int $j = 1;
                    while ($j < $variadic_idx) {
                        my int $arg_idx = $j - 1;
                        sb_append($sb, ", __strada_get_arg(args, " . $arg_idx . ")");
                        $j = $j + 1;
                    }
                    sb_append($sb, ", __va_arr);\n");
                    sb_append($sb, "    strada_decref(__va_arr);\n");
                    if ($is_void == 1) {
                        sb_append($sb, "    return strada_undef_static();\n");
                    } else {
                        sb_append($sb, "    return __va_result;\n");
                    }
                }
            } else {
                if ($is_void == 1) {
                    sb_append($sb, "    " . $func_name . "(self");
                } else {
                    sb_append($sb, "    return " . $func_name . "(self");
                }
                my int $j = 1;
                while ($j < $param_count) {
                    my int $arg_idx = $j - 1;
                    sb_append($sb, ", __strada_get_arg(args, " . $arg_idx . ")");
                    $j = $j + 1;
                }
                sb_append($sb, ");\n");
                if ($is_void == 1) {
                    sb_append($sb, "    return strada_undef_static();\n");
                }
            }
        }

        sb_append($sb, "}\n\n");
        $i = $i + 1;
    }

    # Generate initialization function for this package
    my str $c_pkg = sanitize_name($pkg);
    sb_append($sb, "/* OOP method registration initializer */\n");
    sb_append($sb, "static int __" . $c_pkg . "_oop_initialized = 0;\n");
    sb_append($sb, "void __" . $c_pkg . "_oop_init(void) {\n");
    sb_append($sb, "    if (__" . $c_pkg . "_oop_initialized) return;\n");
    sb_append($sb, "    __" . $c_pkg . "_oop_initialized = 1;\n\n");

    $i = 0;
    while ($i < $method_count) {
        my scalar $m = $methods->[$i];
        my str $func_name = $m->{"func_name"};
        my str $method_name = $m->{"method_name"};

        sb_append($sb, "    strada_method_register(\"" . $pkg . "\", \"" . $method_name . "\", __wrap_" . $func_name . ");\n");
        $i = $i + 1;
    }

    # Generate overload registrations for this package
    if ($has_overloads == 1) {
        my str $pkg_ol_check = "" . $overloads->{$pkg};
        if (length($pkg_ol_check) > 0) {
            my scalar $pkg_ol = $overloads->{$pkg};
            sb_append($sb, "\n    /* Operator overloads */\n");
            # For each operator in the overload hash, find the matching wrapper
            # and emit strada_overload_register() calls.
            # We check each known operator individually (bootstrap-safe, no array iteration).
            gen_overload_reg_if($sb, $pkg, $pkg_ol, $methods, $method_count, "+");
            gen_overload_reg_if($sb, $pkg, $pkg_ol, $methods, $method_count, "-");
            gen_overload_reg_if($sb, $pkg, $pkg_ol, $methods, $method_count, "*");
            gen_overload_reg_if($sb, $pkg, $pkg_ol, $methods, $method_count, "/");
            gen_overload_reg_if($sb, $pkg, $pkg_ol, $methods, $method_count, "%");
            gen_overload_reg_if($sb, $pkg, $pkg_ol, $methods, $method_count, "**");
            gen_overload_reg_if($sb, $pkg, $pkg_ol, $methods, $method_count, ".");
            gen_overload_reg_if($sb, $pkg, $pkg_ol, $methods, $method_count, "==");
            gen_overload_reg_if($sb, $pkg, $pkg_ol, $methods, $method_count, "!=");
            gen_overload_reg_if($sb, $pkg, $pkg_ol, $methods, $method_count, "<");
            gen_overload_reg_if($sb, $pkg, $pkg_ol, $methods, $method_count, ">");
            gen_overload_reg_if($sb, $pkg, $pkg_ol, $methods, $method_count, "<=");
            gen_overload_reg_if($sb, $pkg, $pkg_ol, $methods, $method_count, ">=");
            gen_overload_reg_if($sb, $pkg, $pkg_ol, $methods, $method_count, "<=>");
            gen_overload_reg_if($sb, $pkg, $pkg_ol, $methods, $method_count, "eq");
            gen_overload_reg_if($sb, $pkg, $pkg_ol, $methods, $method_count, "ne");
            gen_overload_reg_if($sb, $pkg, $pkg_ol, $methods, $method_count, "lt");
            gen_overload_reg_if($sb, $pkg, $pkg_ol, $methods, $method_count, "gt");
            gen_overload_reg_if($sb, $pkg, $pkg_ol, $methods, $method_count, "le");
            gen_overload_reg_if($sb, $pkg, $pkg_ol, $methods, $method_count, "ge");
            gen_overload_reg_if($sb, $pkg, $pkg_ol, $methods, $method_count, "cmp");
            gen_overload_reg_if($sb, $pkg, $pkg_ol, $methods, $method_count, "neg");
            gen_overload_reg_if($sb, $pkg, $pkg_ol, $methods, $method_count, "~");
            gen_overload_reg_if($sb, $pkg, $pkg_ol, $methods, $method_count, "bool");
            # Stringify ("") overload - key in hash is two double-quote chars
            gen_overload_reg_stringify($sb, $pkg, $pkg_ol, $methods, $method_count);
        }
    }

    # Generate method modifier registrations for this package
    if ($method_modifier_count > 0) {
        my int $has_mod = 0;
        my int $mi = 0;
        while ($mi < $method_modifier_count) {
            my scalar $mod = $method_modifiers->[$mi];
            if ($mod->{"package"} eq $pkg) {
                if ($has_mod == 0) {
                    sb_append($sb, "\n    /* Method modifiers */\n");
                    $has_mod = 1;
                }
                my str $mod_type = $mod->{"mod_type"};
                my int $type_int = 0;
                if ($mod_type eq "before") {
                    $type_int = 1;
                } elsif ($mod_type eq "after") {
                    $type_int = 2;
                } elsif ($mod_type eq "around") {
                    $type_int = 3;
                }
                my str $func_name = $mod->{"func_name"};
                my str $method_name = $mod->{"method_name"};
                # Find the wrapper for this modifier function
                my int $wi = 0;
                while ($wi < $method_count) {
                    my scalar $wm = $methods->[$wi];
                    if ($wm->{"func_name"} eq $func_name) {
                        sb_append($sb, "    strada_modifier_register(\"" . $pkg . "\", \"" . $method_name . "\", " . $type_int . ", __wrap_" . $func_name . ");\n");
                        $wi = $method_count;
                    }
                    $wi = $wi + 1;
                }
            }
            $mi = $mi + 1;
        }
    }

    sb_append($sb, "}\n\n");
}

# Generate method wrappers for ALL packages
func gen_all_method_wrappers(scalar $cg) str {
    my int $num_pkgs = get_oop_pkg_count($cg);
    if ($num_pkgs == 0) { return ""; }

    my scalar $pkg_methods = $cg->{"pkg_methods"};
    my scalar $pkg_list = get_oop_packages($cg);

    my scalar $sb = sb_new();

    # Add the helper function once
    gen_oop_helper_decl($sb);

    # Get overload info
    my int $has_overloads = $cg->{"has_overloads"};
    my scalar $overloads = $cg->{"overloads"};

    # Get method modifier info
    my scalar $method_modifiers = $cg->{"method_modifiers"};
    my int $method_modifier_count = $cg->{"method_modifier_count"};

    # Generate wrappers for each package
    my int $i = 0;
    while ($i < $num_pkgs) {
        my str $pkg = $pkg_list->[$i];
        my scalar $pkg_info = $pkg_methods->{$pkg};
        gen_method_wrappers_for_pkg($sb, $pkg, $pkg_info, $has_overloads, $overloads, $method_modifiers, $method_modifier_count);
        $i = $i + 1;
    }

    return sb_to_string($sb);
}

# Get all packages that have registered methods
# Returns the pkg_list array reference (not a copy)
func get_oop_packages(scalar $cg) scalar {
    return $cg->{"pkg_list"};
}

# Get count of packages
func get_oop_pkg_count(scalar $cg) int {
    return $cg->{"pkg_count"};
}

# Check if an expression could produce a blessed object at runtime.
# Returns 1 if the expression MIGHT be blessed, 0 if it CANNOT be.
# Used for operator overloading: only emit dispatch code when operands could be blessed.
func could_be_blessed(scalar $expr) int {
    my int $type = $expr->{"type"};

    # Variables with scalar/undef type could be blessed
    if ($type == NODE_VARIABLE()) {
        my int $var_type = $expr->{"var_type"};
        if ($var_type == TYPE_SCALAR() || $var_type == 0) {
            return 1;
        }
        # Typed variables (int, num, str) cannot be blessed
        return 0;
    }

    # Literals cannot be blessed
    if ($type == NODE_INT_LITERAL() || $type == NODE_NUM_LITERAL() || $type == NODE_STR_LITERAL()) {
        return 0;
    }
    if ($type == NODE_UNDEF()) {
        return 0;
    }

    # Function calls returning scalar could be blessed
    if ($type == NODE_CALL()) {
        return 1;
    }

    # Method calls always return scalar (could be blessed)
    if ($type == NODE_METHOD_CALL()) {
        return 1;
    }

    # Dynamic method calls could return blessed
    if ($type == NODE_DYN_METHOD_CALL()) {
        return 1;
    }

    # Hash/array dereference access could return blessed
    if ($type == NODE_HASH_ACCESS() || $type == NODE_DEREF_HASH() ||
        $type == NODE_DEREF_ARRAY() || $type == NODE_SUBSCRIPT()) {
        return 1;
    }

    # Ternary could return blessed
    if ($type == NODE_TERNARY()) {
        return 1;
    }

    # Closure calls could return blessed
    if ($type == NODE_CLOSURE_CALL()) {
        return 1;
    }

    # Binary/unary ops produce numeric/string results, not blessed
    # (unless they themselves use overloading, but the dispatch handles that)
    return 0;
}

# Generate overloaded binary operator dispatch
# Emits: ({ StradaValue *__ol_l = <left>; StradaValue *__ol_r = <right>;
#           StradaValue *__ol_res = strada_overload_binary(__ol_l, __ol_r, "op");
#           if (!__ol_res) __ol_res = <fallback>; __ol_res; })
# Emit the default (non-overloaded) fallback for a binary op using __ol_l, __ol_r temps
func emit_overload_binary_fallback(scalar $cg, str $op) void {
    if ($op eq "+") {
        emit($cg, "strada_new_num(strada_to_num(__ol_l) + strada_to_num(__ol_r))");
    } elsif ($op eq "-") {
        emit($cg, "strada_new_num(strada_to_num(__ol_l) - strada_to_num(__ol_r))");
    } elsif ($op eq "*") {
        emit($cg, "strada_new_num(strada_to_num(__ol_l) * strada_to_num(__ol_r))");
    } elsif ($op eq "/") {
        emit($cg, "strada_safe_div(strada_to_num(__ol_l), strada_to_num(__ol_r))");
    } elsif ($op eq "%") {
        emit($cg, "strada_safe_mod((int64_t)strada_to_int(__ol_l), (int64_t)strada_to_int(__ol_r))");
    } elsif ($op eq "**") {
        emit($cg, "strada_new_num(pow(strada_to_num(__ol_l), strada_to_num(__ol_r)))");
    } elsif ($op eq ".") {
        emit($cg, "strada_concat_sv(__ol_l, __ol_r)");
    } elsif ($op eq "==") {
        emit($cg, "strada_new_int(strada_to_num(__ol_l) == strada_to_num(__ol_r))");
    } elsif ($op eq "!=") {
        emit($cg, "strada_new_int(strada_to_num(__ol_l) != strada_to_num(__ol_r))");
    } elsif ($op eq "<") {
        emit($cg, "strada_new_int(strada_to_num(__ol_l) < strada_to_num(__ol_r))");
    } elsif ($op eq ">") {
        emit($cg, "strada_new_int(strada_to_num(__ol_l) > strada_to_num(__ol_r))");
    } elsif ($op eq "<=") {
        emit($cg, "strada_new_int(strada_to_num(__ol_l) <= strada_to_num(__ol_r))");
    } elsif ($op eq ">=") {
        emit($cg, "strada_new_int(strada_to_num(__ol_l) >= strada_to_num(__ol_r))");
    } else {
        emit($cg, "strada_new_num(strada_to_num(__ol_l))");
    }
}

# Emit string comparison fallback for overloaded ops
func emit_overload_strcmp_fallback(scalar $cg, str $op) void {
    emit($cg, "({ char *__sl = strada_to_str(__ol_l); char *__sr = strada_to_str(__ol_r); ");
    if ($op eq "eq") {
        emit($cg, "int __r = (strcmp(__sl, __sr) == 0); ");
    } elsif ($op eq "ne") {
        emit($cg, "int __r = (strcmp(__sl, __sr) != 0); ");
    } elsif ($op eq "lt") {
        emit($cg, "int __r = (strcmp(__sl, __sr) < 0); ");
    } elsif ($op eq "gt") {
        emit($cg, "int __r = (strcmp(__sl, __sr) > 0); ");
    } elsif ($op eq "le") {
        emit($cg, "int __r = (strcmp(__sl, __sr) <= 0); ");
    } elsif ($op eq "ge") {
        emit($cg, "int __r = (strcmp(__sl, __sr) >= 0); ");
    } elsif ($op eq "cmp") {
        emit($cg, "int __c = strcmp(__sl, __sr); int __r = (__c < 0) ? -1 : ((__c > 0) ? 1 : 0); ");
    } elsif ($op eq "<=>") {
        emit($cg, "double __nl = strada_to_num(__ol_l); double __nr = strada_to_num(__ol_r); int __r = (__nl < __nr) ? -1 : ((__nl > __nr) ? 1 : 0); ");
    } else {
        emit($cg, "int __r = 0; ");
    }
    emit($cg, "free(__sl); free(__sr); strada_new_int(__r); })");
}

func gen_overloaded_binary(scalar $cg, scalar $left, scalar $right, str $op) void {
    my int $left_tmp = 0;
    my int $right_tmp = 0;
    if ($cg->{"cleanup_enabled"} == 1) {
        $left_tmp = needs_temp_cleanup($cg, $left);
        $right_tmp = needs_temp_cleanup($cg, $right);
    }
    emit($cg, "({ StradaValue *__ol_l = ");
    gen_expression($cg, $left);
    emit($cg, "; StradaValue *__ol_r = ");
    gen_expression($cg, $right);
    emit($cg, "; StradaValue *__ol_res = strada_overload_binary(__ol_l, __ol_r, \"");
    emit($cg, $op);
    emit($cg, "\"); if (!__ol_res) { __ol_res = ");

    # Generate the fallback - dispatch to appropriate helper
    if ($op eq "eq" || $op eq "ne" || $op eq "lt" || $op eq "gt" || $op eq "le" || $op eq "ge" || $op eq "cmp" || $op eq "<=>") {
        emit_overload_strcmp_fallback($cg, $op);
    } else {
        emit_overload_binary_fallback($cg, $op);
    }
    emit($cg, "; }");
    # Clean up temporary operands
    if ($left_tmp == 1) {
        emit($cg, " strada_decref(__ol_l);");
    }
    if ($right_tmp == 1) {
        emit($cg, " strada_decref(__ol_r);");
    }
    emit($cg, " __ol_res; })");
}

# Generate overloaded unary operator dispatch
func gen_overloaded_unary(scalar $cg, scalar $operand, str $op) void {
    my int $op_tmp = 0;
    if ($cg->{"cleanup_enabled"} == 1) {
        $op_tmp = needs_temp_cleanup($cg, $operand);
    }
    emit($cg, "({ StradaValue *__ol_v = ");
    gen_expression($cg, $operand);
    emit($cg, "; StradaValue *__ol_res = strada_overload_unary(__ol_v, \"");
    emit($cg, $op);
    emit($cg, "\"); if (!__ol_res) { __ol_res = ");

    # Generate the fallback
    if ($op eq "neg") {
        emit($cg, "strada_new_num(-strada_to_num(__ol_v))");
    } elsif ($op eq "!") {
        emit($cg, "strada_new_int(!strada_to_bool(__ol_v))");
    } elsif ($op eq "~") {
        emit($cg, "strada_new_int(~strada_to_int(__ol_v))");
    } else {
        emit($cg, "strada_new_num(strada_to_num(__ol_v))");
    }
    emit($cg, "; }");
    if ($op_tmp == 1) {
        emit($cg, " strada_decref(__ol_v);");
    }
    emit($cg, " __ol_res; })");
}

# Generate overloaded string concatenation with stringify dispatch
func gen_overloaded_concat(scalar $cg, scalar $left, scalar $right) void {
    my int $left_tmp = 0;
    my int $right_tmp = 0;
    if ($cg->{"cleanup_enabled"} == 1) {
        $left_tmp = needs_temp_cleanup($cg, $left);
        $right_tmp = needs_temp_cleanup($cg, $right);
    }
    emit($cg, "({ StradaValue *__ol_l = ");
    gen_expression($cg, $left);
    emit($cg, "; StradaValue *__ol_r = ");
    gen_expression($cg, $right);
    emit($cg, "; StradaValue *__ol_ls = strada_overload_stringify(__ol_l);");
    emit($cg, " StradaValue *__ol_rs = strada_overload_stringify(__ol_r);");
    emit($cg, " StradaValue *__ol_res = strada_concat_sv(__ol_ls ? __ol_ls : __ol_l, __ol_rs ? __ol_rs : __ol_r);");
    emit($cg, " if (__ol_ls) strada_decref(__ol_ls);");
    emit($cg, " if (__ol_rs) strada_decref(__ol_rs);");
    if ($left_tmp == 1) {
        emit($cg, " strada_decref(__ol_l);");
    }
    if ($right_tmp == 1) {
        emit($cg, " strada_decref(__ol_r);");
    }
    emit($cg, " __ol_res; })");
}

# Check if a binary operator might be overloaded for given operands
func check_overload_binary(scalar $cg, scalar $left, scalar $right, str $op) int {
    if ($cg->{"has_overloads"} == 0) {
        return 0;
    }
    # Check if this operator is overloaded (bootstrap-safe: no exists() on chained deref)
    my scalar $ol_ops = $cg->{"overloaded_ops"};
    my str $op_check = "" . $ol_ops->{$op};
    if (length($op_check) == 0) {
        return 0;
    }
    if (could_be_blessed($left) == 1 || could_be_blessed($right) == 1) {
        return 1;
    }
    return 0;
}

# Check if an expression is clearly a scalar value (not an array or function call)
# Used to determine if we need to wrap it when assigning to an array variable
func is_scalar_expr(scalar $expr) int {
    my int $type = $expr->{"type"};

    # Scalar variables ($x)
    if ($type == NODE_VARIABLE()) {
        my str $sigil = $expr->{"sigil"};
        if ($sigil eq "$") {
            return 1;
        }
        return 0;
    }

    # Literal values
    if ($type == NODE_INT_LITERAL() || $type == NODE_NUM_LITERAL() || $type == NODE_STR_LITERAL()) {
        return 1;
    }

    # Unary operators on scalars
    if ($type == NODE_UNARY_OP()) {
        return 1;
    }

    # Binary operators produce scalars (arithmetic, comparison, etc.)
    if ($type == NODE_BINARY_OP()) {
        return 1;
    }

    # Ternary produces a scalar
    if ($type == NODE_TERNARY()) {
        return 1;
    }

    # Array/hash subscript returns a scalar
    if ($type == NODE_SUBSCRIPT() || $type == NODE_HASH_ACCESS()) {
        return 1;
    }

    # Field access returns a scalar
    if ($type == NODE_FIELD_ACCESS()) {
        return 1;
    }

    # Everything else (function calls, deref, etc.) - assume not scalar
    return 0;
}

func emit(scalar $cg, str $text) void {
    # O(1) amortized append using StringBuilder
    sb_append($cg->{"output_sb"}, $text);
}

# Emit #line directive for source-level debugging
# Format: #line <line_number> "<filename>"
func emit_line_directive(scalar $cg, int $line) void {
    if ($cg->{"debug_info"} == 0) {
        return;
    }
    if ($line <= 0) {
        return;
    }
    # Avoid emitting duplicate line directives
    if ($line == $cg->{"last_line"}) {
        return;
    }
    $cg->{"last_line"} = $line;

    my str $filename = $cg->{"filename"};
    emit($cg, "#line " . $line . " \"" . $filename . "\"\n");
}

# Emit #line directive before a statement (with indent)
func emit_line_for_stmt(scalar $cg, scalar $stmt) void {
    if ($cg->{"debug_info"} == 0) {
        return;
    }
    # stmt should always be defined when called from gen_statement
    my int $line = $stmt->{"line"};
    if ($line > 0) {
        emit_line_directive($cg, $line);
    }
}

# Generate string comparison with proper cleanup of temporaries
# If one side is a string literal, use strada_str_*_lit to avoid creating temporaries
func gen_str_cmp(scalar $cg, scalar $expr, str $op) void {
    my scalar $left = $expr->{"left"};
    my scalar $right = $expr->{"right"};
    my int $left_type = $left->{"type"};
    my int $right_type = $right->{"type"};

    # Determine comparison function suffix and C operator
    my str $cmp_suffix = $op;
    my str $cmp_op = "== 0";
    if ($op eq "ne") {
        $cmp_op = "!= 0";
    } elsif ($op eq "lt") {
        $cmp_op = "< 0";
    } elsif ($op eq "gt") {
        $cmp_op = "> 0";
    } elsif ($op eq "le") {
        $cmp_op = "<= 0";
    } elsif ($op eq "ge") {
        $cmp_op = ">= 0";
    }

    # Case 1: Right side is string literal - use strada_str_*_lit (no temp allocation)
    if ($right_type == NODE_STR_LITERAL()) {
        # Check if left needs cleanup
        if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $left) == 1) {
            emit($cg, "({ StradaValue *__cmp_l = ");
            gen_expression($cg, $left);
            emit($cg, "; int __cmp_r = strada_str_");
            emit($cg, $cmp_suffix);
            emit($cg, "_lit(__cmp_l, ");
            gen_str_literal_c($cg, $right->{"value"});
            emit($cg, "); strada_decref(__cmp_l); strada_new_int(__cmp_r); })");
        } else {
            emit($cg, "strada_new_int(strada_str_");
            emit($cg, $cmp_suffix);
            emit($cg, "_lit(");
            gen_expression($cg, $left);
            emit($cg, ", ");
            gen_str_literal_c($cg, $right->{"value"});
            emit($cg, "))");
        }
        return;
    }

    # Case 2: Left side is string literal - swap and use strada_str_*_lit
    if ($left_type == NODE_STR_LITERAL()) {
        my str $swapped = $cmp_suffix;
        if ($op eq "lt") {
            $swapped = "gt";
        } elsif ($op eq "gt") {
            $swapped = "lt";
        } elsif ($op eq "le") {
            $swapped = "ge";
        } elsif ($op eq "ge") {
            $swapped = "le";
        }
        # Check if right needs cleanup
        if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $right) == 1) {
            emit($cg, "({ StradaValue *__cmp_r = ");
            gen_expression($cg, $right);
            emit($cg, "; int __cmp_res = strada_str_");
            emit($cg, $swapped);
            emit($cg, "_lit(__cmp_r, ");
            gen_str_literal_c($cg, $left->{"value"});
            emit($cg, "); strada_decref(__cmp_r); strada_new_int(__cmp_res); })");
        } else {
            emit($cg, "strada_new_int(strada_str_");
            emit($cg, $swapped);
            emit($cg, "_lit(");
            gen_expression($cg, $right);
            emit($cg, ", ");
            gen_str_literal_c($cg, $left->{"value"});
            emit($cg, "))");
        }
        return;
    }

    # Case 3: Neither side is a string literal - use standard comparison
    # Must free both the strada_to_str() results AND the StradaValue temporaries
    my int $left_needs_cleanup = needs_temp_cleanup($cg, $left);
    my int $right_needs_cleanup = needs_temp_cleanup($cg, $right);

    if ($cg->{"cleanup_enabled"} == 1 && ($left_needs_cleanup == 1 || $right_needs_cleanup == 1)) {
        emit($cg, "({ StradaValue *__cmp_lv = ");
        gen_expression($cg, $left);
        emit($cg, "; StradaValue *__cmp_rv = ");
        gen_expression($cg, $right);
        emit($cg, "; char *__cmp_ls = strada_to_str(__cmp_lv); char *__cmp_rs = strada_to_str(__cmp_rv); ");
        emit($cg, "int __cmp_res = strcmp(__cmp_ls, __cmp_rs) ");
        emit($cg, $cmp_op);
        emit($cg, "; free(__cmp_ls); free(__cmp_rs); ");
        if ($left_needs_cleanup == 1) {
            emit($cg, "strada_decref(__cmp_lv); ");
        }
        if ($right_needs_cleanup == 1) {
            emit($cg, "strada_decref(__cmp_rv); ");
        }
        emit($cg, "strada_new_int(__cmp_res); })");
    } else {
        emit($cg, "({ char *__cmp_ls = strada_to_str(");
        gen_expression($cg, $left);
        emit($cg, "); char *__cmp_rs = strada_to_str(");
        gen_expression($cg, $right);
        emit($cg, "); int __cmp_res = strcmp(__cmp_ls, __cmp_rs) ");
        emit($cg, $cmp_op);
        emit($cg, "; free(__cmp_ls); free(__cmp_rs); strada_new_int(__cmp_res); })");
    }
}

# Emit a C string literal with proper escaping
func gen_str_literal_c(scalar $cg, str $val) void {
    emit($cg, "\"");
    my int $i = 0;
    my int $len = bytes($val);
    my str $bs = chr(92);
    while ($i < $len) {
        my str $ch = substr_bytes($val, $i, 1);
        my int $byte = ord($ch);
        if ($byte == 92) {
            emit($cg, $bs);
            emit($cg, $bs);
        } elsif ($byte == 34) {
            emit($cg, $bs);
            emit($cg, chr(34));
        } elsif ($byte == 10) {
            emit($cg, $bs);
            emit($cg, "n");
        } elsif ($byte == 13) {
            emit($cg, $bs);
            emit($cg, "r");
        } elsif ($byte == 9) {
            emit($cg, $bs);
            emit($cg, "t");
        } elsif ($byte >= 32 && $byte < 127) {
            emit($cg, $ch);
        } else {
            my int $o1 = $byte / 64;
            my int $tmp = $byte / 8;
            my int $o2 = $tmp - ($o1 * 8);
            my int $o3 = $byte - ($tmp * 8);
            emit($cg, $bs);
            emit($cg, $o1);
            emit($cg, $o2);
            emit($cg, $o3);
        }
        $i = $i + 1;
    }
    emit($cg, "\"");
}

# Get accumulated output as a single string
func get_output(scalar $cg) str {
    # Get the current output from StringBuilder
    my str $final = sb_to_string($cg->{"output_sb"});

    # Check if we used multi-phase generation
    my str $preamble = $cg->{"preamble_content"};
    if (length($preamble) > 0) {
        my str $funcs = $cg->{"funcs_content"};
        my str $anon_decls = $cg->{"anon_func_decls"};
        my str $oop_decls = $cg->{"oop_fwd_decls"};

        # Build result: preamble + oop_decls + anon_decls + funcs + final
        my scalar $out_sb = sb_new();
        sb_append($out_sb, $preamble);
        if (length($oop_decls) > 0) {
            sb_append($out_sb, $oop_decls);
        }
        if (length($anon_decls) > 0) {
            sb_append($out_sb, "/* Anonymous function forward declarations */\n");
            sb_append($out_sb, $anon_decls);
            sb_append($out_sb, "\n");
        }
        sb_append($out_sb, $funcs);
        sb_append($out_sb, $final);
        return sb_to_string($out_sb);
    }

    return $final;
}

# Set output - for save/restore pattern in anonymous functions
func set_output(scalar $cg, str $text) void {
    sb_clear($cg->{"output_sb"});
    sb_append($cg->{"output_sb"}, $text);
}

func emit_line(scalar $cg, str $text) void {
    emit_indent($cg);
    emit($cg, $text . "\n");
}

func emit_indent(scalar $cg) void {
    my int $i = 0;
    while ($i < $cg->{"indent"}) {
        emit($cg, "    ");
        $i = $i + 1;
    }
}

# Emit stack_pop if stack tracing is enabled
func emit_stack_pop(scalar $cg) void {
    if ($cg->{"enable_stack_trace"} == 1) {
        emit_indent($cg);
        emit($cg, "strada_stack_pop();\n");
    }
}

# Emit inline stack_pop (no indent, for use in single-line statements)
func emit_stack_pop_inline(scalar $cg) str {
    if ($cg->{"enable_stack_trace"} == 1) {
        return " strada_stack_pop();";
    }
    return "";
}

# Scan a statement to check if it contains any try blocks
# Returns 1 if try found, 0 otherwise
func stmt_has_try(scalar $stmt) int {
    # If $stmt is null, $stmt->{"type"} returns 0/undef which won't match any NODE_* constant
    my int $type = $stmt->{"type"} + 0;

    # Direct try statement
    if ($type == NODE_TRY_CATCH()) {
        return 1;
    }

    # Check block statements
    if ($type == NODE_BLOCK()) {
        my scalar $stmts = $stmt->{"statements"};
        my int $count = $stmt->{"statement_count"};
        my int $i = 0;
        while ($i < $count) {
            if (stmt_has_try($stmts->[$i]) == 1) {
                return 1;
            }
            $i = $i + 1;
        }
        return 0;
    }

    # Check if/elsif/else
    if ($type == NODE_IF_STMT()) {
        if (stmt_has_try($stmt->{"then_block"}) == 1) {
            return 1;
        }
        if (stmt_has_try($stmt->{"else_block"}) == 1) {
            return 1;
        }
        return 0;
    }

    # Check while/for loops
    if ($type == NODE_WHILE_STMT() || $type == NODE_FOR_STMT()) {
        if (stmt_has_try($stmt->{"body"}) == 1) {
            return 1;
        }
        return 0;
    }

    # Check foreach
    if ($type == NODE_FOREACH_STMT()) {
        if (stmt_has_try($stmt->{"body"}) == 1) {
            return 1;
        }
        return 0;
    }

    # Check switch/case
    if ($type == NODE_SWITCH()) {
        my scalar $cases = $stmt->{"cases"};
        my int $count = $stmt->{"case_count"};
        my int $i = 0;
        while ($i < $count) {
            my scalar $case_node = $cases->[$i];
            if (stmt_has_try($case_node->{"body"}) == 1) {
                return 1;
            }
            $i = $i + 1;
        }
        return 0;
    }

    return 0;
}

# Check if a function body contains any try blocks
func func_body_has_try(scalar $body) int {
    # If $body is null, statement_count will be 0/undef, loop won't run
    my scalar $stmts = $body->{"statements"};
    my int $count = $body->{"statement_count"} + 0;
    my int $i = 0;
    while ($i < $count) {
        if (stmt_has_try($stmts->[$i]) == 1) {
            return 1;
        }
        $i = $i + 1;
    }
    return 0;
}

# Emit StradaValue* declaration with volatile qualifier when function contains try blocks
# This is needed because setjmp/longjmp can corrupt non-volatile local variables
# that were modified after setjmp was called. Using volatile ensures the variable
# values survive longjmp in exception handling.
# IMPORTANT: Use "StradaValue * volatile" (volatile pointer) not "volatile StradaValue *"
# (pointer to volatile). The pointer value needs to survive longjmp.
# We check func_has_try (set before generating the function) to determine if volatile is needed.
func emit_sv_ptr_decl(scalar $cg, str $name) void {
    my int $has_try = $cg->{"func_has_try"} + 0;
    if ($has_try > 0) {
        emit($cg, "StradaValue * volatile " . $name);
    } else {
        emit($cg, "StradaValue *" . $name);
    }
}

func indent(scalar $cg) void {
    $cg->{"indent"} = $cg->{"indent"} + 1;
}

func dedent(scalar $cg) void {
    $cg->{"indent"} = $cg->{"indent"} - 1;
}

# Check if name is in comma-separated string (workaround for bootstrap limitation)
func str_contains_name(str $list, str $name) int {
    my str $search = "," . $name . ",";
    my str $padded = "," . $list . ",";
    my int $pos = index($padded, $search);
    if ($pos >= 0) { return 1; }
    return 0;
}

# Get index of name in comma-separated capture string
func get_capture_index(str $list, str $name) int {
    if ($list eq "") { return -1; }
    my int $idx = 0;
    my int $start = 0;
    my int $len = length($list);
    my int $i = 0;
    while ($i <= $len) {
        my str $ch = "";
        if ($i < $len) { $ch = substr($list, $i, 1); }
        if ($ch eq "," || $i == $len) {
            my str $part = substr($list, $start, $i - $start);
            if ($part eq $name) { return $idx; }
            $idx = $idx + 1;
            $start = $i + 1;
        }
        $i = $i + 1;
    }
    return -1;
}

# Generate code for regex pattern with variable interpolation
# Pattern like "$foo" or "^$pattern$" gets converted to runtime string building
func gen_regex_interpolated_pattern(scalar $cg, str $pattern) void {
    # Parse pattern into parts (literals and variables)
    # We manually track the count since bootstrap doesn't support scalar(@array)
    my array @parts = ();
    my int $num_parts = 0;
    my int $len = length($pattern);
    my int $i = 0;
    my str $literal = "";

    while ($i < $len) {
        my str $ch = substr($pattern, $i, 1);

        if ($ch eq "$") {
            # Save any accumulated literal
            if (length($literal) > 0) {
                my hash %part = ();
                $part{"type"} = "lit";
                $part{"value"} = $literal;
                push(@parts, \%part);
                $num_parts = $num_parts + 1;
                $literal = "";
            }

            # Parse variable name
            $i = $i + 1;
            my str $varname = "";
            while ($i < $len) {
                my str $vch = substr($pattern, $i, 1);
                if ($vch eq "_" || ($vch ge "a" && $vch le "z") || ($vch ge "A" && $vch le "Z") || ($vch ge "0" && $vch le "9")) {
                    $varname = $varname . $vch;
                    $i = $i + 1;
                } else {
                    last;
                }
            }

            if (length($varname) > 0) {
                my hash %part = ();
                $part{"type"} = "var";
                $part{"value"} = $varname;
                push(@parts, \%part);
                $num_parts = $num_parts + 1;
            } else {
                # Not a variable - preserve $ as literal (regex end-of-line anchor)
                $literal = $literal . "$";
            }
        } else {
            $literal = $literal . $ch;
            $i = $i + 1;
        }
    }

    # Save any remaining literal
    if (length($literal) > 0) {
        my hash %part = ();
        $part{"type"} = "lit";
        $part{"value"} = $literal;
        push(@parts, \%part);
        $num_parts = $num_parts + 1;
    }

    # Generate concatenation code
    if ($num_parts == 0) {
        emit($cg, "strada_new_str(\"\")");
        return;
    }
    if ($num_parts == 1) {
        my scalar $p = $parts[0];
        if ($p->{"type"} eq "var") {
            emit($cg, $p->{"value"});
        } else {
            emit($cg, "strada_new_str(\"");
            emit_escaped_string($cg, $p->{"value"});
            emit($cg, "\")");
        }
        return;
    }

    # Multiple parts - build with sequential concat (no leaked intermediates)
    # Capture all parts into named temps, concat sequentially, free literal temps
    emit($cg, "({ ");
    # Capture all parts into named temps
    my int $pi = 0;
    while ($pi < $num_parts) {
        my scalar $p = $parts[$pi];
        emit($cg, "StradaValue *__rp" . $pi . " = ");
        if ($p->{"type"} eq "var") {
            emit($cg, $p->{"value"});
        } else {
            emit($cg, "strada_new_str(\"");
            emit_escaped_string($cg, $p->{"value"});
            emit($cg, "\")");
        }
        emit($cg, "; ");
        $pi = $pi + 1;
    }
    # Build chain: first concat, then concat_inplace for rest (frees intermediates)
    emit($cg, "StradaValue *__rr = strada_concat_sv(__rp0, __rp1); ");
    $pi = 2;
    while ($pi < $num_parts) {
        emit($cg, "__rr = strada_concat_inplace(__rr, __rp" . $pi . "); ");
        $pi = $pi + 1;
    }
    # Free literal temps (not variable refs which are borrowed)
    $pi = 0;
    while ($pi < $num_parts) {
        my scalar $p = $parts[$pi];
        if ($p->{"type"} eq "lit") {
            emit($cg, "strada_decref(__rp" . $pi . "); ");
        }
        $pi = $pi + 1;
    }
    emit($cg, "__rr; })");
}

# Helper to emit an escaped C string
func emit_escaped_string(scalar $cg, str $s) void {
    my int $i = 0;
    my int $len = length($s);
    while ($i < $len) {
        my str $ch = substr($s, $i, 1);
        if ($ch eq "\\") {
            emit($cg, "\\\\");
        } elsif ($ch eq "\"") {
            emit($cg, "\\\"");
        } elsif ($ch eq "\n") {
            emit($cg, "\\n");
        } elsif ($ch eq "\t") {
            emit($cg, "\\t");
        } else {
            emit($cg, $ch);
        }
        $i = $i + 1;
    }
}

# ============================================================
# Type Conversion
# ============================================================

func type_to_c(int $type) str {
    if ($type == TYPE_INT()) { return "StradaValue*"; }
    if ($type == TYPE_NUM()) { return "StradaValue*"; }
    if ($type == TYPE_STR()) { return "StradaValue*"; }
    if ($type == TYPE_BOOL()) { return "StradaValue*"; }
    if ($type == TYPE_ARRAY()) { return "StradaValue*"; }
    if ($type == TYPE_HASH()) { return "StradaValue*"; }
    if ($type == TYPE_SCALAR()) { return "StradaValue*"; }
    if ($type == TYPE_VOID()) { return "void"; }
    if ($type == TYPE_DYNAMIC()) { return "StradaValue*"; }
    if ($type == TYPE_FUNCPTR()) { return "void*"; }  # Function pointer
    return "StradaValue*";
}

# ============================================================
# Expression Code Generation
# ============================================================

# Helper: emit a numeric operand efficiently
# For literals, emit the value directly; otherwise use strada_to_num()
func emit_num_operand(scalar $cg, scalar $expr) void {
    my int $type = $expr->{"type"};
    if ($type == NODE_INT_LITERAL()) {
        my str $val = $expr->{"value"};
        # Check if it's a hex, octal, or binary literal
        # Also check for leading zeros (octal in C)
        my str $first = substr($val, 0, 1);
        my str $second = "";
        if (length($val) > 1) {
            $second = substr($val, 1, 1);
        }
        if (substr($val, 0, 2) eq "0x" || substr($val, 0, 2) eq "0X" ||
            substr($val, 0, 2) eq "0o" || substr($val, 0, 2) eq "0O" ||
            substr($val, 0, 2) eq "0b" || substr($val, 0, 2) eq "0B") {
            # Cast hex/octal/binary to double
            emit($cg, "(double)(" . $val . ")");
        } elsif ($first eq "0" && length($val) > 1 && $second ne ".") {
            # Leading zero means octal in C - must cast to preserve value
            emit($cg, "(double)(" . $val . ")");
        } else {
            emit($cg, $val . ".0");
        }
    } elsif ($type == NODE_NUM_LITERAL()) {
        emit($cg, $expr->{"value"});
    } else {
        # Check if expression creates a temp that needs cleanup
        if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $expr) == 1) {
            # Wrap in statement expression to capture and cleanup temp
            emit($cg, "({ StradaValue *__num_tmp = ");
            gen_expression($cg, $expr);
            emit($cg, "; double __num_val = strada_to_num(__num_tmp); strada_decref(__num_tmp); __num_val; })");
        } else {
            emit($cg, "strada_to_num(");
            gen_expression($cg, $expr);
            emit($cg, ")");
        }
    }
}

# Helper: emit an integer operand efficiently
# For literals, emit the value directly; otherwise use strada_to_int()
func emit_int_operand(scalar $cg, scalar $expr) void {
    my int $type = $expr->{"type"};
    if ($type == NODE_INT_LITERAL()) {
        emit($cg, $expr->{"value"});
    } elsif ($type == NODE_NUM_LITERAL()) {
        emit($cg, "(int64_t)" . $expr->{"value"});
    } else {
        # Check if expression creates a temp that needs cleanup
        if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $expr) == 1) {
            # Wrap in statement expression to capture and cleanup temp
            emit($cg, "({ StradaValue *__int_tmp = ");
            gen_expression($cg, $expr);
            emit($cg, "; int64_t __int_val = strada_to_int(__int_tmp); strada_decref(__int_tmp); __int_val; })");
        } else {
            emit($cg, "strada_to_int(");
            gen_expression($cg, $expr);
            emit($cg, ")");
        }
    }
}

# Helper: emit a bool operand efficiently
# For literals, emit the value directly; otherwise use strada_to_bool()
func emit_bool_operand(scalar $cg, scalar $expr) void {
    my int $type = $expr->{"type"};
    if ($type == NODE_INT_LITERAL()) {
        my str $val = $expr->{"value"};
        if ($val eq "0") {
            emit($cg, "0");
        } else {
            emit($cg, "1");
        }
    } elsif ($type == NODE_NUM_LITERAL()) {
        my str $val = $expr->{"value"};
        if ($val eq "0" || $val eq "0.0") {
            emit($cg, "0");
        } else {
            emit($cg, "1");
        }
    } else {
        # Check if expression creates a temp that needs cleanup
        if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $expr) == 1) {
            # Wrap in statement expression to capture and cleanup temp
            emit($cg, "({ StradaValue *__bool_tmp = ");
            gen_expression($cg, $expr);
            emit($cg, "; int __bool_val = strada_to_bool(__bool_tmp); strada_decref(__bool_tmp); __bool_val; })");
        } else {
            emit($cg, "strada_to_bool(");
            gen_expression($cg, $expr);
            emit($cg, ")");
        }
    }
}

# Helper: emit an expression as a C string in extern mode
# Converts non-string types (int, num) to strings using helper functions
func emit_extern_str_operand(scalar $cg, scalar $expr) void {
    my int $type = $expr->{"type"};

    # String literals - emit as raw C string
    if ($type == NODE_STR_LITERAL()) {
        gen_expression($cg, $expr);
        return;
    }

    # Integer literals - convert to string
    if ($type == NODE_INT_LITERAL()) {
        emit($cg, "strada_int_to_cstr(" . $expr->{"value"} . ")");
        return;
    }

    # Number literals - convert to string
    if ($type == NODE_NUM_LITERAL()) {
        emit($cg, "strada_num_to_cstr(" . $expr->{"value"} . ")");
        return;
    }

    # Variables - check extern_params for type and convert if needed
    if ($type == NODE_VARIABLE()) {
        my str $var_name = $expr->{"name"};
        my scalar $extern_params = $cg->{"extern_params"};
        if ($extern_params) {
            my scalar $param_type = $extern_params->{$var_name};
            if ($param_type) {
                if ($param_type == TYPE_INT() || $param_type == TYPE_BOOL() || $param_type == TYPE_INT32() || $param_type == TYPE_INT64()) {
                    emit($cg, "strada_int_to_cstr(" . $var_name . ")");
                    return;
                } elsif ($param_type == TYPE_NUM() || $param_type == TYPE_FLOAT32() || $param_type == TYPE_FLOAT64()) {
                    emit($cg, "strada_num_to_cstr(" . $var_name . ")");
                    return;
                }
            }
        }
        # String type or unknown - emit as-is
        emit($cg, $var_name);
        return;
    }

    # Binary op (nested concatenation) - recurse
    if ($type == NODE_BINARY_OP() && $expr->{"op"} eq ".") {
        emit($cg, "strada_cstr_concat(");
        emit_extern_str_operand($cg, $expr->{"left"});
        emit($cg, ", ");
        emit_extern_str_operand($cg, $expr->{"right"});
        emit($cg, ")");
        return;
    }

    # Other expressions - just emit (assume they return char*)
    gen_expression($cg, $expr);
}

# Helper: emit a condition as raw C boolean (avoids strada_new_int allocation)
# Used for while/for/if conditions to prevent memory leaks
func emit_condition(scalar $cg, scalar $expr) void {
    my int $type = $expr->{"type"};

    # Literals: emit 0 or 1 directly
    if ($type == NODE_INT_LITERAL()) {
        my str $val = $expr->{"value"};
        if ($val eq "0") {
            emit($cg, "0");
        } else {
            emit($cg, "1");
        }
        return;
    }
    if ($type == NODE_NUM_LITERAL()) {
        my str $val = $expr->{"value"};
        if ($val eq "0" || $val eq "0.0") {
            emit($cg, "0");
        } else {
            emit($cg, "1");
        }
        return;
    }

    # Binary operators: handle comparisons and logical ops without allocation
    if ($type == NODE_BINARY_OP()) {
        my str $op = $expr->{"op"};

        # Comparison operators: emit raw C comparison
        if ($op eq "==" || $op eq "!=" || $op eq "<" || $op eq ">" || $op eq "<=" || $op eq ">=") {
            emit($cg, "(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " " . $op . " ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
            return;
        }

        # Logical AND: recurse on both sides
        if ($op eq "&&") {
            emit($cg, "(");
            emit_condition($cg, $expr->{"left"});
            emit($cg, " && ");
            emit_condition($cg, $expr->{"right"});
            emit($cg, ")");
            return;
        }

        # Logical OR: recurse on both sides
        if ($op eq "||") {
            emit($cg, "(");
            emit_condition($cg, $expr->{"left"});
            emit($cg, " || ");
            emit_condition($cg, $expr->{"right"});
            emit($cg, ")");
            return;
        }
    }

    # Unary NOT: recurse
    if ($type == NODE_UNARY_OP()) {
        my str $op = $expr->{"op"};
        if ($op eq "!") {
            emit($cg, "!(");
            emit_condition($cg, $expr->{"operand"});
            emit($cg, ")");
            return;
        }
    }

    # Function call: handle defined() specially to avoid leak
    if ($type == NODE_CALL()) {
        my str $name = $expr->{"name"};
        if ($name eq "defined") {
            my scalar $args = $expr->{"args"};
            my scalar $arg = $args->[0];
            # Use non-allocating strada_defined_bool, cleanup arg if temporary
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $arg) == 1) {
                emit($cg, "({ StradaValue *__def_tmp = ");
                gen_expression($cg, $arg);
                emit($cg, "; int __def_res = strada_defined_bool(__def_tmp); strada_decref(__def_tmp); __def_res; })");
            } else {
                emit($cg, "strada_defined_bool(");
                gen_expression($cg, $arg);
                emit($cg, ")");
            }
            return;
        }
    }

    # Fallback: use strada_to_bool on the expression
    # If expression produces temporary value, capture and free it
    if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $expr) == 1) {
        emit($cg, "({ StradaValue *__cond_tmp = ");
        gen_expression($cg, $expr);
        emit($cg, "; int __cond_res = strada_to_bool(__cond_tmp); strada_decref(__cond_tmp); __cond_res; })");
    } else {
        emit($cg, "strada_to_bool(");
        gen_expression($cg, $expr);
        emit($cg, ")");
    }
}

# Helper: check if expression is a simple variable (doesn't need cleanup)
func is_variable_expr(scalar $expr) int {
    my int $type = $expr->{"type"};
    if ($type == NODE_VARIABLE()) {
        return 1;
    }
    return 0;
}

# Helper: check if expression produces an owned StradaValue* that needs cleanup
# Returns 1 for expressions we KNOW produce owned pointers (literals, concat, arithmetic)
# Returns 0 for unknown types (function calls, etc.) to be safe
func needs_temp_cleanup(scalar $cg, scalar $expr) int {
    my int $type = $expr->{"type"};

    # Literals always create owned StradaValue*
    if ($type == NODE_INT_LITERAL() || $type == NODE_NUM_LITERAL() || $type == NODE_STR_LITERAL() || $type == NODE_UNDEF()) {
        return 1;
    }

    # Binary ops that produce StradaValue*
    if ($type == NODE_BINARY_OP()) {
        my str $op = $expr->{"op"};
        # These ops produce owned StradaValue*
        if ($op eq "." || $op eq "+" || $op eq "-" || $op eq "*" || $op eq "/" ||
            $op eq "%" || $op eq "**" || $op eq "x" || $op eq "==" || $op eq "!=" ||
            $op eq "<" || $op eq ">" || $op eq "<=" || $op eq ">=" ||
            $op eq "&&" || $op eq "||" || $op eq "//" || $op eq "&" || $op eq "|" ||
            $op eq "^" || $op eq "<<" || $op eq ">>" ||
            $op eq "eq" || $op eq "ne" || $op eq "lt" || $op eq "gt" ||
            $op eq "le" || $op eq "ge" || $op eq "<=>" || $op eq "cmp" ||
            $op eq "=~" || $op eq "!~") {
            return 1;
        }
    }

    # Unary ops that produce StradaValue*
    if ($type == NODE_UNARY_OP()) {
        my str $op = $expr->{"op"};
        if ($op eq "!" || $op eq "-") {
            return 1;
        }
    }

    # Array/hash constructors
    if ($type == NODE_ANON_ARRAY() || $type == NODE_ANON_HASH()) {
        return 1;
    }

    # Hash access now returns owned ref (via strada_hv_fetch_owned)
    if ($type == NODE_HASH_ACCESS() || $type == NODE_DEREF_HASH()) {
        return 1;
    }

    # Slices create new arrays
    if ($type == NODE_ARRAY_SLICE() || $type == NODE_HASH_SLICE()) {
        return 1;
    }

    # Reference expressions (\$var, \@arr, \%hash) create owned refs
    if ($type == NODE_REF()) {
        return 1;
    }

    # Scalar deref ($$ref) returns owned reference via strada_deref() which increfs
    if ($type == NODE_DEREF_SCALAR() && $expr->{"sigil"} eq "$") {
        return 1;
    }

    # Ternary produces owned StradaValue* (from either branch)
    if ($type == NODE_TERNARY()) {
        return 1;
    }

    # Range expression produces owned array
    if ($type == NODE_RANGE()) {
        return 1;
    }

    # Sort expression (with comparison block) produces owned array
    if ($type == NODE_SORT()) {
        return 1;
    }

    # Regex match produces strada_new_int() (owned)
    if ($type == NODE_REGEX_MATCH()) {
        return 1;
    }

    # Capture variables ($1-$9) return owned references
    if ($type == NODE_CAPTURE_VAR()) {
        return 1;
    }

    # Variables don't need cleanup (already tracked) - UNLESS they are 'our' variables
    # which emit strada_global_get() returning an owned StradaValue*
    if ($type == NODE_VARIABLE()) {
        my str $var_name = $expr->{"name"};
        my str $c_name = escape_c_keyword($var_name);
        my scalar $our_vars = $cg->{"our_vars"};
        my str $our_check = "" . $our_vars->{$c_name};
        if (length($our_check) > 0) {
            return 1;
        }
        return 0;
    }

    # Method calls return owned StradaValue* that need cleanup
    if ($type == NODE_METHOD_CALL()) {
        return 1;
    }

    # Dynamic method calls return owned StradaValue* that need cleanup
    if ($type == NODE_DYN_METHOD_CALL()) {
        return 1;
    }

    # Closure calls return owned StradaValue* that need cleanup
    if ($type == NODE_CLOSURE_CALL()) {
        return 1;
    }

    # Anonymous functions (closures) return owned StradaValue* that need cleanup
    if ($type == NODE_ANON_FUNC()) {
        return 1;
    }

    # Function calls: check if it's a known function that returns owned StradaValue*
    if ($type == NODE_CALL()) {
        # Constant references (enum values) always create owned StradaValue*
        if ($expr->{"is_constant"} == 1) {
            return 1;
        }
        my str $name = $expr->{"name"};
        # Normalize core:: to sys::
        if (length($name) > 6 && substr($name, 0, 6) eq "core::") {
            $name = "sys::" . substr($name, 6, length($name) - 6);
        }
        # Built-in functions that return owned StradaValue*
        if ($name eq "chr" || $name eq "ord" ||
            $name eq "sys::base64_encode" || $name eq "sys::base64_decode" ||
            $name eq "sys::pack" || $name eq "sys::unpack" ||
            $name eq "sys::hex" ||
            $name eq "sys::ord_byte" || $name eq "sys::get_byte" ||
            $name eq "sys::byte_length" || $name eq "sys::byte_substr" ||
            $name eq "sys::set_byte" ||
            $name eq "sys::random_bytes" || $name eq "sys::random_bytes_hex" ||
            $name eq "sys::global_get" || $name eq "sys::global_exists" || $name eq "sys::global_keys" ||
            $name eq "sys::stack_trace" ||
            $name eq "sys::set_recursion_limit" || $name eq "sys::get_recursion_limit" ||
            $name eq "sys::wantarray" || $name eq "sys::wantscalar" || $name eq "sys::wanthash" ||
            $name eq "utf8::is_utf8" || $name eq "utf8::valid" ||
            $name eq "utf8::encode" || $name eq "utf8::decode" ||
            $name eq "utf8::downgrade" || $name eq "utf8::upgrade" ||
            $name eq "utf8::unicode_to_native" ||
            $name eq "substr" || $name eq "length" || $name eq "index" || $name eq "rindex" ||
            $name eq "uc" || $name eq "lc" || $name eq "ucfirst" || $name eq "lcfirst" ||
            $name eq "trim" || $name eq "ltrim" || $name eq "rtrim" ||
            $name eq "chomp" || $name eq "chop" ||
            $name eq "sprintf" || $name eq "join" || $name eq "reverse" ||
            $name eq "split" || $name eq "keys" || $name eq "values" ||
            $name eq "defined" || $name eq "exists" ||
            $name eq "ref" || $name eq "reftype" || $name eq "is_ref" || $name eq "is_refto" ||
            $name eq "deref" || $name eq "derefto" ||
            $name eq "bless" || $name eq "blessed" ||
            $name eq "isa" || $name eq "can" ||
            $name eq "UNIVERSAL::isa" || $name eq "UNIVERSAL::can" ||
            $name eq "size" || $name eq "scalar" ||
            $name eq "push" || $name eq "pop" || $name eq "shift" || $name eq "unshift" ||
            $name eq "sort" || $name eq "nsort" ||
            $name eq "splice" || $name eq "each" || $name eq "select" || $name eq "tied" || $name eq "tie" ||
            $name eq "abs" || $name eq "int" || $name eq "rand" || $name eq "srand" ||
            $name eq "refcount" || $name eq "sys::isweak" ||
            $name eq "time" || $name eq "localtime" || $name eq "gmtime" ||
            $name eq "math::sin" || $name eq "math::cos" || $name eq "math::tan" ||
            $name eq "math::sqrt" || $name eq "math::pow" || $name eq "math::log" ||
            $name eq "math::exp" || $name eq "math::floor" || $name eq "math::ceil" ||
            $name eq "math::abs" || $name eq "math::round" ||
            $name eq "match" || $name eq "replace" || $name eq "replace_all" ||
            $name eq "captures" || $name eq "named_captures" ||
            $name eq "sys::quotemeta" ||
            $name eq "bytes" || $name eq "hash_new" ||
            $name eq "sys::file_exists" ||
            $name eq "sys::open" || $name eq "sys::open_str" || $name eq "sys::str_from_fh" ||
            $name eq "sys::slurp" || $name eq "slurp" ||
            $name eq "sys::mkdir" || $name eq "sys::seek" || $name eq "sys::waitpid" ||
            $name eq "sys::getaddrinfo" ||
            $name eq "sys::socket_fd" || $name eq "sys::socket_send" ||
            $name eq "sys::socket_set_nonblocking" ||
            $name eq "sys::udp_bind" || $name eq "sys::udp_sendto" ||
            $name eq "sys::array_default_capacity" || $name eq "sys::hash_default_capacity" ||
            $name eq "sys::cstruct_new" || $name eq "sys::cstruct_get_int" ||
            $name eq "sys::cstruct_get_double" || $name eq "sys::cstruct_get_string" ||
            # Inline codegen builtins that return owned StradaValue*
            $name eq "substr_bytes" || $name eq "char_at" ||
            $name eq "sb_new" || $name eq "sb_to_string" || $name eq "sb_length" ||
            # File system ops
            $name eq "sys::chdir" || $name eq "sys::chroot" ||
            $name eq "sys::rmdir" || $name eq "sys::unlink" ||
            $name eq "sys::link" || $name eq "sys::symlink" || $name eq "sys::readlink" ||
            $name eq "sys::rename" || $name eq "sys::chmod" || $name eq "sys::access" ||
            $name eq "sys::umask" ||
            # User/group/process
            $name eq "sys::getuid" || $name eq "sys::geteuid" ||
            $name eq "sys::getgid" || $name eq "sys::getegid" ||
            $name eq "sys::kill" || $name eq "sys::signal" || $name eq "sys::alarm" ||
            # File stat/test
            $name eq "sys::stat" || $name eq "sys::lstat" || $name eq "sys::isatty" ||
            $name eq "sys::is_dir" || $name eq "sys::is_file" ||
            $name eq "sys::dir_exists" || $name eq "sys::file_size" ||
            # Error/errno
            $name eq "sys::strerror" || $name eq "sys::errno" ||
            # Time functions
            $name eq "sys::mktime" || $name eq "sys::strftime" || $name eq "sys::ctime" ||
            $name eq "sys::gettimeofday" || $name eq "sys::hires_time" ||
            $name eq "sys::tv_interval" || $name eq "sys::nanosleep" ||
            $name eq "sys::clock_gettime" || $name eq "sys::clock_getres" ||
            # Dynamic loading
            $name eq "sys::dl_open" || $name eq "sys::dl_sym" || $name eq "sys::dl_error" ||
            $name eq "sys::dl_call_export_info" || $name eq "sys::dl_call_version" ||
            # Pointer conversion
            $name eq "sys::int_ptr" || $name eq "sys::num_ptr" || $name eq "sys::str_ptr" ||
            $name eq "sys::ptr_deref_int" || $name eq "sys::ptr_deref_num" || $name eq "sys::ptr_deref_str" ||
            # Directory/path
            $name eq "sys::readdir" || $name eq "sys::readdir_full" ||
            $name eq "sys::realpath" || $name eq "sys::dirname" || $name eq "sys::basename" ||
            $name eq "sys::glob" || $name eq "sys::fnmatch" ||
            $name eq "sys::file_ext" || $name eq "sys::path_join" ||
            # File I/O
            $name eq "sys::tell" || $name eq "sys::rewind" || $name eq "sys::eof" ||
            $name eq "sys::flush" || $name eq "sys::readline" ||
            $name eq "sys::open_fd" ||
            # Network
            $name eq "sys::gethostbyname" || $name eq "sys::gethostbyname_all" ||
            $name eq "sys::gethostname" ||
            # Math two-arg
            $name eq "math::atan2" || $name eq "math::fabs" || $name eq "math::fmod" ||
            # Math one-arg (trig/hyperbolic)
            $name eq "math::asin" || $name eq "math::acos" || $name eq "math::atan" ||
            $name eq "math::sinh" || $name eq "math::cosh" || $name eq "math::tanh" ||
            $name eq "math::log10" ||
            # Math additional
            $name eq "math::hypot" || $name eq "math::cbrt" ||
            $name eq "math::isnan" || $name eq "math::isinf" || $name eq "math::isfinite" ||
            $name eq "math::fmax" || $name eq "math::fmin" ||
            $name eq "math::copysign" || $name eq "math::remainder" ||
            $name eq "math::trunc" || $name eq "math::ldexp" ||
            $name eq "math::frexp" || $name eq "math::modf" || $name eq "math::scalbn" ||
            # Environment/process
            $name eq "sys::getenv" || $name eq "sys::setenv" || $name eq "sys::unsetenv" ||
            $name eq "sys::popen" || $name eq "sys::pclose" ||
            $name eq "sys::mkstemp" || $name eq "sys::mkdtemp" || $name eq "sys::tmpfile" ||
            $name eq "sys::sleep" || $name eq "sys::usleep" ||
            $name eq "sys::qx" ||
            # File system additional
            $name eq "sys::truncate" || $name eq "sys::ftruncate" ||
            $name eq "sys::statvfs" || $name eq "sys::fstatvfs" ||
            $name eq "sys::dup" ||
            # Misc
            $name eq "dumper_str" ||
            # Async/threading
            $name eq "async::channel" || $name eq "async::mutex" || $name eq "async::atomic") {
            return 1;
        }
        # For user-defined functions, look up return type in $cg->{"functions"}
        my str $c_name = sanitize_name($name);
        my scalar $funcs = $cg->{"functions"};
        if ($funcs != 0) {
            my scalar $func_info = $funcs->{$c_name};
            if ($func_info != 0) {
                my int $ret_type = $func_info->{"return_type"};
                # TYPE_VOID() means no return value - don't try to capture it
                if ($ret_type == TYPE_VOID()) {
                    return 0;
                }
                # Non-void function returns owned StradaValue* that needs cleanup
                return 1;
            }
        }
        # Unknown function - be conservative, don't cleanup
        return 0;
    }

    # Default: don't cleanup (be conservative)
    return 0;
}

# Helper: check if return value needs incref before returning
# Returns 1 for variables and borrowed references (need incref to survive scope cleanup)
# Returns 0 for new/owned values (already have correct refcount)
func return_needs_incref(scalar $expr) int {
    my int $type = $expr->{"type"};

    # Variables need incref because scope cleanup will decref them
    if ($type == NODE_VARIABLE()) {
        return 1;
    }

    # Array access returns borrowed reference - need incref
    if ($type == NODE_SUBSCRIPT()) {
        return 1;
    }

    # Hash access now returns owned ref (via strada_hv_fetch_owned) - no incref
    if ($type == NODE_HASH_ACCESS() || $type == NODE_DEREF_HASH()) {
        return 0;
    }

    # Deref array returns borrowed ref - need incref
    if ($type == NODE_DEREF_ARRAY()) {
        return 1;
    }

    # Method calls return owned values - no incref needed (they already have refcount)
    if ($type == NODE_METHOD_CALL()) {
        return 0;
    }

    # Dynamic method calls return owned values - no incref needed
    if ($type == NODE_DYN_METHOD_CALL()) {
        return 0;
    }

    # Function calls - most return owned values, but bless() returns its argument
    if ($type == NODE_CALL()) {
        my str $name = $expr->{"name"};
        # bless() returns its first argument, so check if THAT needs incref
        if ($name eq "bless") {
            my scalar $args = $expr->{"args"};
            if ($args && $expr->{"arg_count"} > 0) {
                return return_needs_incref($args->[0]);
            }
            return 0;
        }
        return 0;
    }

    # Literals create owned values
    if ($type == NODE_INT_LITERAL() || $type == NODE_NUM_LITERAL() || $type == NODE_STR_LITERAL()) {
        return 0;
    }

    # Undef creates an owned value
    if ($type == NODE_UNDEF()) {
        return 0;
    }

    # Binary ops create owned values
    if ($type == NODE_BINARY_OP()) {
        return 0;
    }

    # Unary ops create owned values
    if ($type == NODE_UNARY_OP()) {
        return 0;
    }

    # Reference/anon constructors create owned values
    if ($type == NODE_REF() || $type == NODE_ANON_ARRAY() || $type == NODE_ANON_HASH()) {
        return 0;
    }

    # Anonymous functions (closures) create owned values with refcount=1
    if ($type == NODE_ANON_FUNC()) {
        return 0;
    }

    # Closure calls return owned values
    if ($type == NODE_CLOSURE_CALL()) {
        return 0;
    }

    # Ternary - check both branches (if either needs incref, do incref to be safe)
    if ($type == NODE_TERNARY()) {
        my int $true_needs = return_needs_incref($expr->{"true_expr"});
        my int $false_needs = return_needs_incref($expr->{"false_expr"});
        if ($true_needs == 1 || $false_needs == 1) {
            return 1;
        }
        return 0;
    }

    # Default: incref to be safe (conservative)
    return 1;
}

# Helper: generate a function call with temporary argument cleanup
# c_func_name: the C function to call (e.g., "strada_glob")
# args: array of argument expressions
# arg_count: number of arguments
# Returns nothing, emits code directly
func gen_call_with_arg_cleanup(scalar $cg, str $c_func_name, scalar $args, int $arg_count) void {
    if ($cg->{"cleanup_enabled"} == 0 || $arg_count == 0) {
        # No cleanup needed - emit simple call
        emit($cg, $c_func_name . "(");
        my int $i = 0;
        while ($i < $arg_count) {
            if ($i > 0) {
                emit($cg, ", ");
            }
            gen_expression($cg, $args->[$i]);
            $i = $i + 1;
        }
        emit($cg, ")");
        return;
    }

    # Check which arguments are temporaries (up to 8 args supported)
    my int $temp0 = 0;
    my int $temp1 = 0;
    my int $temp2 = 0;
    my int $temp3 = 0;
    my int $has_temps = 0;

    if ($arg_count > 0 && needs_temp_cleanup($cg, $args->[0]) == 1) {
        $temp0 = 1;
        $has_temps = 1;
    }
    if ($arg_count > 1 && needs_temp_cleanup($cg, $args->[1]) == 1) {
        $temp1 = 1;
        $has_temps = 1;
    }
    if ($arg_count > 2 && needs_temp_cleanup($cg, $args->[2]) == 1) {
        $temp2 = 1;
        $has_temps = 1;
    }
    if ($arg_count > 3 && needs_temp_cleanup($cg, $args->[3]) == 1) {
        $temp3 = 1;
        $has_temps = 1;
    }

    if ($has_temps == 0) {
        # No temporaries - emit simple call
        emit($cg, $c_func_name . "(");
        my int $i = 0;
        while ($i < $arg_count) {
            if ($i > 0) {
                emit($cg, ", ");
            }
            gen_expression($cg, $args->[$i]);
            $i = $i + 1;
        }
        emit($cg, ")");
        return;
    }

    # Has temporaries - wrap with cleanup
    emit($cg, "({ ");

    # Declare temp variables for each temporary argument
    if ($temp0 == 1) {
        emit($cg, "StradaValue *__call_arg0 = ");
        gen_expression($cg, $args->[0]);
        emit($cg, "; ");
    }
    if ($temp1 == 1) {
        emit($cg, "StradaValue *__call_arg1 = ");
        gen_expression($cg, $args->[1]);
        emit($cg, "; ");
    }
    if ($temp2 == 1) {
        emit($cg, "StradaValue *__call_arg2 = ");
        gen_expression($cg, $args->[2]);
        emit($cg, "; ");
    }
    if ($temp3 == 1) {
        emit($cg, "StradaValue *__call_arg3 = ");
        gen_expression($cg, $args->[3]);
        emit($cg, "; ");
    }

    # Emit the call with result capture
    emit($cg, "StradaValue *__call_result = " . $c_func_name . "(");
    my int $i = 0;
    while ($i < $arg_count) {
        if ($i > 0) {
            emit($cg, ", ");
        }
        if ($i == 0 && $temp0 == 1) {
            emit($cg, "__call_arg0");
        } elsif ($i == 1 && $temp1 == 1) {
            emit($cg, "__call_arg1");
        } elsif ($i == 2 && $temp2 == 1) {
            emit($cg, "__call_arg2");
        } elsif ($i == 3 && $temp3 == 1) {
            emit($cg, "__call_arg3");
        } else {
            gen_expression($cg, $args->[$i]);
        }
        $i = $i + 1;
    }
    emit($cg, "); ");

    # Decref all temp arguments
    if ($temp0 == 1) {
        emit($cg, "strada_decref(__call_arg0); ");
    }
    if ($temp1 == 1) {
        emit($cg, "strada_decref(__call_arg1); ");
    }
    if ($temp2 == 1) {
        emit($cg, "strada_decref(__call_arg2); ");
    }
    if ($temp3 == 1) {
        emit($cg, "strada_decref(__call_arg3); ");
    }

    # Return the result
    emit($cg, "__call_result; })");
}

func gen_expression(scalar $cg, scalar $expr) void {
    my int $type = $expr->{"type"};
    my int $in_extern = $cg->{"in_extern"};

    # Integer literal
    if ($type == NODE_INT_LITERAL()) {
        if ($in_extern) {
            emit($cg, $expr->{"value"});
        } else {
            emit($cg, "strada_new_int(" . $expr->{"value"} . ")");
        }
        return;
    }

    # Number literal
    if ($type == NODE_NUM_LITERAL()) {
        if ($in_extern) {
            emit($cg, $expr->{"value"});
        } else {
            emit($cg, "strada_new_num(" . $expr->{"value"} . ")");
        }
        return;
    }
    
    # String literal - use byte-level operations for proper UTF-8 handling
    if ($type == NODE_STR_LITERAL()) {
        # In extern mode, emit raw C string literal
        if ($in_extern) {
            emit($cg, "\"");
        } else {
            emit($cg, "strada_new_str(\"");
        }
        my str $val = $expr->{"value"};
        my int $i = 0;
        my int $len = bytes($val);
        while ($i < $len) {
            my int $code = char_at($val, $i);
            if ($code == 10) {
                emit($cg, "\\n");
            } elsif ($code == 9) {
                emit($cg, "\\t");
            } elsif ($code == 13) {
                emit($cg, "\\r");
            } elsif ($code == 0) {
                emit($cg, "\\0");
            } elsif ($code == 7) {
                emit($cg, "\\a");
            } elsif ($code == 8) {
                emit($cg, "\\b");
            } elsif ($code == 12) {
                emit($cg, "\\f");
            } elsif ($code == 11) {
                emit($cg, "\\v");
            } elsif ($code == 27) {
                emit($cg, "\\033");
            } elsif ($code == 34) {
                emit($cg, "\\\"");
            } elsif ($code == 92) {
                emit($cg, "\\\\");
            } elsif ($code >= 32 && $code <= 126) {
                # Printable ASCII - output as-is
                emit($cg, chr($code));
            } else {
                # Non-printable/high bytes - output raw byte directly
                # The C source file is UTF-8, so raw UTF-8 bytes are valid
                emit($cg, substr_bytes($val, $i, 1));
            }
            $i = $i + 1;
        }
        if ($in_extern) {
            emit($cg, "\"");
        } else {
            emit($cg, "\")");
        }
        return;
    }

    # Undef literal
    if ($type == NODE_UNDEF()) {
        emit($cg, "strada_new_undef()");
        return;
    }

    # Variable
    if ($type == NODE_VARIABLE()) {
        my str $var_name = $expr->{"name"};
        # Escape C keywords in variable names
        my str $c_var_name = escape_c_keyword($var_name);
        # Check if this is an 'our' variable - emit strada_global_get() instead
        my scalar $our_vars = $cg->{"our_vars"};
        my str $our_key = "" . $our_vars->{$c_var_name};
        if (length($our_key) > 0) {
            emit($cg, "strada_global_get(strada_new_str(\"");
            emit($cg, $our_key);
            emit($cg, "\"))");
            return;
        }
        # Handle magic variables for map/sort/grep blocks (only when in those contexts)
        if ($var_name eq "_" && ($cg->{"in_map_block"} || $cg->{"in_grep_block"})) {
            emit($cg, "__elem_");
        } elsif ($var_name eq "a" && $cg->{"in_sort_block"}) {
            emit($cg, "__sort_a_");
        } elsif ($var_name eq "b" && $cg->{"in_sort_block"}) {
            emit($cg, "__sort_b_");
        } elsif ($cg->{"in_anon_func"}) {
            # Inside anonymous function - check if it's a param, local, or capture
            my str $param_str = $cg->{"anon_param_str"};
            my str $local_str = $cg->{"anon_local_str"};
            my str $capture_str = $cg->{"anon_capture_str"};
            if (str_contains_name($param_str, $var_name)) {
                # It's a parameter - use directly (escaped for C)
                emit($cg, $c_var_name);
            } elsif (str_contains_name($local_str, $var_name)) {
                # It's a local variable - use directly (escaped for C)
                emit($cg, $c_var_name);
            } else {
                # It's a capture - get or add index
                my int $idx = get_capture_index($capture_str, $var_name);
                if ($idx < 0) {
                    # New capture - add it
                    if ($capture_str eq "") {
                        $cg->{"anon_capture_str"} = $var_name;
                    } else {
                        $cg->{"anon_capture_str"} = $capture_str . "," . $var_name;
                    }
                    $idx = $cg->{"anon_capture_count"};
                    $cg->{"anon_capture_count"} = $idx + 1;
                }
                # Use double pointer dereference for capture-by-reference
                emit($cg, "(*__captures[" . $idx . "])");
            }
        } else {
            emit($cg, $c_var_name);
        }
        return;
    }
    
    # Binary operation
    if ($type == NODE_BINARY_OP()) {
        my str $op = $expr->{"op"};

        # For extern functions, generate raw C arithmetic
        if ($in_extern) {
            if ($op eq "+" || $op eq "-" || $op eq "*" || $op eq "/" || $op eq "%") {
                emit($cg, "(");
                gen_expression($cg, $expr->{"left"});
                emit($cg, " " . $op . " ");
                gen_expression($cg, $expr->{"right"});
                emit($cg, ")");
            } elsif ($op eq "**") {
                # Exponentiation in extern - use pow()
                emit($cg, "pow(");
                gen_expression($cg, $expr->{"left"});
                emit($cg, ", ");
                gen_expression($cg, $expr->{"right"});
                emit($cg, ")");
            } elsif ($op eq "==" || $op eq "!=" || $op eq "<" || $op eq ">" || $op eq "<=" || $op eq ">=") {
                emit($cg, "(");
                gen_expression($cg, $expr->{"left"});
                emit($cg, " " . $op . " ");
                gen_expression($cg, $expr->{"right"});
                emit($cg, ")");
            } elsif ($op eq "&&" || $op eq "||" || $op eq "&" || $op eq "|" || $op eq "^" || $op eq "<<" || $op eq ">>") {
                emit($cg, "(");
                gen_expression($cg, $expr->{"left"});
                emit($cg, " " . $op . " ");
                gen_expression($cg, $expr->{"right"});
                emit($cg, ")");
            } elsif ($op eq ".") {
                # String concatenation in extern mode - use strada_cstr_concat helper
                # Need to convert non-string types to strings
                emit($cg, "strada_cstr_concat(");
                emit_extern_str_operand($cg, $expr->{"left"});
                emit($cg, ", ");
                emit_extern_str_operand($cg, $expr->{"right"});
                emit($cg, ")");
            } else {
                # Fallback for other ops
                emit($cg, "(");
                gen_expression($cg, $expr->{"left"});
                emit($cg, " " . $op . " ");
                gen_expression($cg, $expr->{"right"});
                emit($cg, ")");
            }
            return;
        }

        # Operator overloading dispatch for binary operators
        if ($op eq "+" || $op eq "-" || $op eq "*" || $op eq "/" || $op eq "%" || $op eq "**") {
            my scalar $left = $expr->{"left"};
            my scalar $right = $expr->{"right"};
            if (check_overload_binary($cg, $left, $right, $op) == 1) {
                gen_overloaded_binary($cg, $left, $right, $op);
                return;
            }
        }
        if ($op eq "==" || $op eq "!=" || $op eq "<" || $op eq ">" || $op eq "<=" || $op eq ">=" || $op eq "<=>") {
            my scalar $left = $expr->{"left"};
            my scalar $right = $expr->{"right"};
            if (check_overload_binary($cg, $left, $right, $op) == 1) {
                gen_overloaded_binary($cg, $left, $right, $op);
                return;
            }
        }
        if ($op eq "eq" || $op eq "ne" || $op eq "lt" || $op eq "gt" || $op eq "le" || $op eq "ge" || $op eq "cmp") {
            my scalar $left = $expr->{"left"};
            my scalar $right = $expr->{"right"};
            if (check_overload_binary($cg, $left, $right, $op) == 1) {
                gen_overloaded_binary($cg, $left, $right, $op);
                return;
            }
        }

        if ($op eq "+") {
            emit($cg, "strada_new_num(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " + ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "-") {
            emit($cg, "strada_new_num(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " - ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "*") {
            emit($cg, "strada_new_num(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " * ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "/") {
            # Safe division - returns undef if divisor is zero
            emit($cg, "strada_safe_div(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, ", ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "**") {
            # Exponentiation - use pow() from math.h
            emit($cg, "strada_new_num(pow(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, ", ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, "))");
        } elsif ($op eq "%") {
            # Safe modulo - returns undef if divisor is zero
            emit($cg, "strada_safe_mod((int64_t)");
            emit_int_operand($cg, $expr->{"left"});
            emit($cg, ", (int64_t)");
            emit_int_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "x") {
            # String repetition: "ab" x 3
            my int $left_cleanup = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $expr->{"left"}) == 1;
            if ($left_cleanup == 1) {
                emit($cg, "({ StradaValue *__rep_s = ");
                gen_expression($cg, $expr->{"left"});
                emit($cg, "; StradaValue *__rep_r = strada_string_repeat(__rep_s, (int64_t)");
                emit_int_operand($cg, $expr->{"right"});
                emit($cg, "); strada_decref(__rep_s); __rep_r; })");
            } else {
                emit($cg, "strada_string_repeat(");
                gen_expression($cg, $expr->{"left"});
                emit($cg, ", (int64_t)");
                emit_int_operand($cg, $expr->{"right"});
                emit($cg, ")");
            }
        } elsif ($op eq ".") {
            # Check for stringify ("") or concat (.) overloading
            my scalar $left = $expr->{"left"};
            my scalar $right = $expr->{"right"};

            if ($cg->{"has_overloads"} == 1) {
                my int $has_dot = 0;
                my int $has_stringify = 0;
                my scalar $ol_ops2 = $cg->{"overloaded_ops"};
                my str $dot_check = "" . $ol_ops2->{"."};
                if (length($dot_check) > 0) { $has_dot = 1; }
                my str $str_check = "" . $ol_ops2->{"\"\""};
                if (length($str_check) > 0) { $has_stringify = 1; }
                if (($has_dot == 1 || $has_stringify == 1) &&
                    (could_be_blessed($left) == 1 || could_be_blessed($right) == 1)) {
                    if ($has_dot == 1) {
                        # Full concat overload (checks . operator first, then falls back)
                        gen_overloaded_binary($cg, $left, $right, ".");
                    } else {
                        # Only stringify overload - stringify both sides then concat
                        gen_overloaded_concat($cg, $left, $right);
                    }
                    return;
                }
            }

            # Fast concat directly on StradaValues - no intermediate copies
            # When cleanup enabled, properly handle temporary arguments
            my int $left_is_temp = 0;
            my int $right_is_temp = 0;
            if ($cg->{"cleanup_enabled"} == 1) {
                if (needs_temp_cleanup($cg, $left) == 1) {
                    $left_is_temp = 1;
                }
                if (needs_temp_cleanup($cg, $right) == 1) {
                    $right_is_temp = 1;
                }
            }

            if ($left_is_temp == 1 || $right_is_temp == 1) {
                emit($cg, "({ ");
                if ($left_is_temp == 1) {
                    emit($cg, "StradaValue *__concat_l = ");
                    gen_expression($cg, $left);
                    emit($cg, "; ");
                }
                if ($right_is_temp == 1) {
                    emit($cg, "StradaValue *__concat_r = ");
                    gen_expression($cg, $right);
                    emit($cg, "; ");
                }
                emit($cg, "StradaValue *__concat_res = strada_concat_sv(");
                if ($left_is_temp == 1) {
                    emit($cg, "__concat_l");
                } else {
                    gen_expression($cg, $left);
                }
                emit($cg, ", ");
                if ($right_is_temp == 1) {
                    emit($cg, "__concat_r");
                } else {
                    gen_expression($cg, $right);
                }
                emit($cg, "); ");
                if ($left_is_temp == 1) {
                    emit($cg, "strada_decref(__concat_l); ");
                }
                if ($right_is_temp == 1) {
                    emit($cg, "strada_decref(__concat_r); ");
                }
                emit($cg, "__concat_res; })");
            } else {
                emit($cg, "strada_concat_sv(");
                gen_expression($cg, $left);
                emit($cg, ", ");
                gen_expression($cg, $right);
                emit($cg, ")");
            }
        } elsif ($op eq "==") {
            emit($cg, "strada_new_int(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " == ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "!=") {
            emit($cg, "strada_new_int(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " != ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "<") {
            emit($cg, "strada_new_int(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " < ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq ">") {
            emit($cg, "strada_new_int(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " > ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "<=") {
            emit($cg, "strada_new_int(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " <= ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq ">=") {
            emit($cg, "strada_new_int(");
            emit_num_operand($cg, $expr->{"left"});
            emit($cg, " >= ");
            emit_num_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "&&") {
            emit($cg, "strada_new_int(");
            emit_bool_operand($cg, $expr->{"left"});
            emit($cg, " && ");
            emit_bool_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "||") {
            # Perl-style || - return left if truthy, otherwise return right
            my scalar $left = $expr->{"left"};
            my scalar $right = $expr->{"right"};
            my int $left_needs_cleanup = needs_temp_cleanup($cg, $left);
            my int $left_needs_incref = return_needs_incref($left);
            my int $right_needs_incref = return_needs_incref($right);

            if ($cg->{"cleanup_enabled"} == 1) {
                emit($cg, "({ StradaValue *__or_l = ");
                gen_expression($cg, $left);
                emit($cg, "; StradaValue *__or_r; if (strada_to_bool(__or_l)) { __or_r = __or_l; ");
                if ($left_needs_incref == 1) {
                    emit($cg, "strada_incref(__or_r); ");
                }
                emit($cg, "} else { ");
                if ($left_needs_cleanup == 1) {
                    emit($cg, "strada_decref(__or_l); ");
                }
                emit($cg, "__or_r = ");
                gen_expression($cg, $right);
                emit($cg, "; ");
                if ($right_needs_incref == 1) {
                    emit($cg, "strada_incref(__or_r); ");
                }
                emit($cg, "} __or_r; })");
            } else {
                # No cleanup - simpler form (avoids double-evaluation)
                emit($cg, "({ StradaValue *__or_l = ");
                gen_expression($cg, $left);
                emit($cg, "; strada_to_bool(__or_l) ? __or_l : ");
                gen_expression($cg, $right);
                emit($cg, "; })");
            }
        } elsif ($op eq "//") {
            # Defined-or - return left if defined, otherwise return right
            my scalar $left = $expr->{"left"};
            my scalar $right = $expr->{"right"};
            my int $left_needs_cleanup = needs_temp_cleanup($cg, $left);
            my int $left_needs_incref = return_needs_incref($left);
            my int $right_needs_incref = return_needs_incref($right);

            if ($cg->{"cleanup_enabled"} == 1) {
                emit($cg, "({ StradaValue *__dor_l = ");
                gen_expression($cg, $left);
                emit($cg, "; StradaValue *__dor_r; if (strada_defined_bool(__dor_l)) { __dor_r = __dor_l; ");
                if ($left_needs_incref == 1) {
                    emit($cg, "strada_incref(__dor_r); ");
                }
                emit($cg, "} else { ");
                if ($left_needs_cleanup == 1) {
                    emit($cg, "strada_decref(__dor_l); ");
                }
                emit($cg, "__dor_r = ");
                gen_expression($cg, $right);
                emit($cg, "; ");
                if ($right_needs_incref == 1) {
                    emit($cg, "strada_incref(__dor_r); ");
                }
                emit($cg, "} __dor_r; })");
            } else {
                # No cleanup - simpler form
                emit($cg, "({ StradaValue *__dor_l = ");
                gen_expression($cg, $left);
                emit($cg, "; strada_defined_bool(__dor_l) ? __dor_l : ");
                gen_expression($cg, $right);
                emit($cg, "; })");
            }
        } elsif ($op eq "&") {
            emit($cg, "strada_new_int(");
            emit_int_operand($cg, $expr->{"left"});
            emit($cg, " & ");
            emit_int_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "|") {
            emit($cg, "strada_new_int(");
            emit_int_operand($cg, $expr->{"left"});
            emit($cg, " | ");
            emit_int_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "^") {
            emit($cg, "strada_new_int(");
            emit_int_operand($cg, $expr->{"left"});
            emit($cg, " ^ ");
            emit_int_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "<<") {
            emit($cg, "strada_new_int(");
            emit_int_operand($cg, $expr->{"left"});
            emit($cg, " << ");
            emit_int_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq ">>") {
            emit($cg, "strada_new_int(");
            emit_int_operand($cg, $expr->{"left"});
            emit($cg, " >> ");
            emit_int_operand($cg, $expr->{"right"});
            emit($cg, ")");
        } elsif ($op eq "eq") {
            gen_str_cmp($cg, $expr, "eq");
        } elsif ($op eq "ne") {
            gen_str_cmp($cg, $expr, "ne");
        } elsif ($op eq "lt") {
            gen_str_cmp($cg, $expr, "lt");
        } elsif ($op eq "gt") {
            gen_str_cmp($cg, $expr, "gt");
        } elsif ($op eq "le") {
            gen_str_cmp($cg, $expr, "le");
        } elsif ($op eq "ge") {
            gen_str_cmp($cg, $expr, "ge");
        } elsif ($op eq "<=>") {
            # Spaceship operator: returns -1, 0, or 1
            # Must cleanup StradaValue temporaries from operands
            my scalar $left = $expr->{"left"};
            my scalar $right = $expr->{"right"};
            my int $left_needs_cleanup = needs_temp_cleanup($cg, $left);
            my int $right_needs_cleanup = needs_temp_cleanup($cg, $right);

            if ($cg->{"cleanup_enabled"} == 1 && ($left_needs_cleanup == 1 || $right_needs_cleanup == 1)) {
                emit($cg, "({ StradaValue *__sp_lv = ");
                gen_expression($cg, $left);
                emit($cg, "; StradaValue *__sp_rv = ");
                gen_expression($cg, $right);
                emit($cg, "; double __l = strada_to_num(__sp_lv); double __r = strada_to_num(__sp_rv); ");
                if ($left_needs_cleanup == 1) {
                    emit($cg, "strada_decref(__sp_lv); ");
                }
                if ($right_needs_cleanup == 1) {
                    emit($cg, "strada_decref(__sp_rv); ");
                }
                emit($cg, "strada_new_int((__l < __r) ? -1 : ((__l > __r) ? 1 : 0)); })");
            } else {
                emit($cg, "strada_new_int(({ double __l = strada_to_num(");
                gen_expression($cg, $left);
                emit($cg, "); double __r = strada_to_num(");
                gen_expression($cg, $right);
                emit($cg, "); (__l < __r) ? -1 : ((__l > __r) ? 1 : 0); }))");
            }
        } elsif ($op eq "cmp") {
            # String comparison operator: returns -1, 0, or 1
            # Must free strada_to_str results AND cleanup StradaValue temporaries
            my scalar $left = $expr->{"left"};
            my scalar $right = $expr->{"right"};
            my int $left_needs_cleanup = needs_temp_cleanup($cg, $left);
            my int $right_needs_cleanup = needs_temp_cleanup($cg, $right);

            if ($cg->{"cleanup_enabled"} == 1 && ($left_needs_cleanup == 1 || $right_needs_cleanup == 1)) {
                emit($cg, "({ StradaValue *__cmp_lv = ");
                gen_expression($cg, $left);
                emit($cg, "; StradaValue *__cmp_rv = ");
                gen_expression($cg, $right);
                emit($cg, "; char *__sl = strada_to_str(__cmp_lv); char *__sr = strada_to_str(__cmp_rv); ");
                emit($cg, "int __cmp_res = strcmp(__sl, __sr); free(__sl); free(__sr); ");
                if ($left_needs_cleanup == 1) {
                    emit($cg, "strada_decref(__cmp_lv); ");
                }
                if ($right_needs_cleanup == 1) {
                    emit($cg, "strada_decref(__cmp_rv); ");
                }
                emit($cg, "strada_new_int((__cmp_res < 0) ? -1 : ((__cmp_res > 0) ? 1 : 0)); })");
            } else {
                emit($cg, "strada_new_int(({ char *__sl = strada_to_str(");
                gen_expression($cg, $left);
                emit($cg, "); char *__sr = strada_to_str(");
                gen_expression($cg, $right);
                emit($cg, "); int __cmp_res = strcmp(__sl, __sr); free(__sl); free(__sr); (__cmp_res < 0) ? -1 : ((__cmp_res > 0) ? 1 : 0); }))");
            }
        } elsif ($op eq "=~") {
            # Regex match with string pattern (no flags)
            my scalar $re_left = $expr->{"left"};
            my scalar $re_right = $expr->{"right"};
            my int $re_left_cleanup = needs_temp_cleanup($cg, $re_left);
            my int $re_right_cleanup = needs_temp_cleanup($cg, $re_right);
            emit($cg, "({ StradaValue *__re_lv = ");
            gen_expression($cg, $re_left);
            emit($cg, "; StradaValue *__re_rv = ");
            gen_expression($cg, $re_right);
            emit($cg, "; char *__re_l = strada_to_str(__re_lv); char *__re_r = strada_to_str(__re_rv); ");
            emit($cg, "int __re_m = strada_regex_match_with_capture(__re_l, __re_r, NULL); ");
            emit($cg, "free(__re_l); free(__re_r); ");
            if ($re_left_cleanup == 1) {
                emit($cg, "strada_decref(__re_lv); ");
            }
            if ($re_right_cleanup == 1) {
                emit($cg, "strada_decref(__re_rv); ");
            }
            emit($cg, "strada_new_int(__re_m); })");
        } elsif ($op eq "!~") {
            # Negated regex match with string pattern (no flags)
            my scalar $re_left = $expr->{"left"};
            my scalar $re_right = $expr->{"right"};
            my int $re_left_cleanup = needs_temp_cleanup($cg, $re_left);
            my int $re_right_cleanup = needs_temp_cleanup($cg, $re_right);
            emit($cg, "({ StradaValue *__re_lv = ");
            gen_expression($cg, $re_left);
            emit($cg, "; StradaValue *__re_rv = ");
            gen_expression($cg, $re_right);
            emit($cg, "; char *__re_l = strada_to_str(__re_lv); char *__re_r = strada_to_str(__re_rv); ");
            emit($cg, "int __re_m = !strada_regex_match_with_capture(__re_l, __re_r, NULL); ");
            emit($cg, "free(__re_l); free(__re_r); ");
            if ($re_left_cleanup == 1) {
                emit($cg, "strada_decref(__re_lv); ");
            }
            if ($re_right_cleanup == 1) {
                emit($cg, "strada_decref(__re_rv); ");
            }
            emit($cg, "strada_new_int(__re_m); })");
        }
        return;
    }

    # Regex match: $str =~ /pattern/flags or $str !~ /pattern/flags
    if ($type == NODE_REGEX_MATCH()) {
        my str $op = $expr->{"op"};
        my str $pattern = $expr->{"pattern"};
        my str $flags = $expr->{"flags"};

        # Check if pattern contains variable interpolation ($varname)
        # Only consider it interpolation if $ is followed by a word character
        # (not $ at end of pattern which is regex end-of-line anchor)
        my int $has_interp = 0;
        my int $check_i = 0;
        my int $pat_len = length($pattern);
        while ($check_i < $pat_len) {
            my str $ch = substr($pattern, $check_i, 1);
            if ($ch eq "$" && $check_i + 1 < $pat_len) {
                my str $next_ch = substr($pattern, $check_i + 1, 1);
                # Check if next char is start of variable name (letter or underscore)
                if ($next_ch eq "_" || ($next_ch ge "a" && $next_ch le "z") || ($next_ch ge "A" && $next_ch le "Z")) {
                    $has_interp = 1;
                    last;
                }
            }
            $check_i = $check_i + 1;
        }

        # Wrap in statement expression to free strada_to_str() temp
        # Also cleanup target if it's a temp (e.g., string literal in "abc" =~ /pattern/)
        my int $tgt_needs_cleanup = 0;
        if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $expr->{"target"}) == 1) {
            $tgt_needs_cleanup = 1;
        }
        if ($tgt_needs_cleanup == 1) {
            emit($cg, "({ StradaValue *__re_tgt = ");
            gen_expression($cg, $expr->{"target"});
            emit($cg, "; char *__re_str = strada_to_str(__re_tgt); ");
        } else {
            emit($cg, "({ char *__re_str = strada_to_str(");
            gen_expression($cg, $expr->{"target"});
            emit($cg, "); ");
        }

        # Also free interpolated pattern temp if needed
        if ($has_interp == 1) {
            emit($cg, "char *__re_pat = strada_to_str(");
            gen_regex_interpolated_pattern($cg, $pattern);
            emit($cg, "); ");
        }

        if ($op eq "=~") {
            emit($cg, "int __re_res = strada_regex_match_with_capture(__re_str, ");
        } else {
            emit($cg, "int __re_res = !strada_regex_match_with_capture(__re_str, ");
        }

        if ($has_interp == 1) {
            emit($cg, "__re_pat");
        } else {
            # Static pattern - emit as literal string
            emit($cg, "\"");
            my int $i = 0;
            my int $len = length($pattern);
            while ($i < $len) {
                my str $ch = substr($pattern, $i, 1);
                if ($ch eq "\\") {
                    emit($cg, "\\\\");
                } elsif ($ch eq "\"") {
                    emit($cg, "\\\"");
                } elsif ($ch eq "\n") {
                    emit($cg, "\\n");
                } elsif ($ch eq "\t") {
                    emit($cg, "\\t");
                } else {
                    emit($cg, $ch);
                }
                $i = $i + 1;
            }
            emit($cg, "\"");
        }
        emit($cg, ", ");
        # Pass flags (or NULL if empty)
        if (length($flags) > 0) {
            emit($cg, "\"" . $flags . "\"");
        } else {
            emit($cg, "NULL");
        }
        emit($cg, "); free(__re_str); ");
        if ($has_interp == 1) {
            emit($cg, "free(__re_pat); ");
        }
        if ($tgt_needs_cleanup == 1) {
            emit($cg, "strada_decref(__re_tgt); ");
        }
        emit($cg, "strada_new_int(__re_res); })");
        return;
    }

    # Regex substitution: $str =~ s/pattern/replacement/flags
    if ($type == NODE_REGEX_SUBST()) {
        my str $pattern = $expr->{"pattern"};
        my str $replacement = $expr->{"replacement"};
        my str $flags = $expr->{"flags"};

        # Check for flags
        my int $global = 0;
        if (index($flags, "g") >= 0) {
            $global = 1;
        }
        my int $eval_mode = 0;
        if (index($flags, "e") >= 0) {
            $eval_mode = 1;
        }

        if ($eval_mode == 1) {
            # /e modifier: evaluate replacement as expression for each match
            emit($cg, "{\n");
            emit_indent($cg);
            emit($cg, "char *__re_src = strada_to_str(");
            gen_expression($cg, $expr->{"target"});
            emit($cg, ");\n");
            emit_indent($cg);
            emit($cg, "StradaValue *__re_matches = strada_regex_find_all(__re_src, \"");
            # Escape pattern for C string
            my int $i = 0;
            my int $len = length($pattern);
            while ($i < $len) {
                my str $ch = substr($pattern, $i, 1);
                if ($ch eq "\\") {
                    emit($cg, "\\\\");
                } elsif ($ch eq "\"") {
                    emit($cg, "\\\"");
                } elsif ($ch eq "\n") {
                    emit($cg, "\\n");
                } elsif ($ch eq "\t") {
                    emit($cg, "\\t");
                } elsif ($ch eq "\r") {
                    emit($cg, "\\r");
                } else {
                    emit($cg, $ch);
                }
                $i = $i + 1;
            }
            emit($cg, "\", ");
            if (length($flags) > 0) {
                emit($cg, "\"" . $flags . "\"");
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ", " . $global . ");\n");
            emit_indent($cg);
            emit($cg, "StradaValue *__re_repls = strada_new_array();\n");
            emit_indent($cg);
            emit($cg, "for (size_t __re_i = 0; __re_i < __re_matches->value.av->size; __re_i++) {\n");
            emit_indent($cg);
            emit($cg, "    strada_set_captures_sv(__re_matches->value.av->elements[__re_i]);\n");
            emit_indent($cg);
            emit($cg, "    StradaValue *__re_repl = ");
            my scalar $eval_expr = $expr->{"eval_expr"};
            gen_expression($cg, $eval_expr);
            emit($cg, ";\n");
            emit_indent($cg);
            emit($cg, "    strada_array_push(__re_repls->value.av, __re_repl);\n");
            emit_indent($cg);
            emit($cg, "    strada_decref(__re_repl);\n");
            emit_indent($cg);
            emit($cg, "}\n");
            emit_indent($cg);
            emit($cg, "strada_decref(");
            gen_expression($cg, $expr->{"target"});
            emit($cg, ");\n");
            emit_indent($cg);
            gen_expression($cg, $expr->{"target"});
            emit($cg, " = strada_regex_build_result(__re_src, __re_matches, __re_repls);\n");
            emit_indent($cg);
            emit($cg, "strada_decref(__re_matches);\n");
            emit_indent($cg);
            emit($cg, "strada_decref(__re_repls);\n");
            emit_indent($cg);
            emit($cg, "free(__re_src);\n");
            emit($cg, "}\n");
            return;
        }

        # Generate: { char *__subst_src = strada_to_str(target); char *__subst_res = strada_regex_replace[_all](__subst_src, pattern, replacement, flags); strada_decref(target); target = strada_new_str(__subst_res); free(__subst_res); free(__subst_src); }
        emit($cg, "{ char *__subst_src = strada_to_str(");
        gen_expression($cg, $expr->{"target"});
        emit($cg, "); char *__subst_res = ");
        if ($global == 1) {
            emit($cg, "strada_regex_replace_all(");
        } else {
            emit($cg, "strada_regex_replace(");
        }
        emit($cg, "__subst_src, \"");
        # Escape pattern
        my int $i = 0;
        my int $len = length($pattern);
        while ($i < $len) {
            my str $ch = substr($pattern, $i, 1);
            if ($ch eq "\\") {
                emit($cg, "\\\\");
            } elsif ($ch eq "\"") {
                emit($cg, "\\\"");
            } elsif ($ch eq "\n") {
                emit($cg, "\\n");
            } elsif ($ch eq "\t") {
                emit($cg, "\\t");
            } elsif ($ch eq "\r") {
                emit($cg, "\\r");
            } else {
                emit($cg, $ch);
            }
            $i = $i + 1;
        }
        emit($cg, "\", \"");
        # Escape replacement
        $i = 0;
        $len = length($replacement);
        while ($i < $len) {
            my str $ch = substr($replacement, $i, 1);
            if ($ch eq "\\") {
                emit($cg, "\\\\");
            } elsif ($ch eq "\"") {
                emit($cg, "\\\"");
            } elsif ($ch eq "\n") {
                emit($cg, "\\n");
            } elsif ($ch eq "\t") {
                emit($cg, "\\t");
            } elsif ($ch eq "\r") {
                emit($cg, "\\r");
            } else {
                emit($cg, $ch);
            }
            $i = $i + 1;
        }
        emit($cg, "\", ");
        # Pass flags (or NULL if empty)
        if (length($flags) > 0) {
            emit($cg, "\"" . $flags . "\"");
        } else {
            emit($cg, "NULL");
        }
        emit($cg, "); strada_decref(");
        gen_expression($cg, $expr->{"target"});
        emit($cg, "); ");
        gen_expression($cg, $expr->{"target"});
        emit($cg, " = strada_new_str(__subst_res); free(__subst_res); free(__subst_src); }");
        return;
    }

    # Transliteration: $str =~ tr/search/replace/flags
    if ($type == NODE_TR()) {
        my str $search = $expr->{"search"};
        my str $replace_str = $expr->{"replace"};
        my str $flags = $expr->{"flags"};

        # Generate: ({ StradaValue *__tr_r = strada_tr(target, ...); strada_decref(__tr_r); })
        # strada_tr modifies the string in-place and returns the count
        emit($cg, "({ StradaValue *__tr_r = strada_tr(");
        gen_expression($cg, $expr->{"target"});
        emit($cg, ", \"");
        # Escape search string
        my int $i = 0;
        my int $len = length($search);
        while ($i < $len) {
            my str $ch = substr($search, $i, 1);
            if ($ch eq "\\") {
                emit($cg, "\\\\");
            } elsif ($ch eq "\"") {
                emit($cg, "\\\"");
            } else {
                emit($cg, $ch);
            }
            $i = $i + 1;
        }
        emit($cg, "\", \"");
        # Escape replace string
        $i = 0;
        $len = length($replace_str);
        while ($i < $len) {
            my str $ch = substr($replace_str, $i, 1);
            if ($ch eq "\\") {
                emit($cg, "\\\\");
            } elsif ($ch eq "\"") {
                emit($cg, "\\\"");
            } else {
                emit($cg, $ch);
            }
            $i = $i + 1;
        }
        emit($cg, "\", ");
        if (length($flags) > 0) {
            emit($cg, "\"" . $flags . "\"");
        } else {
            emit($cg, "\"\"");
        }
        emit($cg, "); strada_decref(__tr_r); })");
        return;
    }

    # Unary operation
    if ($type == NODE_UNARY_OP()) {
        my str $op = $expr->{"op"};
        my scalar $operand = $expr->{"operand"};
        my int $needs_cleanup = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $operand) == 1;

        # Check for overloaded unary operators
        if ($cg->{"has_overloads"} == 1 && could_be_blessed($operand) == 1) {
            my str $ol_op = $op;
            if ($op eq "-") { $ol_op = "neg"; }
            my scalar $ol_ops3 = $cg->{"overloaded_ops"};
            my str $uop_check = "" . $ol_ops3->{$ol_op};
            if (length($uop_check) > 0) {
                gen_overloaded_unary($cg, $operand, $ol_op);
                return;
            }
        }

        if ($op eq "-") {
            if ($needs_cleanup == 1) {
                emit($cg, "({ StradaValue *__unary_tmp = ");
                gen_expression($cg, $operand);
                emit($cg, "; StradaValue *__unary_res = strada_new_num(-strada_to_num(__unary_tmp)); strada_decref(__unary_tmp); __unary_res; })");
            } else {
                emit($cg, "strada_new_num(-strada_to_num(");
                gen_expression($cg, $operand);
                emit($cg, "))");
            }
        } elsif ($op eq "!") {
            if ($needs_cleanup == 1) {
                emit($cg, "({ StradaValue *__unary_tmp = ");
                gen_expression($cg, $operand);
                emit($cg, "; StradaValue *__unary_res = strada_new_int(!strada_to_bool(__unary_tmp)); strada_decref(__unary_tmp); __unary_res; })");
            } else {
                emit($cg, "strada_new_int(!strada_to_bool(");
                gen_expression($cg, $operand);
                emit($cg, "))");
            }
        } elsif ($op eq "~") {
            if ($needs_cleanup == 1) {
                emit($cg, "({ StradaValue *__unary_tmp = ");
                gen_expression($cg, $operand);
                emit($cg, "; StradaValue *__unary_res = strada_new_int(~strada_to_int(__unary_tmp)); strada_decref(__unary_tmp); __unary_res; })");
            } else {
                emit($cg, "strada_new_int(~strada_to_int(");
                gen_expression($cg, $operand);
                emit($cg, "))");
            }
        }
        return;
    }

    # Increment/decrement (++ and --)
    if ($type == NODE_INCREMENT()) {
        my str $op = $expr->{"op"};
        my int $is_prefix = $expr->{"is_prefix"};
        my scalar $operand = $expr->{"operand"};
        my int $operand_type = $operand->{"type"};

        # For simple variables, use address-of
        if ($operand_type == NODE_VARIABLE()) {
            if ($is_prefix == 1) {
                if ($op eq "++") {
                    emit($cg, "strada_preincr(&");
                } else {
                    emit($cg, "strada_predecr(&");
                }
            } else {
                if ($op eq "++") {
                    emit($cg, "strada_postincr(&");
                } else {
                    emit($cg, "strada_postdecr(&");
                }
            }
            gen_expression($cg, $operand);
            emit($cg, ")");
        } else {
            # For complex expressions, fall back to inline increment
            # This works for statement context but returns wrong value for postfix
            emit($cg, "(");
            gen_expression($cg, $operand);
            emit($cg, " = strada_new_num(strada_to_num(");
            gen_expression($cg, $operand);
            if ($op eq "++") {
                emit($cg, ") + 1))");
            } else {
                emit($cg, ") - 1))");
            }
        }
        return;
    }

    # Function call
    if ($type == NODE_CALL()) {
        my str $name = $expr->{"name"};

        # Normalize core:: to sys:: (core:: is a preferred alias)
        if (length($name) > 6 && substr($name, 0, 6) eq "core::") {
            $name = "sys::" . substr($name, 6, length($name) - 6);
            $expr->{"name"} = $name;
        }

        # Handle constant references (e.g., enum values like Color::RED)
        if ($expr->{"is_constant"} == 1) {
            emit($cg, "strada_new_int(" . sanitize_name($name) . ")");
            return;
        }

        # Built-in functions
        if ($name eq "say") {
            my int $argc = $expr->{"arg_count"};
            my scalar $args = $expr->{"args"};
            if ($argc == 2) {
                # say($fh, $text) - say to filehandle
                my scalar $text_arg = $args->[1];
                if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $text_arg) == 1) {
                    emit($cg, "({ StradaValue *__say_tmp = ");
                    gen_expression($cg, $text_arg);
                    emit($cg, "; strada_say_fh(__say_tmp, ");
                    gen_expression($cg, $args->[0]);
                    emit($cg, "); strada_decref(__say_tmp); })");
                } else {
                    emit($cg, "strada_say_fh(");
                    gen_expression($cg, $text_arg);
                    emit($cg, ", ");
                    gen_expression($cg, $args->[0]);
                    emit($cg, ")");
                }
            } elsif ($argc > 0) {
                my scalar $arg = $args->[0];
                # If cleanup enabled and arg is a temporary, wrap to decref after
                if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $arg) == 1) {
                    emit($cg, "({ StradaValue *__say_tmp = ");
                    gen_expression($cg, $arg);
                    emit($cg, "; strada_say(__say_tmp); strada_decref(__say_tmp); })");
                } else {
                    emit($cg, "strada_say(");
                    gen_expression($cg, $arg);
                    emit($cg, ")");
                }
            } else {
                emit($cg, "({ StradaValue *__say_tmp = strada_new_str(\"\"); strada_say(__say_tmp); strada_decref(__say_tmp); })");
            }
            return;
        }

        if ($name eq "print") {
            my int $argc = $expr->{"arg_count"};
            my scalar $args = $expr->{"args"};
            if ($argc == 2) {
                # print($fh, $text) - print to filehandle
                my scalar $text_arg = $args->[1];
                if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $text_arg) == 1) {
                    emit($cg, "({ StradaValue *__print_tmp = ");
                    gen_expression($cg, $text_arg);
                    emit($cg, "; strada_print_fh(__print_tmp, ");
                    gen_expression($cg, $args->[0]);
                    emit($cg, "); strada_decref(__print_tmp); })");
                } else {
                    emit($cg, "strada_print_fh(");
                    gen_expression($cg, $text_arg);
                    emit($cg, ", ");
                    gen_expression($cg, $args->[0]);
                    emit($cg, ")");
                }
            } elsif ($argc > 0) {
                my scalar $arg = $args->[0];
                # If cleanup enabled and arg is a temporary, wrap to decref after
                if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $arg) == 1) {
                    emit($cg, "({ StradaValue *__print_tmp = ");
                    gen_expression($cg, $arg);
                    emit($cg, "; strada_print(__print_tmp); strada_decref(__print_tmp); })");
                } else {
                    emit($cg, "strada_print(");
                    gen_expression($cg, $arg);
                    emit($cg, ")");
                }
            } else {
                emit($cg, "({ StradaValue *__print_tmp = strada_new_str(\"\"); strada_print(__print_tmp); strada_decref(__print_tmp); })");
            }
            return;
        }
        
        if ($name eq "length") {
            # UTF-8 character count
            # strada_to_str() returns a strdup'd string that MUST be freed
            my scalar $args = $expr->{"args"};
            my scalar $arg = $args->[0];
            emit($cg, "({ StradaValue *__len_tmp = ");
            gen_expression($cg, $arg);
            emit($cg, "; char *__len_str = strada_to_str(__len_tmp); int64_t __len_res = strada_length(__len_str); free(__len_str); ");
            if (needs_temp_cleanup($cg, $arg) == 1) {
                emit($cg, "strada_decref(__len_tmp); ");
            }
            emit($cg, "strada_new_int(__len_res); })");
            return;
        }

        if ($name eq "bytes") {
            # Binary-safe byte count using struct_size
            my scalar $args = $expr->{"args"};
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1) {
                emit($cg, "({ StradaValue *__bytes_v = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; StradaValue *__bytes_r = strada_new_int(strada_length_sv(__bytes_v)); strada_decref(__bytes_v); __bytes_r; })");
            } else {
                emit($cg, "strada_new_int(strada_length_sv(");
                gen_expression($cg, $args->[0]);
                emit($cg, "))");
            }
            return;
        }

        if ($name eq "char_at") {
            my scalar $args = $expr->{"args"};
            my scalar $ca_arg0 = $args->[0];
            my scalar $ca_arg1 = $args->[1];
            my int $ca_cleanup0 = needs_temp_cleanup($cg, $ca_arg0);
            my int $ca_cleanup1 = needs_temp_cleanup($cg, $ca_arg1);
            if ($ca_cleanup0 == 1 || $ca_cleanup1 == 1) {
                emit($cg, "({ ");
                if ($ca_cleanup0 == 1) {
                    emit($cg, "StradaValue *__ca_a0 = ");
                    gen_expression($cg, $ca_arg0);
                    emit($cg, "; ");
                }
                if ($ca_cleanup1 == 1) {
                    emit($cg, "StradaValue *__ca_a1 = ");
                    gen_expression($cg, $ca_arg1);
                    emit($cg, "; ");
                }
                emit($cg, "StradaValue *__ca_res = strada_char_at(");
                if ($ca_cleanup0 == 1) {
                    emit($cg, "__ca_a0");
                } else {
                    gen_expression($cg, $ca_arg0);
                }
                emit($cg, ", ");
                if ($ca_cleanup1 == 1) {
                    emit($cg, "__ca_a1");
                } else {
                    gen_expression($cg, $ca_arg1);
                }
                emit($cg, "); ");
                if ($ca_cleanup0 == 1) {
                    emit($cg, "strada_decref(__ca_a0); ");
                }
                if ($ca_cleanup1 == 1) {
                    emit($cg, "strada_decref(__ca_a1); ");
                }
                emit($cg, "__ca_res; })");
            } else {
                emit($cg, "strada_char_at(");
                gen_expression($cg, $ca_arg0);
                emit($cg, ", ");
                gen_expression($cg, $ca_arg1);
                emit($cg, ")");
            }
            return;
        }

        if ($name eq "substr_bytes") {
            my scalar $args = $expr->{"args"};
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1) {
                emit($cg, "({ StradaValue *__subb_v = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; StradaValue *__subb_r = strada_substr_bytes(__subb_v, ");
                emit_int_operand($cg, $args->[1]);
                emit($cg, ", ");
                if ($expr->{"arg_count"} > 2) {
                    emit_int_operand($cg, $args->[2]);
                } else {
                    emit($cg, "-1");
                }
                emit($cg, "); strada_decref(__subb_v); __subb_r; })");
            } else {
                emit($cg, "strada_substr_bytes(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", ");
                emit_int_operand($cg, $args->[1]);
                emit($cg, ", ");
                if ($expr->{"arg_count"} > 2) {
                    emit_int_operand($cg, $args->[2]);
                } else {
                    emit($cg, "-1");
                }
                emit($cg, ")");
            }
            return;
        }

        if ($name eq "substr") {
            my scalar $args = $expr->{"args"};
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1) {
                emit($cg, "({ StradaValue *__sub_v = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; StradaValue *__sub_r = strada_substr(__sub_v, ");
                emit_int_operand($cg, $args->[1]);
                emit($cg, ", ");
                if ($expr->{"arg_count"} > 2) {
                    emit_int_operand($cg, $args->[2]);
                } else {
                    emit($cg, "-1");
                }
                emit($cg, "); strada_decref(__sub_v); __sub_r; })");
            } else {
                emit($cg, "strada_substr(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", ");
                emit_int_operand($cg, $args->[1]);
                emit($cg, ", ");
                if ($expr->{"arg_count"} > 2) {
                    emit_int_operand($cg, $args->[2]);
                } else {
                    emit($cg, "-1");
                }
                emit($cg, ")");
            }
            return;
        }
        
        if ($name eq "push") {
            my scalar $args = $expr->{"args"};
            my scalar $val_arg = $args->[1];
            my int $arr_cleanup = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1;
            # Check if value needs cleanup after push (newly created values do)
            if (needs_temp_cleanup($cg, $val_arg) == 1 || $arr_cleanup == 1) {
                emit($cg, "({ ");
                if ($arr_cleanup == 1) {
                    emit($cg, "StradaValue *__push_a = ");
                    gen_expression($cg, $args->[0]);
                    emit($cg, "; ");
                }
                if (needs_temp_cleanup($cg, $val_arg) == 1) {
                    emit($cg, "StradaValue *__push_v = ");
                    gen_expression($cg, $val_arg);
                    emit($cg, "; strada_array_push(strada_deref_array(");
                    if ($arr_cleanup == 1) {
                        emit($cg, "__push_a");
                    } else {
                        gen_expression($cg, $args->[0]);
                    }
                    emit($cg, "), __push_v); strada_decref(__push_v); ");
                } else {
                    emit($cg, "strada_array_push(strada_deref_array(");
                    if ($arr_cleanup == 1) {
                        emit($cg, "__push_a");
                    } else {
                        gen_expression($cg, $args->[0]);
                    }
                    emit($cg, "), ");
                    gen_expression($cg, $val_arg);
                    emit($cg, "); ");
                }
                if ($arr_cleanup == 1) {
                    emit($cg, "strada_decref(__push_a); ");
                }
                emit($cg, "strada_undef_static(); })");
            } else {
                # Value is borrowed (variable, array/hash access) - no decref needed
                emit($cg, "(strada_array_push(strada_deref_array(");
                gen_expression($cg, $args->[0]);
                emit($cg, "), ");
                gen_expression($cg, $val_arg);
                emit($cg, "), strada_undef_static())");
            }
            return;
        }

        # reserve - pre-allocate array capacity
        if ($name eq "reserve") {
            my scalar $args = $expr->{"args"};
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1) {
                emit($cg, "({ StradaValue *__rsv_v = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; strada_reserve_sv(__rsv_v, ");
                emit_int_operand($cg, $args->[1]);
                emit($cg, "); strada_decref(__rsv_v); strada_undef_static(); })");
            } else {
                emit($cg, "(strada_reserve_sv(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", ");
                emit_int_operand($cg, $args->[1]);
                emit($cg, "), strada_undef_static())");
            }
            return;
        }

        if ($name eq "size") {
            my scalar $args = $expr->{"args"};
            my scalar $arg = $args->[0];
            if (needs_temp_cleanup($cg, $arg) == 1) {
                emit($cg, "({ StradaValue *__sz_v = ");
                gen_expression($cg, $arg);
                emit($cg, "; StradaValue *__sz_r = strada_new_int(strada_size(__sz_v)); strada_decref(__sz_v); __sz_r; })");
            } else {
                emit($cg, "strada_new_int(strada_size(");
                gen_expression($cg, $arg);
                emit($cg, "))");
            }
            return;
        }
        
        if ($name eq "pop") {
            my scalar $args = $expr->{"args"};
            my int $arr_cleanup = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1;
            if ($arr_cleanup == 1) {
                emit($cg, "({ StradaValue *__pop_a = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; StradaValue *__pop_r = strada_array_pop(strada_deref_array(__pop_a)); strada_decref(__pop_a); __pop_r; })");
            } else {
                emit($cg, "strada_array_pop(strada_deref_array(");
                gen_expression($cg, $args->[0]);
                emit($cg, "))");
            }
            return;
        }

        if ($name eq "shift") {
            my scalar $args = $expr->{"args"};
            my int $arr_cleanup = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1;
            if ($arr_cleanup == 1) {
                emit($cg, "({ StradaValue *__shift_a = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; StradaValue *__shift_r = strada_array_shift(strada_deref_array(__shift_a)); strada_decref(__shift_a); __shift_r; })");
            } else {
                emit($cg, "strada_array_shift(strada_deref_array(");
                gen_expression($cg, $args->[0]);
                emit($cg, "))");
            }
            return;
        }
        
        if ($name eq "unshift") {
            my scalar $args = $expr->{"args"};
            my scalar $val_arg = $args->[1];
            my int $arr_cleanup = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1;
            # Check if value or array needs cleanup
            if (needs_temp_cleanup($cg, $val_arg) == 1 || $arr_cleanup == 1) {
                emit($cg, "({ ");
                if ($arr_cleanup == 1) {
                    emit($cg, "StradaValue *__unsh_a = ");
                    gen_expression($cg, $args->[0]);
                    emit($cg, "; ");
                }
                if (needs_temp_cleanup($cg, $val_arg) == 1) {
                    emit($cg, "StradaValue *__unsh_v = ");
                    gen_expression($cg, $val_arg);
                    emit($cg, "; strada_array_unshift(strada_deref_array(");
                    if ($arr_cleanup == 1) {
                        emit($cg, "__unsh_a");
                    } else {
                        gen_expression($cg, $args->[0]);
                    }
                    emit($cg, "), __unsh_v); strada_decref(__unsh_v); ");
                } else {
                    emit($cg, "strada_array_unshift(strada_deref_array(");
                    if ($arr_cleanup == 1) {
                        emit($cg, "__unsh_a");
                    } else {
                        gen_expression($cg, $args->[0]);
                    }
                    emit($cg, "), ");
                    gen_expression($cg, $val_arg);
                    emit($cg, "); ");
                }
                if ($arr_cleanup == 1) {
                    emit($cg, "strada_decref(__unsh_a); ");
                }
                emit($cg, "strada_undef_static(); })");
            } else {
                # Value is borrowed (variable, array/hash access) - no decref needed
                emit($cg, "(strada_array_unshift(strada_deref_array(");
                gen_expression($cg, $args->[0]);
                emit($cg, "), ");
                gen_expression($cg, $val_arg);
                emit($cg, "), strada_undef_static())");
            }
            return;
        }

        # splice(@arr, offset [, length [, @replacement]])
        if ($name eq "splice") {
            my scalar $args = $expr->{"args"};
            my int $argc = $expr->{"arg_count"};
            my int $sp_arr_cleanup = 0;
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1) {
                $sp_arr_cleanup = 1;
            }
            my int $sp_repl_cleanup = 0;
            if ($argc >= 4 && $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[3]) == 1) {
                $sp_repl_cleanup = 1;
            }
            if ($sp_arr_cleanup == 1 || $sp_repl_cleanup == 1) {
                emit($cg, "({ ");
                if ($sp_arr_cleanup == 1) {
                    emit($cg, "StradaValue *__sp_a = ");
                    gen_expression($cg, $args->[0]);
                    emit($cg, "; ");
                }
                if ($sp_repl_cleanup == 1) {
                    emit($cg, "StradaValue *__sp_r = ");
                    gen_expression($cg, $args->[3]);
                    emit($cg, "; ");
                }
                emit($cg, "StradaValue *__sp_res = strada_array_splice_sv(");
                if ($sp_arr_cleanup == 1) {
                    emit($cg, "__sp_a");
                } else {
                    gen_expression($cg, $args->[0]);
                }
                emit($cg, ", ");
                if ($argc >= 2) {
                    emit_int_operand($cg, $args->[1]);
                } else {
                    emit($cg, "0");
                }
                emit($cg, ", ");
                if ($argc >= 3) {
                    emit_int_operand($cg, $args->[2]);
                } else {
                    emit($cg, "-1");
                }
                emit($cg, ", ");
                if ($sp_repl_cleanup == 1) {
                    emit($cg, "__sp_r");
                } else {
                    if ($argc >= 4) {
                        gen_expression($cg, $args->[3]);
                    } else {
                        emit($cg, "NULL");
                    }
                }
                emit($cg, "); ");
                if ($sp_arr_cleanup == 1) {
                    emit($cg, "strada_decref(__sp_a); ");
                }
                if ($sp_repl_cleanup == 1) {
                    emit($cg, "strada_decref(__sp_r); ");
                }
                emit($cg, "__sp_res; })");
            } else {
                emit($cg, "strada_array_splice_sv(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", ");
                if ($argc >= 2) {
                    emit_int_operand($cg, $args->[1]);
                } else {
                    emit($cg, "0");
                }
                emit($cg, ", ");
                if ($argc >= 3) {
                    emit_int_operand($cg, $args->[2]);
                } else {
                    emit($cg, "-1");
                }
                emit($cg, ", ");
                if ($argc >= 4) {
                    gen_expression($cg, $args->[3]);
                } else {
                    emit($cg, "NULL");
                }
                emit($cg, ")");
            }
            return;
        }

        # each(%hash) - returns [key, value] pair or empty array
        if ($name eq "each") {
            my scalar $args = $expr->{"args"};
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1) {
                emit($cg, "({ StradaValue *__each_h = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; StradaValue *__each_r = strada_hash_each(strada_deref_hash(__each_h)); strada_decref(__each_h); __each_r; })");
            } else {
                emit($cg, "strada_hash_each(strada_deref_hash(");
                gen_expression($cg, $args->[0]);
                emit($cg, "))");
            }
            return;
        }

        # select() - get/set default filehandle
        if ($name eq "select") {
            my scalar $args = $expr->{"args"};
            my int $argc = $expr->{"arg_count"};
            if ($argc == 0) {
                emit($cg, "strada_select_get()");
            } else {
                if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1) {
                    emit($cg, "({ StradaValue *__sel_tmp = ");
                    gen_expression($cg, $args->[0]);
                    emit($cg, "; StradaValue *__sel_r = strada_select(__sel_tmp); strada_decref(__sel_tmp); __sel_r; })");
                } else {
                    emit($cg, "strada_select(");
                    gen_expression($cg, $args->[0]);
                    emit($cg, ")");
                }
            }
            return;
        }

        # tie(%hash, "ClassName", @args)
        if ($name eq "tie") {
            my scalar $args = $expr->{"args"};
            my int $argc = $expr->{"arg_count"};
            # tie(%hash, "ClassName", @extra_args...)
            # strada_tie_hash(ref, const char *classname, int argc, ...)
            emit($cg, "strada_tie_hash(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            # Class name must be a string literal for now
            if ($argc >= 2 && $args->[1]->{"type"} == NODE_STR_LITERAL()) {
                emit($cg, "\"" . $args->[1]->{"value"} . "\"");
            } elsif ($argc >= 2) {
                emit($cg, "\"HASH\"");
            } else {
                emit($cg, "\"HASH\"");
            }
            # Pass remaining args count and values
            my int $extra = $argc - 2;
            if ($extra < 0) {
                $extra = 0;
            }
            emit($cg, ", " . $extra);
            my int $ai = 2;
            while ($ai < $argc) {
                emit($cg, ", ");
                gen_expression($cg, $args->[$ai]);
                $ai = $ai + 1;
            }
            emit($cg, ")");
            return;
        }

        # untie(%hash)
        if ($name eq "untie") {
            my scalar $args = $expr->{"args"};
            emit($cg, "(strada_untie(");
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_undef_static())");
            return;
        }

        # tied(%hash) - returns tied object or undef
        if ($name eq "tied") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_tied(");
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sort") {
            my scalar $args = $expr->{"args"};
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1) {
                emit($cg, "({ StradaValue *__sort_a = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; StradaValue *__sort_r = strada_sort(__sort_a); strada_decref(__sort_a); __sort_r; })");
            } else {
                emit($cg, "strada_sort(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")");
            }
            return;
        }

        if ($name eq "nsort") {
            my scalar $args = $expr->{"args"};
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1) {
                emit($cg, "({ StradaValue *__nsort_a = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; StradaValue *__nsort_r = strada_nsort(__nsort_a); strada_decref(__nsort_a); __nsort_r; })");
            } else {
                emit($cg, "strada_nsort(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")");
            }
            return;
        }

        if ($name eq "split") {
            # split(pattern, string) - like Perl
            # strada_regex_split(str, pattern) - runtime signature
            # Need to properly cleanup strada_to_str() results and temp args
            # Use strada_new_array_from_av() to avoid leaking the initial empty array
            my scalar $args = $expr->{"args"};
            my scalar $pattern_arg = $args->[0];
            my scalar $string_arg = $args->[1];
            my int $pattern_needs_cleanup = needs_temp_cleanup($cg, $pattern_arg);
            my int $string_needs_cleanup = needs_temp_cleanup($cg, $string_arg);

            emit($cg, "(({ ");
            emit($cg, "StradaValue *__split_pat = ");
            gen_expression($cg, $pattern_arg);
            emit($cg, "; StradaValue *__split_str = ");
            gen_expression($cg, $string_arg);
            emit($cg, "; char *__pat_cstr = strada_to_str(__split_pat); ");
            emit($cg, "char *__str_cstr = strada_to_str(__split_str); ");
            emit($cg, "StradaValue *__sv = strada_new_array_from_av(strada_regex_split(__str_cstr, __pat_cstr)); ");
            emit($cg, "free(__pat_cstr); free(__str_cstr); ");
            if ($pattern_needs_cleanup == 1) {
                emit($cg, "strada_decref(__split_pat); ");
            }
            if ($string_needs_cleanup == 1) {
                emit($cg, "strada_decref(__split_str); ");
            }
            emit($cg, "__sv; }))");
            return;
        }
        
        if ($name eq "join") {
            # join(separator, array) - need to cleanup strada_to_str() result and strada_join() result
            my scalar $args = $expr->{"args"};
            my scalar $sep_arg = $args->[0];
            my int $sep_needs_cleanup = needs_temp_cleanup($cg, $sep_arg);

            my int $arr_needs_cleanup = needs_temp_cleanup($cg, $args->[1]);

            emit($cg, "(({ ");
            emit($cg, "StradaValue *__join_sep = ");
            gen_expression($cg, $sep_arg);
            emit($cg, "; char *__sep_cstr = strada_to_str(__join_sep); ");
            if ($arr_needs_cleanup == 1) {
                emit($cg, "StradaValue *__join_arr = ");
                gen_expression($cg, $args->[1]);
                emit($cg, "; char *__joined = strada_join(__sep_cstr, strada_deref_array(__join_arr)); ");
            } else {
                emit($cg, "char *__joined = strada_join(__sep_cstr, strada_deref_array(");
                gen_expression($cg, $args->[1]);
                emit($cg, ")); ");
            }
            emit($cg, "StradaValue *__join_res = strada_new_str(__joined); ");
            emit($cg, "free(__joined); free(__sep_cstr); ");
            if ($sep_needs_cleanup == 1) {
                emit($cg, "strada_decref(__join_sep); ");
            }
            if ($arr_needs_cleanup == 1) {
                emit($cg, "strada_decref(__join_arr); ");
            }
            emit($cg, "__join_res; }))");
            return;
        }
        
        if ($name eq "keys") {
            my scalar $args = $expr->{"args"};
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1) {
                emit($cg, "({ StradaValue *__keys_v = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; StradaValue *__keys_r = strada_new_array_from_av(strada_hash_keys(strada_deref_hash(__keys_v))); strada_decref(__keys_v); __keys_r; })");
            } else {
                emit($cg, "strada_new_array_from_av(strada_hash_keys(strada_deref_hash(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")))");
            }
            return;
        }
        
        if ($name eq "values") {
            my scalar $args = $expr->{"args"};
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1) {
                emit($cg, "({ StradaValue *__vals_v = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; StradaValue *__vals_r = strada_new_array_from_av(strada_hash_values(strada_deref_hash(__vals_v))); strada_decref(__vals_v); __vals_r; })");
            } else {
                emit($cg, "strada_new_array_from_av(strada_hash_values(strada_deref_hash(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")))");
            }
            return;
        }
        
        if ($name eq "exists") {
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];

            # Check if single arg is a hash access node
            if ($expr->{"arg_count"} == 1 && $arg0->{"type"} == NODE_HASH_ACCESS()) {
                my scalar $key_expr = $arg0->{"key"};
                my int $key_needs_cleanup = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $key_expr) == 1;
                # Generate block to properly clean up C string and key temp
                emit($cg, "({ StradaValue *__ex_key = ");
                gen_expression($cg, $key_expr);
                emit($cg, "; char *__ex_ks = strada_to_str(__ex_key); int __ex_res = strada_hv_exists(");
                gen_expression($cg, $arg0->{"hash"});
                emit($cg, ", __ex_ks); free(__ex_ks); ");
                if ($key_needs_cleanup == 1) {
                    emit($cg, "strada_decref(__ex_key); ");
                }
                emit($cg, "strada_new_int(__ex_res); })");
            } elsif ($expr->{"arg_count"} == 1 && $arg0->{"type"} == NODE_DEREF_HASH()) {
                my scalar $key_expr = $arg0->{"key"};
                my int $key_needs_cleanup = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $key_expr) == 1;
                emit($cg, "({ StradaValue *__ex_key = ");
                gen_expression($cg, $key_expr);
                emit($cg, "; char *__ex_ks = strada_to_str(__ex_key); int __ex_res = strada_hv_exists(");
                gen_expression($cg, $arg0->{"ref"});
                emit($cg, ", __ex_ks); free(__ex_ks); ");
                if ($key_needs_cleanup == 1) {
                    emit($cg, "strada_decref(__ex_key); ");
                }
                emit($cg, "strada_new_int(__ex_res); })");
            } else {
                # Two arg form: exists(hash, key)
                my scalar $key_expr = $args->[1];
                my int $key_needs_cleanup = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $key_expr) == 1;
                emit($cg, "({ StradaValue *__ex_key = ");
                gen_expression($cg, $key_expr);
                emit($cg, "; char *__ex_ks = strada_to_str(__ex_key); int __ex_res = strada_hv_exists(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", __ex_ks); free(__ex_ks); ");
                if ($key_needs_cleanup == 1) {
                    emit($cg, "strada_decref(__ex_key); ");
                }
                emit($cg, "strada_new_int(__ex_res); })");
            }
            return;
        }
        
        if ($name eq "delete") {
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];

            # Check if single arg is a hash access node
            if ($expr->{"arg_count"} == 1 && $arg0->{"type"} == NODE_HASH_ACCESS()) {
                my scalar $key_expr = $arg0->{"key"};
                my int $key_needs_cleanup = needs_temp_cleanup($cg, $key_expr);
                # Generate a block to properly clean up C string (and key temp if needed)
                emit($cg, "({ StradaValue *__del_key = ");
                gen_expression($cg, $key_expr);
                emit($cg, "; char *__del_key_str = strada_to_str(__del_key); strada_hv_delete(");
                gen_expression($cg, $arg0->{"hash"});
                emit($cg, ", __del_key_str); free(__del_key_str); ");
                if ($key_needs_cleanup == 1) {
                    emit($cg, "strada_decref(__del_key); ");
                }
                emit($cg, "strada_undef_static(); })");
            } elsif ($expr->{"arg_count"} == 1 && $arg0->{"type"} == NODE_DEREF_HASH()) {
                my scalar $key_expr = $arg0->{"key"};
                my int $key_needs_cleanup = needs_temp_cleanup($cg, $key_expr);
                emit($cg, "({ StradaValue *__del_key = ");
                gen_expression($cg, $key_expr);
                emit($cg, "; char *__del_key_str = strada_to_str(__del_key); strada_hv_delete(");
                gen_expression($cg, $arg0->{"ref"});
                emit($cg, ", __del_key_str); free(__del_key_str); ");
                if ($key_needs_cleanup == 1) {
                    emit($cg, "strada_decref(__del_key); ");
                }
                emit($cg, "strada_undef_static(); })");
            } else {
                # Two-arg form: delete($hash, $key)
                my scalar $key_expr = $args->[1];
                my int $key_needs_cleanup = needs_temp_cleanup($cg, $key_expr);
                emit($cg, "({ StradaValue *__del_key = ");
                gen_expression($cg, $key_expr);
                emit($cg, "; char *__del_key_str = strada_to_str(__del_key); strada_hv_delete(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", __del_key_str); free(__del_key_str); ");
                if ($key_needs_cleanup == 1) {
                    emit($cg, "strada_decref(__del_key); ");
                }
                emit($cg, "strada_undef_static(); })");
            }
            return;
        }
        
        if ($name eq "hash_new") {
            emit($cg, "strada_new_hash()");
            return;
        }
        
        if ($name eq "hash_get") {
            my scalar $args = $expr->{"args"};
            my scalar $key_arg = $args->[1];
            emit($cg, "({ StradaValue *__hg_kv = ");
            gen_expression($cg, $key_arg);
            emit($cg, "; char *__hg_ks = strada_to_str(__hg_kv); StradaValue *__hg_r = strada_hv_fetch(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", __hg_ks); free(__hg_ks); ");
            if (needs_temp_cleanup($cg, $key_arg) == 1) {
                emit($cg, "strada_decref(__hg_kv); ");
            }
            emit($cg, "__hg_r; })");
            return;
        }

        if ($name eq "hash_set") {
            my scalar $args = $expr->{"args"};
            my scalar $key_arg = $args->[1];
            emit($cg, "({ StradaValue *__hs_kv = ");
            gen_expression($cg, $key_arg);
            emit($cg, "; char *__hs_ks = strada_to_str(__hs_kv); strada_hv_store(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", __hs_ks, ");
            gen_expression($cg, $args->[2]);
            emit($cg, "); free(__hs_ks); ");
            if (needs_temp_cleanup($cg, $key_arg) == 1) {
                emit($cg, "strada_decref(__hs_kv); ");
            }
            emit($cg, "})");
            return;
        }
        
        if ($name eq "array_new") {
            emit($cg, "strada_new_array()");
            return;
        }
        
        if ($name eq "sys::cstruct_new") {
            emit($cg, "strada_new_hash()");
            return;
        }
        
        if ($name eq "defined") {
            my scalar $args = $expr->{"args"};
            my scalar $arg = $args->[0];
            # If cleanup enabled and arg is a temporary, wrap to decref after
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $arg) == 1) {
                emit($cg, "({ StradaValue *__def_tmp = ");
                gen_expression($cg, $arg);
                emit($cg, "; int __def_res = strada_defined_bool(__def_tmp); strada_decref(__def_tmp); strada_new_int(__def_res); })");
            } else {
                emit($cg, "strada_defined(");
                gen_expression($cg, $arg);
                emit($cg, ")");
            }
            return;
        }
        
        if ($name eq "ref") {
            my scalar $args = $expr->{"args"};
            my scalar $arg = $args->[0];
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $arg) == 1) {
                emit($cg, "({ StradaValue *__ref_tmp = ");
                gen_expression($cg, $arg);
                emit($cg, "; StradaValue *__ref_res = strada_new_str(strada_reftype(__ref_tmp)); strada_decref(__ref_tmp); __ref_res; })");
            } else {
                emit($cg, "strada_new_str(strada_reftype(");
                gen_expression($cg, $arg);
                emit($cg, "))");
            }
            return;
        }
        
        if ($name eq "dumper") {
            my scalar $args = $expr->{"args"};
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1) {
                emit($cg, "({ StradaValue *__dump_v = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; strada_dumper(__dump_v); strada_decref(__dump_v); (StradaValue*)NULL; })");
            } else {
                emit($cg, "strada_dumper(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")");
            }
            return;
        }

        if ($name eq "dumper_str") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_dumper_str", $args, 1);
            return;
        }

        if ($name eq "exit") {
            emit($cg, "exit(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # Process control functions (sys::sleep and sys::usleep handled below with gen_call_with_arg_cleanup)

        if ($name eq "sys::fork") {
            emit($cg, "strada_fork()");
            return;
        }

        if ($name eq "sys::wait") {
            emit($cg, "strada_wait()");
            return;
        }

        if ($name eq "sys::waitpid") {
            emit($cg, "strada_waitpid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            if ($expr->{"arg_count"} > 1) {
                gen_expression($cg, $args->[1]);
            } else {
                emit($cg, "strada_new_int(0)");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getpid") {
            emit($cg, "strada_getpid()");
            return;
        }

        if ($name eq "sys::getppid") {
            emit($cg, "strada_getppid()");
            return;
        }

        if ($name eq "sys::exit") {
            emit($cg, "(strada_exit(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")), strada_undef_static())");
            return;
        }

        if ($name eq "sys::_exit") {
            emit($cg, "(_exit(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")), strada_undef_static())");
            return;
        }

        # Global variable registry
        if ($name eq "sys::global_set") {
            my scalar $args = $expr->{"args"};
            emit($cg, "(strada_global_set(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_undef_static())");
            return;
        }

        if ($name eq "sys::global_get") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_global_get(");
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::global_exists") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_new_int(strada_global_exists(");
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        if ($name eq "sys::global_delete") {
            my scalar $args = $expr->{"args"};
            emit($cg, "(strada_global_delete(");
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_undef_static())");
            return;
        }

        if ($name eq "sys::global_keys") {
            emit($cg, "strada_global_keys()");
            return;
        }

        if ($name eq "sys::argv") {
            emit($cg, "ARGV");
            return;
        }

        # Pipe and IPC functions
        if ($name eq "sys::pipe") {
            emit($cg, "strada_pipe()");
            return;
        }

        if ($name eq "sys::dup2") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_dup2", $args, 2);
            return;
        }

        if ($name eq "sys::close_fd") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_close_fd", $args, 1);
            return;
        }

        if ($name eq "sys::exec") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_exec", $args, 1);
            return;
        }

        if ($name eq "exec_argv") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_exec_argv", $args, 2);
            return;
        }

        if ($name eq "sys::system") {
            my scalar $args = $expr->{"args"};
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1) {
                emit($cg, "({ StradaValue *__sys_v = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; StradaValue *__sys_r = strada_system(__sys_v); strada_decref(__sys_v); __sys_r; })");
            } else {
                emit($cg, "strada_system(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")");
            }
            return;
        }

        if ($name eq "sys::system_argv") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_system_argv", $args, 2);
            return;
        }

        if ($name eq "sys::setprocname") {
            emit($cg, "strada_setprocname(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getprocname") {
            emit($cg, "strada_getprocname()");
            return;
        }

        if ($name eq "sys::setproctitle") {
            emit($cg, "strada_setproctitle(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getproctitle") {
            emit($cg, "strada_getproctitle()");
            return;
        }

        if ($name eq "sys::read_fd") {
            emit($cg, "strada_read_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::write_fd") {
            emit($cg, "strada_write_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::read_all_fd") {
            emit($cg, "strada_read_all_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "fdopen_read") {
            emit($cg, "strada_fdopen_read(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "fdopen_write") {
            emit($cg, "strada_fdopen_write(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # POSIX functions
        if ($name eq "sys::getenv") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_getenv", $args, 1);
            return;
        }

        if ($name eq "sys::setenv") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_setenv", $args, 2);
            return;
        }

        if ($name eq "sys::unsetenv") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_unsetenv", $args, 1);
            return;
        }

        # sys::array_default_capacity - get or set default array capacity
        if ($name eq "sys::array_default_capacity") {
            my scalar $args = $expr->{"args"};
            my int $nargs = size($args);
            if ($nargs == 0) {
                # Get current default capacity
                emit($cg, "strada_new_int(strada_get_array_default_capacity())");
            } else {
                # Set new default capacity and return it
                emit($cg, "(strada_set_array_default_capacity(strada_to_int(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")), strada_new_int(strada_get_array_default_capacity()))");
            }
            return;
        }

        # sys::hash_default_capacity - get or set default hash bucket count
        if ($name eq "sys::hash_default_capacity") {
            my scalar $args = $expr->{"args"};
            my int $nargs = size($args);
            if ($nargs == 0) {
                # Get current default capacity
                emit($cg, "strada_new_int(strada_get_hash_default_capacity())");
            } else {
                # Set new default capacity and return it
                emit($cg, "(strada_set_hash_default_capacity(strada_to_int(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")), strada_new_int(strada_get_hash_default_capacity()))");
            }
            return;
        }

        if ($name eq "sys::getcwd") {
            emit($cg, "strada_getcwd()");
            return;
        }

        if ($name eq "sys::stack_trace") {
            # Returns current call stack as a string
            emit($cg, "({ char *__st = strada_capture_stack_trace(); StradaValue *__st_sv = strada_new_str(__st ? __st : \"\"); free(__st); __st_sv; })");
            return;
        }

        # sys::set_recursion_limit - set max recursion depth (0 = disabled)
        if ($name eq "sys::set_recursion_limit") {
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $arg0) == 1) {
                emit($cg, "({ StradaValue *__arg_tmp = ");
                gen_expression($cg, $arg0);
                emit($cg, "; strada_set_recursion_limit(strada_to_int(__arg_tmp)); strada_decref(__arg_tmp); strada_new_int(strada_get_recursion_limit()); })");
            } else {
                emit($cg, "(strada_set_recursion_limit(strada_to_int(");
                gen_expression($cg, $arg0);
                emit($cg, ")), strada_new_int(strada_get_recursion_limit()))");
            }
            return;
        }

        # sys::get_recursion_limit - get current max recursion depth
        if ($name eq "sys::get_recursion_limit") {
            emit($cg, "strada_new_int(strada_get_recursion_limit())");
            return;
        }

        # sys::wantarray - check if called in array context
        if ($name eq "sys::wantarray") {
            emit($cg, "strada_new_int(strada_wantarray())");
            return;
        }

        # sys::wantscalar - check if called in scalar context
        if ($name eq "sys::wantscalar") {
            emit($cg, "strada_new_int(strada_wantscalar())");
            return;
        }

        # sys::wanthash - check if called in hash context
        if ($name eq "sys::wanthash") {
            emit($cg, "strada_new_int(strada_wanthash())");
            return;
        }

        # ---- utf8:: namespace functions ----

        # utf8::is_utf8($str) - check if string is valid UTF-8
        if ($name eq "utf8::is_utf8") {
            my scalar $u8args = $expr->{"args"};
            my scalar $arg0 = $u8args->[0];
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $arg0) == 1) {
                emit($cg, "({ StradaValue *__arg_tmp = ");
                gen_expression($cg, $arg0);
                emit($cg, "; StradaValue *__res = strada_utf8_is_utf8(__arg_tmp); strada_decref(__arg_tmp); __res; })");
            } else {
                emit($cg, "strada_utf8_is_utf8(");
                gen_expression($cg, $arg0);
                emit($cg, ")");
            }
            return;
        }

        # utf8::valid($str) - validate UTF-8 sequence
        if ($name eq "utf8::valid") {
            my scalar $u8args = $expr->{"args"};
            my scalar $arg0 = $u8args->[0];
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $arg0) == 1) {
                emit($cg, "({ StradaValue *__arg_tmp = ");
                gen_expression($cg, $arg0);
                emit($cg, "; StradaValue *__res = strada_utf8_valid(__arg_tmp); strada_decref(__arg_tmp); __res; })");
            } else {
                emit($cg, "strada_utf8_valid(");
                gen_expression($cg, $arg0);
                emit($cg, ")");
            }
            return;
        }

        # utf8::encode($str) - no-op in Strada (strings are already bytes), returns string
        if ($name eq "utf8::encode") {
            my scalar $u8args = $expr->{"args"};
            my scalar $arg0 = $u8args->[0];
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $arg0) == 1) {
                emit($cg, "({ StradaValue *__arg_tmp = ");
                gen_expression($cg, $arg0);
                emit($cg, "; StradaValue *__res = strada_utf8_encode(__arg_tmp); strada_decref(__arg_tmp); __res; })");
            } else {
                emit($cg, "strada_utf8_encode(");
                gen_expression($cg, $arg0);
                emit($cg, ")");
            }
            return;
        }

        # utf8::decode($str) - validate UTF-8, returns 1 if valid, 0 if not
        if ($name eq "utf8::decode") {
            my scalar $u8args = $expr->{"args"};
            my scalar $arg0 = $u8args->[0];
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $arg0) == 1) {
                emit($cg, "({ StradaValue *__arg_tmp = ");
                gen_expression($cg, $arg0);
                emit($cg, "; StradaValue *__res = strada_utf8_decode(__arg_tmp); strada_decref(__arg_tmp); __res; })");
            } else {
                emit($cg, "strada_utf8_decode(");
                gen_expression($cg, $arg0);
                emit($cg, ")");
            }
            return;
        }

        # utf8::downgrade($str) or utf8::downgrade($str, $fail_ok) - ASCII check
        if ($name eq "utf8::downgrade") {
            my scalar $u8args = $expr->{"args"};
            my int $u8argc = $expr->{"arg_count"};
            my scalar $arg0 = $u8args->[0];
            my int $has_fail_ok = 0;
            if ($u8argc > 1) {
                $has_fail_ok = 1;
            }
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $arg0) == 1) {
                emit($cg, "({ StradaValue *__arg_tmp = ");
                gen_expression($cg, $arg0);
                emit($cg, "; StradaValue *__res = strada_utf8_downgrade(__arg_tmp, ");
                if ($has_fail_ok == 1) {
                    emit($cg, "({ StradaValue *__fo_tmp = ");
                    gen_expression($cg, $u8args->[1]);
                    emit($cg, "; int __fo_val = (int)strada_to_int(__fo_tmp); strada_decref(__fo_tmp); __fo_val; })");
                } else {
                    emit($cg, "0");
                }
                emit($cg, "); strada_decref(__arg_tmp); __res; })");
            } else {
                if ($has_fail_ok == 1 && $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $u8args->[1]) == 1) {
                    emit($cg, "({ StradaValue *__fo_tmp = ");
                    gen_expression($cg, $u8args->[1]);
                    emit($cg, "; int __fo_val = (int)strada_to_int(__fo_tmp); strada_decref(__fo_tmp); strada_utf8_downgrade(");
                    gen_expression($cg, $arg0);
                    emit($cg, ", __fo_val); })");
                } else {
                    emit($cg, "strada_utf8_downgrade(");
                    gen_expression($cg, $arg0);
                    emit($cg, ", ");
                    if ($has_fail_ok == 1) {
                        emit($cg, "(int)strada_to_int(");
                        gen_expression($cg, $u8args->[1]);
                        emit($cg, ")");
                    } else {
                        emit($cg, "0");
                    }
                    emit($cg, ")");
                }
            }
            return;
        }

        # utf8::upgrade($str) - no-op in Strada, returns string
        if ($name eq "utf8::upgrade") {
            my scalar $u8args = $expr->{"args"};
            my scalar $arg0 = $u8args->[0];
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $arg0) == 1) {
                emit($cg, "({ StradaValue *__arg_tmp = ");
                gen_expression($cg, $arg0);
                emit($cg, "; StradaValue *__res = strada_utf8_upgrade(__arg_tmp); strada_decref(__arg_tmp); __res; })");
            } else {
                emit($cg, "strada_utf8_upgrade(");
                gen_expression($cg, $arg0);
                emit($cg, ")");
            }
            return;
        }

        # utf8::unicode_to_native($codepoint) - identity on modern systems
        if ($name eq "utf8::unicode_to_native") {
            my scalar $u8args = $expr->{"args"};
            my scalar $arg0 = $u8args->[0];
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $arg0) == 1) {
                emit($cg, "({ StradaValue *__arg_tmp = ");
                gen_expression($cg, $arg0);
                emit($cg, "; StradaValue *__res = strada_utf8_unicode_to_native(__arg_tmp); strada_decref(__arg_tmp); __res; })");
            } else {
                emit($cg, "strada_utf8_unicode_to_native(");
                gen_expression($cg, $arg0);
                emit($cg, ")");
            }
            return;
        }

        if ($name eq "sys::chdir") {
            my scalar $args = $expr->{"args"};
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1) {
                emit($cg, "({ StradaValue *__cd_v = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; StradaValue *__cd_r = strada_chdir(__cd_v); strada_decref(__cd_v); __cd_r; })");
            } else {
                emit($cg, "strada_chdir(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")");
            }
            return;
        }

        if ($name eq "sys::chroot") {
            my scalar $args = $expr->{"args"};
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1) {
                emit($cg, "({ StradaValue *__cr_v = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; StradaValue *__cr_r = strada_chroot(__cr_v); strada_decref(__cr_v); __cr_r; })");
            } else {
                emit($cg, "strada_chroot(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")");
            }
            return;
        }

        if ($name eq "sys::mkdir") {
            my scalar $args = $expr->{"args"};
            my int $mk_cleanup0 = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1;
            my int $mk_has_mode = $expr->{"arg_count"} > 1;
            my int $mk_cleanup1 = $mk_has_mode == 1 && $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[1]) == 1;
            # Default mode strada_new_int(0755) is a temp that must be cleaned up
            my int $mk_default_mode = $mk_has_mode == 0 && $cg->{"cleanup_enabled"} == 1;
            if ($mk_cleanup0 == 1 || $mk_cleanup1 == 1 || $mk_default_mode == 1) {
                emit($cg, "({ ");
                if ($mk_cleanup0 == 1) {
                    emit($cg, "StradaValue *__mk_a0 = ");
                    gen_expression($cg, $args->[0]);
                    emit($cg, "; ");
                }
                if ($mk_cleanup1 == 1) {
                    emit($cg, "StradaValue *__mk_a1 = ");
                    gen_expression($cg, $args->[1]);
                    emit($cg, "; ");
                }
                if ($mk_default_mode == 1) {
                    emit($cg, "StradaValue *__mk_a1 = strada_new_int(0755); ");
                }
                emit($cg, "StradaValue *__mk_r = strada_mkdir(");
                if ($mk_cleanup0 == 1) {
                    emit($cg, "__mk_a0");
                } else {
                    gen_expression($cg, $args->[0]);
                }
                emit($cg, ", ");
                if ($mk_cleanup1 == 1 || $mk_default_mode == 1) {
                    emit($cg, "__mk_a1");
                } else {
                    gen_expression($cg, $args->[1]);
                }
                emit($cg, "); ");
                if ($mk_cleanup0 == 1) {
                    emit($cg, "strada_decref(__mk_a0); ");
                }
                if ($mk_cleanup1 == 1 || $mk_default_mode == 1) {
                    emit($cg, "strada_decref(__mk_a1); ");
                }
                emit($cg, "__mk_r; })");
            } else {
                emit($cg, "strada_mkdir(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", ");
                if ($mk_has_mode == 1) {
                    gen_expression($cg, $args->[1]);
                } else {
                    emit($cg, "strada_new_int(0755)");
                }
                emit($cg, ")");
            }
            return;
        }

        if ($name eq "sys::rmdir") {
            my scalar $args = $expr->{"args"};
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1) {
                emit($cg, "({ StradaValue *__rm_v = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; StradaValue *__rm_r = strada_rmdir(__rm_v); strada_decref(__rm_v); __rm_r; })");
            } else {
                emit($cg, "strada_rmdir(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")");
            }
            return;
        }

        if ($name eq "sys::unlink") {
            my scalar $args = $expr->{"args"};
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1) {
                emit($cg, "({ StradaValue *__ul_v = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; StradaValue *__ul_r = strada_unlink(__ul_v); strada_decref(__ul_v); __ul_r; })");
            } else {
                emit($cg, "strada_unlink(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")");
            }
            return;
        }

        if ($name eq "sys::link") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_link", $args, 2);
            return;
        }

        if ($name eq "sys::symlink") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_symlink", $args, 2);
            return;
        }

        if ($name eq "sys::readlink") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_readlink", $args, 1);
            return;
        }

        if ($name eq "sys::rename") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_rename", $args, 2);
            return;
        }

        if ($name eq "sys::chmod") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_chmod", $args, 2);
            return;
        }

        if ($name eq "sys::access") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_access", $args, 2);
            return;
        }

        if ($name eq "sys::umask") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_umask", $args, 1);
            return;
        }

        if ($name eq "sys::getuid") {
            emit($cg, "strada_getuid()");
            return;
        }

        if ($name eq "sys::geteuid") {
            emit($cg, "strada_geteuid()");
            return;
        }

        if ($name eq "sys::getgid") {
            emit($cg, "strada_getgid()");
            return;
        }

        if ($name eq "sys::getegid") {
            emit($cg, "strada_getegid()");
            return;
        }

        if ($name eq "sys::kill") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_kill", $args, 2);
            return;
        }

        if ($name eq "sys::signal") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_signal", $args, 2);
            return;
        }

        if ($name eq "sys::alarm") {
            emit($cg, "strada_alarm(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::stat") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_stat", $args, 1);
            return;
        }

        if ($name eq "sys::lstat") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_lstat", $args, 1);
            return;
        }

        if ($name eq "sys::isatty") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_isatty", $args, 1);
            return;
        }

        if ($name eq "sys::strerror") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_strerror", $args, 1);
            return;
        }

        if ($name eq "sys::errno") {
            emit($cg, "strada_errno()");
            return;
        }

        if ($name eq "sys::time") {
            emit($cg, "strada_time()");
            return;
        }

        if ($name eq "sys::localtime") {
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_call_with_arg_cleanup($cg, "strada_localtime", $args, 1);
            } else {
                emit($cg, "strada_localtime(NULL)");
            }
            return;
        }

        if ($name eq "sys::gmtime") {
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_call_with_arg_cleanup($cg, "strada_gmtime", $args, 1);
            } else {
                emit($cg, "strada_gmtime(NULL)");
            }
            return;
        }

        if ($name eq "sys::mktime") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_mktime", $args, 1);
            return;
        }

        if ($name eq "sys::strftime") {
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 1) {
                gen_call_with_arg_cleanup($cg, "strada_strftime", $args, 2);
            } else {
                # Single arg - pass NULL as second arg
                my scalar $arg0 = $args->[0];
                my int $a0_cleanup = needs_temp_cleanup($cg, $arg0);
                if ($a0_cleanup == 1) {
                    emit($cg, "({ StradaValue *__call_arg0 = ");
                    gen_expression($cg, $arg0);
                    emit($cg, "; StradaValue *__call_result = strada_strftime(__call_arg0, NULL); strada_decref(__call_arg0); __call_result; })");
                } else {
                    emit($cg, "strada_strftime(");
                    gen_expression($cg, $arg0);
                    emit($cg, ", NULL)");
                }
            }
            return;
        }

        if ($name eq "sys::ctime") {
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_call_with_arg_cleanup($cg, "strada_ctime", $args, 1);
            } else {
                emit($cg, "strada_ctime(NULL)");
            }
            return;
        }

        if ($name eq "sys::sleep") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_sleep", $args, 1);
            return;
        }

        if ($name eq "sys::usleep") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_usleep", $args, 1);
            return;
        }

        if ($name eq "sys::gettimeofday") {
            emit($cg, "strada_gettimeofday()");
            return;
        }

        if ($name eq "sys::hires_time") {
            emit($cg, "strada_hires_time()");
            return;
        }

        # Memory profiler functions
        if ($name eq "sys::memprof_enable") {
            emit($cg, "(strada_memprof_enable(), strada_undef_static())");
            return;
        }
        if ($name eq "sys::memprof_disable") {
            emit($cg, "(strada_memprof_disable(), strada_undef_static())");
            return;
        }
        if ($name eq "sys::memprof_report") {
            emit($cg, "(strada_memprof_report(), strada_undef_static())");
            return;
        }
        if ($name eq "sys::memprof_reset") {
            emit($cg, "(strada_memprof_reset(), strada_undef_static())");
            return;
        }

        if ($name eq "sys::tv_interval") {
            emit($cg, "strada_tv_interval(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            if ($arg_count > 1) {
                gen_expression($cg, $args->[1]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::nanosleep") {
            emit($cg, "strada_nanosleep_ns(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::clock_gettime") {
            emit($cg, "strada_clock_gettime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::clock_getres") {
            emit($cg, "strada_clock_getres(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_open") {
            emit($cg, "strada_dl_open(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "strada_dl_open_raw") {
            emit($cg, "strada_dl_open_raw(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_sym") {
            emit($cg, "strada_dl_sym(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_close") {
            emit($cg, "strada_dl_close(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_error") {
            emit($cg, "strada_dl_error()");
            return;
        }

        if ($name eq "sys::dl_call_int") {
            emit($cg, "strada_dl_call_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_num") {
            emit($cg, "strada_dl_call_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_str") {
            emit($cg, "strada_dl_call_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_void") {
            emit($cg, "strada_dl_call_void(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_int_sv") {
            my scalar $args = $expr->{"args"};
            my scalar $arg1 = $args->[1];
            # Clean up the args array if it's a temporary (like anonymous array)
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $arg1) == 1) {
                emit($cg, "({ StradaValue *__dl_args = ");
                gen_expression($cg, $arg1);
                emit($cg, "; StradaValue *__dl_res = strada_dl_call_int_sv(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", __dl_args); strada_decref(__dl_args); __dl_res; })");
            } else {
                emit($cg, "strada_dl_call_int_sv(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", ");
                gen_expression($cg, $arg1);
                emit($cg, ")");
            }
            return;
        }

        if ($name eq "sys::dl_call_str_sv") {
            my scalar $args = $expr->{"args"};
            my scalar $arg1 = $args->[1];
            # Clean up the args array if it's a temporary (like anonymous array)
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $arg1) == 1) {
                emit($cg, "({ StradaValue *__dl_args = ");
                gen_expression($cg, $arg1);
                emit($cg, "; StradaValue *__dl_res = strada_dl_call_str_sv(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", __dl_args); strada_decref(__dl_args); __dl_res; })");
            } else {
                emit($cg, "strada_dl_call_str_sv(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", ");
                gen_expression($cg, $arg1);
                emit($cg, ")");
            }
            return;
        }

        if ($name eq "sys::dl_call_void_sv") {
            my scalar $args = $expr->{"args"};
            my scalar $arg1 = $args->[1];
            # Clean up the args array if it's a temporary (like anonymous array)
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $arg1) == 1) {
                emit($cg, "({ StradaValue *__dl_args = ");
                gen_expression($cg, $arg1);
                emit($cg, "; strada_dl_call_void_sv(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", __dl_args); strada_decref(__dl_args); })");
            } else {
                emit($cg, "strada_dl_call_void_sv(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", ");
                gen_expression($cg, $arg1);
                emit($cg, ")");
            }
            return;
        }

        if ($name eq "sys::dl_call_sv") {
            my scalar $args = $expr->{"args"};
            my scalar $arg1 = $args->[1];
            # Clean up the args array if it's a temporary (like anonymous array)
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $arg1) == 1) {
                emit($cg, "({ StradaValue *__dl_args = ");
                gen_expression($cg, $arg1);
                emit($cg, "; StradaValue *__dl_res = strada_dl_call_sv(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", __dl_args); strada_decref(__dl_args); __dl_res; })");
            } else {
                emit($cg, "strada_dl_call_sv(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", ");
                gen_expression($cg, $arg1);
                emit($cg, ")");
            }
            return;
        }

        if ($name eq "sys::dl_call_export_info") {
            emit($cg, "strada_dl_call_export_info(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_version") {
            emit($cg, "strada_dl_call_version(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Pointer access for FFI
        if ($name eq "sys::int_ptr") {
            emit($cg, "strada_int_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::num_ptr") {
            emit($cg, "strada_num_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::str_ptr") {
            emit($cg, "strada_str_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_deref_int") {
            emit($cg, "strada_ptr_deref_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_deref_num") {
            emit($cg, "strada_ptr_deref_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_deref_str") {
            emit($cg, "strada_ptr_deref_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_set_int") {
            emit($cg, "strada_ptr_set_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_set_num") {
            emit($cg, "strada_ptr_set_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "math::rand") {
            emit($cg, "strada_rand()");
            return;
        }

        if ($name eq "sys::exit_status") {
            emit($cg, "strada_exit_status(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Thread functions
        if ($name eq "thread::create") {
            emit($cg, "strada_thread_create(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::join") {
            emit($cg, "strada_thread_join(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::detach") {
            emit($cg, "strada_thread_detach(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::self") {
            emit($cg, "strada_thread_self()");
            return;
        }

        if ($name eq "thread::mutex_new") {
            emit($cg, "strada_mutex_new()");
            return;
        }

        if ($name eq "thread::mutex_lock") {
            emit($cg, "strada_mutex_lock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::mutex_trylock") {
            emit($cg, "strada_mutex_trylock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::mutex_unlock") {
            emit($cg, "strada_mutex_unlock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::mutex_destroy") {
            emit($cg, "strada_mutex_destroy(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::cond_new") {
            emit($cg, "strada_cond_new()");
            return;
        }

        if ($name eq "thread::cond_wait") {
            emit($cg, "strada_cond_wait(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::cond_signal") {
            emit($cg, "strada_cond_signal(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::cond_broadcast") {
            emit($cg, "strada_cond_broadcast(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "thread::cond_destroy") {
            emit($cg, "strada_cond_destroy(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # ===== ASYNC/AWAIT NAMESPACE FUNCTIONS =====
        if ($name eq "async::all") {
            emit($cg, "strada_future_all(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "async::race") {
            emit($cg, "strada_future_race(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "async::timeout") {
            emit($cg, "strada_async_timeout(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "async::cancel") {
            emit($cg, "(strada_future_cancel(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_undef_static())");
            return;
        }

        if ($name eq "async::is_done") {
            emit($cg, "strada_new_int(strada_future_is_done(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        if ($name eq "async::is_cancelled") {
            emit($cg, "strada_new_int(strada_future_is_cancelled(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        if ($name eq "async::pool_init") {
            emit($cg, "(strada_pool_init(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")), strada_undef_static())");
            return;
        }

        if ($name eq "async::pool_shutdown") {
            emit($cg, "(strada_pool_shutdown(), strada_undef_static())");
            return;
        }

        # ===== CHANNEL NAMESPACE FUNCTIONS =====
        if ($name eq "async::channel") {
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                emit($cg, "strada_channel_new(strada_to_int(");
                gen_expression($cg, $args->[0]);
                emit($cg, "))");
            } else {
                emit($cg, "strada_channel_new(0)");
            }
            return;
        }

        if ($name eq "async::send") {
            emit($cg, "(strada_channel_send(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, "), strada_undef_static())");
            return;
        }

        if ($name eq "async::recv") {
            emit($cg, "strada_channel_recv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "async::try_send") {
            emit($cg, "strada_new_int(strada_channel_try_send(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        if ($name eq "async::try_recv") {
            emit($cg, "strada_channel_try_recv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "async::close") {
            emit($cg, "(strada_channel_close(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "), strada_undef_static())");
            return;
        }

        if ($name eq "async::is_closed") {
            emit($cg, "strada_new_int(strada_channel_is_closed(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        if ($name eq "async::len") {
            emit($cg, "strada_new_int(strada_channel_len(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # ===== MUTEX NAMESPACE FUNCTIONS =====
        # These use the existing sys::mutex_* implementation (CPOINTER-based)
        if ($name eq "async::mutex") {
            emit($cg, "strada_mutex_new()");
            return;
        }

        if ($name eq "async::lock") {
            emit($cg, "strada_mutex_lock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "async::unlock") {
            emit($cg, "strada_mutex_unlock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "async::try_lock") {
            emit($cg, "strada_mutex_trylock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "async::mutex_destroy") {
            emit($cg, "strada_mutex_destroy(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # ===== ATOMIC NAMESPACE FUNCTIONS =====
        if ($name eq "async::atomic") {
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                emit($cg, "strada_atomic_new(strada_to_int(");
                gen_expression($cg, $args->[0]);
                emit($cg, "))");
            } else {
                emit($cg, "strada_atomic_new(0)");
            }
            return;
        }

        if ($name eq "async::atomic_load") {
            emit($cg, "strada_new_int(strada_atomic_load(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        if ($name eq "async::atomic_store") {
            emit($cg, "(strada_atomic_store(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            emit_int_operand($cg, $args->[1]);
            emit($cg, "), strada_undef_static())");
            return;
        }

        if ($name eq "async::atomic_add") {
            emit($cg, "strada_new_int(strada_atomic_add(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            emit_int_operand($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        if ($name eq "async::atomic_sub") {
            emit($cg, "strada_new_int(strada_atomic_sub(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            emit_int_operand($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        if ($name eq "async::atomic_inc") {
            emit($cg, "strada_new_int(strada_atomic_inc(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        if ($name eq "async::atomic_dec") {
            emit($cg, "strada_new_int(strada_atomic_dec(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        if ($name eq "async::atomic_cas") {
            emit($cg, "strada_new_int(strada_atomic_cas(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            emit_int_operand($cg, $args->[1]);
            emit($cg, ", ");
            emit_int_operand($cg, $args->[2]);
            emit($cg, "))");
            return;
        }

        # Directory functions
        if ($name eq "sys::readdir") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_readdir", $args, 1);
            return;
        }

        if ($name eq "sys::readdir_full") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_readdir_full", $args, 1);
            return;
        }

        if ($name eq "sys::is_dir") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_is_dir", $args, 1);
            return;
        }

        if ($name eq "sys::is_file") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_is_file", $args, 1);
            return;
        }

        if ($name eq "sys::file_exists") {
            my scalar $args = $expr->{"args"};
            my scalar $arg = $args->[0];
            emit($cg, "({ StradaValue *__fe_v = ");
            gen_expression($cg, $arg);
            emit($cg, "; char *__fe_s = strada_to_str(__fe_v); int __fe_i = strada_file_exists(__fe_s); free(__fe_s); ");
            if (needs_temp_cleanup($cg, $arg) == 1) {
                emit($cg, "strada_decref(__fe_v); ");
            }
            emit($cg, "strada_new_int(__fe_i); })");
            return;
        }

        if ($name eq "sys::dir_exists") {
            # dir_exists is the same as is_dir
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_is_dir", $args, 1);
            return;
        }

        if ($name eq "sys::file_size") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_file_size", $args, 1);
            return;
        }

        # Math functions - with argument cleanup
        if ($name eq "math::sin" || $name eq "math::cos" || $name eq "math::tan" ||
            $name eq "math::asin" || $name eq "math::acos" || $name eq "math::atan" ||
            $name eq "math::sqrt" || $name eq "math::log" || $name eq "math::log10" ||
            $name eq "math::exp" || $name eq "math::floor" || $name eq "math::ceil" ||
            $name eq "math::abs" || $name eq "math::round" ||
            $name eq "math::sinh" || $name eq "math::cosh" || $name eq "math::tanh") {
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];
            my int $needs_cleanup = needs_temp_cleanup($cg, $arg0);

            # Determine the C function name
            my str $c_func = "strada_sin";
            if ($name eq "math::cos") { $c_func = "strada_cos"; }
            if ($name eq "math::tan") { $c_func = "strada_tan"; }
            if ($name eq "math::asin") { $c_func = "strada_asin"; }
            if ($name eq "math::acos") { $c_func = "strada_acos"; }
            if ($name eq "math::atan") { $c_func = "strada_atan"; }
            if ($name eq "math::sqrt") { $c_func = "strada_sqrt"; }
            if ($name eq "math::log") { $c_func = "strada_log"; }
            if ($name eq "math::log10") { $c_func = "strada_log10"; }
            if ($name eq "math::exp") { $c_func = "strada_exp"; }
            if ($name eq "math::floor") { $c_func = "strada_floor"; }
            if ($name eq "math::ceil") { $c_func = "strada_ceil"; }
            if ($name eq "math::abs") { $c_func = "strada_abs"; }
            if ($name eq "math::round") { $c_func = "strada_round"; }
            if ($name eq "math::sinh") { $c_func = "strada_sinh"; }
            if ($name eq "math::cosh") { $c_func = "strada_cosh"; }
            if ($name eq "math::tanh") { $c_func = "strada_tanh"; }

            if ($needs_cleanup == 1) {
                emit($cg, "(({ StradaValue *__math_arg = ");
                gen_expression($cg, $arg0);
                emit($cg, "; StradaValue *__math_res = " . $c_func . "(__math_arg); ");
                emit($cg, "strada_decref(__math_arg); __math_res; }))");
            } else {
                emit($cg, $c_func . "(");
                gen_expression($cg, $arg0);
                emit($cg, ")");
            }
            return;
        }

        if ($name eq "math::atan2") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_atan2", $args, 2);
            return;
        }

        if ($name eq "math::log") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_log", $args, 1);
            return;
        }

        if ($name eq "math::log10") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_log10", $args, 1);
            return;
        }

        if ($name eq "math::exp") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_exp", $args, 1);
            return;
        }

        if ($name eq "math::pow") {
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];
            my scalar $arg1 = $args->[1];
            my int $arg0_needs_cleanup = needs_temp_cleanup($cg, $arg0);
            my int $arg1_needs_cleanup = needs_temp_cleanup($cg, $arg1);

            if ($arg0_needs_cleanup == 1 || $arg1_needs_cleanup == 1) {
                emit($cg, "(({ StradaValue *__pow_arg0 = ");
                gen_expression($cg, $arg0);
                emit($cg, "; StradaValue *__pow_arg1 = ");
                gen_expression($cg, $arg1);
                emit($cg, "; StradaValue *__pow_res = strada_pow(__pow_arg0, __pow_arg1); ");
                if ($arg0_needs_cleanup == 1) {
                    emit($cg, "strada_decref(__pow_arg0); ");
                }
                if ($arg1_needs_cleanup == 1) {
                    emit($cg, "strada_decref(__pow_arg1); ");
                }
                emit($cg, "__pow_res; }))");
            } else {
                emit($cg, "strada_pow(");
                gen_expression($cg, $arg0);
                emit($cg, ", ");
                gen_expression($cg, $arg1);
                emit($cg, ")");
            }
            return;
        }

        if ($name eq "math::floor") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_floor", $args, 1);
            return;
        }

        if ($name eq "math::ceil") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_ceil", $args, 1);
            return;
        }

        if ($name eq "math::round") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_round", $args, 1);
            return;
        }

        if ($name eq "math::fabs") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_fabs", $args, 1);
            return;
        }

        if ($name eq "math::fmod") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_fmod", $args, 2);
            return;
        }

        if ($name eq "math::sinh") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_sinh", $args, 1);
            return;
        }

        if ($name eq "math::cosh") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_cosh", $args, 1);
            return;
        }

        if ($name eq "math::tanh") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_tanh", $args, 1);
            return;
        }

        # File seek functions
        if ($name eq "sys::seek") {
            my scalar $args = $expr->{"args"};
            emit($cg, "({ StradaValue *__sk_off = ");
            gen_expression($cg, $args->[1]);
            emit($cg, "; StradaValue *__sk_wh = ");
            if ($expr->{"arg_count"} > 2) {
                gen_expression($cg, $args->[2]);
            } else {
                emit($cg, "strada_new_int(0)");
            }
            emit($cg, "; StradaValue *__sk_r = strada_seek(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", __sk_off, __sk_wh); ");
            if (needs_temp_cleanup($cg, $args->[1]) == 1) {
                emit($cg, "strada_decref(__sk_off); ");
            }
            if ($expr->{"arg_count"} > 2) {
                if (needs_temp_cleanup($cg, $args->[2]) == 1) {
                    emit($cg, "strada_decref(__sk_wh); ");
                }
            } else {
                emit($cg, "strada_decref(__sk_wh); ");
            }
            emit($cg, "__sk_r; })");
            return;
        }

        if ($name eq "sys::tell") {
            emit($cg, "strada_tell(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::rewind") {
            emit($cg, "strada_rewind(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::eof") {
            emit($cg, "strada_eof(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::flush") {
            emit($cg, "strada_flush(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::readline") {
            emit($cg, "strada_read_line(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # DNS/Hostname functions
        if ($name eq "sys::gethostbyname") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_gethostbyname", $args, 1);
            return;
        }

        if ($name eq "sys::gethostbyname_all") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_gethostbyname_all", $args, 1);
            return;
        }

        if ($name eq "sys::gethostname") {
            emit($cg, "strada_gethostname()");
            return;
        }

        if ($name eq "sys::getaddrinfo") {
            emit($cg, "strada_getaddrinfo_first(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            if ($expr->{"arg_count"} > 1) {
                gen_expression($cg, $args->[1]);
            } else {
                emit($cg, "strada_new_str(\"\")");
            }
            emit($cg, ")");
            return;
        }

        # Path functions
        if ($name eq "sys::realpath") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_realpath", $args, 1);
            return;
        }

        if ($name eq "sys::dirname") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_dirname", $args, 1);
            return;
        }

        if ($name eq "sys::basename") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_basename", $args, 1);
            return;
        }

        if ($name eq "sys::glob") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_glob", $args, 1);
            return;
        }

        if ($name eq "sys::fnmatch") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_fnmatch", $args, 2);
            return;
        }

        if ($name eq "sys::file_ext") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_file_ext", $args, 1);
            return;
        }

        if ($name eq "sys::path_join") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_path_join", $args, 1);
            return;
        }

        if ($name eq "int") {
            emit($cg, "strada_new_int(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        if ($name eq "chr") {
            # Use strada_chr_sv for binary-safe chr that handles NUL bytes
            # Use emit_int_operand to avoid leaking memoria for integer literals
            emit($cg, "strada_chr_sv(");
            my scalar $args = $expr->{"args"};
            emit_int_operand($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        if ($name eq "ord") {
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];
            my int $needs_cleanup = needs_temp_cleanup($cg, $arg0);
            emit($cg, "(({ StradaValue *__ord_tmp = ");
            gen_expression($cg, $arg0);
            emit($cg, "; char *__ord_str = strada_to_str(__ord_tmp); ");
            emit($cg, "StradaValue *__ord_res = strada_new_int(strada_ord(__ord_str)); ");
            emit($cg, "free(__ord_str); ");
            if ($needs_cleanup == 1) {
                emit($cg, "strada_decref(__ord_tmp); ");
            }
            emit($cg, "__ord_res; }))");
            return;
        }

        # hex - convert hex string to integer: hex("ff") -> 255
        if ($name eq "sys::hex") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_hex", $args, 1);
            return;
        }

        # ord_byte - binary-safe ord that returns raw byte value 0-255
        if ($name eq "sys::ord_byte") {
            emit($cg, "strada_new_int(strada_ord_byte(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # get_byte - get byte at position (0-indexed), returns 0-255 or -1
        if ($name eq "sys::get_byte") {
            emit($cg, "strada_new_int(strada_get_byte(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            emit_int_operand($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        # set_byte - set byte at position, returns new string
        if ($name eq "sys::set_byte") {
            emit($cg, "strada_set_byte(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            emit_int_operand($cg, $args->[1]);
            emit($cg, ", ");
            emit_int_operand($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        # byte_length - get byte length (not UTF-8 character count)
        if ($name eq "sys::byte_length") {
            emit($cg, "strada_new_int(strada_byte_length(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # byte_substr - substring by byte positions
        if ($name eq "sys::byte_substr") {
            emit($cg, "strada_byte_substr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            emit_int_operand($cg, $args->[1]);
            emit($cg, ", ");
            emit_int_operand($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        # pack - pack values into binary string (Perl-like)
        # sys::pack($fmt, $val1, $val2, ...) -> strada_pack(fmt, array_of_values)
        if ($name eq "sys::pack") {
            my scalar $args = $expr->{"args"};
            my scalar $fmt_arg = $args->[0];
            emit($cg, "({ StradaValue *__pk_v = ");
            gen_expression($cg, $fmt_arg);
            emit($cg, "; char *__pk_fmt = strada_to_str(__pk_v); StradaValue *__pk_av = strada_new_array(); ");
            # Build array from remaining arguments using push_take to avoid leaking temps
            my int $i = 1;
            while ($i < $expr->{"arg_count"}) {
                emit($cg, "strada_array_push_take(__pk_av->value.av, ");
                gen_expression($cg, $args->[$i]);
                emit($cg, "); ");
                $i = $i + 1;
            }
            emit($cg, "StradaValue *__pk_arr = strada_ref_create_take(__pk_av); StradaValue *__pk_r = strada_pack(__pk_fmt, __pk_arr); free(__pk_fmt); strada_decref(__pk_arr); ");
            if (needs_temp_cleanup($cg, $fmt_arg) == 1) {
                emit($cg, "strada_decref(__pk_v); ");
            }
            emit($cg, "__pk_r; })");
            return;
        }

        # unpack - unpack binary string to array (Perl-like)
        if ($name eq "sys::unpack") {
            my scalar $args = $expr->{"args"};
            my scalar $fmt_arg = $args->[0];
            my scalar $data_arg = $args->[1];
            my int $up_data_cleanup = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $data_arg) == 1;
            emit($cg, "({ StradaValue *__up_v = ");
            gen_expression($cg, $fmt_arg);
            emit($cg, "; char *__up_fmt = strada_to_str(__up_v); ");
            if ($up_data_cleanup == 1) {
                emit($cg, "StradaValue *__up_d = ");
                gen_expression($cg, $data_arg);
                emit($cg, "; StradaValue *__up_r = strada_unpack(__up_fmt, __up_d); ");
            } else {
                emit($cg, "StradaValue *__up_r = strada_unpack(__up_fmt, ");
                gen_expression($cg, $data_arg);
                emit($cg, "); ");
            }
            emit($cg, "free(__up_fmt); ");
            if (needs_temp_cleanup($cg, $fmt_arg) == 1) {
                emit($cg, "strada_decref(__up_v); ");
            }
            if ($up_data_cleanup == 1) {
                emit($cg, "strada_decref(__up_d); ");
            }
            emit($cg, "__up_r; })");
            return;
        }

        # base64_encode - encode string to base64
        if ($name eq "sys::base64_encode") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_base64_encode", $args, 1);
            return;
        }

        # base64_decode - decode base64 to string
        if ($name eq "sys::base64_decode") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_base64_decode", $args, 1);
            return;
        }

        if ($name eq "uc" || $name eq "upper") {
            # uc returns allocated memory, strada_to_str also allocates - both need freeing
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];
            my int $needs_cleanup = needs_temp_cleanup($cg, $arg0);
            emit($cg, "(({ StradaValue *__uc_tmp = ");
            gen_expression($cg, $arg0);
            emit($cg, "; char *__uc_in = strada_to_str(__uc_tmp); ");
            emit($cg, "char *__uc_out = strada_uc(__uc_in); ");
            emit($cg, "StradaValue *__uc_res = strada_new_str(__uc_out); ");
            emit($cg, "free(__uc_in); free(__uc_out); ");
            if ($needs_cleanup == 1) {
                emit($cg, "strada_decref(__uc_tmp); ");
            }
            emit($cg, "__uc_res; }))");
            return;
        }

        if ($name eq "lc" || $name eq "lower") {
            # lc returns allocated memory, strada_to_str also allocates - both need freeing
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];
            my int $needs_cleanup = needs_temp_cleanup($cg, $arg0);
            emit($cg, "(({ StradaValue *__lc_tmp = ");
            gen_expression($cg, $arg0);
            emit($cg, "; char *__lc_in = strada_to_str(__lc_tmp); ");
            emit($cg, "char *__lc_out = strada_lc(__lc_in); ");
            emit($cg, "StradaValue *__lc_res = strada_new_str(__lc_out); ");
            emit($cg, "free(__lc_in); free(__lc_out); ");
            if ($needs_cleanup == 1) {
                emit($cg, "strada_decref(__lc_tmp); ");
            }
            emit($cg, "__lc_res; }))");
            return;
        }
        
        if ($name eq "index") {
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            my scalar $arg0 = $args->[0];
            my scalar $arg1 = $args->[1];
            my int $arg0_needs_cleanup = needs_temp_cleanup($cg, $arg0);
            my int $arg1_needs_cleanup = needs_temp_cleanup($cg, $arg1);

            if ($arg_count == 3) {
                # 3-argument form: index(string, substring, offset)
                emit($cg, "(({ StradaValue *__idx_str = ");
                gen_expression($cg, $arg0);
                emit($cg, "; StradaValue *__idx_sub = ");
                gen_expression($cg, $arg1);
                emit($cg, "; char *__idx_s1 = strada_to_str(__idx_str); ");
                emit($cg, "char *__idx_s2 = strada_to_str(__idx_sub); ");
                emit($cg, "StradaValue *__idx_res = strada_new_int(strada_index_offset(__idx_s1, __idx_s2, ");
                emit_int_operand($cg, $args->[2]);
                emit($cg, ")); ");
                emit($cg, "free(__idx_s1); free(__idx_s2); ");
                if ($arg0_needs_cleanup == 1) {
                    emit($cg, "strada_decref(__idx_str); ");
                }
                if ($arg1_needs_cleanup == 1) {
                    emit($cg, "strada_decref(__idx_sub); ");
                }
                emit($cg, "__idx_res; }))");
            } else {
                # 2-argument form: index(string, substring)
                emit($cg, "(({ StradaValue *__idx_str = ");
                gen_expression($cg, $arg0);
                emit($cg, "; StradaValue *__idx_sub = ");
                gen_expression($cg, $arg1);
                emit($cg, "; char *__idx_s1 = strada_to_str(__idx_str); ");
                emit($cg, "char *__idx_s2 = strada_to_str(__idx_sub); ");
                emit($cg, "StradaValue *__idx_res = strada_new_int(strada_index(__idx_s1, __idx_s2)); ");
                emit($cg, "free(__idx_s1); free(__idx_s2); ");
                if ($arg0_needs_cleanup == 1) {
                    emit($cg, "strada_decref(__idx_str); ");
                }
                if ($arg1_needs_cleanup == 1) {
                    emit($cg, "strada_decref(__idx_sub); ");
                }
                emit($cg, "__idx_res; }))");
            }
            return;
        }

        if ($name eq "rindex") {
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];
            my scalar $arg1 = $args->[1];
            my int $arg0_needs_cleanup = needs_temp_cleanup($cg, $arg0);
            my int $arg1_needs_cleanup = needs_temp_cleanup($cg, $arg1);

            emit($cg, "(({ StradaValue *__ridx_str = ");
            gen_expression($cg, $arg0);
            emit($cg, "; StradaValue *__ridx_sub = ");
            gen_expression($cg, $arg1);
            emit($cg, "; char *__ridx_s1 = strada_to_str(__ridx_str); ");
            emit($cg, "char *__ridx_s2 = strada_to_str(__ridx_sub); ");
            emit($cg, "StradaValue *__ridx_res = strada_new_int(strada_rindex(__ridx_s1, __ridx_s2)); ");
            emit($cg, "free(__ridx_s1); free(__ridx_s2); ");
            if ($arg0_needs_cleanup == 1) {
                emit($cg, "strada_decref(__ridx_str); ");
            }
            if ($arg1_needs_cleanup == 1) {
                emit($cg, "strada_decref(__ridx_sub); ");
            }
            emit($cg, "__ridx_res; }))");
            return;
        }

        if ($name eq "sprintf") {
            # sprintf needs to capture and cleanup all argument temps
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};

            emit($cg, "(({ ");

            # Generate temp vars for each argument and track which need cleanup
            my int $i = 0;
            while ($i < $arg_count) {
                emit($cg, "StradaValue *__sprintf_arg" . $i . " = ");
                gen_expression($cg, $args->[$i]);
                emit($cg, "; ");
                $i = $i + 1;
            }

            # Call sprintf_sv with the temp vars
            emit($cg, "StradaValue *__sprintf_res = strada_sprintf_sv(__sprintf_arg0, " . ($arg_count - 1));
            $i = 1;
            while ($i < $arg_count) {
                emit($cg, ", __sprintf_arg" . $i);
                $i = $i + 1;
            }
            emit($cg, "); ");

            # Cleanup temps that need it
            $i = 0;
            while ($i < $arg_count) {
                if (needs_temp_cleanup($cg, $args->[$i]) == 1) {
                    emit($cg, "strada_decref(__sprintf_arg" . $i . "); ");
                }
                $i = $i + 1;
            }

            emit($cg, "__sprintf_res; }))");
            return;
        }
        
        if ($name eq "printf") {
            my scalar $args = $expr->{"args"};
            my int $argc = $expr->{"arg_count"};
            emit($cg, "({ ");
            # Pre-convert all args to strings
            my int $i = 0;
            while ($i < $argc) {
                emit($cg, "StradaValue *__pf_v" . $i . " = ");
                gen_expression($cg, $args->[$i]);
                emit($cg, "; char *__pf_s" . $i . " = strada_to_str(__pf_v" . $i . "); ");
                $i = $i + 1;
            }
            # Call strada_printf with pre-converted strings
            emit($cg, "strada_printf(__pf_s0");
            $i = 1;
            while ($i < $argc) {
                emit($cg, ", __pf_s" . $i);
                $i = $i + 1;
            }
            emit($cg, "); ");
            # Free all converted strings and decref temps
            $i = 0;
            while ($i < $argc) {
                emit($cg, "free(__pf_s" . $i . "); ");
                if (needs_temp_cleanup($cg, $args->[$i]) == 1) {
                    emit($cg, "strada_decref(__pf_v" . $i . "); ");
                }
                $i = $i + 1;
            }
            emit($cg, "(StradaValue*)NULL; })");
            return;
        }
        
        if ($name eq "warn") {
            my scalar $args = $expr->{"args"};
            my scalar $arg = $args->[0];
            emit($cg, "({ StradaValue *__wn_v = ");
            gen_expression($cg, $arg);
            emit($cg, "; char *__wn_s = strada_to_str(__wn_v); strada_warn(\"%s\", __wn_s); free(__wn_s); ");
            if (needs_temp_cleanup($cg, $arg) == 1) {
                emit($cg, "strada_decref(__wn_v); ");
            }
            emit($cg, "(StradaValue*)NULL; })");
            return;
        }
        
        if ($name eq "sys::slurp" || $name eq "slurp") {
            my scalar $args = $expr->{"args"};
            my scalar $arg = $args->[0];
            emit($cg, "({ StradaValue *__sl_v = ");
            gen_expression($cg, $arg);
            emit($cg, "; char *__sl_s = strada_to_str(__sl_v); StradaValue *__sl_r = strada_slurp(__sl_s); free(__sl_s); ");
            if (needs_temp_cleanup($cg, $arg) == 1) {
                emit($cg, "strada_decref(__sl_v); ");
            }
            emit($cg, "__sl_r; })");
            return;
        }

        if ($name eq "sys::slurp_fh") {
            emit($cg, "strada_slurp_fh(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::slurp_fd") {
            emit($cg, "strada_slurp_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::spew" || $name eq "spew") {
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];
            my scalar $arg1 = $args->[1];
            emit($cg, "({ StradaValue *__sp_v0 = ");
            gen_expression($cg, $arg0);
            emit($cg, "; StradaValue *__sp_v1 = ");
            gen_expression($cg, $arg1);
            emit($cg, "; char *__sp_s0 = strada_to_str(__sp_v0); char *__sp_s1 = strada_to_str(__sp_v1); ");
            emit($cg, "strada_spew(__sp_s0, __sp_s1); free(__sp_s0); free(__sp_s1); ");
            if (needs_temp_cleanup($cg, $arg0) == 1) {
                emit($cg, "strada_decref(__sp_v0); ");
            }
            if (needs_temp_cleanup($cg, $arg1) == 1) {
                emit($cg, "strada_decref(__sp_v1); ");
            }
            emit($cg, "(StradaValue*)NULL; })");
            return;
        }

        if ($name eq "sys::spew_fh") {
            emit($cg, "strada_spew_fh(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::spew_fd") {
            emit($cg, "strada_spew_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # StringBuilder functions for O(1) amortized append
        if ($name eq "sb_new") {
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_call_with_arg_cleanup($cg, "strada_sb_new_cap", $args, 1);
            } else {
                emit($cg, "strada_sb_new()");
            }
            return;
        }

        if ($name eq "sb_append") {
            my scalar $args = $expr->{"args"};
            my int $sb0_cleanup = needs_temp_cleanup($cg, $args->[0]);
            my int $sba_cleanup = needs_temp_cleanup($cg, $args->[1]);
            if ($sb0_cleanup == 1 || $sba_cleanup == 1) {
                emit($cg, "({ ");
                if ($sb0_cleanup == 1) {
                    emit($cg, "StradaValue *__sba_sb = ");
                    gen_expression($cg, $args->[0]);
                    emit($cg, "; ");
                }
                if ($sba_cleanup == 1) {
                    emit($cg, "StradaValue *__sba_tmp = ");
                    gen_expression($cg, $args->[1]);
                    emit($cg, "; ");
                }
                emit($cg, "strada_sb_append(");
                if ($sb0_cleanup == 1) {
                    emit($cg, "__sba_sb");
                } else {
                    gen_expression($cg, $args->[0]);
                }
                emit($cg, ", ");
                if ($sba_cleanup == 1) {
                    emit($cg, "__sba_tmp");
                } else {
                    gen_expression($cg, $args->[1]);
                }
                emit($cg, "); ");
                if ($sb0_cleanup == 1) {
                    emit($cg, "strada_decref(__sba_sb); ");
                }
                if ($sba_cleanup == 1) {
                    emit($cg, "strada_decref(__sba_tmp); ");
                }
                emit($cg, "strada_undef_static(); })");
            } else {
                emit($cg, "(strada_sb_append(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", ");
                gen_expression($cg, $args->[1]);
                emit($cg, "), strada_undef_static())");
            }
            return;
        }

        if ($name eq "sb_to_string") {
            my scalar $args = $expr->{"args"};
            if (needs_temp_cleanup($cg, $args->[0]) == 1) {
                emit($cg, "({ StradaValue *__sb_tmp = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; StradaValue *__sb_res = strada_sb_to_string(__sb_tmp); strada_decref(__sb_tmp); __sb_res; })");
            } else {
                emit($cg, "strada_sb_to_string(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")");
            }
            return;
        }

        if ($name eq "sb_length") {
            my scalar $args = $expr->{"args"};
            if (needs_temp_cleanup($cg, $args->[0]) == 1) {
                emit($cg, "({ StradaValue *__sb_tmp = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; StradaValue *__sb_res = strada_sb_length(__sb_tmp); strada_decref(__sb_tmp); __sb_res; })");
            } else {
                emit($cg, "strada_sb_length(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")");
            }
            return;
        }

        if ($name eq "sb_clear") {
            my scalar $args = $expr->{"args"};
            if (needs_temp_cleanup($cg, $args->[0]) == 1) {
                emit($cg, "({ StradaValue *__sb_tmp = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; strada_sb_clear(__sb_tmp); strada_decref(__sb_tmp); strada_undef_static(); })");
            } else {
                emit($cg, "(strada_sb_clear(");
                gen_expression($cg, $args->[0]);
                emit($cg, "), strada_undef_static())");
            }
            return;
        }

        if ($name eq "sb_free") {
            my scalar $args = $expr->{"args"};
            if (needs_temp_cleanup($cg, $args->[0]) == 1) {
                emit($cg, "({ StradaValue *__sb_tmp = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; strada_sb_free(__sb_tmp); strada_decref(__sb_tmp); strada_undef_static(); })");
            } else {
                emit($cg, "(strada_sb_free(");
                gen_expression($cg, $args->[0]);
                emit($cg, "), strada_undef_static())");
            }
            return;
        }

        # open(filename_or_ref, mode) - open file or in-memory handle
        if ($name eq "sys::open") {
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];
            my scalar $arg1 = $args->[1];
            emit($cg, "({ StradaValue *__op_v0 = ");
            gen_expression($cg, $arg0);
            emit($cg, "; StradaValue *__op_v1 = ");
            gen_expression($cg, $arg1);
            emit($cg, "; StradaValue *__op_r = strada_open_sv(__op_v0, __op_v1); ");
            if (needs_temp_cleanup($cg, $arg0) == 1) {
                emit($cg, "strada_decref(__op_v0); ");
            }
            if (needs_temp_cleanup($cg, $arg1) == 1) {
                emit($cg, "strada_decref(__op_v1); ");
            }
            emit($cg, "__op_r; })");
            return;
        }

        if ($name eq "sys::open_fd") {
            emit($cg, "strada_open_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # open_str(content, mode) - open in-memory file handle
        if ($name eq "sys::open_str") {
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];
            my scalar $arg1 = $args->[1];
            emit($cg, "({ StradaValue *__op_v0 = ");
            gen_expression($cg, $arg0);
            emit($cg, "; StradaValue *__op_v1 = ");
            gen_expression($cg, $arg1);
            emit($cg, "; char *__op_s0 = strada_to_str(__op_v0); char *__op_s1 = strada_to_str(__op_v1); ");
            emit($cg, "StradaValue *__op_r = strada_open_str(__op_s0, __op_s1); free(__op_s0); free(__op_s1); ");
            if (needs_temp_cleanup($cg, $arg0) == 1) {
                emit($cg, "strada_decref(__op_v0); ");
            }
            if (needs_temp_cleanup($cg, $arg1) == 1) {
                emit($cg, "strada_decref(__op_v1); ");
            }
            emit($cg, "__op_r; })");
            return;
        }

        # str_from_fh(fh) - extract accumulated string from memstream
        if ($name eq "sys::str_from_fh") {
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];
            emit($cg, "({ StradaValue *__op_v0 = ");
            gen_expression($cg, $arg0);
            emit($cg, "; StradaValue *__op_r = strada_str_from_fh(__op_v0); ");
            if (needs_temp_cleanup($cg, $arg0) == 1) {
                emit($cg, "strada_decref(__op_v0); ");
            }
            emit($cg, "__op_r; })");
            return;
        }

        # close(fh) - close file handle
        if ($name eq "sys::close") {
            emit($cg, "strada_close(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # write_fd(fd, str) - write to file descriptor
        if ($name eq "write_fd" || $name eq "sys::write_fd") {
            emit($cg, "strada_write_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # close_fd(fd) - close file descriptor
        if ($name eq "close_fd" || $name eq "sys::close_fd") {
            emit($cg, "strada_close_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # getpid() - get process ID
        if ($name eq "getpid" || $name eq "sys::getpid") {
            emit($cg, "strada_new_int(getpid())");
            return;
        }

        # unlink(path) - delete file
        if ($name eq "unlink" || $name eq "sys::unlink") {
            emit($cg, "strada_unlink(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # fwrite(fh, content) - write to file handle
        if ($name eq "sys::fwrite") {
            my scalar $args = $expr->{"args"};
            my scalar $data_arg = $args->[1];
            emit($cg, "({ StradaValue *__fw_v = ");
            gen_expression($cg, $data_arg);
            emit($cg, "; char *__fw_s = strada_to_str(__fw_v); strada_write_file(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", __fw_s); free(__fw_s); ");
            if (needs_temp_cleanup($cg, $data_arg) == 1) {
                emit($cg, "strada_decref(__fw_v); ");
            }
            emit($cg, "(StradaValue*)NULL; })");
            return;
        }

        # fread(fh) - read entire file from handle
        if ($name eq "sys::fread") {
            emit($cg, "strada_read_file(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "die") {
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];
            if (needs_temp_cleanup($cg, $arg0) == 1) {
                emit($cg, "({ StradaValue *__die_arg = ");
                gen_expression($cg, $arg0);
                emit($cg, "; strada_cleanup_push(__die_arg); strada_die_sv(__die_arg); })");
            } else {
                emit($cg, "strada_die_sv(");
                gen_expression($cg, $arg0);
                emit($cg, ")");
            }
            return;
        }

        if ($name eq "throw") {
            emit($cg, "strada_throw_value(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # scalar() - get array length as int
        if ($name eq "scalar") {
            my scalar $args = $expr->{"args"};
            my scalar $arg = $args->[0];
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $arg) == 1) {
                emit($cg, "({ StradaValue *__sc_tmp = ");
                gen_expression($cg, $arg);
                emit($cg, "; int64_t __sc_res = strada_array_length(strada_deref_array(__sc_tmp)); strada_decref(__sc_tmp); strada_new_int(__sc_res); })");
            } else {
                emit($cg, "strada_new_int(strada_array_length(strada_deref_array(");
                gen_expression($cg, $arg);
                emit($cg, ")))");
            }
            return;
        }
        
        # is_ref / is_refto - check if value is a reference
        if ($name eq "is_ref" || $name eq "is_refto") {
            emit($cg, "strada_new_int(strada_is_ref(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        # reftype - get reference type string
        if ($name eq "reftype") {
            emit($cg, "strada_new_str(strada_reftype(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        # refto - create a reference
        if ($name eq "refto") {
            emit($cg, "strada_new_ref(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", '$')");
            return;
        }
        
        # derefto - dereference
        if ($name eq "derefto" || $name eq "deref") {
            emit($cg, "strada_deref(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # deref_array - dereference to array (returns StradaValue*)
        if ($name eq "deref_array") {
            emit($cg, "strada_deref_array_value(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # deref_hash - dereference to hash (returns StradaValue*)
        if ($name eq "deref_hash") {
            emit($cg, "strada_deref_hash_value(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # deref_set - set value through a scalar reference
        if ($name eq "deref_set") {
            emit($cg, "strada_deref_set(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # clone - deep copy a value
        if ($name eq "clone") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_clone", $args, 1);
            return;
        }
        
        # typeof - get type name string (returns StradaValue* str)
        if ($name eq "typeof") {
            emit($cg, "strada_new_str(strada_typeof(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        # abs - absolute value
        if ($name eq "math::abs") {
            emit($cg, "strada_abs(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # sqrt - square root
        if ($name eq "math::sqrt") {
            emit($cg, "strada_sqrt(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # rand - random number
        if ($name eq "math::rand") {
            emit($cg, "strada_rand()");
            return;
        }
        
        # time - current timestamp
        if ($name eq "sys::time") {
            emit($cg, "strada_time()");
            return;
        }

        # localtime - convert timestamp to local time hash
        if ($name eq "sys::localtime") {
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_call_with_arg_cleanup($cg, "strada_localtime", $args, 1);
            } else {
                emit($cg, "strada_localtime(NULL)");
            }
            return;
        }

        # gmtime - convert timestamp to UTC time hash
        if ($name eq "sys::gmtime") {
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_call_with_arg_cleanup($cg, "strada_gmtime", $args, 1);
            } else {
                emit($cg, "strada_gmtime(NULL)");
            }
            return;
        }

        # mktime - convert time hash to timestamp
        if ($name eq "sys::mktime") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_mktime", $args, 1);
            return;
        }

        # strftime - format time
        if ($name eq "sys::strftime") {
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 1) {
                gen_call_with_arg_cleanup($cg, "strada_strftime", $args, 2);
            } else {
                my scalar $arg0 = $args->[0];
                my int $a0_cleanup = needs_temp_cleanup($cg, $arg0);
                if ($a0_cleanup == 1) {
                    emit($cg, "({ StradaValue *__call_arg0 = ");
                    gen_expression($cg, $arg0);
                    emit($cg, "; StradaValue *__call_result = strada_strftime(__call_arg0, NULL); strada_decref(__call_arg0); __call_result; })");
                } else {
                    emit($cg, "strada_strftime(");
                    gen_expression($cg, $arg0);
                    emit($cg, ", NULL)");
                }
            }
            return;
        }

        # ctime - convert timestamp to string
        if ($name eq "sys::ctime") {
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_call_with_arg_cleanup($cg, "strada_ctime", $args, 1);
            } else {
                emit($cg, "strada_ctime(NULL)");
            }
            return;
        }

        # gettimeofday - high-res time
        if ($name eq "sys::gettimeofday") {
            emit($cg, "strada_gettimeofday()");
            return;
        }

        # hires_time - floating point seconds
        if ($name eq "sys::hires_time") {
            emit($cg, "strada_hires_time()");
            return;
        }

        # Memory profiler functions
        if ($name eq "sys::memprof_enable") {
            emit($cg, "(strada_memprof_enable(), strada_undef_static())");
            return;
        }
        if ($name eq "sys::memprof_disable") {
            emit($cg, "(strada_memprof_disable(), strada_undef_static())");
            return;
        }
        if ($name eq "sys::memprof_report") {
            emit($cg, "(strada_memprof_report(), strada_undef_static())");
            return;
        }
        if ($name eq "sys::memprof_reset") {
            emit($cg, "(strada_memprof_reset(), strada_undef_static())");
            return;
        }

        # tv_interval - time interval
        if ($name eq "sys::tv_interval") {
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 1) {
                gen_call_with_arg_cleanup($cg, "strada_tv_interval", $args, 2);
            } else {
                my scalar $arg0 = $args->[0];
                my int $a0_cleanup = needs_temp_cleanup($cg, $arg0);
                if ($a0_cleanup == 1) {
                    emit($cg, "({ StradaValue *__call_arg0 = ");
                    gen_expression($cg, $arg0);
                    emit($cg, "; StradaValue *__call_result = strada_tv_interval(__call_arg0, NULL); strada_decref(__call_arg0); __call_result; })");
                } else {
                    emit($cg, "strada_tv_interval(");
                    gen_expression($cg, $arg0);
                    emit($cg, ", NULL)");
                }
            }
            return;
        }

        # nanosleep - sleep nanoseconds
        if ($name eq "sys::nanosleep") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_nanosleep_ns", $args, 1);
            return;
        }

        # clock_gettime - get clock time
        if ($name eq "sys::clock_gettime") {
            emit($cg, "strada_clock_gettime(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # clock_getres - get clock resolution
        if ($name eq "sys::clock_getres") {
            emit($cg, "strada_clock_getres(");
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                gen_expression($cg, $args->[0]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        # dl_open - open shared library
        if ($name eq "sys::dl_open") {
            emit($cg, "strada_dl_open(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # strada_dl_open_raw - internal raw library open
        if ($name eq "strada_dl_open_raw") {
            emit($cg, "strada_dl_open_raw(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # strada_dl_sym_raw - internal raw symbol lookup
        if ($name eq "strada_dl_sym_raw") {
            emit($cg, "strada_dl_sym_raw(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # strada_dl_close_raw - internal raw library close
        if ($name eq "strada_dl_close_raw") {
            emit($cg, "strada_dl_close_raw(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # dl_sym - get symbol from library
        if ($name eq "sys::dl_sym") {
            emit($cg, "strada_dl_sym(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_close - close library
        if ($name eq "sys::dl_close") {
            emit($cg, "strada_dl_close(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # dl_error - get last error
        if ($name eq "sys::dl_error") {
            emit($cg, "strada_dl_error()");
            return;
        }

        # dl_call_int - call function returning int
        if ($name eq "sys::dl_call_int") {
            emit($cg, "strada_dl_call_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_call_num - call function returning num
        if ($name eq "sys::dl_call_num") {
            emit($cg, "strada_dl_call_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_call_str - call function returning string
        if ($name eq "sys::dl_call_str") {
            emit($cg, "strada_dl_call_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_call_void - call function with no return
        if ($name eq "sys::dl_call_void") {
            emit($cg, "strada_dl_call_void(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # dl_call_int_sv - call function passing StradaValue* directly, returns int
        if ($name eq "sys::dl_call_int_sv") {
            my scalar $args = $expr->{"args"};
            my scalar $arg1 = $args->[1];
            # Clean up the args array if it's a temporary (like anonymous array)
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $arg1) == 1) {
                emit($cg, "({ StradaValue *__dl_args = ");
                gen_expression($cg, $arg1);
                emit($cg, "; StradaValue *__dl_res = strada_dl_call_int_sv(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", __dl_args); strada_decref(__dl_args); __dl_res; })");
            } else {
                emit($cg, "strada_dl_call_int_sv(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", ");
                gen_expression($cg, $arg1);
                emit($cg, ")");
            }
            return;
        }

        # dl_call_str_sv - call function passing StradaValue* directly, returns string
        if ($name eq "sys::dl_call_str_sv") {
            my scalar $args = $expr->{"args"};
            my scalar $arg1 = $args->[1];
            # Clean up the args array if it's a temporary (like anonymous array)
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $arg1) == 1) {
                emit($cg, "({ StradaValue *__dl_args = ");
                gen_expression($cg, $arg1);
                emit($cg, "; StradaValue *__dl_res = strada_dl_call_str_sv(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", __dl_args); strada_decref(__dl_args); __dl_res; })");
            } else {
                emit($cg, "strada_dl_call_str_sv(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", ");
                gen_expression($cg, $arg1);
                emit($cg, ")");
            }
            return;
        }

        # dl_call_void_sv - call function passing StradaValue* directly, no return
        if ($name eq "sys::dl_call_void_sv") {
            my scalar $args = $expr->{"args"};
            my scalar $arg1 = $args->[1];
            # Clean up the args array if it's a temporary (like anonymous array)
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $arg1) == 1) {
                emit($cg, "({ StradaValue *__dl_args = ");
                gen_expression($cg, $arg1);
                emit($cg, "; strada_dl_call_void_sv(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", __dl_args); strada_decref(__dl_args); })");
            } else {
                emit($cg, "strada_dl_call_void_sv(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", ");
                gen_expression($cg, $arg1);
                emit($cg, ")");
            }
            return;
        }

        if ($name eq "sys::dl_call_sv") {
            my scalar $args = $expr->{"args"};
            my scalar $arg1 = $args->[1];
            # Clean up the args array if it's a temporary (like anonymous array)
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $arg1) == 1) {
                emit($cg, "({ StradaValue *__dl_args = ");
                gen_expression($cg, $arg1);
                emit($cg, "; StradaValue *__dl_res = strada_dl_call_sv(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", __dl_args); strada_decref(__dl_args); __dl_res; })");
            } else {
                emit($cg, "strada_dl_call_sv(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", ");
                gen_expression($cg, $arg1);
                emit($cg, ")");
            }
            return;
        }

        if ($name eq "sys::dl_call_export_info") {
            emit($cg, "strada_dl_call_export_info(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::dl_call_version") {
            emit($cg, "strada_dl_call_version(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Pointer access for FFI
        if ($name eq "sys::int_ptr") {
            emit($cg, "strada_int_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::num_ptr") {
            emit($cg, "strada_num_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::str_ptr") {
            emit($cg, "strada_str_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_deref_int") {
            emit($cg, "strada_ptr_deref_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_deref_num") {
            emit($cg, "strada_ptr_deref_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_deref_str") {
            emit($cg, "strada_ptr_deref_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_set_int") {
            emit($cg, "strada_ptr_set_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ptr_set_num") {
            emit($cg, "strada_ptr_set_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # ============================================
        # c:: namespace - C interop helper functions
        # ============================================

        # c::str_to_ptr - Convert Strada string to C char* (allocates)
        if ($name eq "c::str_to_ptr") {
            emit($cg, "strada_c_str_to_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # c::ptr_to_str - Convert C char* to Strada string (copies)
        if ($name eq "c::ptr_to_str") {
            emit($cg, "strada_c_ptr_to_str(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # c::ptr_to_str_n - Convert C char* to Strada string with length
        if ($name eq "c::ptr_to_str_n") {
            emit($cg, "strada_c_ptr_to_str_n(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # c::free - Free C-allocated memory
        if ($name eq "c::free") {
            emit($cg, "strada_c_free(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # c::alloc - Allocate memory (malloc wrapper)
        if ($name eq "c::alloc") {
            emit($cg, "strada_c_alloc(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # c::realloc - Reallocate memory
        if ($name eq "c::realloc") {
            emit($cg, "strada_c_realloc(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # c::null - Return NULL pointer
        if ($name eq "c::null") {
            emit($cg, "strada_c_null()");
            return;
        }

        # c::is_null - Check if pointer is NULL
        if ($name eq "c::is_null") {
            emit($cg, "strada_c_is_null(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # c::ptr_add - Pointer arithmetic
        if ($name eq "c::ptr_add") {
            emit($cg, "strada_c_ptr_add(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # c:: memory read functions
        if ($name eq "c::read_int8") {
            emit($cg, "strada_c_read_int8(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::read_int16") {
            emit($cg, "strada_c_read_int16(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::read_int32") {
            emit($cg, "strada_c_read_int32(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::read_int64") {
            emit($cg, "strada_c_read_int64(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::read_ptr") {
            emit($cg, "strada_c_read_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::read_float") {
            emit($cg, "strada_c_read_float(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::read_double") {
            emit($cg, "strada_c_read_double(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # c:: memory write functions
        if ($name eq "c::write_int8") {
            emit($cg, "strada_c_write_int8(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::write_int16") {
            emit($cg, "strada_c_write_int16(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::write_int32") {
            emit($cg, "strada_c_write_int32(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::write_int64") {
            emit($cg, "strada_c_write_int64(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::write_ptr") {
            emit($cg, "strada_c_write_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::write_float") {
            emit($cg, "strada_c_write_float(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::write_double") {
            emit($cg, "strada_c_write_double(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # c:: size introspection
        if ($name eq "c::sizeof_int") {
            emit($cg, "strada_c_sizeof_int()");
            return;
        }

        if ($name eq "c::sizeof_long") {
            emit($cg, "strada_c_sizeof_long()");
            return;
        }

        if ($name eq "c::sizeof_ptr") {
            emit($cg, "strada_c_sizeof_ptr()");
            return;
        }

        if ($name eq "c::sizeof_size_t") {
            emit($cg, "strada_c_sizeof_size_t()");
            return;
        }

        # c:: memory operations
        if ($name eq "c::memcpy") {
            emit($cg, "strada_c_memcpy(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "c::memset") {
            emit($cg, "strada_c_memset(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        # readline - read line from stdin or file handle
        if ($name eq "readline") {
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count > 0) {
                # readline(fh) - read from file handle
                emit($cg, "strada_read_line(");
                my scalar $args = $expr->{"args"};
                gen_expression($cg, $args->[0]);
                emit($cg, ")");
            } else {
                # readline() - read from stdin
                emit($cg, "strada_readline()");
            }
            return;
        }
        
        # refcount - get reference count
        if ($name eq "refcount") {
            emit($cg, "strada_new_int(strada_refcount(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # core::weaken / sys::weaken - make a reference weak
        # Passes a pointer to the variable so the runtime can replace it with a weak wrapper
        if ($name eq "sys::weaken") {
            my scalar $args = $expr->{"args"};
            my scalar $arg = $args->[0];
            # For variable references, pass address of variable
            if ($arg->{"type"} == NODE_VARIABLE()) {
                emit($cg, "(strada_weaken(&");
                gen_expression($cg, $arg);
                emit($cg, "), strada_undef_static())");
            } elsif ($arg->{"type"} == NODE_HASH_ACCESS()) {
                # For %hash{"key"} style access
                emit($cg, "({ StradaHash *__wk_hv = strada_deref_hash(");
                gen_expression($cg, $arg->{"object"});
                emit($cg, "); StradaValue *__wk_kv = ");
                gen_expression($cg, $arg->{"key"});
                emit($cg, "; char *__wk_key = strada_to_str(__wk_kv); strada_weaken_hv_entry(__wk_hv, __wk_key); free(__wk_key); ");
                if (needs_temp_cleanup($cg, $arg->{"key"}) == 1) {
                    emit($cg, "strada_decref(__wk_kv); ");
                }
                emit($cg, "strada_undef_static(); })");
            } elsif ($arg->{"type"} == NODE_DEREF_HASH()) {
                # For $ref->{"key"} style access
                emit($cg, "({ StradaHash *__wk_hv = strada_deref_hash(");
                gen_expression($cg, $arg->{"ref"});
                emit($cg, "); StradaValue *__wk_kv = ");
                gen_expression($cg, $arg->{"key"});
                emit($cg, "; char *__wk_key = strada_to_str(__wk_kv); strada_weaken_hv_entry(__wk_hv, __wk_key); free(__wk_key); ");
                if (needs_temp_cleanup($cg, $arg->{"key"}) == 1) {
                    emit($cg, "strada_decref(__wk_kv); ");
                }
                emit($cg, "strada_undef_static(); })");
            } else {
                # Fallback for other expression types - weaken in a temp variable
                emit($cg, "({ StradaValue *__wk_tmp = ");
                gen_expression($cg, $arg);
                emit($cg, "; strada_weaken(&__wk_tmp); strada_undef_static(); })");
            }
            return;
        }

        # core::isweak / sys::isweak - check if a reference is weak
        if ($name eq "sys::isweak") {
            my scalar $args = $expr->{"args"};
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1) {
                emit($cg, "({ StradaValue *__iw_tmp = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; StradaValue *__iw_r = strada_new_int(strada_isweak(__iw_tmp)); strada_decref(__iw_tmp); __iw_r; })");
            } else {
                emit($cg, "strada_new_int(strada_isweak(");
                gen_expression($cg, $args->[0]);
                emit($cg, "))");
            }
            return;
        }

        # free - explicitly decrement refcount, free if zero, and set variable to undef
        # free(\$var) -> frees $var's value and sets $var = undef (same as release)
        if ($name eq "free" || $name eq "sys::free" || $name eq "sys::release") {
            my scalar $args = $expr->{"args"};
            my scalar $ref_arg = $args->[0];

            # Check if argument is a reference expression like \$var
            if ($ref_arg->{"type"} == NODE_REF() && $ref_arg->{"target"}->{"type"} == NODE_VARIABLE()) {
                my str $varname = $ref_arg->{"target"}->{"name"};
                # Generate: (strada_free(varname), varname = strada_new_undef())
                emit($cg, "(strada_free(" . $varname . "), " . $varname . " = strada_new_undef())");
            } else {
                # Fallback: just call the runtime function
                emit($cg, "strada_release(");
                gen_expression($cg, $ref_arg);
                emit($cg, ")");
            }
            return;
        }

        # ucfirst - uppercase first letter
        if ($name eq "ucfirst") {
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];
            my int $needs_cleanup = needs_temp_cleanup($cg, $arg0);
            emit($cg, "(({ StradaValue *__ucf_tmp = ");
            gen_expression($cg, $arg0);
            emit($cg, "; char *__ucf_in = strada_to_str(__ucf_tmp); ");
            emit($cg, "char *__ucf_out = strada_ucfirst(__ucf_in); ");
            emit($cg, "StradaValue *__ucf_res = strada_new_str(__ucf_out); ");
            emit($cg, "free(__ucf_in); free(__ucf_out); ");
            if ($needs_cleanup == 1) {
                emit($cg, "strada_decref(__ucf_tmp); ");
            }
            emit($cg, "__ucf_res; }))");
            return;
        }

        # lcfirst - lowercase first letter
        if ($name eq "lcfirst") {
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];
            my int $needs_cleanup = needs_temp_cleanup($cg, $arg0);
            emit($cg, "(({ StradaValue *__lcf_tmp = ");
            gen_expression($cg, $arg0);
            emit($cg, "; char *__lcf_in = strada_to_str(__lcf_tmp); ");
            emit($cg, "char *__lcf_out = strada_lcfirst(__lcf_in); ");
            emit($cg, "StradaValue *__lcf_res = strada_new_str(__lcf_out); ");
            emit($cg, "free(__lcf_in); free(__lcf_out); ");
            if ($needs_cleanup == 1) {
                emit($cg, "strada_decref(__lcf_tmp); ");
            }
            emit($cg, "__lcf_res; }))");
            return;
        }
        
        # match - regex match (with capture support so captures() works after match())
        if ($name eq "match") {
            my scalar $args = $expr->{"args"};
            my int $a0_temp = 0;
            my int $a1_temp = 0;
            if ($cg->{"cleanup_enabled"} == 1) {
                $a0_temp = needs_temp_cleanup($cg, $args->[0]);
                $a1_temp = needs_temp_cleanup($cg, $args->[1]);
            }
            emit($cg, "({ ");
            if ($a0_temp == 1) {
                emit($cg, "StradaValue *__m_a0 = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; char *__m_s = strada_to_str(__m_a0); ");
            } else {
                emit($cg, "char *__m_s = strada_to_str(");
                gen_expression($cg, $args->[0]);
                emit($cg, "); ");
            }
            if ($a1_temp == 1) {
                emit($cg, "StradaValue *__m_a1 = ");
                gen_expression($cg, $args->[1]);
                emit($cg, "; char *__m_p = strada_to_str(__m_a1); ");
            } else {
                emit($cg, "char *__m_p = strada_to_str(");
                gen_expression($cg, $args->[1]);
                emit($cg, "); ");
            }
            emit($cg, "int __m_r = strada_regex_match_with_capture(__m_s, __m_p, NULL); free(__m_p); free(__m_s); ");
            if ($a0_temp == 1) { emit($cg, "strada_decref(__m_a0); "); }
            if ($a1_temp == 1) { emit($cg, "strada_decref(__m_a1); "); }
            emit($cg, "strada_new_int(__m_r); })");
            return;
        }
        
        # capture - regex capture
        if ($name eq "capture") {
            my scalar $args = $expr->{"args"};
            my int $cap0_cl = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1;
            my int $cap1_cl = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[1]) == 1;
            emit($cg, "({ ");
            if ($cap0_cl == 1) {
                emit($cg, "StradaValue *__cap_sv0 = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; char *__cap_s = strada_to_str(__cap_sv0); ");
            } else {
                emit($cg, "char *__cap_s = strada_to_str(");
                gen_expression($cg, $args->[0]);
                emit($cg, "); ");
            }
            if ($cap1_cl == 1) {
                emit($cg, "StradaValue *__cap_sv1 = ");
                gen_expression($cg, $args->[1]);
                emit($cg, "; char *__cap_p = strada_to_str(__cap_sv1); ");
            } else {
                emit($cg, "char *__cap_p = strada_to_str(");
                gen_expression($cg, $args->[1]);
                emit($cg, "); ");
            }
            emit($cg, "StradaValue *__cap_r = strada_new_array_from_av(strada_regex_capture(__cap_s, __cap_p)); free(__cap_p); free(__cap_s); ");
            if ($cap0_cl == 1) {
                emit($cg, "strada_decref(__cap_sv0); ");
            }
            if ($cap1_cl == 1) {
                emit($cg, "strada_decref(__cap_sv1); ");
            }
            emit($cg, "__cap_r; })");
            return;
        }

        # captures - get captures from last =~ match
        if ($name eq "captures") {
            emit($cg, "strada_captures()");
            return;
        }

        # named_captures - get named captures hash from last =~ match (PCRE2)
        if ($name eq "named_captures") {
            emit($cg, "strada_named_captures()");
            return;
        }

        # replace - regex replace (no flags for function-based API)
        if ($name eq "replace") {
            my scalar $args = $expr->{"args"};
            my int $a0_temp = 0;
            my int $a1_temp = 0;
            my int $a2_temp = 0;
            if ($cg->{"cleanup_enabled"} == 1) {
                $a0_temp = needs_temp_cleanup($cg, $args->[0]);
                $a1_temp = needs_temp_cleanup($cg, $args->[1]);
                $a2_temp = needs_temp_cleanup($cg, $args->[2]);
            }
            emit($cg, "({ ");
            if ($a0_temp == 1) {
                emit($cg, "StradaValue *__rp_a0 = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; char *__rp_s = strada_to_str(__rp_a0); ");
            } else {
                emit($cg, "char *__rp_s = strada_to_str(");
                gen_expression($cg, $args->[0]);
                emit($cg, "); ");
            }
            if ($a1_temp == 1) {
                emit($cg, "StradaValue *__rp_a1 = ");
                gen_expression($cg, $args->[1]);
                emit($cg, "; char *__rp_p = strada_to_str(__rp_a1); ");
            } else {
                emit($cg, "char *__rp_p = strada_to_str(");
                gen_expression($cg, $args->[1]);
                emit($cg, "); ");
            }
            if ($a2_temp == 1) {
                emit($cg, "StradaValue *__rp_a2 = ");
                gen_expression($cg, $args->[2]);
                emit($cg, "; char *__rp_r = strada_to_str(__rp_a2); ");
            } else {
                emit($cg, "char *__rp_r = strada_to_str(");
                gen_expression($cg, $args->[2]);
                emit($cg, "); ");
            }
            emit($cg, "char *__rp_res = strada_regex_replace(__rp_s, __rp_p, __rp_r, NULL); StradaValue *__rp_sv = strada_new_str(__rp_res); free(__rp_res); free(__rp_r); free(__rp_p); free(__rp_s); ");
            if ($a0_temp == 1) { emit($cg, "strada_decref(__rp_a0); "); }
            if ($a1_temp == 1) { emit($cg, "strada_decref(__rp_a1); "); }
            if ($a2_temp == 1) { emit($cg, "strada_decref(__rp_a2); "); }
            emit($cg, "__rp_sv; })");
            return;
        }
        
        # cstruct_set_int
        if ($name eq "sys::cstruct_set_int") {
            my scalar $args = $expr->{"args"};
            my scalar $field_arg = $args->[1];
            emit($cg, "({ StradaValue *__csi_v = ");
            gen_expression($cg, $field_arg);
            emit($cg, "; char *__csi_s = strada_to_str(__csi_v); strada_cstruct_set_int(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", __csi_s, strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[3]);
            emit($cg, ")); free(__csi_s); ");
            if (needs_temp_cleanup($cg, $field_arg) == 1) {
                emit($cg, "strada_decref(__csi_v); ");
            }
            emit($cg, "(StradaValue*)NULL; })");
            return;
        }

        # cstruct_set_string
        if ($name eq "sys::cstruct_set_string") {
            my scalar $args = $expr->{"args"};
            my scalar $field_arg = $args->[1];
            my scalar $val_arg = $args->[3];
            emit($cg, "({ StradaValue *__css_fv = ");
            gen_expression($cg, $field_arg);
            emit($cg, "; StradaValue *__css_vv = ");
            gen_expression($cg, $val_arg);
            emit($cg, "; char *__css_fs = strada_to_str(__css_fv); char *__css_vs = strada_to_str(__css_vv); strada_cstruct_set_string(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", __css_fs, strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), __css_vs); free(__css_fs); free(__css_vs); ");
            if (needs_temp_cleanup($cg, $field_arg) == 1) {
                emit($cg, "strada_decref(__css_fv); ");
            }
            if (needs_temp_cleanup($cg, $val_arg) == 1) {
                emit($cg, "strada_decref(__css_vv); ");
            }
            emit($cg, "(StradaValue*)NULL; })");
            return;
        }

        # cstruct_set_double
        if ($name eq "sys::cstruct_set_double") {
            my scalar $args = $expr->{"args"};
            my scalar $field_arg = $args->[1];
            emit($cg, "({ StradaValue *__csd_v = ");
            gen_expression($cg, $field_arg);
            emit($cg, "; char *__csd_s = strada_to_str(__csd_v); strada_cstruct_set_double(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", __csd_s, strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_num(");
            gen_expression($cg, $args->[3]);
            emit($cg, ")); free(__csd_s); ");
            if (needs_temp_cleanup($cg, $field_arg) == 1) {
                emit($cg, "strada_decref(__csd_v); ");
            }
            emit($cg, "(StradaValue*)NULL; })");
            return;
        }

        # cstruct_get_int
        if ($name eq "sys::cstruct_get_int") {
            my scalar $args = $expr->{"args"};
            my scalar $field_arg = $args->[1];
            emit($cg, "({ StradaValue *__cgi_v = ");
            gen_expression($cg, $field_arg);
            emit($cg, "; char *__cgi_s = strada_to_str(__cgi_v); int64_t __cgi_r = strada_cstruct_get_int(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", __cgi_s, strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")); free(__cgi_s); ");
            if (needs_temp_cleanup($cg, $field_arg) == 1) {
                emit($cg, "strada_decref(__cgi_v); ");
            }
            emit($cg, "strada_new_int(__cgi_r); })");
            return;
        }

        # cstruct_get_string
        if ($name eq "sys::cstruct_get_string") {
            my scalar $args = $expr->{"args"};
            my scalar $field_arg = $args->[1];
            emit($cg, "({ StradaValue *__cgs_v = ");
            gen_expression($cg, $field_arg);
            emit($cg, "; char *__cgs_s = strada_to_str(__cgs_v); const char *__cgs_r = strada_cstruct_get_string(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", __cgs_s, strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")); free(__cgs_s); ");
            if (needs_temp_cleanup($cg, $field_arg) == 1) {
                emit($cg, "strada_decref(__cgs_v); ");
            }
            emit($cg, "strada_new_str(__cgs_r); })");
            return;
        }

        # cstruct_get_double
        if ($name eq "sys::cstruct_get_double") {
            my scalar $args = $expr->{"args"};
            my scalar $field_arg = $args->[1];
            emit($cg, "({ StradaValue *__cgd_v = ");
            gen_expression($cg, $field_arg);
            emit($cg, "; char *__cgd_s = strada_to_str(__cgd_v); double __cgd_r = strada_cstruct_get_double(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", __cgd_s, strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")); free(__cgd_s); ");
            if (needs_temp_cleanup($cg, $field_arg) == 1) {
                emit($cg, "strada_decref(__cgd_v); ");
            }
            emit($cg, "strada_new_num(__cgd_r); })");
            return;
        }

        # cstruct_new
        if ($name eq "sys::cstruct_new") {
            my scalar $args = $expr->{"args"};
            my scalar $name_arg = $args->[0];
            emit($cg, "({ StradaValue *__cn_v = ");
            gen_expression($cg, $name_arg);
            emit($cg, "; char *__cn_s = strada_to_str(__cn_v); StradaValue *__cn_r = strada_cstruct_new(__cn_s, strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")); free(__cn_s); ");
            if (needs_temp_cleanup($cg, $name_arg) == 1) {
                emit($cg, "strada_decref(__cn_v); ");
            }
            emit($cg, "__cn_r; })");
            return;
        }
        
        # cstruct_ptr
        if ($name eq "sys::cstruct_ptr") {
            emit($cg, "strada_cstruct_ptr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # socket_client
        if ($name eq "sys::socket_client") {
            my scalar $args = $expr->{"args"};
            my scalar $host_arg = $args->[0];
            emit($cg, "({ StradaValue *__sc_v = ");
            gen_expression($cg, $host_arg);
            emit($cg, "; char *__sc_s = strada_to_str(__sc_v); StradaValue *__sc_r = strada_socket_client(__sc_s, strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")); free(__sc_s); ");
            if (needs_temp_cleanup($cg, $host_arg) == 1) {
                emit($cg, "strada_decref(__sc_v); ");
            }
            emit($cg, "__sc_r; })");
            return;
        }
        
        # socket_server
        if ($name eq "sys::socket_server") {
            emit($cg, "strada_socket_server(");
            my scalar $args = $expr->{"args"};
            emit_int_operand($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # socket_server_backlog
        if ($name eq "sys::socket_server_backlog") {
            emit($cg, "strada_socket_server_backlog(");
            my scalar $args = $expr->{"args"};
            emit_int_operand($cg, $args->[0]);
            emit($cg, ", ");
            emit_int_operand($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # socket_accept
        if ($name eq "sys::socket_accept") {
            emit($cg, "strada_socket_accept(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }
        
        # socket_recv
        if ($name eq "sys::socket_recv") {
            emit($cg, "strada_socket_recv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            emit_int_operand($cg, $args->[1]);
            emit($cg, ")");
            return;
        }
        
        # socket_send - use binary-safe version that handles NUL bytes
        if ($name eq "sys::socket_send") {
            emit($cg, "strada_new_int(strada_socket_send_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }
        
        # socket_close
        if ($name eq "sys::socket_close") {
            emit($cg, "strada_socket_close(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # socket_flush - flush write buffer
        if ($name eq "sys::socket_flush") {
            emit($cg, "strada_socket_flush(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # socket_select - wait for sockets to be ready for reading
        if ($name eq "sys::socket_select") {
            emit($cg, "strada_socket_select(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        # socket_fd - get file descriptor from socket
        if ($name eq "sys::socket_fd") {
            emit($cg, "strada_new_int(strada_socket_fd(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # select_fds - wait for file descriptors to be ready for reading
        if ($name eq "sys::select_fds") {
            emit($cg, "strada_select_fds(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        # socket_set_nonblocking - set or clear non-blocking mode on a socket
        if ($name eq "sys::socket_set_nonblocking") {
            emit($cg, "strada_new_int(strada_socket_set_nonblocking(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }

        # UDP socket functions

        # udp_socket - create a UDP socket
        if ($name eq "sys::udp_socket") {
            emit($cg, "strada_udp_socket()");
            return;
        }

        # udp_bind - bind UDP socket to a port
        if ($name eq "sys::udp_bind") {
            emit($cg, "strada_new_int(strada_udp_bind(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, ")))");
            return;
        }

        # udp_server - create UDP server bound to a port
        if ($name eq "sys::udp_server") {
            emit($cg, "strada_udp_server(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }

        # udp_recvfrom - receive UDP packet with sender info
        if ($name eq "sys::udp_recvfrom") {
            emit($cg, "strada_udp_recvfrom(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))");
            return;
        }

        # udp_sendto - send UDP packet to host:port
        if ($name eq "sys::udp_sendto") {
            emit($cg, "strada_new_int(strada_udp_sendto_sv(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", strada_to_str(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[3]);
            emit($cg, ")))");
            return;
        }

        # stacktrace - print stack trace to stderr (like Carp::cluck)
        if ($name eq "stacktrace") {
            emit($cg, "(strada_stacktrace(), strada_undef_static())");
            return;
        }

        # stacktrace_str - return stack trace as string (like Carp::longmess)
        if ($name eq "stacktrace_str") {
            emit($cg, "strada_new_str(strada_stacktrace_str())");
            return;
        }

        # caller - get caller info at given level
        if ($name eq "caller") {
            my scalar $args = $expr->{"args"};
            if ($expr->{"arg_count"} > 0) {
                emit($cg, "strada_new_str(strada_caller(strada_to_int(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")))");
            } else {
                emit($cg, "strada_new_str(strada_caller(1))");
            }
            return;
        }
        
        # trim - trim whitespace
        if ($name eq "trim") {
            my scalar $args = $expr->{"args"};
            my scalar $arg = $args->[0];
            emit($cg, "({ StradaValue *__tr_v = ");
            gen_expression($cg, $arg);
            emit($cg, "; char *__tr_s = strada_to_str(__tr_v); StradaValue *__tr_r = strada_new_str_take(strada_trim(__tr_s)); free(__tr_s); ");
            if (needs_temp_cleanup($cg, $arg) == 1) {
                emit($cg, "strada_decref(__tr_v); ");
            }
            emit($cg, "__tr_r; })");
            return;
        }

        # ltrim - trim left whitespace
        if ($name eq "ltrim") {
            my scalar $args = $expr->{"args"};
            my scalar $arg = $args->[0];
            emit($cg, "({ StradaValue *__lt_v = ");
            gen_expression($cg, $arg);
            emit($cg, "; char *__lt_s = strada_to_str(__lt_v); StradaValue *__lt_r = strada_new_str_take(strada_ltrim(__lt_s)); free(__lt_s); ");
            if (needs_temp_cleanup($cg, $arg) == 1) {
                emit($cg, "strada_decref(__lt_v); ");
            }
            emit($cg, "__lt_r; })");
            return;
        }

        # rtrim - trim right whitespace
        if ($name eq "rtrim") {
            my scalar $args = $expr->{"args"};
            my scalar $arg = $args->[0];
            emit($cg, "({ StradaValue *__rt_v = ");
            gen_expression($cg, $arg);
            emit($cg, "; char *__rt_s = strada_to_str(__rt_v); StradaValue *__rt_r = strada_new_str_take(strada_rtrim(__rt_s)); free(__rt_s); ");
            if (needs_temp_cleanup($cg, $arg) == 1) {
                emit($cg, "strada_decref(__rt_v); ");
            }
            emit($cg, "__rt_r; })");
            return;
        }
        
        # cstruct_new - create new C struct
        if ($name eq "sys::cstruct_new") {
            emit($cg, "strada_cstruct_new(\"struct\", ");
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_to_int(");
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        # cstruct_set_int - set int field in C struct
        if ($name eq "sys::cstruct_set_int") {
            my scalar $args = $expr->{"args"};
            my scalar $field_arg = $args->[1];
            emit($cg, "({ StradaValue *__csi_v = ");
            gen_expression($cg, $field_arg);
            emit($cg, "; char *__csi_s = strada_to_str(__csi_v); strada_cstruct_set_int(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", __csi_s, strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_int(");
            gen_expression($cg, $args->[3]);
            emit($cg, ")); free(__csi_s); ");
            if (needs_temp_cleanup($cg, $field_arg) == 1) {
                emit($cg, "strada_decref(__csi_v); ");
            }
            emit($cg, "(StradaValue*)NULL; })");
            return;
        }

        # cstruct_get_int - get int field from C struct
        if ($name eq "sys::cstruct_get_int") {
            my scalar $args = $expr->{"args"};
            my scalar $field_arg = $args->[1];
            emit($cg, "({ StradaValue *__cgi_v = ");
            gen_expression($cg, $field_arg);
            emit($cg, "; char *__cgi_s = strada_to_str(__cgi_v); int64_t __cgi_r = strada_cstruct_get_int(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", __cgi_s, strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")); free(__cgi_s); ");
            if (needs_temp_cleanup($cg, $field_arg) == 1) {
                emit($cg, "strada_decref(__cgi_v); ");
            }
            emit($cg, "strada_new_int(__cgi_r); })");
            return;
        }
        
        # reverse - reverse a string or array
        if ($name eq "reverse") {
            my scalar $args = $expr->{"args"};
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1) {
                emit($cg, "({ StradaValue *__rev_a = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; StradaValue *__rev_r = strada_reverse_sv(__rev_a); strada_decref(__rev_a); __rev_r; })");
            } else {
                emit($cg, "strada_reverse_sv(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")");
            }
            return;
        }
        
        # repeat - repeat a string
        if ($name eq "repeat") {
            my scalar $args = $expr->{"args"};
            my scalar $arg = $args->[0];
            emit($cg, "({ StradaValue *__rp_v = ");
            gen_expression($cg, $arg);
            emit($cg, "; char *__rp_s = strada_to_str(__rp_v); StradaValue *__rp_r = strada_new_str_take(strada_repeat(__rp_s, strada_to_int(");
            gen_expression($cg, $args->[1]);
            emit($cg, "))); free(__rp_s); ");
            if (needs_temp_cleanup($cg, $arg) == 1) {
                emit($cg, "strada_decref(__rp_v); ");
            }
            emit($cg, "__rp_r; })");
            return;
        }
        
        # replace_all - replace all occurrences
        if ($name eq "replace_all") {
            my scalar $args = $expr->{"args"};
            my int $a0_temp = 0;
            my int $a1_temp = 0;
            my int $a2_temp = 0;
            if ($cg->{"cleanup_enabled"} == 1) {
                $a0_temp = needs_temp_cleanup($cg, $args->[0]);
                $a1_temp = needs_temp_cleanup($cg, $args->[1]);
                $a2_temp = needs_temp_cleanup($cg, $args->[2]);
            }
            emit($cg, "({ ");
            if ($a0_temp == 1) {
                emit($cg, "StradaValue *__ra_a0 = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; char *__ra_s = strada_to_str(__ra_a0); ");
            } else {
                emit($cg, "char *__ra_s = strada_to_str(");
                gen_expression($cg, $args->[0]);
                emit($cg, "); ");
            }
            if ($a1_temp == 1) {
                emit($cg, "StradaValue *__ra_a1 = ");
                gen_expression($cg, $args->[1]);
                emit($cg, "; char *__ra_f = strada_to_str(__ra_a1); ");
            } else {
                emit($cg, "char *__ra_f = strada_to_str(");
                gen_expression($cg, $args->[1]);
                emit($cg, "); ");
            }
            if ($a2_temp == 1) {
                emit($cg, "StradaValue *__ra_a2 = ");
                gen_expression($cg, $args->[2]);
                emit($cg, "; char *__ra_r = strada_to_str(__ra_a2); ");
            } else {
                emit($cg, "char *__ra_r = strada_to_str(");
                gen_expression($cg, $args->[2]);
                emit($cg, "); ");
            }
            emit($cg, "char *__ra_res = strada_replace_all(__ra_s, __ra_f, __ra_r); StradaValue *__ra_sv = strada_new_str(__ra_res); free(__ra_res); free(__ra_r); free(__ra_f); free(__ra_s); ");
            if ($a0_temp == 1) { emit($cg, "strada_decref(__ra_a0); "); }
            if ($a1_temp == 1) { emit($cg, "strada_decref(__ra_a1); "); }
            if ($a2_temp == 1) { emit($cg, "strada_decref(__ra_a2); "); }
            emit($cg, "__ra_sv; })");
            return;
        }
        
        # chomp - remove trailing newline
        if ($name eq "chomp") {
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];
            my int $needs_cleanup = needs_temp_cleanup($cg, $arg0);
            emit($cg, "(({ StradaValue *__chomp_tmp = ");
            gen_expression($cg, $arg0);
            emit($cg, "; char *__chomp_in = strada_to_str(__chomp_tmp); ");
            emit($cg, "char *__chomp_out = strada_chomp(__chomp_in); ");
            emit($cg, "StradaValue *__chomp_res = strada_new_str(__chomp_out); ");
            emit($cg, "free(__chomp_in); free(__chomp_out); ");
            if ($needs_cleanup == 1) {
                emit($cg, "strada_decref(__chomp_tmp); ");
            }
            emit($cg, "__chomp_res; }))");
            return;
        }

        # chop - remove last character
        if ($name eq "chop") {
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];
            my int $needs_cleanup = needs_temp_cleanup($cg, $arg0);
            emit($cg, "(({ StradaValue *__chop_tmp = ");
            gen_expression($cg, $arg0);
            emit($cg, "; char *__chop_in = strada_to_str(__chop_tmp); ");
            emit($cg, "char *__chop_out = strada_chop(__chop_in); ");
            emit($cg, "StradaValue *__chop_res = strada_new_str(__chop_out); ");
            emit($cg, "free(__chop_in); free(__chop_out); ");
            if ($needs_cleanup == 1) {
                emit($cg, "strada_decref(__chop_tmp); ");
            }
            emit($cg, "__chop_res; }))");
            return;
        }
        
        # cstruct_set_string - set string field in C struct
        if ($name eq "sys::cstruct_set_string") {
            my scalar $args = $expr->{"args"};
            my scalar $field_arg = $args->[1];
            my scalar $val_arg = $args->[3];
            emit($cg, "({ StradaValue *__css_fv = ");
            gen_expression($cg, $field_arg);
            emit($cg, "; StradaValue *__css_vv = ");
            gen_expression($cg, $val_arg);
            emit($cg, "; char *__css_fs = strada_to_str(__css_fv); char *__css_vs = strada_to_str(__css_vv); strada_cstruct_set_string(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", __css_fs, strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), __css_vs); free(__css_fs); free(__css_vs); ");
            if (needs_temp_cleanup($cg, $field_arg) == 1) {
                emit($cg, "strada_decref(__css_fv); ");
            }
            if (needs_temp_cleanup($cg, $val_arg) == 1) {
                emit($cg, "strada_decref(__css_vv); ");
            }
            emit($cg, "(StradaValue*)NULL; })");
            return;
        }

        # cstruct_set_double - set double field in C struct
        if ($name eq "sys::cstruct_set_double") {
            my scalar $args = $expr->{"args"};
            my scalar $field_arg = $args->[1];
            emit($cg, "({ StradaValue *__csd_v = ");
            gen_expression($cg, $field_arg);
            emit($cg, "; char *__csd_s = strada_to_str(__csd_v); strada_cstruct_set_double(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", __csd_s, strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, "), strada_to_num(");
            gen_expression($cg, $args->[3]);
            emit($cg, ")); free(__csd_s); ");
            if (needs_temp_cleanup($cg, $field_arg) == 1) {
                emit($cg, "strada_decref(__csd_v); ");
            }
            emit($cg, "(StradaValue*)NULL; })");
            return;
        }
        
        # cast_int - cast value to int
        if ($name eq "cast_int") {
            emit($cg, "strada_new_int(strada_to_int(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        # cast_num - cast value to num
        if ($name eq "cast_num") {
            emit($cg, "strada_new_num(strada_to_num(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, "))");
            return;
        }
        
        # cast_str - cast value to str
        if ($name eq "cast_str") {
            my scalar $args = $expr->{"args"};
            my scalar $arg = $args->[0];
            emit($cg, "({ StradaValue *__cs_v = ");
            gen_expression($cg, $arg);
            emit($cg, "; StradaValue *__cs_r = strada_new_str_take(strada_to_str(__cs_v)); ");
            if (needs_temp_cleanup($cg, $arg) == 1) {
                emit($cg, "strada_decref(__cs_v); ");
            }
            emit($cg, "__cs_r; })");
            return;
        }
        
        # cstruct_get_string - get string field from C struct
        if ($name eq "sys::cstruct_get_string") {
            my scalar $args = $expr->{"args"};
            my scalar $field_arg = $args->[1];
            emit($cg, "({ StradaValue *__cgs_v = ");
            gen_expression($cg, $field_arg);
            emit($cg, "; char *__cgs_s = strada_to_str(__cgs_v); const char *__cgs_r = strada_cstruct_get_string(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", __cgs_s, strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")); free(__cgs_s); ");
            if (needs_temp_cleanup($cg, $field_arg) == 1) {
                emit($cg, "strada_decref(__cgs_v); ");
            }
            emit($cg, "strada_new_str(__cgs_r); })");
            return;
        }

        # cstruct_get_double - get double field from C struct
        if ($name eq "sys::cstruct_get_double") {
            my scalar $args = $expr->{"args"};
            my scalar $field_arg = $args->[1];
            emit($cg, "({ StradaValue *__cgd_v = ");
            gen_expression($cg, $field_arg);
            emit($cg, "; char *__cgd_s = strada_to_str(__cgd_v); double __cgd_r = strada_cstruct_get_double(");
            gen_expression($cg, $args->[0]);
            emit($cg, ", __cgd_s, strada_to_int(");
            gen_expression($cg, $args->[2]);
            emit($cg, ")); free(__cgd_s); ");
            if (needs_temp_cleanup($cg, $field_arg) == 1) {
                emit($cg, "strada_decref(__cgd_v); ");
            }
            emit($cg, "strada_new_num(__cgd_r); })");
            return;
        }
        
        # cstruct_ptr - get raw pointer from C struct
        if ($name eq "sys::cstruct_ptr") {
            my scalar $args = $expr->{"args"};
            emit($cg, "strada_cstruct_ptr(");
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # OOP - bless($ref, "Package") - bless a reference into a package
        if ($name eq "bless") {
            my scalar $args = $expr->{"args"};
            my scalar $pkg_arg = $args->[1];
            if ($pkg_arg->{"type"} == NODE_STR_LITERAL()) {
                # String literal - emit directly (no allocation)
                emit($cg, "strada_bless(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", ");
                gen_str_literal_c($cg, $pkg_arg->{"value"});
                emit($cg, ")");
            } else {
                # Expression - need to convert and free after bless
                emit($cg, "({ StradaValue *__bless_tmp = ");
                gen_expression($cg, $pkg_arg);
                emit($cg, "; char *__bless_ps = strada_to_str(__bless_tmp); ");
                if (needs_temp_cleanup($cg, $pkg_arg) == 1) {
                    emit($cg, "strada_decref(__bless_tmp); ");
                }
                emit($cg, "StradaValue *__bless_r = strada_bless(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", __bless_ps); free(__bless_ps); __bless_r; })");
            }
            return;
        }

        # OOP - blessed($ref) - get package name or undef
        if ($name eq "blessed") {
            my scalar $args = $expr->{"args"};
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $args->[0]) == 1) {
                emit($cg, "({ StradaValue *__bld_v = ");
                gen_expression($cg, $args->[0]);
                emit($cg, "; StradaValue *__bld_r = strada_blessed(__bld_v); strada_decref(__bld_v); __bld_r; })");
            } else {
                emit($cg, "strada_blessed(");
                gen_expression($cg, $args->[0]);
                emit($cg, ")");
            }
            return;
        }

        # OOP - set_package("Name") - set current package context
        if ($name eq "set_package") {
            my scalar $args = $expr->{"args"};
            my scalar $pkg_arg = $args->[0];
            if ($pkg_arg->{"type"} == NODE_STR_LITERAL()) {
                emit($cg, "strada_set_package(");
                gen_str_literal_c($cg, $pkg_arg->{"value"});
                emit($cg, ")");
            } else {
                emit($cg, "({ StradaValue *__setpkg_t = ");
                gen_expression($cg, $pkg_arg);
                emit($cg, "; char *__setpkg_s = strada_to_str(__setpkg_t); ");
                if (needs_temp_cleanup($cg, $pkg_arg) == 1) {
                    emit($cg, "strada_decref(__setpkg_t); ");
                }
                emit($cg, "strada_set_package(__setpkg_s); free(__setpkg_s); })");
            }
            return;
        }

        # OOP - inherit("Parent") or inherit("Child", "Parent") - set up inheritance
        if ($name eq "inherit") {
            my scalar $args = $expr->{"args"};
            my int $arg_count = $expr->{"arg_count"};
            if ($arg_count == 1) {
                # Single arg: inherit from parent using current package
                my scalar $parent_arg = $args->[0];
                if ($parent_arg->{"type"} == NODE_STR_LITERAL()) {
                    # String literal - emit directly
                    emit($cg, "strada_inherit_from(");
                    gen_str_literal_c($cg, $parent_arg->{"value"});
                    emit($cg, ")");
                } else {
                    # Expression - need to free temp
                    emit($cg, "({ StradaValue *__inh_p = ");
                    gen_expression($cg, $parent_arg);
                    emit($cg, "; char *__inh_ps = strada_to_str(__inh_p); ");
                    emit($cg, "strada_inherit_from(__inh_ps); ");
                    emit($cg, "free(__inh_ps); ");
                    if (needs_temp_cleanup($cg, $parent_arg) == 1) {
                        emit($cg, "strada_decref(__inh_p); ");
                    }
                    emit($cg, "})");
                }
            } else {
                # Two args: inherit(child, parent)
                my scalar $child_arg = $args->[0];
                my scalar $parent_arg = $args->[1];
                my int $child_is_lit = $child_arg->{"type"} == NODE_STR_LITERAL();
                my int $parent_is_lit = $parent_arg->{"type"} == NODE_STR_LITERAL();

                if ($child_is_lit == 1 && $parent_is_lit == 1) {
                    # Both literals - emit directly
                    emit($cg, "strada_inherit(");
                    gen_str_literal_c($cg, $child_arg->{"value"});
                    emit($cg, ", ");
                    gen_str_literal_c($cg, $parent_arg->{"value"});
                    emit($cg, ")");
                } else {
                    # At least one expression - wrap for cleanup
                    emit($cg, "({ StradaValue *__inh_c = ");
                    gen_expression($cg, $child_arg);
                    emit($cg, "; StradaValue *__inh_p = ");
                    gen_expression($cg, $parent_arg);
                    emit($cg, "; char *__inh_cs = strada_to_str(__inh_c); ");
                    emit($cg, "char *__inh_ps = strada_to_str(__inh_p); ");
                    emit($cg, "strada_inherit(__inh_cs, __inh_ps); ");
                    emit($cg, "free(__inh_cs); free(__inh_ps); ");
                    if (needs_temp_cleanup($cg, $child_arg) == 1) {
                        emit($cg, "strada_decref(__inh_c); ");
                    }
                    if (needs_temp_cleanup($cg, $parent_arg) == 1) {
                        emit($cg, "strada_decref(__inh_p); ");
                    }
                    emit($cg, "})");
                }
            }
            return;
        }

        # OOP - isa($obj, "Package") - check if object is of a type
        if ($name eq "isa") {
            my scalar $args = $expr->{"args"};
            my scalar $pkg_arg = $args->[1];
            if ($pkg_arg->{"type"} == NODE_STR_LITERAL()) {
                emit($cg, "strada_new_int(strada_isa(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", ");
                gen_str_literal_c($cg, $pkg_arg->{"value"});
                emit($cg, "))");
            } else {
                emit($cg, "({ StradaValue *__isa_t = ");
                gen_expression($cg, $pkg_arg);
                emit($cg, "; char *__isa_s = strada_to_str(__isa_t); ");
                if (needs_temp_cleanup($cg, $pkg_arg) == 1) {
                    emit($cg, "strada_decref(__isa_t); ");
                }
                emit($cg, "int __isa_r = strada_isa(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", __isa_s); free(__isa_s); strada_new_int(__isa_r); })");
            }
            return;
        }

        # OOP - can($obj, "method") - check if object can do a method
        if ($name eq "can") {
            my scalar $args = $expr->{"args"};
            my scalar $meth_arg = $args->[1];
            if ($meth_arg->{"type"} == NODE_STR_LITERAL()) {
                emit($cg, "strada_new_int(strada_can(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", ");
                gen_str_literal_c($cg, $meth_arg->{"value"});
                emit($cg, "))");
            } else {
                emit($cg, "({ StradaValue *__can_t = ");
                gen_expression($cg, $meth_arg);
                emit($cg, "; char *__can_s = strada_to_str(__can_t); ");
                if (needs_temp_cleanup($cg, $meth_arg) == 1) {
                    emit($cg, "strada_decref(__can_t); ");
                }
                emit($cg, "int __can_r = strada_can(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", __can_s); free(__can_s); strada_new_int(__can_r); })");
            }
            return;
        }

        # OOP - UNIVERSAL::isa($obj, "Package") - Perl-style type check
        if ($name eq "UNIVERSAL::isa") {
            my scalar $args = $expr->{"args"};
            my scalar $pkg_arg = $args->[1];
            if ($pkg_arg->{"type"} == NODE_STR_LITERAL()) {
                emit($cg, "strada_new_int(strada_isa(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", ");
                gen_str_literal_c($cg, $pkg_arg->{"value"});
                emit($cg, "))");
            } else {
                emit($cg, "({ StradaValue *__isa_t = ");
                gen_expression($cg, $pkg_arg);
                emit($cg, "; char *__isa_s = strada_to_str(__isa_t); ");
                if (needs_temp_cleanup($cg, $pkg_arg) == 1) {
                    emit($cg, "strada_decref(__isa_t); ");
                }
                emit($cg, "int __isa_r = strada_isa(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", __isa_s); free(__isa_s); strada_new_int(__isa_r); })");
            }
            return;
        }

        # OOP - UNIVERSAL::can($obj, "method") - Perl-style method check
        if ($name eq "UNIVERSAL::can") {
            my scalar $args = $expr->{"args"};
            my scalar $meth_arg = $args->[1];
            if ($meth_arg->{"type"} == NODE_STR_LITERAL()) {
                emit($cg, "strada_new_int(strada_can(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", ");
                gen_str_literal_c($cg, $meth_arg->{"value"});
                emit($cg, "))");
            } else {
                emit($cg, "({ StradaValue *__can_t = ");
                gen_expression($cg, $meth_arg);
                emit($cg, "; char *__can_s = strada_to_str(__can_t); ");
                if (needs_temp_cleanup($cg, $meth_arg) == 1) {
                    emit($cg, "strada_decref(__can_t); ");
                }
                emit($cg, "int __can_r = strada_can(");
                gen_expression($cg, $args->[0]);
                emit($cg, ", __can_s); free(__can_s); strada_new_int(__can_r); })");
            }
            return;
        }

        # ============================================================
        # NEW LIBC FUNCTIONS
        # ============================================================

        # Additional File I/O
        if ($name eq "sys::fgetc") {
            emit($cg, "strada_fgetc(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fputc") {
            emit($cg, "strada_fputc(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fgets") {
            emit($cg, "strada_fgets(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fputs") {
            emit($cg, "strada_fputs(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ferror") {
            emit($cg, "strada_ferror(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fileno") {
            emit($cg, "strada_fileno(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::clearerr") {
            emit($cg, "strada_clearerr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Temporary files
        if ($name eq "sys::tmpfile") {
            emit($cg, "strada_tmpfile()");
            return;
        }

        if ($name eq "sys::mkstemp") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_mkstemp", $args, 1);
            return;
        }

        if ($name eq "sys::mkdtemp") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_mkdtemp", $args, 1);
            return;
        }

        # Command execution (popen)
        if ($name eq "sys::popen") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_popen", $args, 2);
            return;
        }

        if ($name eq "sys::pclose") {
            emit($cg, "strada_pclose(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Command execution with output capture (backticks/qx)
        if ($name eq "sys::qx") {
            my scalar $args = $expr->{"args"};
            emit($cg, "({ StradaValue *__qx_v = ");
            gen_expression($cg, $args->[0]);
            emit($cg, "; StradaValue *__qx_r = strada_qx(__qx_v); ");
            if (needs_temp_cleanup($cg, $args->[0]) == 1) {
                emit($cg, "strada_decref(__qx_v); ");
            }
            emit($cg, "__qx_r; })");
            return;
        }

        # Additional file system
        if ($name eq "sys::truncate") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_truncate", $args, 2);
            return;
        }

        if ($name eq "sys::ftruncate") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_ftruncate", $args, 2);
            return;
        }

        if ($name eq "sys::chown") {
            emit($cg, "strada_chown(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::lchown") {
            emit($cg, "strada_lchown(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fchmod") {
            emit($cg, "strada_fchmod(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::fchown") {
            emit($cg, "strada_fchown(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::utime") {
            emit($cg, "strada_utime(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::utimes") {
            emit($cg, "strada_utimes(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        # Session/process group control
        if ($name eq "sys::setsid") {
            emit($cg, "strada_setsid()");
            return;
        }

        if ($name eq "sys::getsid") {
            emit($cg, "strada_getsid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setpgid") {
            emit($cg, "strada_setpgid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getpgid") {
            emit($cg, "strada_getpgid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getpgrp") {
            emit($cg, "strada_getpgrp()");
            return;
        }

        if ($name eq "sys::setpgrp") {
            emit($cg, "strada_setpgrp()");
            return;
        }

        # User/group ID control
        if ($name eq "sys::setuid") {
            emit($cg, "strada_setuid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setgid") {
            emit($cg, "strada_setgid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::seteuid") {
            emit($cg, "strada_seteuid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setegid") {
            emit($cg, "strada_setegid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setreuid") {
            emit($cg, "strada_setreuid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setregid") {
            emit($cg, "strada_setregid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # Additional socket operations
        if ($name eq "sys::setsockopt") {
            emit($cg, "strada_setsockopt(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ", ");
            gen_expression($cg, $args->[3]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getsockopt") {
            emit($cg, "strada_getsockopt(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::shutdown") {
            emit($cg, "strada_shutdown(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getpeername") {
            emit($cg, "strada_getpeername(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getsockname") {
            emit($cg, "strada_getsockname(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::inet_pton") {
            emit($cg, "strada_inet_pton(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::inet_ntop") {
            emit($cg, "strada_inet_ntop(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::inet_addr") {
            emit($cg, "strada_inet_addr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::inet_ntoa") {
            emit($cg, "strada_inet_ntoa(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::htons") {
            emit($cg, "strada_htons(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::htonl") {
            emit($cg, "strada_htonl(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ntohs") {
            emit($cg, "strada_ntohs(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::ntohl") {
            emit($cg, "strada_ntohl(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::poll") {
            emit($cg, "strada_poll(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # Random seeding
        if ($name eq "sys::srand") {
            emit($cg, "strada_srand(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::srandom") {
            emit($cg, "strada_srandom(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::rand") {
            emit($cg, "strada_libc_rand()");
            return;
        }

        if ($name eq "sys::random") {
            emit($cg, "strada_libc_random()");
            return;
        }

        # Cryptographic random bytes from /dev/urandom
        if ($name eq "sys::random_bytes") {
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $arg0) == 1) {
                emit($cg, "({ StradaValue *__arg_tmp = ");
                gen_expression($cg, $arg0);
                emit($cg, "; StradaValue *__res = strada_random_bytes(__arg_tmp); strada_decref(__arg_tmp); __res; })");
            } else {
                emit($cg, "strada_random_bytes(");
                gen_expression($cg, $arg0);
                emit($cg, ")");
            }
            return;
        }

        if ($name eq "sys::random_bytes_hex") {
            my scalar $args = $expr->{"args"};
            my scalar $arg0 = $args->[0];
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $arg0) == 1) {
                emit($cg, "({ StradaValue *__arg_tmp = ");
                gen_expression($cg, $arg0);
                emit($cg, "; StradaValue *__res = strada_random_bytes_hex(__arg_tmp); strada_decref(__arg_tmp); __res; })");
            } else {
                emit($cg, "strada_random_bytes_hex(");
                gen_expression($cg, $arg0);
                emit($cg, ")");
            }
            return;
        }

        # Advanced signals
        if ($name eq "sys::sigprocmask") {
            emit($cg, "strada_sigprocmask(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::raise") {
            emit($cg, "strada_raise(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::killpg") {
            emit($cg, "strada_killpg(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::pause") {
            emit($cg, "strada_pause()");
            return;
        }

        # User/Group database
        if ($name eq "sys::getpwnam") {
            emit($cg, "strada_getpwnam(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getpwuid") {
            emit($cg, "strada_getpwuid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getgrnam") {
            emit($cg, "strada_getgrnam(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getgrgid") {
            emit($cg, "strada_getgrgid(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getlogin") {
            emit($cg, "strada_getlogin()");
            return;
        }

        if ($name eq "sys::getgroups") {
            emit($cg, "strada_getgroups()");
            return;
        }

        # Resource/Priority
        if ($name eq "sys::nice") {
            emit($cg, "strada_nice(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getpriority") {
            emit($cg, "strada_getpriority(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setpriority") {
            emit($cg, "strada_setpriority(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getrusage") {
            emit($cg, "strada_getrusage(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::getrlimit") {
            emit($cg, "strada_getrlimit(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::setrlimit") {
            emit($cg, "strada_setrlimit(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # Additional time functions
        if ($name eq "sys::difftime") {
            emit($cg, "strada_difftime(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::clock") {
            emit($cg, "strada_clock()");
            return;
        }

        if ($name eq "sys::times") {
            emit($cg, "strada_times()");
            return;
        }

        # Additional memory functions
        if ($name eq "sys::calloc") {
            emit($cg, "strada_calloc(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::realloc") {
            emit($cg, "strada_realloc(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::mmap") {
            emit($cg, "strada_mmap(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ", ");
            gen_expression($cg, $args->[3]);
            emit($cg, ", ");
            gen_expression($cg, $args->[4]);
            emit($cg, ", ");
            gen_expression($cg, $args->[5]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::munmap") {
            emit($cg, "strada_munmap(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::mlock") {
            emit($cg, "strada_mlock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::munlock") {
            emit($cg, "strada_munlock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # String conversion
        if ($name eq "sys::strtol") {
            emit($cg, "strada_strtol(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::strtod") {
            emit($cg, "strada_strtod(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::atoi") {
            emit($cg, "strada_atoi(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::atof") {
            emit($cg, "strada_atof(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Terminal/TTY
        if ($name eq "sys::ttyname") {
            emit($cg, "strada_ttyname(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::tcgetattr") {
            emit($cg, "strada_tcgetattr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::tcsetattr") {
            emit($cg, "strada_tcsetattr(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            gen_expression($cg, $args->[2]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::cfgetospeed") {
            emit($cg, "strada_cfgetospeed(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::cfsetospeed") {
            emit($cg, "strada_cfsetospeed(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::cfgetispeed") {
            emit($cg, "strada_cfgetispeed(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::cfsetispeed") {
            emit($cg, "strada_cfsetispeed(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # serial_open - high-level serial port open
        if ($name eq "sys::serial_open") {
            my scalar $args = $expr->{"args"};
            my scalar $dev_arg = $args->[0];
            emit($cg, "({ StradaValue *__so_v0 = ");
            gen_expression($cg, $dev_arg);
            emit($cg, "; char *__so_s0 = strada_to_str(__so_v0); ");
            if ($expr->{"arg_count"} > 2) {
                my scalar $opt_arg = $args->[2];
                emit($cg, "StradaValue *__so_v2 = ");
                gen_expression($cg, $opt_arg);
                emit($cg, "; char *__so_s2 = strada_to_str(__so_v2); ");
                emit($cg, "StradaValue *__so_r = strada_serial_open(__so_s0, strada_to_int(");
                gen_expression($cg, $args->[1]);
                emit($cg, "), __so_s2); free(__so_s0); free(__so_s2); ");
                if (needs_temp_cleanup($cg, $dev_arg) == 1) {
                    emit($cg, "strada_decref(__so_v0); ");
                }
                if (needs_temp_cleanup($cg, $opt_arg) == 1) {
                    emit($cg, "strada_decref(__so_v2); ");
                }
            } else {
                emit($cg, "StradaValue *__so_r = strada_serial_open(__so_s0, strada_to_int(");
                gen_expression($cg, $args->[1]);
                emit($cg, "), NULL); free(__so_s0); ");
                if (needs_temp_cleanup($cg, $dev_arg) == 1) {
                    emit($cg, "strada_decref(__so_v0); ");
                }
            }
            emit($cg, "__so_r; })");
            return;
        }

        # tcflush - flush input/output queues
        if ($name eq "sys::tcflush") {
            emit($cg, "strada_tcflush(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        # tcdrain - wait for output to be transmitted
        if ($name eq "sys::tcdrain") {
            emit($cg, "strada_tcdrain(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ")");
            return;
        }

        # Baud rate constants
        if ($name eq "sys::B0") { emit($cg, "strada_new_int(B0)"); return; }
        if ($name eq "sys::B50") { emit($cg, "strada_new_int(B50)"); return; }
        if ($name eq "sys::B75") { emit($cg, "strada_new_int(B75)"); return; }
        if ($name eq "sys::B110") { emit($cg, "strada_new_int(B110)"); return; }
        if ($name eq "sys::B134") { emit($cg, "strada_new_int(B134)"); return; }
        if ($name eq "sys::B150") { emit($cg, "strada_new_int(B150)"); return; }
        if ($name eq "sys::B200") { emit($cg, "strada_new_int(B200)"); return; }
        if ($name eq "sys::B300") { emit($cg, "strada_new_int(B300)"); return; }
        if ($name eq "sys::B600") { emit($cg, "strada_new_int(B600)"); return; }
        if ($name eq "sys::B1200") { emit($cg, "strada_new_int(B1200)"); return; }
        if ($name eq "sys::B1800") { emit($cg, "strada_new_int(B1800)"); return; }
        if ($name eq "sys::B2400") { emit($cg, "strada_new_int(B2400)"); return; }
        if ($name eq "sys::B4800") { emit($cg, "strada_new_int(B4800)"); return; }
        if ($name eq "sys::B9600") { emit($cg, "strada_new_int(B9600)"); return; }
        if ($name eq "sys::B19200") { emit($cg, "strada_new_int(B19200)"); return; }
        if ($name eq "sys::B38400") { emit($cg, "strada_new_int(B38400)"); return; }
        if ($name eq "sys::B57600") { emit($cg, "strada_new_int(B57600)"); return; }
        if ($name eq "sys::B115200") { emit($cg, "strada_new_int(B115200)"); return; }
        if ($name eq "sys::B230400") { emit($cg, "strada_new_int(B230400)"); return; }
        if ($name eq "sys::B460800") { emit($cg, "strada_new_int(B460800)"); return; }
        if ($name eq "sys::B500000") { emit($cg, "strada_new_int(B500000)"); return; }
        if ($name eq "sys::B576000") { emit($cg, "strada_new_int(B576000)"); return; }
        if ($name eq "sys::B921600") { emit($cg, "strada_new_int(B921600)"); return; }
        if ($name eq "sys::B1000000") { emit($cg, "strada_new_int(B1000000)"); return; }
        if ($name eq "sys::B1152000") { emit($cg, "strada_new_int(B1152000)"); return; }
        if ($name eq "sys::B1500000") { emit($cg, "strada_new_int(B1500000)"); return; }
        if ($name eq "sys::B2000000") { emit($cg, "strada_new_int(B2000000)"); return; }

        # Termios control mode flags (c_cflag)
        if ($name eq "sys::CSIZE") { emit($cg, "strada_new_int(CSIZE)"); return; }
        if ($name eq "sys::CS5") { emit($cg, "strada_new_int(CS5)"); return; }
        if ($name eq "sys::CS6") { emit($cg, "strada_new_int(CS6)"); return; }
        if ($name eq "sys::CS7") { emit($cg, "strada_new_int(CS7)"); return; }
        if ($name eq "sys::CS8") { emit($cg, "strada_new_int(CS8)"); return; }
        if ($name eq "sys::CSTOPB") { emit($cg, "strada_new_int(CSTOPB)"); return; }
        if ($name eq "sys::CREAD") { emit($cg, "strada_new_int(CREAD)"); return; }
        if ($name eq "sys::PARENB") { emit($cg, "strada_new_int(PARENB)"); return; }
        if ($name eq "sys::PARODD") { emit($cg, "strada_new_int(PARODD)"); return; }
        if ($name eq "sys::HUPCL") { emit($cg, "strada_new_int(HUPCL)"); return; }
        if ($name eq "sys::CLOCAL") { emit($cg, "strada_new_int(CLOCAL)"); return; }
        if ($name eq "sys::CRTSCTS") { emit($cg, "strada_new_int(CRTSCTS)"); return; }

        # Termios input mode flags (c_iflag)
        if ($name eq "sys::IGNBRK") { emit($cg, "strada_new_int(IGNBRK)"); return; }
        if ($name eq "sys::BRKINT") { emit($cg, "strada_new_int(BRKINT)"); return; }
        if ($name eq "sys::IGNPAR") { emit($cg, "strada_new_int(IGNPAR)"); return; }
        if ($name eq "sys::PARMRK") { emit($cg, "strada_new_int(PARMRK)"); return; }
        if ($name eq "sys::INPCK") { emit($cg, "strada_new_int(INPCK)"); return; }
        if ($name eq "sys::ISTRIP") { emit($cg, "strada_new_int(ISTRIP)"); return; }
        if ($name eq "sys::INLCR") { emit($cg, "strada_new_int(INLCR)"); return; }
        if ($name eq "sys::IGNCR") { emit($cg, "strada_new_int(IGNCR)"); return; }
        if ($name eq "sys::ICRNL") { emit($cg, "strada_new_int(ICRNL)"); return; }
        if ($name eq "sys::IXON") { emit($cg, "strada_new_int(IXON)"); return; }
        if ($name eq "sys::IXOFF") { emit($cg, "strada_new_int(IXOFF)"); return; }
        if ($name eq "sys::IXANY") { emit($cg, "strada_new_int(IXANY)"); return; }

        # Termios output mode flags (c_oflag)
        if ($name eq "sys::OPOST") { emit($cg, "strada_new_int(OPOST)"); return; }
        if ($name eq "sys::ONLCR") { emit($cg, "strada_new_int(ONLCR)"); return; }
        if ($name eq "sys::OCRNL") { emit($cg, "strada_new_int(OCRNL)"); return; }

        # Termios local mode flags (c_lflag)
        if ($name eq "sys::ISIG") { emit($cg, "strada_new_int(ISIG)"); return; }
        if ($name eq "sys::ICANON") { emit($cg, "strada_new_int(ICANON)"); return; }
        if ($name eq "sys::ECHO") { emit($cg, "strada_new_int(ECHO)"); return; }
        if ($name eq "sys::ECHOE") { emit($cg, "strada_new_int(ECHOE)"); return; }
        if ($name eq "sys::ECHOK") { emit($cg, "strada_new_int(ECHOK)"); return; }
        if ($name eq "sys::ECHONL") { emit($cg, "strada_new_int(ECHONL)"); return; }
        if ($name eq "sys::NOFLSH") { emit($cg, "strada_new_int(NOFLSH)"); return; }
        if ($name eq "sys::TOSTOP") { emit($cg, "strada_new_int(TOSTOP)"); return; }
        if ($name eq "sys::IEXTEN") { emit($cg, "strada_new_int(IEXTEN)"); return; }

        # tcsetattr when values
        if ($name eq "sys::TCSANOW") { emit($cg, "strada_new_int(TCSANOW)"); return; }
        if ($name eq "sys::TCSADRAIN") { emit($cg, "strada_new_int(TCSADRAIN)"); return; }
        if ($name eq "sys::TCSAFLUSH") { emit($cg, "strada_new_int(TCSAFLUSH)"); return; }

        # tcflush queue selectors
        if ($name eq "sys::TCIFLUSH") { emit($cg, "strada_new_int(TCIFLUSH)"); return; }
        if ($name eq "sys::TCOFLUSH") { emit($cg, "strada_new_int(TCOFLUSH)"); return; }
        if ($name eq "sys::TCIOFLUSH") { emit($cg, "strada_new_int(TCIOFLUSH)"); return; }

        # File open flags (for low-level open)
        if ($name eq "sys::O_RDONLY") { emit($cg, "strada_new_int(O_RDONLY)"); return; }
        if ($name eq "sys::O_WRONLY") { emit($cg, "strada_new_int(O_WRONLY)"); return; }
        if ($name eq "sys::O_RDWR") { emit($cg, "strada_new_int(O_RDWR)"); return; }
        if ($name eq "sys::O_CREAT") { emit($cg, "strada_new_int(O_CREAT)"); return; }
        if ($name eq "sys::O_EXCL") { emit($cg, "strada_new_int(O_EXCL)"); return; }
        if ($name eq "sys::O_NOCTTY") { emit($cg, "strada_new_int(O_NOCTTY)"); return; }
        if ($name eq "sys::O_TRUNC") { emit($cg, "strada_new_int(O_TRUNC)"); return; }
        if ($name eq "sys::O_APPEND") { emit($cg, "strada_new_int(O_APPEND)"); return; }
        if ($name eq "sys::O_NONBLOCK") { emit($cg, "strada_new_int(O_NONBLOCK)"); return; }
        if ($name eq "sys::O_SYNC") { emit($cg, "strada_new_int(O_SYNC)"); return; }

        # Advanced file operations
        if ($name eq "sys::fcntl") {
            emit($cg, "strada_fcntl(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            if ($expr->{"arg_count"} > 2) {
                gen_expression($cg, $args->[2]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::flock") {
            emit($cg, "strada_flock(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::quotemeta") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_quotemeta", $args, 1);
            return;
        }

        if ($name eq "sys::ioctl") {
            emit($cg, "strada_ioctl(");
            my scalar $args = $expr->{"args"};
            gen_expression($cg, $args->[0]);
            emit($cg, ", ");
            gen_expression($cg, $args->[1]);
            emit($cg, ", ");
            if ($expr->{"arg_count"} > 2) {
                gen_expression($cg, $args->[2]);
            } else {
                emit($cg, "NULL");
            }
            emit($cg, ")");
            return;
        }

        if ($name eq "sys::statvfs") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_statvfs", $args, 1);
            return;
        }

        if ($name eq "sys::fstatvfs") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_fstatvfs", $args, 1);
            return;
        }

        if ($name eq "sys::dup") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_dup", $args, 1);
            return;
        }

        # Additional math functions
        if ($name eq "math::hypot") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_hypot", $args, 2);
            return;
        }

        if ($name eq "math::cbrt") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_cbrt", $args, 1);
            return;
        }

        if ($name eq "math::isnan") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_isnan", $args, 1);
            return;
        }

        if ($name eq "math::isinf") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_isinf", $args, 1);
            return;
        }

        if ($name eq "math::isfinite") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_isfinite", $args, 1);
            return;
        }

        if ($name eq "math::fmax") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_fmax", $args, 2);
            return;
        }

        if ($name eq "math::fmin") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_fmin", $args, 2);
            return;
        }

        if ($name eq "math::copysign") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_copysign", $args, 2);
            return;
        }

        if ($name eq "math::remainder") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_remainder", $args, 2);
            return;
        }

        if ($name eq "math::trunc") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_trunc", $args, 1);
            return;
        }

        if ($name eq "math::ldexp") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_ldexp", $args, 2);
            return;
        }

        if ($name eq "math::frexp") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_frexp", $args, 1);
            return;
        }

        if ($name eq "math::modf") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_modf", $args, 1);
            return;
        }

        if ($name eq "math::scalbn") {
            my scalar $args = $expr->{"args"};
            gen_call_with_arg_cleanup($cg, "strada_scalbn", $args, 2);
            return;
        }

        # User-defined function - check for default parameters
        my str $c_name = sanitize_name($name);
        my scalar $func_info = $cg->{"functions"}->{$c_name};
        my scalar $args = $expr->{"args"};
        my int $arg_count = $expr->{"arg_count"};

        # If function not found, try package-prefixed name when in a package
        my int $func_ret_type = $func_info->{"return_type"};
        my int $func_is_extern = $func_info->{"is_extern"};
        my int $func_found = 0;
        if ($func_ret_type > 0) {
            $func_found = 1;
        }
        if ($func_is_extern == 1) {
            $func_found = 1;
        }
        if ($func_found == 0) {
            my str $fn_pkg = $cg->{"current_fn_package"};
            my int $has_colon = index($name, "::");
            if (length($fn_pkg) > 0 && $fn_pkg ne "main" && $has_colon < 0) {
                # Convert :: to _ in package name
                my str $c_pkg = $fn_pkg;
                my int $ci = index($c_pkg, "::");
                while ($ci >= 0) {
                    $c_pkg = substr($c_pkg, 0, $ci) . "_" . substr($c_pkg, $ci + 2, length($c_pkg) - $ci - 2);
                    $ci = index($c_pkg, "::");
                }
                # Try package-prefixed name
                my str $prefixed_name = $c_pkg . "_" . $c_name;
                my scalar $fn_info_pkg = $cg->{"functions"}->{$prefixed_name};
                my int $pkg_ret = $fn_info_pkg->{"return_type"};
                my int $pkg_is_extern = $fn_info_pkg->{"is_extern"};
                if ($pkg_ret > 0 || $pkg_is_extern == 1) {
                    $c_name = $prefixed_name;
                    $func_info = $fn_info_pkg;
                }
            }
        }

        # Handle extern function calls - convert between StradaValue* and raw C types
        if ($func_info && $func_info->{"is_extern"} == 1) {
            my int $ret_type = $func_info->{"return_type"};
            my int $param_count = $func_info->{"param_count"};
            my scalar $params = $func_info->{"params"};
            my int $is_c_extern = $func_info->{"is_c_extern"};

            # Generate block for extern call with conversion
            emit($cg, "({ ");

            # Create temps for args and convert from StradaValue* to raw C types
            my int $t = 0;
            while ($t < $arg_count) {
                my int $param_type = TYPE_SCALAR();
                if ($t < $param_count) {
                    $param_type = $params->[$t]->{"param_type"};
                }
                emit($cg, "StradaValue *__sv_arg" . $t . " = ");
                gen_expression($cg, $args->[$t]);
                emit($cg, "; ");
                $t = $t + 1;
            }

            # Pre-convert string arguments to char* (non-c_extern only)
            if ($is_c_extern == 0) {
                my int $s = 0;
                while ($s < $arg_count) {
                    my int $spt = TYPE_SCALAR();
                    if ($s < $param_count) {
                        $spt = $params->[$s]->{"param_type"};
                    }
                    if ($spt == TYPE_STR() || ($spt != TYPE_INT() && $spt != TYPE_BOOL() && $spt != TYPE_INT32() && $spt != TYPE_INT64() && $spt != TYPE_NUM() && $spt != TYPE_FLOAT64() && $spt != TYPE_FLOAT32())) {
                        emit($cg, "char *__str_arg" . $s . " = strada_to_str(__sv_arg" . $s . "); ");
                    }
                    $s = $s + 1;
                }
            }

            # Call the extern function with converted args
            if ($ret_type == TYPE_VOID()) {
                emit($cg, $c_name . "(");
            } elsif ($ret_type == TYPE_STR()) {
                emit($cg, "char *__ext_ret = " . $c_name . "(");
            } elsif ($ret_type == TYPE_INT()) {
                emit($cg, "int __ext_ret = " . $c_name . "(");
            } elsif ($ret_type == TYPE_BOOL()) {
                emit($cg, "bool __ext_ret = " . $c_name . "(");
            } elsif ($ret_type == TYPE_NUM()) {
                emit($cg, "double __ext_ret = " . $c_name . "(");
            } elsif ($ret_type == TYPE_INT32()) {
                emit($cg, "int32_t __ext_ret = " . $c_name . "(");
            } elsif ($ret_type == TYPE_INT64()) {
                emit($cg, "int64_t __ext_ret = " . $c_name . "(");
            } elsif ($ret_type == TYPE_FLOAT32()) {
                emit($cg, "float __ext_ret = " . $c_name . "(");
            } elsif ($ret_type == TYPE_FLOAT64()) {
                emit($cg, "double __ext_ret = " . $c_name . "(");
            } else {
                emit($cg, "void *__ext_ret = " . $c_name . "(");
            }

            # Pass converted arguments
            my int $a = 0;
            while ($a < $arg_count) {
                if ($a > 0) {
                    emit($cg, ", ");
                }
                my int $param_type = TYPE_SCALAR();
                if ($a < $param_count) {
                    $param_type = $params->[$a]->{"param_type"};
                }

                # For c_extern, use direct conversions without allocation
                if ($is_c_extern == 1) {
                    if ($param_type == TYPE_STR()) {
                        # For c_extern, str is already a char* pointer stored as int
                        emit($cg, "(char*)strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_INT() || $param_type == TYPE_BOOL()) {
                        emit($cg, "(int)strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_INT32()) {
                        emit($cg, "(int32_t)strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_INT64()) {
                        emit($cg, "strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_UINT8()) {
                        emit($cg, "(uint8_t)strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_UINT16()) {
                        emit($cg, "(uint16_t)strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_UINT32()) {
                        emit($cg, "(uint32_t)strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_UINT64()) {
                        emit($cg, "(uint64_t)strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_SIZE_T()) {
                        emit($cg, "(size_t)strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_CHAR()) {
                        emit($cg, "(char)strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_NUM() || $param_type == TYPE_FLOAT64()) {
                        emit($cg, "strada_to_num(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_FLOAT32()) {
                        emit($cg, "(float)strada_to_num(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_LONG_DOUBLE()) {
                        emit($cg, "(long double)strada_to_num(__sv_arg" . $a . ")");
                    } else {
                        emit($cg, "(void*)strada_to_int(__sv_arg" . $a . ")");
                    }
                } else {
                    # Traditional extern - uses pre-converted __str_argN
                    if ($param_type == TYPE_STR()) {
                        emit($cg, "__str_arg" . $a);
                    } elsif ($param_type == TYPE_INT() || $param_type == TYPE_BOOL()) {
                        emit($cg, "(int)strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_INT32()) {
                        emit($cg, "(int32_t)strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_INT64()) {
                        emit($cg, "strada_to_int(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_NUM() || $param_type == TYPE_FLOAT64()) {
                        emit($cg, "strada_to_num(__sv_arg" . $a . ")");
                    } elsif ($param_type == TYPE_FLOAT32()) {
                        emit($cg, "(float)strada_to_num(__sv_arg" . $a . ")");
                    } else {
                        emit($cg, "__str_arg" . $a);
                    }
                }
                $a = $a + 1;
            }
            emit($cg, "); ");

            # Free pre-converted string arguments (non-c_extern only)
            if ($is_c_extern == 0) {
                my int $f = 0;
                while ($f < $arg_count) {
                    my int $fpt = TYPE_SCALAR();
                    if ($f < $param_count) {
                        $fpt = $params->[$f]->{"param_type"};
                    }
                    if ($fpt == TYPE_STR() || ($fpt != TYPE_INT() && $fpt != TYPE_BOOL() && $fpt != TYPE_INT32() && $fpt != TYPE_INT64() && $fpt != TYPE_NUM() && $fpt != TYPE_FLOAT64() && $fpt != TYPE_FLOAT32())) {
                        emit($cg, "free(__str_arg" . $f . "); ");
                    }
                    $f = $f + 1;
                }
            }

            # Decref the temp StradaValue args (skip for c_extern - no allocations)
            if ($is_c_extern == 0) {
                my int $d = 0;
                while ($d < $arg_count) {
                    if (needs_temp_cleanup($cg, $args->[$d]) == 1) {
                        emit($cg, "strada_decref(__sv_arg" . $d . "); ");
                    }
                    $d = $d + 1;
                }
            }

            # Convert return value back to StradaValue*
            if ($ret_type == TYPE_VOID()) {
                emit($cg, "strada_new_undef(); })");
            } elsif ($ret_type == TYPE_STR()) {
                if ($is_c_extern == 1) {
                    # For c_extern, store the char* as an int64
                    emit($cg, "strada_new_int((int64_t)__ext_ret); })");
                } else {
                    emit($cg, "strada_new_str(__ext_ret); })");
                }
            } elsif ($ret_type == TYPE_INT() || $ret_type == TYPE_BOOL() || $ret_type == TYPE_INT32() || $ret_type == TYPE_INT64()) {
                emit($cg, "strada_new_int(__ext_ret); })");
            } elsif ($ret_type == TYPE_UINT8() || $ret_type == TYPE_UINT16() || $ret_type == TYPE_UINT32() || $ret_type == TYPE_UINT64() || $ret_type == TYPE_SIZE_T() || $ret_type == TYPE_CHAR()) {
                emit($cg, "strada_new_int(__ext_ret); })");
            } elsif ($ret_type == TYPE_NUM() || $ret_type == TYPE_FLOAT32() || $ret_type == TYPE_FLOAT64() || $ret_type == TYPE_LONG_DOUBLE()) {
                emit($cg, "strada_new_num(__ext_ret); })");
            } else {
                emit($cg, "strada_new_undef(); })");
            }
            return;
        }

        # Check if this is a variadic function call or if any arg has spread
        my int $is_variadic_call = 0;
        my int $variadic_param_idx = -1;
        my int $has_spread = 0;

        # Check for spread in arguments
        for (my int $sa = 0; $sa < $arg_count; $sa = $sa + 1) {
            if ($args->[$sa]->{"type"} == NODE_SPREAD()) {
                $has_spread = 1;
            }
        }

        # Check if function is variadic
        if ($func_info) {
            if ($func_info->{"is_variadic"} == 1) {
                $is_variadic_call = 1;
                $variadic_param_idx = $func_info->{"variadic_param_idx"};
            }
        }

        # Check if function returns dynamic (context-sensitive)
        my int $is_dynamic_call = 0;
        if ($func_info) {
            if ($func_info->{"return_type"} == TYPE_DYNAMIC()) {
                $is_dynamic_call = 1;
            }
        }
        my int $dyn_ctx = $cg->{"call_context"} + 0;

        # Variadic call: pack args into array at call site
        if ($is_variadic_call == 1 || $has_spread == 1) {
            # For variadic functions, variadic_param_idx tells us where to start packing
            # For non-variadic functions with spread, pack ALL args and let runtime sort it out
            if ($variadic_param_idx < 0) {
                $variadic_param_idx = 0;  # Pack all args if no variadic info
            }

            # Check if function returns void
            my int $returns_void = 0;
            if ($func_info) {
                my int $ret_type = $func_info->{"return_type"};
                if ($ret_type == TYPE_VOID()) {
                    $returns_void = 1;
                }
            }

            emit($cg, "({ ");
            emit($cg, "StradaValue *__va_arr = strada_new_array(); ");

            # Pack args starting from variadic position
            my int $a = $variadic_param_idx;
            while ($a < $arg_count) {
                my scalar $arg = $args->[$a];
                if ($arg->{"type"} == NODE_SPREAD()) {
                    # Spread: iterate array and push elements
                    # Incref first to keep element alive, then use push_take to transfer ownership to variadic array
                    emit($cg, "{ StradaValue *__spread = ");
                    gen_expression($cg, $arg->{"target"});
                    emit($cg, "; StradaArray *__sa = strada_deref_array(__spread); ");
                    emit($cg, "if (__sa) { for (size_t __si = 0; __si < __sa->size; __si++) { ");
                    emit($cg, "strada_incref(__sa->elements[__si]); ");
                    emit($cg, "strada_array_push_take(strada_deref_array(__va_arr), __sa->elements[__si]); ");
                    emit($cg, "} } } ");
                } else {
                    # Regular arg: push to array using push_take since we're creating new values
                    emit($cg, "strada_array_push_take(strada_deref_array(__va_arr), ");
                    gen_expression($cg, $arg);
                    emit($cg, "); ");
                }
                $a = $a + 1;
            }

            # Emit the function call with fixed args + variadic array
            if ($is_dynamic_call == 1) {
                emit($cg, "strada_set_call_context(" . $dyn_ctx . "); ");
            }
            if ($returns_void == 0) {
                emit($cg, "StradaValue *__va_result = ");
            }
            emit($cg, $c_name . "(");

            # Emit fixed args (before variadic position)
            for (my int $f = 0; $f < $variadic_param_idx; $f = $f + 1) {
                if ($f > 0) {
                    emit($cg, ", ");
                }
                if ($f < $arg_count) {
                    gen_expression($cg, $args->[$f]);
                } else {
                    # Missing arg - use default or undef
                    if ($func_info) {
                        my scalar $params = $func_info->{"params"};
                        my scalar $param = $params->[$f];
                        if ($param->{"has_default"} == 1) {
                            gen_expression($cg, $param->{"default"});
                        } else {
                            emit($cg, "strada_new_undef()");
                        }
                    } else {
                        emit($cg, "strada_new_undef()");
                    }
                }
            }

            # Emit variadic array as last param
            if ($variadic_param_idx > 0) {
                emit($cg, ", ");
            }
            emit($cg, "__va_arr); strada_decref(__va_arr); ");
            if ($is_dynamic_call == 1) {
                emit($cg, "strada_set_call_context(0); ");
            }

            # Return result
            if ($returns_void == 0) {
                emit($cg, "__va_result; })");
            } else {
                emit($cg, "})");
            }
            return;
        }

        # Check if any arguments need temp cleanup (anonymous values)
        my int $needs_temps = 0;
        my int $check_i = 0;
        while ($check_i < $arg_count) {
            if (needs_temp_cleanup($cg, $args->[$check_i]) == 1) {
                $needs_temps = 1;
            }
            $check_i = $check_i + 1;
        }

        if ($needs_temps == 1) {
            # Check if function returns void
            # Default to non-void when we don't have func_info (safer - allows use in expression context)
            my int $returns_void = 0;
            if ($func_info) {
                my int $ret_type = $func_info->{"return_type"};
                if ($ret_type == TYPE_VOID()) {
                    $returns_void = 1;
                }
            }

            # Generate block with temp variables for cleanup
            emit($cg, "({ ");
            # Declare temps for args that need cleanup
            my int $in_try = $cg->{"try_depth"} + 0;
            my int $t = 0;
            while ($t < $arg_count) {
                if (needs_temp_cleanup($cg, $args->[$t]) == 1) {
                    emit($cg, "StradaValue *__arg" . $t . " = ");
                    gen_expression($cg, $args->[$t]);
                    emit($cg, "; ");
                    # If inside a try block, register for cleanup in case the call throws
                    if ($in_try > 0) {
                        emit($cg, "strada_cleanup_push(__arg" . $t . "); ");
                    }
                }
                $t = $t + 1;
            }
            # Emit the function call, storing result if not void
            if ($is_dynamic_call == 1) {
                emit($cg, "strada_set_call_context(" . $dyn_ctx . "); ");
            }
            if ($returns_void == 0) {
                emit($cg, "StradaValue *__call_result = ");
            }
            emit($cg, $c_name . "(");
            if ($func_info) {
                my int $param_count = $func_info->{"param_count"};
                my scalar $params = $func_info->{"params"};
                my int $i = 0;
                while ($i < $param_count) {
                    if ($i > 0) {
                        emit($cg, ", ");
                    }
                    if ($i < $arg_count) {
                        if (needs_temp_cleanup($cg, $args->[$i]) == 1) {
                            emit($cg, "__arg" . $i);
                        } else {
                            gen_expression($cg, $args->[$i]);
                        }
                    } else {
                        my scalar $param = $params->[$i];
                        if ($param->{"has_default"} == 1) {
                            gen_expression($cg, $param->{"default"});
                        } else {
                            emit($cg, "strada_new_undef()");
                        }
                    }
                    $i = $i + 1;
                }
            } else {
                my int $i = 0;
                while ($i < $arg_count) {
                    if ($i > 0) {
                        emit($cg, ", ");
                    }
                    if (needs_temp_cleanup($cg, $args->[$i]) == 1) {
                        emit($cg, "__arg" . $i);
                    } else {
                        gen_expression($cg, $args->[$i]);
                    }
                    $i = $i + 1;
                }
            }
            emit($cg, "); ");
            # Decref temps and pop from cleanup stack
            my int $d = 0;
            while ($d < $arg_count) {
                if (needs_temp_cleanup($cg, $args->[$d]) == 1) {
                    # Pop from cleanup stack first (in case decref throws somehow)
                    if ($in_try > 0) {
                        emit($cg, "strada_cleanup_pop(); ");
                    }
                    emit($cg, "strada_decref(__arg" . $d . "); ");
                }
                $d = $d + 1;
            }
            if ($is_dynamic_call == 1) {
                emit($cg, "strada_set_call_context(0); ");
            }
            # Return result if not void
            if ($returns_void == 0) {
                emit($cg, "__call_result; })");
            } else {
                emit($cg, "})");
            }
        } else {
            # No temps needed, simple call
            if ($is_dynamic_call == 1) {
                emit($cg, "({ strada_set_call_context(" . $dyn_ctx . "); StradaValue *__dyn_r = ");
            }
            emit($cg, $c_name . "(");
            if ($func_info) {
                my int $param_count = $func_info->{"param_count"};
                my scalar $params = $func_info->{"params"};
                my int $i = 0;
                while ($i < $param_count) {
                    if ($i > 0) {
                        emit($cg, ", ");
                    }
                    if ($i < $arg_count) {
                        gen_expression($cg, $args->[$i]);
                    } else {
                        my scalar $param = $params->[$i];
                        if ($param->{"has_default"} == 1) {
                            gen_expression($cg, $param->{"default"});
                        } else {
                            emit($cg, "strada_new_undef()");
                        }
                    }
                    $i = $i + 1;
                }
            } else {
                my int $i = 0;
                while ($i < $arg_count) {
                    if ($i > 0) {
                        emit($cg, ", ");
                    }
                    gen_expression($cg, $args->[$i]);
                    $i = $i + 1;
                }
            }
            if ($is_dynamic_call == 1) {
                emit($cg, "); strada_set_call_context(0); __dyn_r; })");
            } else {
                emit($cg, ")");
            }
        }
        return;
    }
    
    # Assignment
    if ($type == NODE_ASSIGN()) {
        my str $op = $expr->{"op"};
        my scalar $target = $expr->{"target"};
        my int $target_type = $target->{"type"};
        
        if ($op eq "=") {
            # Special case: hash assignment %hash{key} = value
            # strada_hash_set handles incref internally for shared ownership
            # For anonymous values, we need to decref after hash_set takes ownership
            if ($target_type == NODE_HASH_ACCESS()) {
                my scalar $val = $expr->{"value"};
                my int $val_type = $val->{"type"};
                # Check if value is anonymous/owned (needs decref after storing)
                my int $is_anonymous = 0;
                if ($val_type == NODE_ANON_ARRAY() || $val_type == NODE_ANON_HASH() ||
                    $val_type == NODE_INT_LITERAL() || $val_type == NODE_NUM_LITERAL() ||
                    $val_type == NODE_STR_LITERAL() || $val_type == NODE_CALL() ||
                    $val_type == NODE_REF() || $val_type == NODE_METHOD_CALL() ||
                    $val_type == NODE_DYN_METHOD_CALL() ||
                    $val_type == NODE_BINARY_OP() || $val_type == NODE_UNARY_OP() ||
                    $val_type == NODE_TERNARY() ||
                    $val_type == NODE_ANON_FUNC() || $val_type == NODE_CLOSURE_CALL() ||
                    $val_type == NODE_HASH_ACCESS() || $val_type == NODE_DEREF_HASH()) {
                    $is_anonymous = 1;
                }
                my scalar $key_expr = $target->{"key"};
                my int $key_is_literal = $key_expr->{"type"} == NODE_STR_LITERAL();
                if ($is_anonymous == 1) {
                    # Anonymous value: store in temp, hash_set takes shared ownership, then release our copy
                    emit($cg, "({ StradaValue *__hset_v = ");
                    # Handle empty () which parser returns as anon_hash
                    if ($val_type == NODE_ANON_HASH() && $val->{"pair_count"} == 0) {
                        emit($cg, "strada_new_hash()");
                    } else {
                        gen_expression($cg, $val);
                    }
                    emit($cg, "; ");
                    if ($key_is_literal == 1) {
                        # Literal key - use directly without allocation
                        emit($cg, "strada_hv_store(");
                        gen_expression($cg, $target->{"hash"});
                        emit($cg, ", ");
                        gen_str_literal_c($cg, $key_expr->{"value"});
                        emit($cg, ", __hset_v); strada_decref(__hset_v); })");
                    } else {
                        # Expression key - save to temp, get string, cleanup both
                        my int $key_needs_cleanup = needs_temp_cleanup($cg, $key_expr);
                        emit($cg, "StradaValue *__hset_k = ");
                        gen_expression($cg, $key_expr);
                        emit($cg, "; char *__hset_ks = strada_to_str(__hset_k); ");
                        emit($cg, "strada_hv_store(");
                        gen_expression($cg, $target->{"hash"});
                        emit($cg, ", __hset_ks, __hset_v); ");
                        emit($cg, "free(__hset_ks); ");
                        if ($key_needs_cleanup == 1) {
                            emit($cg, "strada_decref(__hset_k); ");
                        }
                        emit($cg, "strada_decref(__hset_v); })");
                    }
                } else {
                    # Borrowed value: just pass to hash_set which handles incref
                    if ($key_is_literal == 1) {
                        # Literal key - use directly without allocation
                        emit($cg, "strada_hv_store(");
                        gen_expression($cg, $target->{"hash"});
                        emit($cg, ", ");
                        gen_str_literal_c($cg, $key_expr->{"value"});
                        emit($cg, ", ");
                        gen_expression($cg, $val);
                        emit($cg, ")");
                    } else {
                        # Expression key - save to temp, get string, cleanup both
                        my int $key_needs_cleanup = needs_temp_cleanup($cg, $key_expr);
                        emit($cg, "({ StradaValue *__hset_k = ");
                        gen_expression($cg, $key_expr);
                        emit($cg, "; char *__hset_ks = strada_to_str(__hset_k); ");
                        emit($cg, "strada_hv_store(");
                        gen_expression($cg, $target->{"hash"});
                        emit($cg, ", __hset_ks, ");
                        gen_expression($cg, $val);
                        emit($cg, "); free(__hset_ks); ");
                        if ($key_needs_cleanup == 1) {
                            emit($cg, "strada_decref(__hset_k); ");
                        }
                        emit($cg, "})");
                    }
                }
                return;
            }
            # Special case: hash deref assignment $ref->{key} = value
            # strada_hash_set handles incref internally for shared ownership
            # For anonymous values, we need to decref after hash_set takes ownership
            if ($target_type == NODE_DEREF_HASH()) {
                my scalar $val = $expr->{"value"};
                my int $val_type = $val->{"type"};
                # Check if value is anonymous/owned (needs decref after storing)
                my int $is_anonymous = 0;
                if ($val_type == NODE_ANON_ARRAY() || $val_type == NODE_ANON_HASH() ||
                    $val_type == NODE_INT_LITERAL() || $val_type == NODE_NUM_LITERAL() ||
                    $val_type == NODE_STR_LITERAL() || $val_type == NODE_CALL() ||
                    $val_type == NODE_REF() || $val_type == NODE_METHOD_CALL() ||
                    $val_type == NODE_DYN_METHOD_CALL() ||
                    $val_type == NODE_BINARY_OP() || $val_type == NODE_UNARY_OP() ||
                    $val_type == NODE_TERNARY() ||
                    $val_type == NODE_ANON_FUNC() || $val_type == NODE_CLOSURE_CALL() ||
                    $val_type == NODE_HASH_ACCESS() || $val_type == NODE_DEREF_HASH()) {
                    $is_anonymous = 1;
                }
                my scalar $key_expr = $target->{"key"};
                my int $key_is_literal = $key_expr->{"type"} == NODE_STR_LITERAL();
                my int $hst_ref_cleanup = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $target->{"ref"}) == 1;
                if ($is_anonymous == 1) {
                    # Anonymous value: store in temp, hash_set takes shared ownership, then release our copy
                    emit($cg, "({ StradaValue *__hset_v = ");
                    gen_expression($cg, $val);
                    emit($cg, "; ");
                    if ($hst_ref_cleanup == 1) {
                        emit($cg, "StradaValue *__hst_ref = ");
                        gen_expression($cg, $target->{"ref"});
                        emit($cg, "; ");
                    }
                    if ($key_is_literal == 1) {
                        # Literal key - use directly without allocation
                        emit($cg, "strada_hv_store(");
                        if ($hst_ref_cleanup == 1) {
                            emit($cg, "__hst_ref");
                        } else {
                            gen_expression($cg, $target->{"ref"});
                        }
                        emit($cg, ", ");
                        gen_str_literal_c($cg, $key_expr->{"value"});
                        emit($cg, ", __hset_v); ");
                        if ($hst_ref_cleanup == 1) {
                            emit($cg, "strada_decref(__hst_ref); ");
                        }
                        emit($cg, "strada_decref(__hset_v); })");
                    } else {
                        # Expression key - save to temp, get string, cleanup both
                        my int $key_needs_cleanup = needs_temp_cleanup($cg, $key_expr);
                        emit($cg, "StradaValue *__hset_k = ");
                        gen_expression($cg, $key_expr);
                        emit($cg, "; char *__hset_ks = strada_to_str(__hset_k); ");
                        emit($cg, "strada_hv_store(");
                        if ($hst_ref_cleanup == 1) {
                            emit($cg, "__hst_ref");
                        } else {
                            gen_expression($cg, $target->{"ref"});
                        }
                        emit($cg, ", __hset_ks, __hset_v); ");
                        emit($cg, "free(__hset_ks); ");
                        if ($key_needs_cleanup == 1) {
                            emit($cg, "strada_decref(__hset_k); ");
                        }
                        if ($hst_ref_cleanup == 1) {
                            emit($cg, "strada_decref(__hst_ref); ");
                        }
                        emit($cg, "strada_decref(__hset_v); })");
                    }
                } else {
                    # Borrowed value: just pass to hash_set which handles incref
                    if ($key_is_literal == 1) {
                        # Literal key - use directly without allocation
                        if ($hst_ref_cleanup == 1) {
                            emit($cg, "({ StradaValue *__hst_ref = ");
                            gen_expression($cg, $target->{"ref"});
                            emit($cg, "; strada_hv_store(__hst_ref, ");
                            gen_str_literal_c($cg, $key_expr->{"value"});
                            emit($cg, ", ");
                            gen_expression($cg, $val);
                            emit($cg, "); strada_decref(__hst_ref); })");
                        } else {
                            emit($cg, "strada_hv_store(");
                            gen_expression($cg, $target->{"ref"});
                            emit($cg, ", ");
                            gen_str_literal_c($cg, $key_expr->{"value"});
                            emit($cg, ", ");
                            gen_expression($cg, $val);
                            emit($cg, ")");
                        }
                    } else {
                        # Expression key - save to temp, get string, cleanup both
                        my int $key_needs_cleanup = needs_temp_cleanup($cg, $key_expr);
                        emit($cg, "({ ");
                        if ($hst_ref_cleanup == 1) {
                            emit($cg, "StradaValue *__hst_ref = ");
                            gen_expression($cg, $target->{"ref"});
                            emit($cg, "; ");
                        }
                        emit($cg, "StradaValue *__hset_k = ");
                        gen_expression($cg, $key_expr);
                        emit($cg, "; char *__hset_ks = strada_to_str(__hset_k); ");
                        emit($cg, "strada_hv_store(");
                        if ($hst_ref_cleanup == 1) {
                            emit($cg, "__hst_ref");
                        } else {
                            gen_expression($cg, $target->{"ref"});
                        }
                        emit($cg, ", __hset_ks, ");
                        gen_expression($cg, $val);
                        emit($cg, "); free(__hset_ks); ");
                        if ($key_needs_cleanup == 1) {
                            emit($cg, "strada_decref(__hset_k); ");
                        }
                        if ($hst_ref_cleanup == 1) {
                            emit($cg, "strada_decref(__hst_ref); ");
                        }
                        emit($cg, "})");
                    }
                }
                return;
            }
            # Special case: array subscript assignment $arr[idx] = value
            if ($target_type == NODE_SUBSCRIPT()) {
                my scalar $idx_expr = $target->{"index"};
                my scalar $val_expr = $expr->{"value"};
                my int $idx_needs_cleanup = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $idx_expr) == 1;
                my int $val_needs_cleanup = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $val_expr) == 1;

                if ($idx_needs_cleanup == 1 || $val_needs_cleanup == 1) {
                    emit($cg, "({ ");
                    if ($idx_needs_cleanup == 1) {
                        emit($cg, "StradaValue *__idx_tmp = ");
                        gen_expression($cg, $idx_expr);
                        emit($cg, "; ");
                    }
                    if ($val_needs_cleanup == 1) {
                        emit($cg, "StradaValue *__val_tmp = ");
                        gen_expression($cg, $val_expr);
                        emit($cg, "; ");
                    }
                    emit($cg, "strada_array_set(strada_deref_array(");
                    gen_expression($cg, $target->{"array"});
                    emit($cg, "), strada_to_int(");
                    if ($idx_needs_cleanup == 1) {
                        emit($cg, "__idx_tmp");
                    } else {
                        gen_expression($cg, $idx_expr);
                    }
                    emit($cg, "), ");
                    if ($val_needs_cleanup == 1) {
                        emit($cg, "__val_tmp");
                    } else {
                        gen_expression($cg, $val_expr);
                    }
                    emit($cg, "); ");
                    if ($idx_needs_cleanup == 1) {
                        emit($cg, "strada_decref(__idx_tmp); ");
                    }
                    if ($val_needs_cleanup == 1) {
                        emit($cg, "strada_decref(__val_tmp); ");
                    }
                    emit($cg, "})");
                } else {
                    emit($cg, "strada_array_set(strada_deref_array(");
                    gen_expression($cg, $target->{"array"});
                    emit($cg, "), strada_to_int(");
                    gen_expression($cg, $idx_expr);
                    emit($cg, "), ");
                    gen_expression($cg, $val_expr);
                    emit($cg, ")");
                }
                return;
            }
            # Special case: array deref assignment $ref->[idx] = value
            if ($target_type == NODE_DEREF_ARRAY()) {
                my scalar $idx_expr = $target->{"index"};
                my scalar $val_expr = $expr->{"value"};
                my int $idx_needs_cleanup = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $idx_expr) == 1;
                my int $val_needs_cleanup = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $val_expr) == 1;

                if ($idx_needs_cleanup == 1 || $val_needs_cleanup == 1) {
                    emit($cg, "({ ");
                    if ($idx_needs_cleanup == 1) {
                        emit($cg, "StradaValue *__idx_tmp = ");
                        gen_expression($cg, $idx_expr);
                        emit($cg, "; ");
                    }
                    if ($val_needs_cleanup == 1) {
                        emit($cg, "StradaValue *__val_tmp = ");
                        gen_expression($cg, $val_expr);
                        emit($cg, "; ");
                    }
                    emit($cg, "strada_array_set(strada_deref_array(");
                    gen_expression($cg, $target->{"ref"});
                    emit($cg, "), strada_to_int(");
                    if ($idx_needs_cleanup == 1) {
                        emit($cg, "__idx_tmp");
                    } else {
                        gen_expression($cg, $idx_expr);
                    }
                    emit($cg, "), ");
                    if ($val_needs_cleanup == 1) {
                        emit($cg, "__val_tmp");
                    } else {
                        gen_expression($cg, $val_expr);
                    }
                    emit($cg, "); ");
                    if ($idx_needs_cleanup == 1) {
                        emit($cg, "strada_decref(__idx_tmp); ");
                    }
                    if ($val_needs_cleanup == 1) {
                        emit($cg, "strada_decref(__val_tmp); ");
                    }
                    emit($cg, "})");
                } else {
                    emit($cg, "strada_array_set(strada_deref_array(");
                    gen_expression($cg, $target->{"ref"});
                    emit($cg, "), strada_to_int(");
                    gen_expression($cg, $idx_expr);
                    emit($cg, "), ");
                    gen_expression($cg, $val_expr);
                    emit($cg, ")");
                }
                return;
            }
            # Special case: scalar deref assignment $$ref = value
            if ($target_type == NODE_DEREF_SCALAR()) {
                emit($cg, "strada_deref_set(");
                gen_expression($cg, $target->{"ref"});
                emit($cg, ", ");
                gen_expression($cg, $expr->{"value"});
                emit($cg, ")");
                return;
            }
            # Special case: assigning scalar to array variable @arr = ($x)
            if ($target_type == NODE_VARIABLE() && $target->{"sigil"} eq "@") {
                my scalar $val = $expr->{"value"};
                my int $val_type = $val->{"type"};
                if ($val_type == NODE_READLINE()) {
                    # Diamond operator in array context - read all lines
                    my str $varname = $val->{"varname"};
                    if ($cg->{"cleanup_enabled"} == 1) {
                        emit($cg, "({ StradaValue *__old = ");
                        gen_expression($cg, $target);
                        emit($cg, "; ");
                    }
                    gen_expression($cg, $target);
                    emit($cg, " = strada_read_all_lines(" . escape_c_keyword($varname) . ")");
                    if ($cg->{"cleanup_enabled"} == 1) {
                        emit($cg, "; strada_decref(__old); ");
                        gen_expression($cg, $target);
                        emit($cg, "; })");
                    }
                } elsif ($val_type == NODE_ANON_HASH() && $val->{"pair_count"} == 0) {
                    # Empty () - clear and reset array
                    if ($cg->{"cleanup_enabled"} == 1) {
                        emit($cg, "({ StradaValue *__old = ");
                        gen_expression($cg, $target);
                        emit($cg, "; ");
                    }
                    gen_expression($cg, $target);
                    emit($cg, " = strada_new_array()");
                    if ($cg->{"cleanup_enabled"} == 1) {
                        emit($cg, "; strada_decref(__old); ");
                        gen_expression($cg, $target);
                        emit($cg, "; })");
                    }
                } elsif ($val_type == NODE_ANON_ARRAY()) {
                    # Array literal [1, 2, 3] - assign directly
                    if ($cg->{"cleanup_enabled"} == 1) {
                        emit($cg, "({ StradaValue *__old = ");
                        gen_expression($cg, $target);
                        emit($cg, "; ");
                    }
                    gen_expression($cg, $target);
                    emit($cg, " = ");
                    gen_expression($cg, $val);
                    if ($cg->{"cleanup_enabled"} == 1) {
                        emit($cg, "; strada_decref(__old); ");
                        gen_expression($cg, $target);
                        emit($cg, "; })");
                    }
                } elsif (is_scalar_expr($val)) {
                    # Single scalar - wrap in array
                    if ($cg->{"cleanup_enabled"} == 1) {
                        emit($cg, "({ StradaValue *__old = ");
                        gen_expression($cg, $target);
                        emit($cg, "; ");
                    }
                    gen_expression($cg, $target);
                    emit($cg, " = strada_new_array(); strada_array_push(");
                    gen_expression($cg, $target);
                    emit($cg, "->value.av, ");
                    gen_expression($cg, $val);
                    emit($cg, ")");
                    if ($cg->{"cleanup_enabled"} == 1) {
                        emit($cg, "; strada_decref(__old); ");
                        gen_expression($cg, $target);
                        emit($cg, "; })");
                    }
                } else {
                    # Value returns an array - copy if from variable/deref to avoid aliasing
                    my int $val_type2 = $val->{"type"};
                    if ($val_type2 == NODE_VARIABLE() && $val->{"sigil"} eq "%") {
                        # Hash-to-array flattening: @arr = %hash
                        emit($cg, "strada_decref(");
                        gen_expression($cg, $target);
                        emit($cg, "); ");
                        gen_expression($cg, $target);
                        emit($cg, " = strada_hash_to_flat_array(");
                        gen_expression($cg, $val);
                        emit($cg, ")");
                    } elsif ($val_type2 == NODE_VARIABLE() || ($val_type2 == NODE_DEREF_SCALAR() && $val->{"sigil"} eq "@")) {
                        # Decref old array, assign copy
                        emit($cg, "strada_decref(");
                        gen_expression($cg, $target);
                        emit($cg, "); ");
                        gen_expression($cg, $target);
                        emit($cg, " = strada_array_copy(");
                        gen_expression($cg, $val);
                        emit($cg, ")");
                    } else {
                        if ($cg->{"cleanup_enabled"} == 1) {
                            emit($cg, "({ StradaValue *__old = ");
                            gen_expression($cg, $target);
                            emit($cg, "; ");
                        }
                        gen_expression($cg, $target);
                        emit($cg, " = ");
                        gen_expression($cg, $val);
                        if ($cg->{"cleanup_enabled"} == 1) {
                            emit($cg, "; strada_decref(__old); ");
                            gen_expression($cg, $target);
                            emit($cg, "; })");
                        }
                    }
                }
                return;
            }
            # Special case: assigning to hash variable %h = (...)
            if ($target_type == NODE_VARIABLE() && $target->{"sigil"} eq "%") {
                my scalar $val = $expr->{"value"};
                my int $val_type = $val->{"type"};
                if ($val_type == NODE_ANON_HASH() && $val->{"pair_count"} == 0) {
                    # Empty () - clear hash: %h = ()
                    if ($cg->{"cleanup_enabled"} == 1) {
                        emit($cg, "({ StradaValue *__old = ");
                        gen_expression($cg, $target);
                        emit($cg, "; ");
                    }
                    gen_expression($cg, $target);
                    emit($cg, " = strada_new_hash()");
                    if ($cg->{"cleanup_enabled"} == 1) {
                        emit($cg, "; strada_decref(__old); ");
                        gen_expression($cg, $target);
                        emit($cg, "; })");
                    }
                } elsif ($val_type == NODE_ANON_ARRAY() || $val_type == NODE_MAP()) {
                    # List init: %h = ("a" => 1, "b" => 2) or %h = map { ... } @arr
                    if ($cg->{"cleanup_enabled"} == 1) {
                        emit($cg, "({ StradaValue *__old = ");
                        gen_expression($cg, $target);
                        emit($cg, "; ");
                    }
                    gen_expression($cg, $target);
                    emit($cg, " = strada_hash_from_flat_array(");
                    gen_expression($cg, $val);
                    emit($cg, ")");
                    if ($cg->{"cleanup_enabled"} == 1) {
                        emit($cg, "; strada_decref(__old); ");
                        gen_expression($cg, $target);
                        emit($cg, "; })");
                    }
                } elsif ($val_type == NODE_VARIABLE() && $val->{"sigil"} eq "%") {
                    # Hash copy: %h = %other
                    emit($cg, "strada_decref(");
                    gen_expression($cg, $target);
                    emit($cg, "); ");
                    gen_expression($cg, $target);
                    emit($cg, " = strada_hash_from_ref(");
                    gen_expression($cg, $val);
                    emit($cg, ")");
                } else {
                    # Generic assignment
                    if ($cg->{"cleanup_enabled"} == 1) {
                        emit($cg, "({ StradaValue *__old = ");
                        gen_expression($cg, $target);
                        emit($cg, "; ");
                    }
                    gen_expression($cg, $target);
                    emit($cg, " = ");
                    if ($val_type == NODE_CALL()) {
                        $cg->{"call_context"} = 2;
                    }
                    gen_expression($cg, $val);
                    if ($val_type == NODE_CALL()) {
                        $cg->{"call_context"} = 0;
                    }
                    if ($cg->{"cleanup_enabled"} == 1) {
                        emit($cg, "; strada_decref(__old); ");
                        gen_expression($cg, $target);
                        emit($cg, "; })");
                    }
                }
                return;
            }
            # Check for 'our' variable assignment - use strada_global_set() instead of local assign
            if ($target_type == NODE_VARIABLE()) {
                my str $our_target_name = escape_c_keyword($target->{"name"});
                my scalar $our_vars2 = $cg->{"our_vars"};
                my str $our_key2 = "" . $our_vars2->{$our_target_name};
                if (length($our_key2) > 0) {
                    emit($cg, "strada_global_set(strada_new_str(\"" . $our_key2 . "\"), ");
                    gen_expression($cg, $expr->{"value"});
                    emit($cg, ")");
                    return;
                }
            }
            # Normal assignment with reference counting
            # Runtime returns owned references, so we just decref the old value
            # For variable-to-variable copy and borrowed references (hash/array access),
            # we need to incref since we're sharing the reference
            my scalar $rhs = $expr->{"value"};
            my int $rhs_type = $rhs->{"type"};
            # Optimize $s = $s . expr  strada_concat_inplace(s, expr)
            if ($target_type == NODE_VARIABLE() && $rhs_type == NODE_BINARY_OP() &&
                $rhs->{"op"} eq ".") {
                my scalar $concat_left = $rhs->{"left"};
                if ($concat_left->{"type"} == NODE_VARIABLE() &&
                    $concat_left->{"name"} eq $target->{"name"}) {
                    my scalar $concat_right = $rhs->{"right"};
                    if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $concat_right) == 1) {
                        emit($cg, "({ StradaValue *__rhs_tmp = ");
                        gen_expression($cg, $concat_right);
                        emit($cg, "; ");
                        gen_expression($cg, $target);
                        emit($cg, " = strada_concat_inplace(");
                        gen_expression($cg, $target);
                        emit($cg, ", __rhs_tmp); strada_decref(__rhs_tmp); ");
                        gen_expression($cg, $target);
                        emit($cg, "; })");
                    } else {
                        gen_expression($cg, $target);
                        emit($cg, " = strada_concat_inplace(");
                        gen_expression($cg, $target);
                        emit($cg, ", ");
                        gen_expression($cg, $concat_right);
                        emit($cg, ")");
                    }
                    return;
                }
            }
            my int $needs_incref = 0;
            # Variable assignment shares reference
            if ($rhs_type == NODE_VARIABLE()) {
                $needs_incref = 1;
            }
            # Array access returns borrowed reference - must incref to own it
            if ($rhs_type == NODE_SUBSCRIPT() || $rhs_type == NODE_DEREF_ARRAY()) {
                $needs_incref = 1;
            }
            # Ternary and other complex expressions - use return_needs_incref() for proper analysis
            if ($rhs_type == NODE_TERNARY()) {
                $needs_incref = return_needs_incref($rhs);
            }
            if ($target_type == NODE_VARIABLE() && $cg->{"cleanup_enabled"} == 1) {
                emit($cg, "({ StradaValue *__old = ");
                gen_expression($cg, $target);
                emit($cg, "; ");
                gen_expression($cg, $target);
                emit($cg, " = ");
                gen_expression($cg, $rhs);
                emit($cg, "; ");
                # Incref for shared references (variables, hash/array access)
                if ($needs_incref == 1) {
                    emit($cg, "strada_incref(");
                    gen_expression($cg, $target);
                    emit($cg, "); ");
                }
                emit($cg, "strada_decref(__old); ");
                gen_expression($cg, $target);
                emit($cg, "; })");
            } else {
                gen_expression($cg, $target);
                emit($cg, " = ");
                gen_expression($cg, $rhs);
            }
        } elsif ($op eq "+=" || $op eq "-=" || $op eq ".=") {
            # Check for 'our' variable compound assignment
            if ($target_type == NODE_VARIABLE()) {
                my str $our_ca_name = escape_c_keyword($target->{"name"});
                my scalar $our_ca_vars = $cg->{"our_vars"};
                my str $our_ca_key = "" . $our_ca_vars->{$our_ca_name};
                if (length($our_ca_key) > 0) {
                    # Read current value, compute new value, set it
                    # Capture RHS in temp to avoid leaking it
                    emit($cg, "({ StradaValue *__our_old = strada_global_get(strada_new_str(\"" . $our_ca_key . "\")); ");
                    emit($cg, "StradaValue *__our_rhs = ");
                    gen_expression($cg, $expr->{"value"});
                    emit($cg, "; ");
                    if ($op eq ".=") {
                        emit($cg, "StradaValue *__our_new = strada_concat_inplace(__our_old, __our_rhs); ");
                        emit($cg, "strada_decref(__our_rhs); ");
                    } elsif ($op eq "+=") {
                        emit($cg, "StradaValue *__our_new = strada_new_num(strada_to_num(__our_old) + strada_to_num(__our_rhs)); ");
                        emit($cg, "strada_decref(__our_rhs); strada_decref(__our_old); ");
                    } else {
                        emit($cg, "StradaValue *__our_new = strada_new_num(strada_to_num(__our_old) - strada_to_num(__our_rhs)); ");
                        emit($cg, "strada_decref(__our_rhs); strada_decref(__our_old); ");
                    }
                    emit($cg, "strada_global_set(strada_new_str(\"" . $our_ca_key . "\"), __our_new); })");
                    return;
                }
            }
            # Check for overloaded compound assignment (Perl: $a += $b uses + overload)
            if ($cg->{"has_overloads"} == 1 && $target_type == NODE_VARIABLE() && could_be_blessed($target) == 1) {
                my str $base_op = "+";
                if ($op eq "-=") {
                    $base_op = "-";
                } elsif ($op eq ".=") {
                    $base_op = ".";
                }
                my scalar $ol_ops = $cg->{"overloaded_ops"};
                my int $base_op_overloaded = 0;
                if (length("" . $ol_ops->{$base_op}) > 0) {
                    $base_op_overloaded = 1;
                }
                if ($op eq ".=") {
                    my str $sq = chr(34) . chr(34);
                    if (length("" . $ol_ops->{$sq}) > 0) {
                        $base_op_overloaded = 1;
                    }
                }
                if ($base_op_overloaded == 1) {
                    my scalar $rhs = $expr->{"value"};
                    my int $rhs_tmp = 0;
                    if ($cg->{"cleanup_enabled"} == 1) {
                        $rhs_tmp = needs_temp_cleanup($cg, $rhs);
                    }
                    emit($cg, "({ StradaValue *__ca_old = ");
                    gen_expression($cg, $target);
                    emit($cg, "; StradaValue *__ca_rhs = ");
                    gen_expression($cg, $rhs);
                    emit($cg, "; StradaValue *__ca_res = ");
                    if ($op eq ".=") {
                        # For .= try both . overload and "" stringify
                        emit($cg, "strada_overload_binary(__ca_old, __ca_rhs, \".\"); ");
                        emit($cg, "if (!__ca_res) { ");
                        emit($cg, "StradaValue *__ca_sl = strada_overload_stringify(__ca_old); ");
                        emit($cg, "StradaValue *__ca_sr = strada_overload_stringify(__ca_rhs); ");
                        emit($cg, "__ca_res = strada_concat_inplace(__ca_sl ? __ca_sl : __ca_old, __ca_sr ? __ca_sr : __ca_rhs); ");
                        emit($cg, "if (__ca_sl) strada_decref(__ca_sl); ");
                        emit($cg, "if (__ca_sr) strada_decref(__ca_sr); } ");
                    } else {
                        emit($cg, "strada_overload_binary(__ca_old, __ca_rhs, \"" . $base_op . "\"); ");
                        if ($op eq "+=") {
                            emit($cg, "if (!__ca_res) __ca_res = strada_new_num(strada_to_num(__ca_old) + strada_to_num(__ca_rhs)); ");
                        } else {
                            emit($cg, "if (!__ca_res) __ca_res = strada_new_num(strada_to_num(__ca_old) - strada_to_num(__ca_rhs)); ");
                        }
                    }
                    if ($rhs_tmp == 1) {
                        emit($cg, "strada_decref(__ca_rhs); ");
                    }
                    gen_expression($cg, $target);
                    emit($cg, " = __ca_res; strada_decref(__ca_old); ");
                    gen_expression($cg, $target);
                    emit($cg, "; })");
                    return;
                }
            }
            if ($op eq "+=") {
            if ($target_type == NODE_VARIABLE() && $cg->{"cleanup_enabled"} == 1) {
                emit($cg, "({ StradaValue *__old = ");
                gen_expression($cg, $target);
                emit($cg, "; ");
                gen_expression($cg, $target);
                emit($cg, " = strada_new_num(strada_to_num(__old) + strada_to_num(");
                gen_expression($cg, $expr->{"value"});
                emit($cg, ")); strada_decref(__old); ");
                gen_expression($cg, $target);
                emit($cg, "; })");
            } else {
                gen_expression($cg, $target);
                emit($cg, " = strada_new_num(strada_to_num(");
                gen_expression($cg, $target);
                emit($cg, ") + strada_to_num(");
                gen_expression($cg, $expr->{"value"});
                emit($cg, "))");
            }
            } elsif ($op eq "-=") {
            if ($target_type == NODE_VARIABLE() && $cg->{"cleanup_enabled"} == 1) {
                emit($cg, "({ StradaValue *__old = ");
                gen_expression($cg, $target);
                emit($cg, "; ");
                gen_expression($cg, $target);
                emit($cg, " = strada_new_num(strada_to_num(__old) - strada_to_num(");
                gen_expression($cg, $expr->{"value"});
                emit($cg, ")); strada_decref(__old); ");
                gen_expression($cg, $target);
                emit($cg, "; })");
            } else {
                gen_expression($cg, $target);
                emit($cg, " = strada_new_num(strada_to_num(");
                gen_expression($cg, $target);
                emit($cg, ") - strada_to_num(");
                gen_expression($cg, $expr->{"value"});
                emit($cg, "))");
            }
            } elsif ($op eq ".=") {
            my scalar $rhs_val = $expr->{"value"};
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $rhs_val) == 1) {
                emit($cg, "({ StradaValue *__rhs_tmp = ");
                gen_expression($cg, $rhs_val);
                emit($cg, "; ");
                gen_expression($cg, $target);
                emit($cg, " = strada_concat_inplace(");
                gen_expression($cg, $target);
                emit($cg, ", __rhs_tmp); strada_decref(__rhs_tmp); ");
                gen_expression($cg, $target);
                emit($cg, "; })");
            } else {
                gen_expression($cg, $target);
                emit($cg, " = strada_concat_inplace(");
                gen_expression($cg, $target);
                emit($cg, ", ");
                gen_expression($cg, $rhs_val);
                emit($cg, ")");
            }
            }
        }
        return;
    }

    # Array subscript - use strada_deref_array to handle both direct arrays and refs
    if ($type == NODE_SUBSCRIPT()) {
        emit($cg, "strada_array_get(strada_deref_array(");
        gen_expression($cg, $expr->{"array"});
        emit($cg, "), ");
        emit_int_operand($cg, $expr->{"index"});
        emit($cg, ")");
        return;
    }
    
    # Hash access - use strada_hv_fetch_owned to return owned ref (fixes tied hash leak)
    if ($type == NODE_HASH_ACCESS()) {
        my scalar $key_expr = $expr->{"key"};
        my int $key_is_literal = $key_expr->{"type"} == NODE_STR_LITERAL();
        if ($key_is_literal == 1) {
            # Literal key - use directly without allocation
            emit($cg, "strada_hv_fetch_owned(");
            gen_expression($cg, $expr->{"hash"});
            emit($cg, ", ");
            gen_str_literal_c($cg, $key_expr->{"value"});
            emit($cg, ")");
        } else {
            # Expression key - wrap in statement expression for cleanup
            my int $key_needs_cleanup = needs_temp_cleanup($cg, $key_expr);
            emit($cg, "({ StradaValue *__hget_k = ");
            gen_expression($cg, $key_expr);
            emit($cg, "; char *__hget_ks = strada_to_str(__hget_k); ");
            emit($cg, "StradaValue *__hget_r = strada_hv_fetch_owned(");
            gen_expression($cg, $expr->{"hash"});
            emit($cg, ", __hget_ks); ");
            emit($cg, "free(__hget_ks); ");
            if ($key_needs_cleanup == 1) {
                emit($cg, "strada_decref(__hget_k); ");
            }
            emit($cg, "__hget_r; })");
        }
        return;
    }

    # Array slice: @arr[0, 2, 4] or @{$ref}[0, 1]
    if ($type == NODE_ARRAY_SLICE()) {
        my scalar $source = $expr->{"source"};
        my scalar $items = $expr->{"items"};
        my int $item_count = $expr->{"item_count"};

        emit($cg, "({ StradaValue *__slice_res = strada_new_array(); ");
        emit($cg, "StradaArray *__slice_src = strada_deref_array(");
        if ($source->{"type"} == NODE_DEREF_SCALAR()) {
            gen_expression($cg, $source->{"ref"});
        } else {
            gen_expression($cg, $source);
        }
        emit($cg, "); ");

        for (my int $i = 0; $i < $item_count; $i = $i + 1) {
            my scalar $item = $items->[$i];
            if ($item->{"type"} == NODE_RANGE()) {
                emit($cg, "for (int64_t __sl_i = ");
                emit_int_operand($cg, $item->{"start"});
                emit($cg, "; __sl_i <= ");
                emit_int_operand($cg, $item->{"end"});
                emit($cg, "; __sl_i++) { ");
                emit($cg, "strada_array_push(__slice_res->value.av, strada_array_get(__slice_src, __sl_i)); ");
                emit($cg, "} ");
            } else {
                emit($cg, "strada_array_push(__slice_res->value.av, strada_array_get(__slice_src, ");
                emit_int_operand($cg, $item);
                emit($cg, ")); ");
            }
        }

        emit($cg, "__slice_res; })");
        return;
    }

    # Hash slice: @hash{"a", "b"} or @{$ref}{"a", "b"}
    if ($type == NODE_HASH_SLICE()) {
        my scalar $source = $expr->{"source"};
        my scalar $items = $expr->{"items"};
        my int $item_count = $expr->{"item_count"};

        emit($cg, "({ StradaValue *__slice_res = strada_new_array(); ");
        emit($cg, "StradaHash *__slice_src = strada_deref_hash(");
        if ($source->{"type"} == NODE_DEREF_SCALAR()) {
            gen_expression($cg, $source->{"ref"});
        } else {
            gen_expression($cg, $source);
        }
        emit($cg, "); ");

        for (my int $i = 0; $i < $item_count; $i = $i + 1) {
            my scalar $item = $items->[$i];
            my int $key_is_literal = $item->{"type"} == NODE_STR_LITERAL();
            if ($key_is_literal == 1) {
                emit($cg, "strada_array_push(__slice_res->value.av, strada_hash_get(__slice_src, ");
                gen_str_literal_c($cg, $item->{"value"});
                emit($cg, ")); ");
            } else {
                my int $key_needs_cleanup = needs_temp_cleanup($cg, $item);
                emit($cg, "{ StradaValue *__sl_k = ");
                gen_expression($cg, $item);
                emit($cg, "; char *__sl_ks = strada_to_str(__sl_k); ");
                emit($cg, "strada_array_push(__slice_res->value.av, strada_hash_get(__slice_src, __sl_ks)); ");
                emit($cg, "free(__sl_ks); ");
                if ($key_needs_cleanup == 1) {
                    emit($cg, "strada_decref(__sl_k); ");
                }
                emit($cg, "} ");
            }
        }

        emit($cg, "__slice_res; })");
        return;
    }

    # Reference
    if ($type == NODE_REF()) {
        my str $ref_type = $expr->{"ref_type"};
        if ($ref_type eq "&") {
            # Function reference - use strada_cpointer_new
            emit($cg, "strada_cpointer_new((void*)");
            gen_expression($cg, $expr->{"target"});
            emit($cg, ")");
        } else {
            emit($cg, "strada_new_ref(");
            gen_expression($cg, $expr->{"target"});
            emit($cg, ", '");
            emit($cg, $ref_type);
            emit($cg, "')");
        }
        return;
    }
    
    # Hash dereference - use strada_hv_fetch_owned for owned ref (fixes tied hash leak)
    if ($type == NODE_DEREF_HASH()) {
        my scalar $key_expr = $expr->{"key"};
        my int $key_is_literal = $key_expr->{"type"} == NODE_STR_LITERAL();
        my int $ref_cleanup = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $expr->{"ref"}) == 1;
        if ($key_is_literal == 1) {
            if ($ref_cleanup == 1) {
                # Ref sub-expression is owned temp - capture and decref after fetch
                emit($cg, "({ StradaValue *__hd_ref = ");
                gen_expression($cg, $expr->{"ref"});
                emit($cg, "; StradaValue *__hd_res = strada_hv_fetch_owned(__hd_ref, ");
                gen_str_literal_c($cg, $key_expr->{"value"});
                emit($cg, "); strada_decref(__hd_ref); __hd_res; })");
            } else {
                # Literal key - use directly without allocation
                emit($cg, "strada_hv_fetch_owned(");
                gen_expression($cg, $expr->{"ref"});
                emit($cg, ", ");
                gen_str_literal_c($cg, $key_expr->{"value"});
                emit($cg, ")");
            }
        } else {
            # Expression key - wrap in statement expression for cleanup
            my int $key_needs_cleanup = needs_temp_cleanup($cg, $key_expr);
            emit($cg, "({ ");
            if ($ref_cleanup == 1) {
                emit($cg, "StradaValue *__hd_ref = ");
                gen_expression($cg, $expr->{"ref"});
                emit($cg, "; ");
            }
            emit($cg, "StradaValue *__hget_k = ");
            gen_expression($cg, $key_expr);
            emit($cg, "; char *__hget_ks = strada_to_str(__hget_k); ");
            emit($cg, "StradaValue *__hget_r = strada_hv_fetch_owned(");
            if ($ref_cleanup == 1) {
                emit($cg, "__hd_ref");
            } else {
                gen_expression($cg, $expr->{"ref"});
            }
            emit($cg, ", __hget_ks); ");
            emit($cg, "free(__hget_ks); ");
            if ($key_needs_cleanup == 1) {
                emit($cg, "strada_decref(__hget_k); ");
            }
            if ($ref_cleanup == 1) {
                emit($cg, "strada_decref(__hd_ref); ");
            }
            emit($cg, "__hget_r; })");
        }
        return;
    }

    # Array dereference
    if ($type == NODE_DEREF_ARRAY()) {
        emit($cg, "strada_array_get(strada_deref_array(");
        gen_expression($cg, $expr->{"ref"});
        emit($cg, "), ");
        emit_int_operand($cg, $expr->{"index"});
        emit($cg, ")");
        return;
    }
    
    # Scalar/Array/Hash dereference (@{}, %{}, $$)
    if ($type == NODE_DEREF_SCALAR()) {
        my str $sigil = $expr->{"sigil"};
        my int $inner_cleanup = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $expr->{"ref"}) == 1;
        if ($inner_cleanup == 1) {
            # Inner expression returns owned ref - capture and decref after deref
            emit($cg, "({ StradaValue *__dtmp = ");
            gen_expression($cg, $expr->{"ref"});
            if ($sigil eq "@") {
                emit($cg, "; StradaValue *__dres = strada_deref_array_value(__dtmp); ");
            } elsif ($sigil eq "%") {
                emit($cg, "; StradaValue *__dres = strada_deref_hash_value(__dtmp); ");
            } else {
                emit($cg, "; StradaValue *__dres = strada_deref(__dtmp); ");
            }
            emit($cg, "strada_decref(__dtmp); __dres; })");
        } else {
            if ($sigil eq "@") {
                emit($cg, "strada_deref_array_value(");
            } elsif ($sigil eq "%") {
                emit($cg, "strada_deref_hash_value(");
            } else {
                emit($cg, "strada_deref(");
            }
            gen_expression($cg, $expr->{"ref"});
            emit($cg, ")");
        }
        return;
    }
    
    # Field access (obj->field)
    if ($type == NODE_FIELD_ACCESS()) {
        gen_expression($cg, $expr->{"object"});
        emit($cg, "->" . $expr->{"field"});
        return;
    }
    
    # Function reference (&func_name)
    if ($type == NODE_FUNC_REF()) {
        emit($cg, "&" . $expr->{"name"});
        return;
    }
    
    # Method call ($obj->method(args)) - Perl-style blessed reference method dispatch
    if ($type == NODE_METHOD_CALL()) {
        my int $arg_count = $expr->{"arg_count"};
        my str $method = $expr->{"method"};
        my scalar $obj = $expr->{"object"};

        {
            # OOP method call - use base_object (the original object, not field access)
            # Generate: strada_method_call(obj, "method", strada_pack_args(count, arg1, arg2, ...))

            my scalar $args = $expr->{"args"};

            # Determine effective object expression and whether it needs cleanup
            my scalar $meth_target = $expr->{"base_object"};
            if (!$meth_target) {
                $meth_target = $obj;
            }
            my int $meth_obj_cleanup = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $meth_target) == 1;

            # Check if any argument has spread operator
            my int $has_spread = 0;
            for (my int $sa = 0; $sa < $arg_count; $sa = $sa + 1) {
                if ($args->[$sa]->{"type"} == NODE_SPREAD()) {
                    $has_spread = 1;
                }
            }

            if ($has_spread == 1) {
                # Build args array dynamically with spread support
                emit($cg, "({ ");
                if ($meth_obj_cleanup == 1) {
                    emit($cg, "StradaValue *__meth_obj = ");
                    gen_expression($cg, $meth_target);
                    emit($cg, "; ");
                }
                emit($cg, "StradaValue *__method_args = strada_new_array(); ");

                my int $a = 0;
                while ($a < $arg_count) {
                    my scalar $arg = $args->[$a];
                    if ($arg->{"type"} == NODE_SPREAD()) {
                        # Spread: iterate array and push elements
                        emit($cg, "{ StradaValue *__spread = ");
                        gen_expression($cg, $arg->{"target"});
                        emit($cg, "; StradaArray *__sa = strada_deref_array(__spread); ");
                        emit($cg, "if (__sa) { for (size_t __si = 0; __si < __sa->size; __si++) { ");
                        emit($cg, "strada_array_push(strada_deref_array(__method_args), __sa->elements[__si]); ");
                        emit($cg, "strada_incref(__sa->elements[__si]); } } } ");
                    } else {
                        # Regular arg: push to array
                        emit($cg, "strada_array_push(strada_deref_array(__method_args), ");
                        gen_expression($cg, $arg);
                        emit($cg, "); ");
                    }
                    $a = $a + 1;
                }

                emit($cg, "StradaValue *__meth_res = strada_method_call(");
                if ($meth_obj_cleanup == 1) {
                    emit($cg, "__meth_obj");
                } else {
                    gen_expression($cg, $meth_target);
                }
                emit($cg, ", \"" . $method . "\", __method_args); ");
                if ($meth_obj_cleanup == 1) {
                    emit($cg, "strada_decref(__meth_obj); ");
                }
                emit($cg, "__meth_res; })");
            } else {
                # No spread - use regular strada_pack_args
                # Check if any args need temp cleanup
                my int $needs_arg_cleanup = 0;
                if ($cg->{"cleanup_enabled"} == 1) {
                    my int $c = 0;
                    while ($c < $arg_count) {
                        if (needs_temp_cleanup($cg, $args->[$c]) == 1) {
                            $needs_arg_cleanup = 1;
                        }
                        $c = $c + 1;
                    }
                }

                if ($needs_arg_cleanup == 1) {
                    # Capture temp args, call method, decref temps and pack_args
                    emit($cg, "({ ");
                    if ($meth_obj_cleanup == 1) {
                        emit($cg, "StradaValue *__meth_obj = ");
                        gen_expression($cg, $meth_target);
                        emit($cg, "; ");
                    }
                    my int $a = 0;
                    while ($a < $arg_count) {
                        if (needs_temp_cleanup($cg, $args->[$a]) == 1) {
                            emit($cg, "StradaValue *__meth_arg_" . $a . " = ");
                            gen_expression($cg, $args->[$a]);
                            emit($cg, "; ");
                        }
                        $a = $a + 1;
                    }
                    emit($cg, "StradaValue *__meth_pa = strada_pack_args(" . $arg_count);
                    my int $i = 0;
                    while ($i < $arg_count) {
                        emit($cg, ", ");
                        if (needs_temp_cleanup($cg, $args->[$i]) == 1) {
                            emit($cg, "__meth_arg_" . $i);
                        } else {
                            gen_expression($cg, $args->[$i]);
                        }
                        $i = $i + 1;
                    }
                    emit($cg, "); ");
                    emit($cg, "StradaValue *__meth_res = strada_method_call(");
                    if ($meth_obj_cleanup == 1) {
                        emit($cg, "__meth_obj");
                    } else {
                        gen_expression($cg, $meth_target);
                    }
                    emit($cg, ", \"" . $method . "\", __meth_pa); ");
                    if ($meth_obj_cleanup == 1) {
                        emit($cg, "strada_decref(__meth_obj); ");
                    }
                    my int $d = 0;
                    while ($d < $arg_count) {
                        if (needs_temp_cleanup($cg, $args->[$d]) == 1) {
                            emit($cg, "strada_decref(__meth_arg_" . $d . "); ");
                        }
                        $d = $d + 1;
                    }
                    emit($cg, "__meth_res; })");
                } elsif ($arg_count == 0) {
                    # Zero args - pass NULL instead of allocating empty pack_args
                    if ($meth_obj_cleanup == 1) {
                        emit($cg, "({ StradaValue *__meth_obj = ");
                        gen_expression($cg, $meth_target);
                        emit($cg, "; StradaValue *__meth_res = strada_method_call(__meth_obj, \"" . $method . "\", NULL); ");
                        emit($cg, "strada_decref(__meth_obj); __meth_res; })");
                    } else {
                        emit($cg, "strada_method_call(");
                        gen_expression($cg, $meth_target);
                        emit($cg, ", \"" . $method . "\", NULL)");
                    }
                } else {
                    # Has args but no temp cleanup needed - use pack_args
                    emit($cg, "({ ");
                    if ($meth_obj_cleanup == 1) {
                        emit($cg, "StradaValue *__meth_obj = ");
                        gen_expression($cg, $meth_target);
                        emit($cg, "; ");
                    }
                    emit($cg, "StradaValue *__meth_pa = strada_pack_args(" . $arg_count);
                    my int $i = 0;
                    while ($i < $arg_count) {
                        emit($cg, ", ");
                        gen_expression($cg, $args->[$i]);
                        $i = $i + 1;
                    }
                    emit($cg, "); StradaValue *__meth_res = strada_method_call(");
                    if ($meth_obj_cleanup == 1) {
                        emit($cg, "__meth_obj");
                    } else {
                        gen_expression($cg, $meth_target);
                    }
                    emit($cg, ", \"" . $method . "\", __meth_pa); ");
                    if ($meth_obj_cleanup == 1) {
                        emit($cg, "strada_decref(__meth_obj); ");
                    }
                    emit($cg, "__meth_res; })");
                }
            }
        }
        return;
    }

    # Dynamic method call: $obj->$method(args)
    if ($type == NODE_DYN_METHOD_CALL()) {
        my int $dm_arg_count = $expr->{"arg_count"};
        my scalar $dm_base = $expr->{"base_object"};
        my scalar $dm_meth_expr = $expr->{"method_expr"};
        my scalar $dm_args = $expr->{"args"};

        # Check if any argument has spread operator
        my int $dm_has_spread = 0;
        for (my int $dm_sa = 0; $dm_sa < $dm_arg_count; $dm_sa = $dm_sa + 1) {
            if ($dm_args->[$dm_sa]->{"type"} == NODE_SPREAD()) {
                $dm_has_spread = 1;
            }
        }

        if ($dm_has_spread == 1) {
            # Build args array dynamically with spread support
            emit($cg, "({ StradaValue *__dm_mval = ");
            gen_expression($cg, $dm_meth_expr);
            emit($cg, "; char *__dm_mname = strada_to_str(__dm_mval); ");
            emit($cg, "StradaValue *__dm_pa = strada_new_array(); ");

            my int $dm_a = 0;
            while ($dm_a < $dm_arg_count) {
                my scalar $dm_arg = $dm_args->[$dm_a];
                if ($dm_arg->{"type"} == NODE_SPREAD()) {
                    emit($cg, "{ StradaValue *__dm_spread = ");
                    gen_expression($cg, $dm_arg->{"target"});
                    emit($cg, "; StradaArray *__dm_sa = strada_deref_array(__dm_spread); ");
                    emit($cg, "if (__dm_sa) { for (size_t __dm_si = 0; __dm_si < __dm_sa->size; __dm_si++) { ");
                    emit($cg, "strada_array_push(strada_deref_array(__dm_pa), __dm_sa->elements[__dm_si]); ");
                    emit($cg, "strada_incref(__dm_sa->elements[__dm_si]); } } } ");
                } else {
                    emit($cg, "strada_array_push(strada_deref_array(__dm_pa), ");
                    gen_expression($cg, $dm_arg);
                    emit($cg, "); ");
                }
                $dm_a = $dm_a + 1;
            }

            emit($cg, "StradaValue *__dm_res = strada_method_call(");
            gen_expression($cg, $dm_base);
            emit($cg, ", __dm_mname, __dm_pa); free(__dm_mname); ");
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $dm_meth_expr) == 1) {
                emit($cg, "strada_decref(__dm_mval); ");
            }
            emit($cg, "__dm_res; })");
        } else {
            # No spread - use regular strada_pack_args
            # Check if any args need temp cleanup
            my int $dm_needs_arg_cleanup = 0;
            if ($cg->{"cleanup_enabled"} == 1) {
                my int $dm_c = 0;
                while ($dm_c < $dm_arg_count) {
                    if (needs_temp_cleanup($cg, $dm_args->[$dm_c]) == 1) {
                        $dm_needs_arg_cleanup = 1;
                    }
                    $dm_c = $dm_c + 1;
                }
            }

            emit($cg, "({ StradaValue *__dm_mval = ");
            gen_expression($cg, $dm_meth_expr);
            emit($cg, "; char *__dm_mname = strada_to_str(__dm_mval); ");

            if ($dm_needs_arg_cleanup == 1) {
                # Capture temp args
                my int $dm_a2 = 0;
                while ($dm_a2 < $dm_arg_count) {
                    if (needs_temp_cleanup($cg, $dm_args->[$dm_a2]) == 1) {
                        emit($cg, "StradaValue *__dm_arg_" . $dm_a2 . " = ");
                        gen_expression($cg, $dm_args->[$dm_a2]);
                        emit($cg, "; ");
                    }
                    $dm_a2 = $dm_a2 + 1;
                }
                emit($cg, "StradaValue *__dm_pa = strada_pack_args(" . $dm_arg_count);
                my int $dm_i = 0;
                while ($dm_i < $dm_arg_count) {
                    emit($cg, ", ");
                    if (needs_temp_cleanup($cg, $dm_args->[$dm_i]) == 1) {
                        emit($cg, "__dm_arg_" . $dm_i);
                    } else {
                        gen_expression($cg, $dm_args->[$dm_i]);
                    }
                    $dm_i = $dm_i + 1;
                }
                emit($cg, "); ");
                emit($cg, "StradaValue *__dm_res = strada_method_call(");
                gen_expression($cg, $dm_base);
                emit($cg, ", __dm_mname, __dm_pa); ");
                my int $dm_d = 0;
                while ($dm_d < $dm_arg_count) {
                    if (needs_temp_cleanup($cg, $dm_args->[$dm_d]) == 1) {
                        emit($cg, "strada_decref(__dm_arg_" . $dm_d . "); ");
                    }
                    $dm_d = $dm_d + 1;
                }
                emit($cg, "free(__dm_mname); ");
                if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $dm_meth_expr) == 1) {
                    emit($cg, "strada_decref(__dm_mval); ");
                }
                emit($cg, "__dm_res; })");
            } else {
                # No temp args
                emit($cg, "StradaValue *__dm_pa = strada_pack_args(" . $dm_arg_count);
                my int $dm_i2 = 0;
                while ($dm_i2 < $dm_arg_count) {
                    emit($cg, ", ");
                    gen_expression($cg, $dm_args->[$dm_i2]);
                    $dm_i2 = $dm_i2 + 1;
                }
                emit($cg, "); StradaValue *__dm_res = strada_method_call(");
                gen_expression($cg, $dm_base);
                emit($cg, ", __dm_mname, __dm_pa); free(__dm_mname); ");
                if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $dm_meth_expr) == 1) {
                    emit($cg, "strada_decref(__dm_mval); ");
                }
                emit($cg, "__dm_res; })");
            }
        }
        return;
    }

    # SUPER::method($self, args...) - calls parent method
    if ($type == NODE_SUPER_CALL()) {
        my int $arg_count = $expr->{"arg_count"};
        my str $method = $expr->{"method"};
        my scalar $args = $expr->{"args"};

        # SUPER::method requires at least one argument (the object/self)
        if ($arg_count < 1) {
            emit($cg, "strada_new_undef() /* SUPER call requires self argument */");
            return;
        }

        # Generate: ({ StradaValue *__pa = strada_pack_args(remaining...); StradaValue *__r = strada_super_call(self, pkg, method, __pa); strada_decref(__pa); __r; })
        my int $remaining = $arg_count - 1;
        emit($cg, "({ StradaValue *__super_pa = strada_pack_args(");
        emit($cg, "" . $remaining);
        my int $i = 1;
        while ($i < $arg_count) {
            emit($cg, ", ");
            gen_expression($cg, $args->[$i]);
            $i = $i + 1;
        }
        emit($cg, "); StradaValue *__super_res = strada_super_call(");
        gen_expression($cg, $args->[0]);
        my str $fn_pkg = $cg->{"current_fn_package"};
        emit($cg, ", \"" . $fn_pkg . "\", \"" . $method . "\", __super_pa); __super_res; })");
        return;
    }

    # $1-$9 capture variables
    if ($type == NODE_CAPTURE_VAR()) {
        emit($cg, "strada_capture_var(");
        emit($cg, "" . $expr->{"number"});
        emit($cg, ")");
        return;
    }

    # __PACKAGE__ - returns current package name
    if ($type == NODE_DUNDER_PACKAGE()) {
        emit($cg, "strada_new_str(strada_current_package() ? strada_current_package() : \"\")");
        return;
    }

    # __FILE__ - returns current file name
    if ($type == NODE_DUNDER_FILE()) {
        my str $filename = $cg->{"filename"};
        emit($cg, "strada_new_str(\"" . $filename . "\")");
        return;
    }

    # __LINE__ - returns current line number
    if ($type == NODE_DUNDER_LINE()) {
        my int $line = $expr->{"line_value"};
        emit($cg, "strada_new_int(" . $line . ")");
        return;
    }

    # Anonymous hash
    if ($type == NODE_ANON_HASH()) {
        my scalar $keys = $expr->{"keys"};
        my scalar $values = $expr->{"values"};
        my scalar $key_exprs = $expr->{"key_exprs"};
        my int $pair_count = $expr->{"pair_count"};

        # Check if any keys are expressions (dynamic keys)
        my int $has_expr_keys = 0;
        my int $check_k = 0;
        while ($check_k < $pair_count) {
            if ($key_exprs && $key_exprs->[$check_k]) {
                $has_expr_keys = 1;
            }
            $check_k = $check_k + 1;
        }

        # Check if any values need temp cleanup (newly created values)
        my int $needs_val_cleanup = 0;
        my int $check_i = 0;
        while ($check_i < $pair_count) {
            if (needs_temp_cleanup($cg, $values->[$check_i]) == 1) {
                $needs_val_cleanup = 1;
            }
            $check_i = $check_i + 1;
        }

        if ($has_expr_keys == 1) {
            # Has expression keys - build hash manually
            emit($cg, "({ StradaValue *__ah_hash = strada_new_hash(); ");
            my int $e = 0;
            while ($e < $pair_count) {
                if ($key_exprs && $key_exprs->[$e]) {
                    # Expression key - use strada_to_str
                    emit($cg, "{ char *__ah_k" . $e . " = strada_to_str(");
                    gen_expression($cg, $key_exprs->[$e]);
                    emit($cg, "); strada_hash_set(__ah_hash->value.hv, __ah_k" . $e . ", ");
                    gen_expression($cg, $values->[$e]);
                    emit($cg, "); free(__ah_k" . $e . "); } ");
                } else {
                    # String key
                    emit($cg, "strada_hash_set(__ah_hash->value.hv, \"" . $keys->[$e] . "\", ");
                    gen_expression($cg, $values->[$e]);
                    emit($cg, "); ");
                }
                $e = $e + 1;
            }
            emit($cg, "__ah_hash; })");
        } elsif ($needs_val_cleanup == 1 && $cg->{"cleanup_enabled"} == 1) {
            # Generate block with temps for values that need cleanup
            emit($cg, "({ ");

            # Create temps for values that need cleanup
            # For anonymous arrays/hashes, use explicit new + new_ref pattern to avoid heap corruption
            my int $t = 0;
            while ($t < $pair_count) {
                if (needs_temp_cleanup($cg, $values->[$t]) == 1) {
                    my scalar $val = $values->[$t];
                    if ($val->{"type"} == NODE_ANON_ARRAY()) {
                        # Anonymous array: create explicit array + ref pattern
                        # This avoids the strada_ref_create_take issue that can cause heap corruption
                        my scalar $elems = $val->{"elements"};
                        my int $elem_count = $val->{"element_count"};
                        emit($cg, "StradaValue *__ah_arr" . $t . " = strada_new_array(); ");
                        # Add elements with proper refcount management
                        my int $e = 0;
                        while ($e < $elem_count) {
                            emit($cg, "StradaValue *__ah_ael" . $t . "_" . $e . " = ");
                            gen_expression($cg, $elems->[$e]);
                            emit($cg, "; strada_array_push(__ah_arr" . $t . "->value.av, __ah_ael" . $t . "_" . $e . "); ");
                            emit($cg, "strada_decref(__ah_ael" . $t . "_" . $e . "); ");
                            $e = $e + 1;
                        }
                        emit($cg, "StradaValue *__ah_val" . $t . " = strada_new_ref(__ah_arr" . $t . ", '@'); ");
                    } elsif ($val->{"type"} == NODE_ANON_HASH()) {
                        # Anonymous hash: create explicit hash + ref pattern
                        # This avoids the strada_ref_create_take issue that can cause heap corruption
                        my scalar $inner_keys = $val->{"keys"};
                        my scalar $inner_values = $val->{"values"};
                        my int $inner_pair_count = $val->{"pair_count"};
                        emit($cg, "StradaValue *__ah_hsh" . $t . " = strada_new_hash(); ");
                        # Add key-value pairs with proper refcount management
                        my int $p = 0;
                        while ($p < $inner_pair_count) {
                            emit($cg, "StradaValue *__ah_hel" . $t . "_" . $p . " = ");
                            gen_expression($cg, $inner_values->[$p]);
                            emit($cg, "; strada_hash_set(__ah_hsh" . $t . "->value.hv, \"" . $inner_keys->[$p] . "\", __ah_hel" . $t . "_" . $p . "); ");
                            emit($cg, "strada_decref(__ah_hel" . $t . "_" . $p . "); ");
                            $p = $p + 1;
                        }
                        emit($cg, "StradaValue *__ah_val" . $t . " = strada_new_ref(__ah_hsh" . $t . ", '%'); ");
                    } else {
                        emit($cg, "StradaValue *__ah_val" . $t . " = ");
                        gen_expression($cg, $val);
                        emit($cg, "; ");
                    }
                }
                $t = $t + 1;
            }

            # Create the hash
            emit($cg, "StradaValue *__ah_hash = strada_anon_hash(" . $pair_count);
            my int $a = 0;
            while ($a < $pair_count) {
                emit($cg, ", \"" . $keys->[$a] . "\", ");
                if (needs_temp_cleanup($cg, $values->[$a]) == 1) {
                    emit($cg, "__ah_val" . $a);
                } else {
                    gen_expression($cg, $values->[$a]);
                }
                $a = $a + 1;
            }
            emit($cg, "); ");

            # Decref temps to balance the incref from strada_hash_set
            # For anonymous arrays/hashes, also decref the underlying container
            my int $d = 0;
            while ($d < $pair_count) {
                if (needs_temp_cleanup($cg, $values->[$d]) == 1) {
                    my scalar $val = $values->[$d];
                    if ($val->{"type"} == NODE_ANON_ARRAY()) {
                        # Decref both the ref and the underlying array
                        emit($cg, "strada_decref(__ah_arr" . $d . "); ");
                    } elsif ($val->{"type"} == NODE_ANON_HASH()) {
                        # Decref both the ref and the underlying hash
                        emit($cg, "strada_decref(__ah_hsh" . $d . "); ");
                    }
                    emit($cg, "strada_decref(__ah_val" . $d . "); ");
                }
                $d = $d + 1;
            }

            # Return the hash
            emit($cg, "__ah_hash; })");
        } else {
            # Simple generation - no cleanup needed
            emit($cg, "strada_anon_hash(" . $pair_count);
            my int $i = 0;
            while ($i < $pair_count) {
                emit($cg, ", \"" . $keys->[$i] . "\", ");
                gen_expression($cg, $values->[$i]);
                $i = $i + 1;
            }
            emit($cg, ")");
        }
        return;
    }
    
    # Anonymous array
    if ($type == NODE_ANON_ARRAY()) {
        my scalar $elems = $expr->{"elements"};
        my int $elem_count = $expr->{"element_count"};

        # Check if any elements need temp cleanup (newly created values)
        my int $needs_elem_cleanup = 0;
        my int $check_i = 0;
        while ($check_i < $elem_count) {
            if (needs_temp_cleanup($cg, $elems->[$check_i]) == 1) {
                $needs_elem_cleanup = 1;
            }
            $check_i = $check_i + 1;
        }

        if ($needs_elem_cleanup == 1 && $cg->{"cleanup_enabled"} == 1) {
            # Generate block with temps for elements that need cleanup
            # This ensures newly created values are decreffed after array creation
            # since strada_array_push increfs them (to handle existing variables)
            emit($cg, "({ ");

            # Create temps for elements that need cleanup
            # For anonymous arrays/hashes, use explicit new + new_ref pattern to avoid heap corruption
            my int $t = 0;
            while ($t < $elem_count) {
                if (needs_temp_cleanup($cg, $elems->[$t]) == 1) {
                    my scalar $elem = $elems->[$t];
                    if ($elem->{"type"} == NODE_ANON_ARRAY()) {
                        # Anonymous array: create explicit array + ref pattern
                        my scalar $inner_elems = $elem->{"elements"};
                        my int $inner_elem_count = $elem->{"element_count"};
                        emit($cg, "StradaValue *__aa_arr" . $t . " = strada_new_array(); ");
                        # Create temps for inner elements, push, then decref
                        my int $e = 0;
                        while ($e < $inner_elem_count) {
                            emit($cg, "StradaValue *__aa_inner" . $t . "_" . $e . " = ");
                            gen_expression($cg, $inner_elems->[$e]);
                            emit($cg, "; strada_array_push(__aa_arr" . $t . "->value.av, __aa_inner" . $t . "_" . $e . "); ");
                            emit($cg, "strada_decref(__aa_inner" . $t . "_" . $e . "); ");
                            $e = $e + 1;
                        }
                        emit($cg, "StradaValue *__aa_el" . $t . " = strada_new_ref(__aa_arr" . $t . ", '@'); ");
                    } elsif ($elem->{"type"} == NODE_ANON_HASH()) {
                        # Anonymous hash: create explicit hash + ref pattern
                        my scalar $inner_keys = $elem->{"keys"};
                        my scalar $inner_values = $elem->{"values"};
                        my int $inner_pair_count = $elem->{"pair_count"};
                        emit($cg, "StradaValue *__aa_hsh" . $t . " = strada_new_hash(); ");
                        # Create temps for inner values, set, then decref
                        my int $p = 0;
                        while ($p < $inner_pair_count) {
                            emit($cg, "StradaValue *__aa_hval" . $t . "_" . $p . " = ");
                            gen_expression($cg, $inner_values->[$p]);
                            emit($cg, "; strada_hash_set(__aa_hsh" . $t . "->value.hv, \"" . $inner_keys->[$p] . "\", __aa_hval" . $t . "_" . $p . "); ");
                            emit($cg, "strada_decref(__aa_hval" . $t . "_" . $p . "); ");
                            $p = $p + 1;
                        }
                        emit($cg, "StradaValue *__aa_el" . $t . " = strada_new_ref(__aa_hsh" . $t . ", '%'); ");
                    } else {
                        emit($cg, "StradaValue *__aa_el" . $t . " = ");
                        gen_expression($cg, $elem);
                        emit($cg, "; ");
                    }
                }
                $t = $t + 1;
            }

            # Create the array
            emit($cg, "StradaValue *__aa_arr = strada_anon_array(" . $elem_count);
            my int $a = 0;
            while ($a < $elem_count) {
                emit($cg, ", ");
                if (needs_temp_cleanup($cg, $elems->[$a]) == 1) {
                    emit($cg, "__aa_el" . $a);
                } else {
                    gen_expression($cg, $elems->[$a]);
                }
                $a = $a + 1;
            }
            emit($cg, "); ");

            # Decref temps to balance the incref from strada_array_push
            # For anonymous arrays/hashes, also decref the underlying container
            my int $d = 0;
            while ($d < $elem_count) {
                if (needs_temp_cleanup($cg, $elems->[$d]) == 1) {
                    my scalar $elem = $elems->[$d];
                    if ($elem->{"type"} == NODE_ANON_ARRAY()) {
                        emit($cg, "strada_decref(__aa_arr" . $d . "); ");
                    } elsif ($elem->{"type"} == NODE_ANON_HASH()) {
                        emit($cg, "strada_decref(__aa_hsh" . $d . "); ");
                    }
                    emit($cg, "strada_decref(__aa_el" . $d . "); ");
                }
                $d = $d + 1;
            }

            # Return the array
            emit($cg, "__aa_arr; })");
        } else {
            # Simple generation - no cleanup needed
            emit($cg, "strada_anon_array(" . $elem_count);
            my int $i = 0;
            while ($i < $elem_count) {
                emit($cg, ", ");
                gen_expression($cg, $elems->[$i]);
                $i = $i + 1;
            }
            emit($cg, ")");
        }
        return;
    }

    # Map expression: map { block } @array
    if ($type == NODE_MAP()) {
        my scalar $block = $expr->{"block"};
        my scalar $array_expr = $expr->{"array"};
        my int $map_id = $cg->{"map_counter"};
        $cg->{"map_counter"} = $map_id + 1;

        my int $map_arr_cleanup = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $array_expr) == 1;
        emit($cg, "({ ");
        if ($map_arr_cleanup == 1) {
            emit($cg, "StradaValue *__map_sv_" . $map_id . " = ");
            gen_expression($cg, $array_expr);
            emit($cg, "; StradaArray *__map_input_" . $map_id . " = strada_deref_array(__map_sv_" . $map_id . "); ");
        } else {
            emit($cg, "StradaArray *__map_input_" . $map_id . " = strada_deref_array(");
            gen_expression($cg, $array_expr);
            emit($cg, "); ");
        }
        emit($cg, "StradaValue *__map_result_" . $map_id . " = strada_new_array(); ");
        emit($cg, "int __map_len_" . $map_id . " = strada_array_length(__map_input_" . $map_id . "); ");
        emit($cg, "for (int __map_i_" . $map_id . " = 0; __map_i_" . $map_id . " < __map_len_" . $map_id . "; __map_i_" . $map_id . "++) { ");
        emit($cg, "StradaValue *__elem_ = strada_array_get(__map_input_" . $map_id . ", __map_i_" . $map_id . "); ");

        # Set flag to enable $_ magic variable
        $cg->{"in_map_block"} = 1;

        # Generate block - the last statement's expression is the result
        my scalar $stmts = $block->{"statements"};
        my int $stmt_count = $block->{"statement_count"};
        if ($stmt_count > 0) {
            # Handle all but last statement normally
            my int $i = 0;
            while ($i < $stmt_count - 1) {
                gen_statement($cg, $stmts->[$i]);
                $i = $i + 1;
            }
            # Last statement - extract its expression for the result
            # Flatten arrays for map { $_ => 1 } idiom
            my scalar $last_stmt = $stmts->[$stmt_count - 1];
            if ($last_stmt->{"type"} == NODE_EXPR_STMT()) {
                emit($cg, "{ StradaValue *__map_elem_" . $map_id . " = ");
                gen_expression($cg, $last_stmt->{"expr"});
                emit($cg, "; ");
                # Handle both STRADA_ARRAY and STRADA_REF to array (from strada_anon_array)
                emit($cg, "StradaValue *__flat_val_" . $map_id . " = __map_elem_" . $map_id . "; ");
                emit($cg, "if (__flat_val_" . $map_id . " && __flat_val_" . $map_id . "->type == STRADA_REF) { ");
                emit($cg, "__flat_val_" . $map_id . " = __flat_val_" . $map_id . "->value.rv; } ");
                emit($cg, "if (__flat_val_" . $map_id . " && __flat_val_" . $map_id . "->type == STRADA_ARRAY) { ");
                emit($cg, "StradaArray *__flat_arr_" . $map_id . " = __flat_val_" . $map_id . "->value.av; ");
                emit($cg, "for (size_t __flat_j_" . $map_id . " = 0; __flat_j_" . $map_id . " < __flat_arr_" . $map_id . "->size; __flat_j_" . $map_id . "++) { ");
                emit($cg, "strada_array_push(__map_result_" . $map_id . "->value.av, __flat_arr_" . $map_id . "->elements[__flat_j_" . $map_id . "]); } ");
                emit($cg, "strada_decref(__map_elem_" . $map_id . "); ");
                emit($cg, "} else { ");
                emit($cg, "strada_array_push(__map_result_" . $map_id . "->value.av, __map_elem_" . $map_id . "); strada_decref(__map_elem_" . $map_id . "); } } ");
            }
        }

        # Reset flag
        $cg->{"in_map_block"} = 0;

        emit($cg, "} ");
        if ($map_arr_cleanup == 1) {
            emit($cg, "strada_decref(__map_sv_" . $map_id . "); ");
        }
        emit($cg, "__map_result_" . $map_id . "; })");
        return;
    }

    # Sort expression: sort { $a <=> $b } @array
    if ($type == NODE_SORT()) {
        my scalar $block = $expr->{"block"};
        my scalar $array_expr = $expr->{"array"};

        # Default sort (no block)
        if (!$block) {
            if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $array_expr) == 1) {
                emit($cg, "({ StradaValue *__sort_a = ");
                gen_expression($cg, $array_expr);
                emit($cg, "; StradaValue *__sort_r = strada_sort(__sort_a); strada_decref(__sort_a); __sort_r; })");
            } else {
                emit($cg, "strada_sort(");
                gen_expression($cg, $array_expr);
                emit($cg, ")");
            }
            return;
        }

        # Custom sort with comparator block
        my int $sort_id = $cg->{"sort_counter"};
        $cg->{"sort_counter"} = $sort_id + 1;

        my int $sort_blk_cleanup = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $array_expr) == 1;
        emit($cg, "({ ");
        if ($sort_blk_cleanup == 1) {
            emit($cg, "StradaValue *__sort_sv_" . $sort_id . " = ");
            gen_expression($cg, $array_expr);
            emit($cg, "; StradaArray *__sort_input_" . $sort_id . " = strada_deref_array(__sort_sv_" . $sort_id . "); ");
        } else {
            emit($cg, "StradaArray *__sort_input_" . $sort_id . " = strada_deref_array(");
            gen_expression($cg, $array_expr);
            emit($cg, "); ");
        }
        emit($cg, "int __sort_len_" . $sort_id . " = strada_array_length(__sort_input_" . $sort_id . "); ");
        emit($cg, "StradaValue *__sort_result_" . $sort_id . " = strada_new_array(); ");
        # Copy elements to result
        emit($cg, "for (int __si_" . $sort_id . " = 0; __si_" . $sort_id . " < __sort_len_" . $sort_id . "; __si_" . $sort_id . "++) { ");
        emit($cg, "strada_array_push(strada_deref_array(__sort_result_" . $sort_id . "), strada_array_get(__sort_input_" . $sort_id . ", __si_" . $sort_id . ")); } ");
        # Bubble sort with custom comparator (simple implementation)
        emit($cg, "for (int __i_" . $sort_id . " = 0; __i_" . $sort_id . " < __sort_len_" . $sort_id . " - 1; __i_" . $sort_id . "++) { ");
        emit($cg, "for (int __j_" . $sort_id . " = 0; __j_" . $sort_id . " < __sort_len_" . $sort_id . " - __i_" . $sort_id . " - 1; __j_" . $sort_id . "++) { ");
        emit($cg, "StradaValue *__sort_a_ = strada_array_get(strada_deref_array(__sort_result_" . $sort_id . "), __j_" . $sort_id . "); ");
        emit($cg, "StradaValue *__sort_b_ = strada_array_get(strada_deref_array(__sort_result_" . $sort_id . "), __j_" . $sort_id . " + 1); ");
        emit($cg, "StradaValue *__cmp_sv_" . $sort_id . " = ");

        # Set flag to enable $a/$b magic variables
        $cg->{"in_sort_block"} = 1;

        # Generate comparator block - extract the comparison expression
        my scalar $stmts = $block->{"statements"};
        my int $stmt_count = $block->{"statement_count"};
        if ($stmt_count > 0) {
            my scalar $last_stmt = $stmts->[$stmt_count - 1];
            if ($last_stmt->{"type"} == NODE_EXPR_STMT()) {
                gen_expression($cg, $last_stmt->{"expr"});
            }
        }

        # Reset flag
        $cg->{"in_sort_block"} = 0;

        emit($cg, "; int __cmp_" . $sort_id . " = strada_to_int(__cmp_sv_" . $sort_id . "); strada_decref(__cmp_sv_" . $sort_id . "); ");
        emit($cg, "if (__cmp_" . $sort_id . " > 0) { ");
        emit($cg, "StradaValue *__tmp_" . $sort_id . " = strada_array_get(strada_deref_array(__sort_result_" . $sort_id . "), __j_" . $sort_id . "); ");
        emit($cg, "strada_array_set(strada_deref_array(__sort_result_" . $sort_id . "), __j_" . $sort_id . ", strada_array_get(strada_deref_array(__sort_result_" . $sort_id . "), __j_" . $sort_id . " + 1)); ");
        emit($cg, "strada_array_set(strada_deref_array(__sort_result_" . $sort_id . "), __j_" . $sort_id . " + 1, __tmp_" . $sort_id . "); ");
        emit($cg, "} } } ");
        if ($sort_blk_cleanup == 1) {
            emit($cg, "strada_decref(__sort_sv_" . $sort_id . "); ");
        }
        emit($cg, "__sort_result_" . $sort_id . "; })");
        return;
    }

    # Grep expression: grep { block } @array
    if ($type == NODE_GREP()) {
        my scalar $block = $expr->{"block"};
        my scalar $array_expr = $expr->{"array"};
        my int $grep_id = $cg->{"grep_counter"};
        $cg->{"grep_counter"} = $grep_id + 1;

        my int $grep_arr_cleanup = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $array_expr) == 1;
        emit($cg, "({ ");
        if ($grep_arr_cleanup == 1) {
            emit($cg, "StradaValue *__grep_sv_" . $grep_id . " = ");
            gen_expression($cg, $array_expr);
            emit($cg, "; StradaArray *__grep_input_" . $grep_id . " = strada_deref_array(__grep_sv_" . $grep_id . "); ");
        } else {
            emit($cg, "StradaArray *__grep_input_" . $grep_id . " = strada_deref_array(");
            gen_expression($cg, $array_expr);
            emit($cg, "); ");
        }
        emit($cg, "StradaValue *__grep_result_" . $grep_id . " = strada_new_array(); ");
        emit($cg, "int __grep_len_" . $grep_id . " = strada_array_length(__grep_input_" . $grep_id . "); ");
        emit($cg, "for (int __grep_i_" . $grep_id . " = 0; __grep_i_" . $grep_id . " < __grep_len_" . $grep_id . "; __grep_i_" . $grep_id . "++) { ");
        emit($cg, "StradaValue *__elem_ = strada_array_get(__grep_input_" . $grep_id . ", __grep_i_" . $grep_id . "); ");

        # Set flag to enable $_ magic variable
        $cg->{"in_grep_block"} = 1;

        # Generate block - evaluate to boolean, cleaning up temp if needed
        my scalar $stmts = $block->{"statements"};
        my int $stmt_count = $block->{"statement_count"};
        my int $grep_needs_cleanup = 0;
        if ($stmt_count > 0) {
            my scalar $last_stmt = $stmts->[$stmt_count - 1];
            if ($last_stmt->{"type"} == NODE_EXPR_STMT()) {
                if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $last_stmt->{"expr"}) == 1) {
                    $grep_needs_cleanup = 1;
                }
            }
        }
        if ($grep_needs_cleanup == 1) {
            emit($cg, "if (({ StradaValue *__grep_cond = ");
            my scalar $last_stmt = $stmts->[$stmt_count - 1];
            gen_expression($cg, $last_stmt->{"expr"});
            emit($cg, "; int __grep_bool = strada_to_bool(__grep_cond); strada_decref(__grep_cond); __grep_bool; })) { ");
        } else {
            emit($cg, "if (strada_to_bool(");
            if ($stmt_count > 0) {
                my scalar $last_stmt = $stmts->[$stmt_count - 1];
                if ($last_stmt->{"type"} == NODE_EXPR_STMT()) {
                    gen_expression($cg, $last_stmt->{"expr"});
                }
            }
            emit($cg, ")) { ");
        }

        # Reset flag
        $cg->{"in_grep_block"} = 0;

        emit($cg, "strada_array_push(strada_deref_array(__grep_result_" . $grep_id . "), __elem_); } ");
        emit($cg, "} ");
        if ($grep_arr_cleanup == 1) {
            emit($cg, "strada_decref(__grep_sv_" . $grep_id . "); ");
        }
        emit($cg, "__grep_result_" . $grep_id . "; })");
        return;
    }

    # Anonymous function
    if ($type == NODE_ANON_FUNC()) {
        my int $id = $cg->{"anon_func_counter"};
        $cg->{"anon_func_counter"} = $id + 1;
        my str $func_name = "__anon_func_" . $id;

        my scalar $params = $expr->{"params"};
        my int $param_count = $expr->{"param_count"};

        # Save current capture state (for nested closures)
        my int $saved_in_anon = $cg->{"in_anon_func"};
        my str $saved_param_str = $cg->{"anon_param_str"};
        my str $saved_local_str = $cg->{"anon_local_str"};
        my str $saved_capture_str = $cg->{"anon_capture_str"};
        my int $saved_capture_count = $cg->{"anon_capture_count"};

        # Set up capture context for this closure
        $cg->{"in_anon_func"} = 1;
        $cg->{"anon_local_str"} = "";
        $cg->{"anon_capture_str"} = "";
        $cg->{"anon_capture_count"} = 0;

        # Build param string from parameters
        my str $param_str = "";
        my int $i = 0;
        while ($i < $param_count) {
            my scalar $p = $params->[$i];
            if ($param_str eq "") {
                $param_str = $p->{"name"};
            } else {
                $param_str = $param_str . "," . $p->{"name"};
            }
            $i = $i + 1;
        }
        $cg->{"anon_param_str"} = $param_str;

        # Generate forward declaration (triple pointer for capture-by-reference)
        my str $decl = "StradaValue* " . $func_name . "(StradaValue ***__captures";
        $i = 0;
        while ($i < $param_count) {
            my scalar $p = $params->[$i];
            $decl = $decl . ", StradaValue *" . $p->{"name"};
            $i = $i + 1;
        }
        $decl = $decl . ")";
        $cg->{"anon_func_decls"} = $cg->{"anon_func_decls"} . $decl . ";\n";

        my str $def = $decl . " {\n";

        # Save current output (using StringBuilder)
        my str $saved_output = sb_to_string($cg->{"output_sb"});
        my int $saved_indent = $cg->{"indent"};
        my int $saved_in_main = $cg->{"in_main"};

        # Save scope state (closures are separate functions with their own scope)
        my scalar $saved_scope_vars = $cg->{"scope_vars"};
        my scalar $saved_scope_counts = $cg->{"scope_counts"};
        my int $saved_scope_depth = $cg->{"scope_depth"};

        # Save function parameter state (closures have their own parameters)
        my scalar $saved_func_params = $cg->{"func_params"};
        my scalar $saved_func_param_names = $cg->{"func_param_names"};
        my int $saved_func_param_count = $cg->{"func_param_count"};

        # Start fresh for function body (closures are NOT main)
        sb_clear($cg->{"output_sb"});
        $cg->{"indent"} = 1;
        $cg->{"in_main"} = 0;

        # Reset scope for closure (it's a new function)
        my array @new_scope_vars = ();
        my array @new_scope_counts = ();
        $cg->{"scope_vars"} = \@new_scope_vars;
        $cg->{"scope_counts"} = \@new_scope_counts;
        $cg->{"scope_depth"} = 0;

        # Reset function parameter tracking for closure (no param incref in closures)
        $cg->{"func_params"} = {};
        $cg->{"func_param_names"} = [];
        $cg->{"func_param_count"} = 0;

        # Save and check func_has_try for this closure
        my int $saved_func_has_try = $cg->{"func_has_try"};
        my scalar $anon_body = $expr->{"body"};
        if (func_body_has_try($anon_body) == 1) {
            $cg->{"func_has_try"} = 1;
        } else {
            $cg->{"func_has_try"} = 0;
        }

        # Generate body (this will populate capture_str as variables are accessed)
        my scalar $body = $expr->{"body"};
        my scalar $stmts = $body->{"statements"};
        my int $stmt_count = $body->{"statement_count"};
        $i = 0;
        while ($i < $stmt_count) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }

        # Get body content
        my str $body_content = sb_to_string($cg->{"output_sb"});
        $def = $def . "    (void)__captures;\n";
        $def = $def . $body_content;

        # Always add implicit return at end of closures to prevent undefined behavior
        # If the closure has an explicit return, this is unreachable and optimized away
        $def = $def . "    return strada_undef_static();\n";

        $def = $def . "}\n\n";

        # Capture the capture info before restoring state
        my str $capture_str = $cg->{"anon_capture_str"};
        my int $capture_count = $cg->{"anon_capture_count"};

        # Restore output (using StringBuilder)
        sb_clear($cg->{"output_sb"});
        sb_append($cg->{"output_sb"}, $saved_output);
        $cg->{"indent"} = $saved_indent;
        $cg->{"in_main"} = $saved_in_main;

        # Restore scope state
        $cg->{"scope_vars"} = $saved_scope_vars;
        $cg->{"scope_counts"} = $saved_scope_counts;
        $cg->{"scope_depth"} = $saved_scope_depth;

        # Restore function parameter state
        $cg->{"func_params"} = $saved_func_params;
        $cg->{"func_param_names"} = $saved_func_param_names;
        $cg->{"func_param_count"} = $saved_func_param_count;

        # Restore capture state
        $cg->{"in_anon_func"} = $saved_in_anon;
        $cg->{"anon_param_str"} = $saved_param_str;
        $cg->{"anon_local_str"} = $saved_local_str;
        $cg->{"anon_capture_str"} = $saved_capture_str;
        $cg->{"anon_capture_count"} = $saved_capture_count;

        # Restore func_has_try
        $cg->{"func_has_try"} = $saved_func_has_try;

        $cg->{"anon_func_defs"} = $cg->{"anon_func_defs"} . $def;

        # Emit closure creation with captures (using double pointers for capture-by-reference)
        if ($capture_count == 0) {
            emit($cg, "strada_closure_new((void*)&" . $func_name . ", " . $param_count . ", 0, NULL)");
        } else {
            # Build capture array inline with addresses for capture-by-reference
            emit($cg, "strada_closure_new((void*)&" . $func_name . ", " . $param_count . ", " . $capture_count . ", ");
            emit($cg, "(StradaValue**[]){");
            # Parse capture_str to emit address of each captured variable
            my int $cap_idx = 0;
            my int $start = 0;
            my int $len = length($capture_str);
            $i = 0;
            while ($i <= $len) {
                my str $ch = "";
                if ($i < $len) { $ch = substr($capture_str, $i, 1); }
                if ($ch eq "," || $i == $len) {
                    if ($cap_idx > 0) { emit($cg, ", "); }
                    my str $cap_name = substr($capture_str, $start, $i - $start);
                    emit($cg, "&" . $cap_name);
                    $cap_idx = $cap_idx + 1;
                    $start = $i + 1;
                }
                $i = $i + 1;
            }
            emit($cg, "})");
        }
        return;
    }

    # Closure call
    if ($type == NODE_CLOSURE_CALL()) {
        my scalar $args = $expr->{"args"};
        my int $arg_count = $expr->{"arg_count"};

        # Check if callee expression needs cleanup (e.g. hash access returning owned ref)
        my int $callee_cleanup = 0;
        if ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $expr->{"closure"}) == 1) {
            $callee_cleanup = 1;
        }

        # Check if any argument needs cleanup
        my int $needs_arg_cleanup = 0;
        if ($cg->{"cleanup_enabled"} == 1 && $arg_count > 0) {
            my int $ca = 0;
            while ($ca < $arg_count) {
                if (needs_temp_cleanup($cg, $args->[$ca]) == 1) {
                    $needs_arg_cleanup = 1;
                }
                $ca = $ca + 1;
            }
        }

        if ($needs_arg_cleanup == 1 || $callee_cleanup == 1) {
            emit($cg, "({ ");
            # Capture callee if it needs cleanup
            if ($callee_cleanup == 1) {
                emit($cg, "StradaValue *__cl_fn = ");
                gen_expression($cg, $expr->{"closure"});
                emit($cg, "; ");
            }
            # Capture each argument that needs cleanup
            my int $ca = 0;
            while ($ca < $arg_count) {
                emit($cg, "StradaValue *__cla" . $ca . " = ");
                gen_expression($cg, $args->[$ca]);
                emit($cg, "; ");
                $ca = $ca + 1;
            }
            # Make the call
            emit($cg, "StradaValue *__clres = strada_closure_call(");
            if ($callee_cleanup == 1) {
                emit($cg, "__cl_fn");
            } else {
                gen_expression($cg, $expr->{"closure"});
            }
            emit($cg, ", " . $arg_count);
            $ca = 0;
            while ($ca < $arg_count) {
                emit($cg, ", __cla" . $ca);
                $ca = $ca + 1;
            }
            emit($cg, "); ");
            # Cleanup callee if needed
            if ($callee_cleanup == 1) {
                emit($cg, "strada_decref(__cl_fn); ");
            }
            # Cleanup arguments that need it
            $ca = 0;
            while ($ca < $arg_count) {
                if (needs_temp_cleanup($cg, $args->[$ca]) == 1) {
                    emit($cg, "strada_decref(__cla" . $ca . "); ");
                }
                $ca = $ca + 1;
            }
            emit($cg, "__clres; })");
        } else {
            emit($cg, "strada_closure_call(");
            gen_expression($cg, $expr->{"closure"});
            emit($cg, ", " . $arg_count);
            my int $i = 0;
            while ($i < $arg_count) {
                emit($cg, ", ");
                gen_expression($cg, $args->[$i]);
                $i = $i + 1;
            }
            emit($cg, ")");
        }
        return;
    }

    # Ternary expression: cond ? true_expr : false_expr
    # FIX: When branches return borrowed references (hash/array access), we need
    # to incref the result so it becomes an owned reference. This prevents the
    # "double hash access in ternary" bug where:
    #   defined($h->{"key"}) ? $h->{"key"} : ""
    # would cause memory corruption because the ternary result is a borrowed
    # reference that might be incorrectly decref'd by callers.
    if ($type == NODE_TERNARY()) {
        my int $true_needs = return_needs_incref($expr->{"true_expr"});
        my int $false_needs = return_needs_incref($expr->{"false_expr"});

        if (($true_needs == 1 || $false_needs == 1) && $cg->{"cleanup_enabled"} == 1) {
            # At least one branch returns borrowed ref  need to make both owned
            my int $true_owned = needs_temp_cleanup($cg, $expr->{"true_expr"});
            my int $false_owned = needs_temp_cleanup($cg, $expr->{"false_expr"});

            if ($true_owned == 1 && $false_owned == 1) {
                # Both branches already return owned values  no incref needed
                emit($cg, "(");
                emit_condition($cg, $expr->{"condition"});
                emit($cg, " ? ");
                gen_expression($cg, $expr->{"true_expr"});
                emit($cg, " : ");
                gen_expression($cg, $expr->{"false_expr"});
                emit($cg, ")");
            } elsif ($true_owned == 0 && $false_owned == 0) {
                # Both branches return borrowed  incref the result
                emit($cg, "({ StradaValue *__tern_tmp = (");
                emit_condition($cg, $expr->{"condition"});
                emit($cg, " ? ");
                gen_expression($cg, $expr->{"true_expr"});
                emit($cg, " : ");
                gen_expression($cg, $expr->{"false_expr"});
                emit($cg, "); strada_incref(__tern_tmp); __tern_tmp; })");
            } else {
                # Mixed: selectively incref only the borrowed branch
                emit($cg, "({ StradaValue *__tern_tmp; if (");
                emit_condition($cg, $expr->{"condition"});
                emit($cg, ") { __tern_tmp = ");
                gen_expression($cg, $expr->{"true_expr"});
                emit($cg, ";");
                if ($true_owned == 0) {
                    emit($cg, " strada_incref(__tern_tmp);");
                }
                emit($cg, " } else { __tern_tmp = ");
                gen_expression($cg, $expr->{"false_expr"});
                emit($cg, ";");
                if ($false_owned == 0) {
                    emit($cg, " strada_incref(__tern_tmp);");
                }
                emit($cg, " } __tern_tmp; })");
            }
        } else {
            emit($cg, "(");
            emit_condition($cg, $expr->{"condition"});
            emit($cg, " ? ");
            gen_expression($cg, $expr->{"true_expr"});
            emit($cg, " : ");
            gen_expression($cg, $expr->{"false_expr"});
            emit($cg, ")");
        }
        return;
    }

    # Range expression: start..end
    if ($type == NODE_RANGE()) {
        my int $start_cleanup = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $expr->{"start"}) == 1;
        my int $end_cleanup = $cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $expr->{"end"}) == 1;
        if ($start_cleanup == 1 || $end_cleanup == 1) {
            emit($cg, "({ ");
            if ($start_cleanup == 1) {
                emit($cg, "StradaValue *__range_s = ");
                gen_expression($cg, $expr->{"start"});
                emit($cg, "; ");
            }
            if ($end_cleanup == 1) {
                emit($cg, "StradaValue *__range_e = ");
                gen_expression($cg, $expr->{"end"});
                emit($cg, "; ");
            }
            emit($cg, "StradaValue *__range_r = strada_range(");
            if ($start_cleanup == 1) {
                emit($cg, "__range_s");
            } else {
                gen_expression($cg, $expr->{"start"});
            }
            emit($cg, ", ");
            if ($end_cleanup == 1) {
                emit($cg, "__range_e");
            } else {
                gen_expression($cg, $expr->{"end"});
            }
            emit($cg, "); ");
            if ($start_cleanup == 1) {
                emit($cg, "strada_decref(__range_s); ");
            }
            if ($end_cleanup == 1) {
                emit($cg, "strada_decref(__range_e); ");
            }
            emit($cg, "__range_r; })");
        } else {
            emit($cg, "strada_range(");
            gen_expression($cg, $expr->{"start"});
            emit($cg, ", ");
            gen_expression($cg, $expr->{"end"});
            emit($cg, ")");
        }
        return;
    }

    # Await expression: await $future
    if ($type == NODE_AWAIT()) {
        emit($cg, "strada_future_await(");
        gen_expression($cg, $expr->{"expr"});
        emit($cg, ")");
        return;
    }

    # Readline expression (diamond operator): <$fh>
    if ($type == NODE_READLINE()) {
        my str $varname = $expr->{"varname"};
        emit($cg, "strada_read_line(" . escape_c_keyword($varname) . ")");
        return;
    }

    # Spread operator - only valid inside function call arguments
    # If we reach here, the spread is being used incorrectly
    if ($type == NODE_SPREAD()) {
        die("error: spread operator (...) is only valid in function call arguments");
        return;
    }
}

# ============================================================
# Statement Code Generation
# ============================================================

func gen_block(scalar $cg, scalar $block) void {
    emit($cg, "{\n");
    indent($cg);
    scope_push($cg);

    my scalar $stmts = $block->{"statements"};
    my int $i = 0;
    while ($i < $block->{"statement_count"}) {
        gen_statement($cg, $stmts->[$i]);
        $i = $i + 1;
    }

    scope_pop($cg);
    dedent($cg);
    emit_indent($cg);
    emit($cg, "}");
}

func gen_statement(scalar $cg, scalar $stmt) void {
    # Emit #line directive for source-level debugging
    emit_line_for_stmt($cg, $stmt);

    my int $type = $stmt->{"type"};

    # Variable declaration
    if ($type == NODE_VAR_DECL()) {
        emit_indent($cg);

        # Track local variables when inside anonymous function
        if ($cg->{"in_anon_func"}) {
            my str $var_name = $stmt->{"name"};
            my str $local_str = $cg->{"anon_local_str"};
            if ($local_str eq "") {
                $cg->{"anon_local_str"} = $var_name;
            } else {
                $cg->{"anon_local_str"} = $local_str . "," . $var_name;
            }
        }

        my str $sigil = $stmt->{"sigil"};
        my int $var_type = $stmt->{"var_type"};
        # Escape C keywords in variable names (e.g., $for -> v_for)
        my str $c_name = escape_c_keyword($stmt->{"name"});

        if ($sigil eq "%" || $var_type == TYPE_HASH()) {
            emit_sv_ptr_decl($cg, $c_name);
            if ($stmt->{"init"}) {
                emit($cg, " = ");
                # Handle empty () which parser returns as anon_hash
                my scalar $init = $stmt->{"init"};
                if ($init->{"type"} == NODE_ANON_HASH() && $init->{"pair_count"} == 0) {
                    emit($cg, "strada_new_hash()");
                } else {
                    my int $init_type = $init->{"type"};
                    # If init is a map expression or array-of-pairs, convert to hash
                    if ($init_type == NODE_MAP() || $init_type == NODE_ANON_ARRAY()) {
                        emit($cg, "strada_hash_from_flat_array(");
                        gen_expression($cg, $init);
                        emit($cg, ")");
                    } else {
                        # Set hash context for dynamic function calls
                        if ($init_type == NODE_CALL()) {
                            $cg->{"call_context"} = 2;
                        }
                        gen_expression($cg, $init);
                        if ($init_type == NODE_CALL()) {
                            $cg->{"call_context"} = 0;
                        }
                        # If initializing from a variable or deref, incref to share ownership properly
                        if ($init_type == NODE_VARIABLE()) {
                            emit($cg, "; strada_incref(" . $c_name . ")");
                        } elsif ($init_type == NODE_DEREF_SCALAR() && $init->{"sigil"} eq "%") {
                            # Hash deref like %{$ref} returns borrowed reference - need to incref
                            emit($cg, "; strada_incref(" . $c_name . ")");
                        }
                    }
                }
            } else {
                emit($cg, " = strada_new_hash()");
            }
            # Handle initial capacity: my hash %name{size};
            if ($stmt->{"initial_capacity"}) {
                emit($cg, "; strada_hash_reserve_sv(" . $c_name . ", ({ StradaValue *__cap_tmp = ");
                gen_expression($cg, $stmt->{"initial_capacity"});
                emit($cg, "; int64_t __cap_val = strada_to_int(__cap_tmp); strada_decref(__cap_tmp); __cap_val; }))");
            }
        } elsif ($sigil eq "@" || $var_type == TYPE_ARRAY()) {
            emit_sv_ptr_decl($cg, $c_name);
            if ($stmt->{"init"}) {
                emit($cg, " = ");
                # Handle empty () which parser returns as anon_hash
                my scalar $init = $stmt->{"init"};
                my int $init_type = $init->{"type"};
                if ($init_type == NODE_READLINE()) {
                    # Diamond operator in array context - read all lines
                    my str $varname = $init->{"varname"};
                    emit($cg, "strada_read_all_lines(" . escape_c_keyword($varname) . ")");
                } elsif ($init_type == NODE_ANON_HASH() && $init->{"pair_count"} == 0) {
                    emit($cg, "strada_new_array()");
                } elsif ($init_type == NODE_ANON_ARRAY()) {
                    # Array literal like [1, 2, 3] - generate directly
                    gen_expression($cg, $init);
                } elsif (is_scalar_expr($init)) {
                    # Single scalar expression like ($x) - wrap in array
                    # Create array and push the element, cleaning up temp if needed
                    my int $init_needs_cleanup = needs_temp_cleanup($cg, $init);
                    if ($init_needs_cleanup == 1) {
                        emit($cg, "strada_new_array(); { StradaValue *__arr_init_tmp = ");
                        gen_expression($cg, $init);
                        emit($cg, "; strada_array_push(" . $c_name . "->value.av, __arr_init_tmp); strada_decref(__arr_init_tmp); }");
                    } else {
                        emit($cg, "strada_new_array(); strada_array_push(" . $c_name . "->value.av, ");
                        gen_expression($cg, $init);
                        emit($cg, ")");
                    }
                } elsif ($init_type == NODE_VARIABLE() && $init->{"sigil"} eq "%") {
                    # Hash-to-array flattening: my array @arr = %hash
                    emit($cg, "strada_hash_to_flat_array(");
                    gen_expression($cg, $init);
                    emit($cg, ")");
                } else {
                    # Could be array/hash/function returning array - assign directly
                    # If source is a variable or deref, copy the array to avoid aliasing
                    if ($init_type == NODE_VARIABLE() || ($init_type == NODE_DEREF_SCALAR() && $init->{"sigil"} eq "@")) {
                        emit($cg, "strada_array_copy(");
                        gen_expression($cg, $init);
                        emit($cg, ")");
                    } else {
                        # Set array context for dynamic function calls
                        if ($init_type == NODE_CALL()) {
                            $cg->{"call_context"} = 1;
                        }
                        gen_expression($cg, $init);
                        if ($init_type == NODE_CALL()) {
                            $cg->{"call_context"} = 0;
                        }
                    }
                }
            } else {
                emit($cg, " = strada_new_array()");
            }
            # Handle initial capacity: my array $name[size];
            if ($stmt->{"initial_capacity"}) {
                emit($cg, "; strada_reserve_sv(" . $c_name . ", ({ StradaValue *__cap_tmp = ");
                gen_expression($cg, $stmt->{"initial_capacity"});
                emit($cg, "; int64_t __cap_val = strada_to_int(__cap_tmp); strada_decref(__cap_tmp); __cap_val; }))");
            }
        } else {
            emit_sv_ptr_decl($cg, $c_name);
            if ($stmt->{"init"}) {
                emit($cg, " = ");
                gen_expression($cg, $stmt->{"init"});
                # If initializing from borrowed reference, incref to share ownership properly
                # This prevents the original value from being freed when this one goes out of scope
                my scalar $init = $stmt->{"init"};
                my int $init_type = $init->{"type"};
                if ($init_type == NODE_VARIABLE()) {
                    emit($cg, "; strada_incref(" . $c_name . ")");
                } elsif ($init_type == NODE_SUBSCRIPT()) {
                    # Array subscript returns borrowed reference
                    emit($cg, "; strada_incref(" . $c_name . ")");
                } elsif ($init_type == NODE_DEREF_ARRAY()) {
                    # Arrow array dereference $ref->[idx] returns borrowed reference
                    emit($cg, "; strada_incref(" . $c_name . ")");
                } elsif ($init_type == NODE_TERNARY()) {
                    # Ternary expression may contain borrowed references in branches
                    if (return_needs_incref($init) == 1) {
                        emit($cg, "; strada_incref(" . $c_name . ")");
                    }
                }
            } else {
                emit($cg, " = strada_new_undef()");
            }
        }
        emit($cg, ";\n");
        # Track variable for scope cleanup
        # Use escaped name for C code generation
        scope_track_var($cg, $c_name);
        # If inside a try block, also push to cleanup stack for exception safety
        # The cleanup_restore at normal try exit will remove without decref
        # The cleanup_drain on exception will decref properly
        my int $in_try = $cg->{"try_depth"} + 0;
        if ($in_try > 0) {
            emit_indent($cg);
            emit($cg, "strada_cleanup_push(" . $c_name . ");\n");
        }
        return;
    }

    # Const declaration (local scope) - emit as regular variable with init
    if ($type == NODE_CONST_DECL()) {
        my str $c_name = escape_c_keyword($stmt->{"name"});
        my scalar $init = $stmt->{"init"};

        # Track variable for cleanup
        scope_track_var($cg, $c_name);

        emit_indent($cg);
        emit_sv_ptr_decl($cg, $c_name);
        emit($cg, " = ");
        gen_expression($cg, $init);
        emit($cg, ";\n");

        # Add to cleanup stack if in try block
        my int $in_try = $cg->{"try_depth"} + 0;
        if ($in_try > 0) {
            emit_indent($cg);
            emit($cg, "strada_cleanup_push(" . $c_name . ");\n");
        }
        return;
    }

    # Our declaration (package-scoped global via global registry)
    if ($type == NODE_OUR_DECL()) {
        my str $var_name = $stmt->{"name"};
        my str $c_name = escape_c_keyword($var_name);
        my str $sigil = $stmt->{"sigil"};
        my str $pkg = $cg->{"package"};
        if (length($pkg) == 0) {
            $pkg = "main";
        }
        my str $our_key = $pkg . "::" . $var_name;

        if ($sigil eq "@" || $sigil eq "%") {
            # Array/hash our: create local C variable backed by global registry
            my str $new_func = "strada_new_array()";
            if ($sigil eq "%") {
                $new_func = "strada_new_hash()";
            }

            if ($stmt->{"init"}) {
                # our array @foo = (1,2,3);  create from init, store in registry
                my scalar $init = $stmt->{"init"};
                my int $init_type = $init->{"type"};
                emit_indent($cg);
                emit($cg, "StradaValue *" . $c_name . " = ");
                if ($init_type == NODE_ANON_HASH() && $init->{"pair_count"} == 0) {
                    emit($cg, $new_func);
                } else {
                    gen_expression($cg, $init);
                }
                emit($cg, ";\n");
                emit_indent($cg);
                emit($cg, "strada_global_set(strada_new_str(\"" . $our_key . "\"), " . $c_name . ");\n");
                # global_set consumes caller's ref; incref so local var has its own ref
                emit_indent($cg);
                emit($cg, "strada_incref(" . $c_name . ");\n");
            } else {
                # our array @foo;  get from registry or create new
                emit_indent($cg);
                emit($cg, "StradaValue *" . $c_name . " = strada_global_get(strada_new_str(\"" . $our_key . "\"));\n");
                emit_indent($cg);
                emit($cg, "if (" . $c_name . "->type == STRADA_UNDEF) { strada_decref(" . $c_name . "); ");
                emit($cg, $c_name . " = " . $new_func . "; ");
                emit($cg, "strada_global_set(strada_new_str(\"" . $our_key . "\"), " . $c_name . "); ");
                emit($cg, "strada_incref(" . $c_name . "); }\n");
            }
            # Track for cleanup (decref at scope exit)
            scope_track_var($cg, $c_name);
            return;
        }

        # Scalar our: register in our_vars for variable reference/assignment interception
        my scalar $our_vars_ref = $cg->{"our_vars"};
        $our_vars_ref->{$c_name} = $our_key;

        # If there's an initializer, emit strada_global_set
        if ($stmt->{"init"}) {
            emit_indent($cg);
            emit($cg, "strada_global_set(strada_new_str(\"" . $our_key . "\"), ");
            gen_expression($cg, $stmt->{"init"});
            emit($cg, ");\n");
        }
        # No scope_track_var - our scalar variables are not locally owned
        return;
    }

    # local $var; or local $var = expr;
    # Saves the current value of an 'our' variable on the local stack
    if ($type == NODE_LOCAL_DECL()) {
        my str $var_name = $stmt->{"name"};
        my str $c_name = escape_c_keyword($var_name);
        my str $sigil = $stmt->{"sigil"};

        # Determine package-qualified name
        my str $pkg = $cg->{"package"};
        if (length($pkg) == 0) {
            $pkg = "main";
        }
        my str $our_key = $pkg . "::" . $var_name;

        # Check if this is an 'our' variable
        my scalar $our_vars_ref = $cg->{"our_vars"};
        my str $our_check = "" . $our_vars_ref->{$c_name};
        if (length($our_check) > 0) {
            $our_key = $our_check;
        }

        # On first local() in this function, emit depth save
        if ($cg->{"has_local"} != 1) {
            $cg->{"has_local"} = 1;
            emit_indent($cg);
            emit($cg, "int __local_saved_depth = strada_local_depth_get();\n");
        }

        # Save current value
        emit_indent($cg);
        emit($cg, "strada_local_save(\"" . $our_key . "\");\n");

        # If there's an initializer, set the new value
        if ($stmt->{"init"}) {
            emit_indent($cg);
            emit($cg, "strada_global_set(strada_new_str(\"" . $our_key . "\"), ");
            gen_expression($cg, $stmt->{"init"});
            emit($cg, ");\n");
        }
        return;
    }

    # Destructuring assignment: my ($a, $b, $c) = @arr;
    if ($type == NODE_DESTRUCTURE()) {
        my scalar $vars = $stmt->{"vars"};
        my int $var_count = $stmt->{"var_count"};
        my scalar $init = $stmt->{"init"};
        my int $is_decl = $stmt->{"is_decl"};

        # If declaration, first declare all variables at outer scope
        if ($is_decl == 1) {
            my int $i = 0;
            while ($i < $var_count) {
                my scalar $var = $vars->[$i];
                my str $name = escape_c_keyword($var->{"name"});
                emit_indent($cg);
                emit($cg, "StradaValue *" . $name . " = strada_new_undef();\n");
                scope_track_var($cg, $name);
                $i = $i + 1;
            }
        }

        # Wrap assignment in a block for the temporary
        emit_indent($cg);
        emit($cg, "{\n");
        indent($cg);

        # Evaluate source expression once
        emit_indent($cg);
        emit($cg, "StradaValue *__destruct_src = ");
        gen_expression($cg, $init);
        emit($cg, ";\n");

        # Check if source is a variable (needs incref since we're borrowing)
        my int $init_type = $init->{"type"};
        if ($init_type == NODE_VARIABLE()) {
            emit_indent($cg);
            emit($cg, "strada_incref(__destruct_src);\n");
        }

        # Assign each variable
        my int $i = 0;
        while ($i < $var_count) {
            my scalar $var = $vars->[$i];
            my str $name = escape_c_keyword($var->{"name"});

            # Decref old value if already assigned
            emit_indent($cg);
            emit($cg, "strada_decref(" . $name . ");\n");

            # Get element from array (strada_array_get_safe returns owned reference)
            emit_indent($cg);
            emit($cg, $name . " = strada_array_get_safe(__destruct_src, " . $i . ");\n");

            $i = $i + 1;
        }

        # Release source
        emit_indent($cg);
        emit($cg, "strada_decref(__destruct_src);\n");

        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");
        return;
    }

    # Bare block { ... }
    if ($type == NODE_BLOCK()) {
        emit_indent($cg);
        gen_block($cg, $stmt);
        emit($cg, "\n");
        return;
    }

    # If statement
    if ($type == NODE_IF_STMT()) {
        emit_indent($cg);
        emit($cg, "if (");
        emit_condition($cg, $stmt->{"condition"});
        emit($cg, ") ");
        gen_block($cg, $stmt->{"then_block"});

        # Elsif clauses
        my scalar $elsif_conds = $stmt->{"elsif_conditions"};
        my scalar $elsif_blocks = $stmt->{"elsif_blocks"};
        my int $i = 0;
        while ($i < $stmt->{"elsif_count"}) {
            emit($cg, " else if (");
            emit_condition($cg, $elsif_conds->[$i]);
            emit($cg, ") ");
            gen_block($cg, $elsif_blocks->[$i]);
            $i = $i + 1;
        }
        
        # Else clause
        if ($stmt->{"else_block"}) {
            emit($cg, " else ");
            gen_block($cg, $stmt->{"else_block"});
        }
        
        emit($cg, "\n");
        return;
    }
    
    # While statement
    if ($type == NODE_WHILE_STMT()) {
        my str $label = $stmt->{"label"};
        # Register label depth BEFORE scope_push so cleanup covers loop body
        if (length($label) > 0) {
            my scalar $label_depths = $cg->{"label_depths"};
            $label_depths->{$label} = $cg->{"scope_depth"};
        }

        # Set up redo label
        my str $saved_redo = $cg->{"current_redo_label"};
        my str $redo_label = "";
        if (length($label) > 0) {
            $redo_label = $label . "_redo";
        } else {
            my int $redo_id = $cg->{"redo_counter"};
            $cg->{"redo_counter"} = $redo_id + 1;
            $redo_label = "__redo_" . $redo_id;
        }
        $cg->{"current_redo_label"} = $redo_label;

        # Track loop body scope depth for unlabeled last/next cleanup
        my int $saved_loop_break_depth = $cg->{"loop_break_depth"};
        $cg->{"loop_break_depth"} = $cg->{"scope_depth"};

        emit_indent($cg);
        emit($cg, "while (");
        emit_condition($cg, $stmt->{"condition"});
        emit($cg, ") {\n");
        indent($cg);
        scope_push($cg);

        # Emit redo label at top of loop body
        emit_indent($cg);
        emit($cg, $redo_label . ": __attribute__((unused));\n");

        my scalar $body = $stmt->{"body"};
        my scalar $stmts = $body->{"statements"};
        my int $i = 0;
        while ($i < $body->{"statement_count"}) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }

        # Add continue label at end of loop body if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_continue: ;\n");
        }

        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");

        # Add break label after loop if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_break: ;\n");
        }
        $cg->{"loop_break_depth"} = $saved_loop_break_depth;
        $cg->{"current_redo_label"} = $saved_redo;
        return;
    }

    # Do-while statement
    if ($type == NODE_DO_WHILE_STMT()) {
        my str $label = $stmt->{"label"};
        # Register label depth BEFORE scope_push so cleanup covers loop body
        if (length($label) > 0) {
            my scalar $label_depths = $cg->{"label_depths"};
            $label_depths->{$label} = $cg->{"scope_depth"};
        }

        # Set up redo label
        my str $saved_redo = $cg->{"current_redo_label"};
        my str $redo_label = "";
        if (length($label) > 0) {
            $redo_label = $label . "_redo";
        } else {
            my int $redo_id = $cg->{"redo_counter"};
            $cg->{"redo_counter"} = $redo_id + 1;
            $redo_label = "__redo_" . $redo_id;
        }
        $cg->{"current_redo_label"} = $redo_label;

        # Track loop body scope depth for unlabeled last/next cleanup
        my int $saved_loop_break_depth = $cg->{"loop_break_depth"};
        $cg->{"loop_break_depth"} = $cg->{"scope_depth"};

        emit_indent($cg);
        emit($cg, "do {\n");
        indent($cg);
        scope_push($cg);

        # Emit redo label at top of loop body
        emit_indent($cg);
        emit($cg, $redo_label . ": __attribute__((unused));\n");

        my scalar $body = $stmt->{"body"};
        my scalar $stmts = $body->{"statements"};
        my int $i = 0;
        while ($i < $body->{"statement_count"}) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }

        # Add continue label at end of loop body if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_continue: ;\n");
        }

        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "} while (");
        emit_condition($cg, $stmt->{"condition"});
        emit($cg, ");\n");

        # Add break label after loop if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_break: ;\n");
        }
        $cg->{"loop_break_depth"} = $saved_loop_break_depth;
        $cg->{"current_redo_label"} = $saved_redo;
        return;
    }

    # For statement
    if ($type == NODE_FOR_STMT()) {
        my str $label = $stmt->{"label"};
        # Register label depth BEFORE any blocks so cleanup covers everything
        if (length($label) > 0) {
            my scalar $label_depths = $cg->{"label_depths"};
            $label_depths->{$label} = $cg->{"scope_depth"};
        }

        # Track loop body scope depth for unlabeled last/next cleanup
        my int $saved_loop_break_depth = $cg->{"loop_break_depth"};
        $cg->{"loop_break_depth"} = $cg->{"scope_depth"};

        # Set up redo label
        my str $saved_redo = $cg->{"current_redo_label"};
        my str $redo_label = "";
        if (length($label) > 0) {
            $redo_label = $label . "_redo";
        } else {
            my int $redo_id = $cg->{"redo_counter"};
            $cg->{"redo_counter"} = $redo_id + 1;
            $redo_label = "__redo_" . $redo_id;
        }
        $cg->{"current_redo_label"} = $redo_label;

        my str $loop_var_name = "";
        my int $has_var_decl = 0;

        # Check if init declares a variable that needs cleanup
        if ($stmt->{"init"}) {
            my scalar $init = $stmt->{"init"};
            if ($init->{"type"} == NODE_VAR_DECL()) {
                $has_var_decl = 1;
                $loop_var_name = escape_c_keyword($init->{"name"});
                # Wrap in a block for proper scoping
                emit_indent($cg);
                emit($cg, "{\n");
                indent($cg);
                emit_indent($cg);
                emit($cg, "StradaValue *" . $loop_var_name . " = ");
                if ($init->{"init"}) {
                    gen_expression($cg, $init->{"init"});
                    # If initializing from borrowed reference, incref to own the value
                    # (matches normal var decl logic at ~line 12670)
                    my scalar $for_init = $init->{"init"};
                    my int $for_init_type = $for_init->{"type"};
                    if ($for_init_type == NODE_VARIABLE()) {
                        emit($cg, "; strada_incref(" . $loop_var_name . ")");
                    } elsif ($for_init_type == NODE_SUBSCRIPT()) {
                        emit($cg, "; strada_incref(" . $loop_var_name . ")");
                    } elsif ($for_init_type == NODE_DEREF_ARRAY()) {
                        emit($cg, "; strada_incref(" . $loop_var_name . ")");
                    } elsif ($for_init_type == NODE_TERNARY()) {
                        if (return_needs_incref($for_init) == 1) {
                            emit($cg, "; strada_incref(" . $loop_var_name . ")");
                        }
                    }
                } else {
                    emit($cg, "strada_new_undef()");
                }
                emit($cg, ";\n");
            }
        }

        emit_indent($cg);
        emit($cg, "for (");

        if ($stmt->{"init"} && $has_var_decl == 0) {
            gen_expression($cg, $stmt->{"init"});
        }
        emit($cg, "; ");

        if ($stmt->{"condition"}) {
            emit_condition($cg, $stmt->{"condition"});
        }
        emit($cg, "; ");

        if ($stmt->{"update"}) {
            my scalar $update = $stmt->{"update"};
            # Check if update is an increment/decrement - its return value must be freed
            if ($update->{"type"} == NODE_INCREMENT()) {
                emit($cg, "({ StradaValue *__upd_tmp = ");
                gen_expression($cg, $update);
                emit($cg, "; strada_decref(__upd_tmp); })");
            } else {
                gen_expression($cg, $update);
            }
        }

        emit($cg, ") {\n");
        indent($cg);
        scope_push($cg);

        # Emit redo label at top of loop body
        emit_indent($cg);
        emit($cg, $redo_label . ": __attribute__((unused));\n");

        my scalar $body = $stmt->{"body"};
        my scalar $stmts = $body->{"statements"};
        my int $i = 0;
        while ($i < $body->{"statement_count"}) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }

        # Add continue label at end of loop body if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_continue: ;\n");
        }

        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");

        # Clean up loop variable if we declared one
        if ($has_var_decl == 1) {
            emit_indent($cg);
            emit($cg, "strada_decref(" . $loop_var_name . ");\n");
            dedent($cg);
            emit_indent($cg);
            emit($cg, "}\n");
        }

        # Add break label after loop if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_break: ;\n");
        }
        $cg->{"loop_break_depth"} = $saved_loop_break_depth;
        $cg->{"current_redo_label"} = $saved_redo;
        return;
    }

    # Foreach statement
    if ($type == NODE_FOREACH_STMT()) {
        my str $label = $stmt->{"label"};
        # Register label depth BEFORE any blocks so cleanup covers everything
        if (length($label) > 0) {
            my scalar $label_depths = $cg->{"label_depths"};
            $label_depths->{$label} = $cg->{"scope_depth"};
        }

        # Track loop body scope depth for unlabeled last/next cleanup
        my int $saved_loop_break_depth = $cg->{"loop_break_depth"};
        $cg->{"loop_break_depth"} = $cg->{"scope_depth"};

        # Set up redo label
        my str $saved_redo = $cg->{"current_redo_label"};
        my str $redo_label = "";
        if (length($label) > 0) {
            $redo_label = $label . "_redo";
        } else {
            my int $redo_id = $cg->{"redo_counter"};
            $cg->{"redo_counter"} = $redo_id + 1;
            $redo_label = "__redo_" . $redo_id;
        }
        $cg->{"current_redo_label"} = $redo_label;

        my scalar $var_decl = $stmt->{"var_decl"};
        my str $var_name = escape_c_keyword($stmt->{"var_name"});
        my scalar $array_expr = $stmt->{"array"};
        my scalar $body = $stmt->{"body"};

        my int $foreach_id = $cg->{"foreach_counter"};
        $cg->{"foreach_counter"} = $foreach_id + 1;

        # Open a block scope
        emit_indent($cg);
        emit($cg, "{\n");
        indent($cg);
        scope_push($cg);

        # Get the array and iterate
        emit_indent($cg);
        emit($cg, "StradaValue *__foreach_arr_" . $foreach_id . " = ");
        # Set array context for dynamic function calls
        if ($array_expr->{"type"} == NODE_CALL()) {
            $cg->{"call_context"} = 1;
        }
        gen_expression($cg, $array_expr);
        if ($array_expr->{"type"} == NODE_CALL()) {
            $cg->{"call_context"} = 0;
        }
        emit($cg, ";\n");

        emit_indent($cg);
        emit($cg, "StradaArray *__foreach_av_" . $foreach_id . " = strada_deref_array(__foreach_arr_" . $foreach_id . ");\n");

        emit_indent($cg);
        emit($cg, "int __foreach_len_" . $foreach_id . " = strada_array_length(__foreach_av_" . $foreach_id . ");\n");

        # For pre-existing loop variables, release the old value before the loop
        if (!$var_decl) {
            emit_indent($cg);
            emit($cg, "strada_decref(" . $var_name . "); " . $var_name . " = NULL;\n");
        }

        emit_indent($cg);
        emit($cg, "for (int __foreach_i_" . $foreach_id . " = 0; __foreach_i_" . $foreach_id . " < __foreach_len_" . $foreach_id . "; __foreach_i_" . $foreach_id . "++) {\n");
        indent($cg);
        scope_push($cg);

        # Declare or assign the loop variable
        emit_indent($cg);
        if ($var_decl) {
            # New variable declaration
            emit($cg, "StradaValue *" . $var_name . " = strada_array_get(__foreach_av_" . $foreach_id . ", __foreach_i_" . $foreach_id . ");\n");
        } else {
            # Existing variable - assign to it (borrowed ref from array_get, no decref needed)
            emit($cg, $var_name . " = strada_array_get(__foreach_av_" . $foreach_id . ", __foreach_i_" . $foreach_id . ");\n");
        }

        # Emit redo label after variable assignment
        emit_indent($cg);
        emit($cg, $redo_label . ": __attribute__((unused));\n");

        # Generate body statements
        my scalar $stmts = $body->{"statements"};
        my int $i = 0;
        while ($i < $body->{"statement_count"}) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }

        # Add continue label at end of loop body if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_continue: ;\n");
        }

        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");

        # Clean up the foreach array if it was an owned value (function call result, etc.)
        if (needs_temp_cleanup($cg, $array_expr) == 1) {
            emit_indent($cg);
            emit($cg, "strada_decref(__foreach_arr_" . $foreach_id . ");\n");
        }

        # Close block scope
        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");

        # Add break label after loop if labeled
        if (length($label) > 0) {
            emit_indent($cg);
            emit($cg, $label);
            emit($cg, "_break: ;\n");
        }
        $cg->{"loop_break_depth"} = $saved_loop_break_depth;
        $cg->{"current_redo_label"} = $saved_redo;
        return;
    }

    # Return statement
    if ($type == NODE_RETURN_STMT()) {
        my int $in_main = $cg->{"in_main"};
        my int $cleanup_enabled = $cg->{"cleanup_enabled"};
        my int $profiling = $cg->{"enable_profiling"};
        my str $func_name = $cg->{"current_func_name"};
        my int $in_extern = $cg->{"in_extern"};

        # Restore local() variables before returning
        if ($cg->{"has_local"} == 1) {
            emit_indent($cg);
            emit($cg, "strada_local_restore_to(__local_saved_depth);\n");
        }

        # extern functions - simple return with raw C types
        if ($in_extern == 1) {
            emit_indent($cg);
            emit($cg, "return");
            if ($stmt->{"value"}) {
                emit($cg, " ");
                gen_expression($cg, $stmt->{"value"});
            }
            emit($cg, ";\n");
            return;
        }

        # main() - evaluate return value, cleanup, then return
        if ($in_main == 1) {
            if ($stmt->{"value"}) {
                # Evaluate return expression BEFORE cleanup to avoid use-after-free
                emit_indent($cg);
                if ($stmt->{"value"}->{"type"} == NODE_INT_LITERAL()) {
                    # Simple literal - can emit directly after cleanup
                    if ($cleanup_enabled == 1) {
                        scope_emit_all_cleanup($cg);
                    }
                    emit_try_cleanup($cg);
                    emit_stack_pop($cg);
                    emit_indent($cg);
                    emit($cg, "return " . $stmt->{"value"}->{"value"} . ";\n");
                } else {
                    # Complex expression - evaluate first, then cleanup
                    emit($cg, "{ int __main_ret = strada_to_int(");
                    gen_expression($cg, $stmt->{"value"});
                    emit($cg, ");\n");
                    indent($cg);
                    if ($cleanup_enabled == 1) {
                        scope_emit_all_cleanup($cg);
                    }
                    emit_try_cleanup($cg);
                    emit_stack_pop($cg);
                    emit_indent($cg);
                    emit($cg, "return __main_ret; }\n");
                    dedent($cg);
                }
            } else {
                # No return value - cleanup then return
                if ($cleanup_enabled == 1) {
                    scope_emit_all_cleanup($cg);
                }
                emit_try_cleanup($cg);
                emit_stack_pop($cg);
                emit_indent($cg);
                emit($cg, "return;\n");
            }
        } elsif ($cleanup_enabled == 0) {
            # Cleanup disabled - simple return
            # Still need to pop try blocks even if cleanup is disabled
            emit_try_cleanup($cg);
            # Add profiling exit if enabled (for non-main)
            if ($profiling == 1 && $in_main == 0 && length($func_name) > 0) {
                if ($stmt->{"value"}) {
                    # Save return value, call profile_exit, then return
                    emit_indent($cg);
                    emit($cg, "{ StradaValue *__retval = ");
                    gen_expression($cg, $stmt->{"value"});
                    emit($cg, "; strada_profile_exit(\"" . $func_name . "\");" . emit_stack_pop_inline($cg) . " return __retval; }\n");
                } else {
                    emit_indent($cg);
                    emit($cg, "strada_profile_exit(\"" . $func_name . "\");\n");
                    emit_stack_pop($cg);
                    emit_indent($cg);
                    emit($cg, "return;\n");
                }
            } else {
                emit_stack_pop($cg);
                emit_indent($cg);
                emit($cg, "return");
                if ($stmt->{"value"}) {
                    emit($cg, " ");
                    gen_expression($cg, $stmt->{"value"});
                }
                emit($cg, ";\n");
            }
        } elsif ($stmt->{"value"}) {
            # Non-main function with return value - save, cleanup, return
            emit_indent($cg);
            emit($cg, "{ StradaValue *__retval = ");
            gen_expression($cg, $stmt->{"value"});
            emit($cg, ";\n");
            indent($cg);
            # Only incref if returning a variable/borrowed ref (not for new values)
            if (return_needs_incref($stmt->{"value"}) == 1) {
                emit_indent($cg);
                emit($cg, "strada_incref(__retval);\n");
            }
            scope_emit_all_cleanup($cg);
            # Pop any active try blocks before returning
            emit_try_cleanup($cg);
            # Add profiling exit if enabled
            if ($profiling == 1 && length($func_name) > 0) {
                emit_indent($cg);
                emit($cg, "strada_profile_exit(\"" . $func_name . "\");\n");
            }
            emit_stack_pop($cg);
            emit_indent($cg);
            emit($cg, "return __retval; }\n");
            dedent($cg);
        } else {
            # Void return - cleanup then return
            scope_emit_all_cleanup($cg);
            # Pop any active try blocks before returning
            emit_try_cleanup($cg);
            # Add profiling exit if enabled
            if ($profiling == 1 && length($func_name) > 0) {
                emit_indent($cg);
                emit($cg, "strada_profile_exit(\"" . $func_name . "\");\n");
            }
            emit_stack_pop($cg);
            emit_indent($cg);
            emit($cg, "return;\n");
        }
        return;
    }
    
    # Expression statement
    if ($type == NODE_EXPR_STMT()) {
        emit_indent($cg);
        my scalar $expr = $stmt->{"expr"};

        # Check if expression produces owned value that must be freed
        # This includes increment/decrement, method calls, and other temp values
        if ($expr->{"type"} == NODE_INCREMENT() ||
            ($cg->{"cleanup_enabled"} == 1 && needs_temp_cleanup($cg, $expr) == 1)) {
            emit($cg, "({ StradaValue *__expr_tmp = ");
            gen_expression($cg, $expr);
            emit($cg, "; strada_decref(__expr_tmp); });\n");
        } else {
            gen_expression($cg, $expr);
            emit($cg, ";\n");
        }
        return;
    }
    
    # Last (break)
    if ($type == 100) {
        my str $label = $stmt->{"label"};
        if (length($label) > 0) {
            # Emit cleanup for all scopes between current and target label's scope
            my scalar $label_depths = $cg->{"label_depths"};
            my int $target_depth = $label_depths->{$label} + 0;
            scope_emit_cleanup_to_depth($cg, $target_depth);
            emit_indent($cg);
            emit($cg, "goto ");
            emit($cg, $label);
            emit($cg, "_break;\n");
        } else {
            # Unlabeled last: cleanup loop body scope vars before break
            scope_emit_cleanup_to_depth($cg, $cg->{"loop_break_depth"});
            emit_indent($cg);
            emit($cg, "break;\n");
        }
        return;
    }

    # Next (continue)
    if ($type == 101) {
        my str $label = $stmt->{"label"};
        if (length($label) > 0) {
            # Emit cleanup for scopes between current and target label's BODY scope
            # Note: For next, we use label_depth + 1 because the _continue label is
            # placed before scope_pop, so the loop body's cleanup still runs normally
            my scalar $label_depths = $cg->{"label_depths"};
            my int $target_depth = $label_depths->{$label} + 1;
            scope_emit_cleanup_to_depth($cg, $target_depth);
            emit_indent($cg);
            emit($cg, "goto ");
            emit($cg, $label);
            emit($cg, "_continue;\n");
        } else {
            # Unlabeled next: cleanup loop body scope vars before continue
            scope_emit_cleanup_to_depth($cg, $cg->{"loop_break_depth"});
            emit_indent($cg);
            emit($cg, "continue;\n");
        }
        return;
    }

    # Redo (restart current iteration without re-checking condition)
    if ($type == NODE_REDO()) {
        my str $label = $stmt->{"label"};
        if (length($label) > 0) {
            # Labeled redo: cleanup to target label's body scope, then goto LABEL_redo
            my scalar $label_depths = $cg->{"label_depths"};
            my int $target_depth = $label_depths->{$label} + 1;
            scope_emit_cleanup_to_depth($cg, $target_depth);
            emit_indent($cg);
            emit($cg, "goto ");
            emit($cg, $label);
            emit($cg, "_redo;\n");
        } else {
            # Unlabeled redo: goto current redo label
            my str $redo_lbl = $cg->{"current_redo_label"};
            emit_indent($cg);
            emit($cg, "goto " . $redo_lbl . ";\n");
        }
        return;
    }

    # Try/Catch statement with typed exceptions
    if ($type == NODE_TRY_CATCH()) {
        # Save cleanup stack depth BEFORE the try block so it's accessible in catch
        my int $cleanup_var_id = $cg->{"try_cleanup_counter"} + 0;
        $cg->{"try_cleanup_counter"} = $cleanup_var_id + 1;
        emit_indent($cg);
        emit($cg, "int __cleanup_mark_" . $cleanup_var_id . " = strada_cleanup_mark();\n");

        emit_indent($cg);
        emit($cg, "if (setjmp(*STRADA_TRY_PUSH()) == 0) {\n");
        indent($cg);
        scope_push($cg);

        # Track that we're inside a try block (for proper cleanup on return)
        my int $try_depth = $cg->{"try_depth"};
        $cg->{"try_depth"} = $try_depth + 1;

        # Generate try block
        my scalar $try_block = $stmt->{"try_block"};
        my scalar $stmts = $try_block->{"statements"};
        my int $i = 0;
        while ($i < $try_block->{"statement_count"}) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }

        # Decrement try_depth before we emit the pop
        $cg->{"try_depth"} = $try_depth;

        # Restore cleanup stack to saved depth (pop local var entries without decref)
        # This is needed because the normal scope cleanup will decref these vars
        emit_indent($cg);
        emit($cg, "strada_cleanup_restore(__cleanup_mark_" . $cleanup_var_id . ");\n");

        emit_indent($cg);
        emit($cg, "STRADA_TRY_POP();\n");
        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "} else {\n");
        indent($cg);
        scope_push($cg);
        emit_indent($cg);
        emit($cg, "STRADA_TRY_POP();\n");

        # Drain pending cleanup args from function calls that threw, but only
        # back to the mark saved at try entry (don't drain caller's items!)
        emit_indent($cg);
        emit($cg, "strada_cleanup_drain_to(__cleanup_mark_" . $cleanup_var_id . ");\n");

        # Get the exception into a temporary variable
        emit_indent($cg);
        emit($cg, "StradaValue *__strada_exc = strada_get_exception();\n");

        # Generate catch clauses
        my scalar $catch_clauses = $stmt->{"catch_clauses"};
        my int $catch_count = $stmt->{"catch_count"};
        my int $has_catchall = 0;

        my int $c = 0;
        while ($c < $catch_count) {
            my scalar $clause = $catch_clauses->[$c];
            my str $catch_type = $clause->{"catch_type"};
            my str $catch_var = $clause->{"catch_var"};
            my scalar $catch_block = $clause->{"catch_block"};

            emit_indent($cg);

            if (length($catch_type) > 0) {
                # Typed catch clause
                if ($c == 0) {
                    emit($cg, "if (strada_isa(__strada_exc, \"");
                } else {
                    emit($cg, "} else if (strada_isa(__strada_exc, \"");
                }
                emit($cg, $catch_type);
                emit($cg, "\")) {\n");
            } else {
                # Catch-all clause
                $has_catchall = 1;
                if ($c == 0) {
                    emit($cg, "{\n");
                } else {
                    emit($cg, "} else {\n");
                }
            }

            indent($cg);
            scope_push($cg);

            # Declare catch variable and assign exception
            emit_indent($cg);
            emit($cg, "StradaValue *");
            emit($cg, $catch_var);
            emit($cg, " = __strada_exc;\n");
            scope_track_var($cg, $catch_var);
            # Push to cleanup stack in case we throw from inside this catch block
            emit_indent($cg);
            emit($cg, "strada_cleanup_push(" . $catch_var . ");\n");
            # Track that we have a catch var on the cleanup stack (for throw handling)
            my int $ccc = $cg->{"catch_cleanup_count"} + 0;
            $cg->{"catch_cleanup_count"} = $ccc + 1;

            # Generate catch block statements
            my scalar $catch_stmts = $catch_block->{"statements"};
            my int $j = 0;
            while ($j < $catch_block->{"statement_count"}) {
                gen_statement($cg, $catch_stmts->[$j]);
                $j = $j + 1;
            }

            # Pop catch variable from cleanup stack (normal exit, scope_pop will decref)
            emit_indent($cg);
            emit($cg, "strada_cleanup_pop();\n");
            # Decrement catch cleanup count since we popped the catch var
            $cg->{"catch_cleanup_count"} = $cg->{"catch_cleanup_count"} - 1;
            scope_pop($cg);
            dedent($cg);

            $c = $c + 1;
        }

        # If no catch-all, add a re-throw for unmatched exceptions
        if ($has_catchall == 0) {
            emit_indent($cg);
            emit($cg, "} else {\n");
            indent($cg);
            emit_indent($cg);
            emit($cg, "strada_throw_value(__strada_exc);\n");
            dedent($cg);
        }

        emit_indent($cg);
        emit($cg, "}\n");

        scope_pop($cg);
        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");
        return;
    }

    # Throw statement
    # Note: We intentionally don't emit scope cleanup before throw because:
    # 1. If inside a try block, the longjmp will skip any cleanup anyway
    # 2. The catch handler is responsible for cleanup via strada_decref on exception var
    # 3. Before throwing, we MUST clean up ALL local variables in scope AND function
    #    parameters, because the normal function epilogue/scope cleanup won't run.
    #    This is especially important when re-throwing from a catch block, where
    #    variables declared before the try block would otherwise leak.
    # 4. IMPORTANT: We must evaluate the throw expression BEFORE cleanup, because the
    #    expression may reference local variables. Then cleanup, then throw.
    # 5. We must incref the throw value before cleanup to protect it, because the
    #    cleanup might decref a variable that IS the throw value (e.g., re-throwing $e).
    #    The incref balances the cleanup's decref; strada_throw_value takes ownership.
    if ($type == NODE_THROW()) {
        my int $td = $cg->{"try_depth"} + 0;
        my int $ccc = $cg->{"catch_cleanup_count"} + 0;
        my scalar $throw_expr = $stmt->{"expr"};
        my int $throw_is_var = 0;
        if ($throw_expr->{"type"} == NODE_VARIABLE()) {
            $throw_is_var = 1;
        }

        if ($ccc > 0) {
            # We're in a catch block (possibly inside an outer try) - need to clean up
            # catch scope and pop catch vars, but if inside outer try, don't clean
            # outer scopes (outer catch will handle cleanup via drain)
            emit_indent($cg);
            emit($cg, "{ StradaValue *__throw_val = ");
            gen_expression($cg, $throw_expr);
            emit($cg, ";\n");
            indent($cg);
            emit_indent($cg);
            emit($cg, "strada_incref(__throw_val);\n");
            if ($td == 0) {
                # Not inside any outer try - clean up everything
                scope_emit_all_cleanup($cg);
            } else {
                # Inside an outer try - only clean up catch scope and catch vars
                scope_emit_cleanup($cg);
                # Pop catch vars from cleanup stack
                my int $cv = $ccc;
                while ($cv > 0) {
                    emit_indent($cg);
                    emit($cg, "strada_cleanup_pop();\n");
                    $cv = $cv - 1;
                }
            }
            # Only decref if throw expression was NOT a variable (variables get decrefd by cleanup)
            if ($throw_is_var == 0) {
                emit_indent($cg);
                emit($cg, "strada_decref(__throw_val);\n");
            }
            emit_indent($cg);
            emit($cg, "strada_throw_value(__throw_val); }\n");
            dedent($cg);
            return;
        }

        if ($td > 0) {
            # We're inside a try block (not a catch) - local catch will handle cleanup
            # Don't do any scope cleanup here; just throw
            emit_indent($cg);
            emit($cg, "strada_throw_value(");
            gen_expression($cg, $throw_expr);
            emit($cg, ");\n");
            return;
        }

        # We're outside any try/catch - exiting the function, full cleanup
        emit_indent($cg);
        emit($cg, "{ StradaValue *__throw_val = ");
        gen_expression($cg, $throw_expr);
        emit($cg, ";\n");
        indent($cg);
        emit_indent($cg);
        emit($cg, "strada_incref(__throw_val);\n");
        scope_emit_all_cleanup($cg);
        # Only decref if throw expression was NOT a variable (variables get decrefd by cleanup)
        if ($throw_is_var == 0) {
            emit_indent($cg);
            emit($cg, "strada_decref(__throw_val);\n");
        }
        emit_indent($cg);
        emit($cg, "strada_throw_value(__throw_val); }\n");
        dedent($cg);
        return;
    }

    # Label statement
    if ($type == NODE_LABEL()) {
        emit($cg, $stmt->{"name"} . ":;\n");
        return;
    }

    # Goto statement
    if ($type == NODE_GOTO()) {
        emit_indent($cg);
        emit($cg, "goto " . $stmt->{"target"} . ";\n");
        return;
    }

    # Switch statement
    if ($type == NODE_SWITCH()) {
        # Generate a unique variable to hold the switch expression
        my int $switch_id = $cg->{"switch_counter"};
        $cg->{"switch_counter"} = $switch_id + 1;
        my str $switch_var = "_switch_val_" . $switch_id;

        emit_indent($cg);
        emit($cg, "{\n");
        indent($cg);

        # Evaluate switch expression once and extract to C string
        emit_indent($cg);
        emit($cg, "StradaValue *" . $switch_var . " = ");
        gen_expression($cg, $stmt->{"expr"});
        emit($cg, ";\n");
        emit_indent($cg);
        emit($cg, "char *" . $switch_var . "_str = strada_to_str(" . $switch_var . ");\n");

        my scalar $cases = $stmt->{"cases"};
        my scalar $blocks = $stmt->{"blocks"};
        my int $case_count = $stmt->{"case_count"};
        my int $i = 0;

        while ($i < $case_count) {
            emit_indent($cg);
            my scalar $case_expr = $cases->[$i];
            if ($i == 0) {
                emit($cg, "if (");
            } else {
                emit($cg, "} else if (");
            }
            # Check if case is a string literal - can compare directly
            if ($case_expr->{"type"} == NODE_STR_LITERAL()) {
                emit($cg, "strcmp(" . $switch_var . "_str, ");
                gen_str_literal_c($cg, $case_expr->{"value"});
                emit($cg, ") == 0");
            } else {
                # Non-literal case - need to extract and free
                emit($cg, "({ StradaValue *__case_sv = ");
                gen_expression($cg, $case_expr);
                emit($cg, "; char *__case_str = strada_to_str(__case_sv); int __case_eq = strcmp(" . $switch_var . "_str, __case_str) == 0; free(__case_str); strada_decref(__case_sv); __case_eq; })");
            }
            emit($cg, ") {\n");
            indent($cg);

            # Generate the block body (statements only, not the braces)
            my scalar $block = $blocks->[$i];
            my scalar $stmts = $block->{"statements"};
            my int $j = 0;
            while ($j < $block->{"statement_count"}) {
                gen_statement($cg, $stmts->[$j]);
                $j = $j + 1;
            }

            dedent($cg);
            $i = $i + 1;
        }

        # Default block
        my int $has_default = $stmt->{"has_default"};
        if ($has_default) {
            my scalar $default_block = $stmt->{"default_block"};
            emit_indent($cg);
            if ($case_count > 0) {
                emit($cg, "} else {\n");
            } else {
                emit($cg, "{\n");
            }
            indent($cg);

            my scalar $def_stmts = $default_block->{"statements"};
            my int $k = 0;
            while ($k < $default_block->{"statement_count"}) {
                gen_statement($cg, $def_stmts->[$k]);
                $k = $k + 1;
            }

            dedent($cg);
        }

        if ($case_count > 0 || $has_default) {
            emit_indent($cg);
            emit($cg, "}\n");
        }

        # Free the switch expression string
        emit_indent($cg);
        emit($cg, "free(" . $switch_var . "_str);\n");

        dedent($cg);
        emit_indent($cg);
        emit($cg, "}\n");
        return;
    }

    # __C__ { ... } - raw C code block
    if ($type == NODE_C_BLOCK()) {
        my str $code = $stmt->{"code"};
        emit($cg, "/* Begin __C__ block */\n");
        emit($cg, $code);
        emit($cg, "\n/* End __C__ block */\n");
        return;
    }
}

# ============================================================
# Function and Program Code Generation
# ============================================================

func gen_function(scalar $cg, scalar $fn) void {
    my str $ret_type = type_to_c($fn->{"return_type"});
    my str $name = sanitize_name($fn->{"name"});
    my int $ret_type_id = $fn->{"return_type"};

    # Reset function parameter tracking for each new function
    $cg->{"func_params"} = {};
    $cg->{"func_param_names"} = [];
    $cg->{"func_param_count"} = 0;

    # Check if this is a DESTROY method - these should NOT have parameter incref/decref
    # because DESTROY is called during object destruction when refcount is already 0
    my int $is_destroy = 0;
    if ($name eq "DESTROY") {
        $is_destroy = 1;
    } else {
        my int $name_len = length($name);
        if ($name_len > 8) {
            my str $suffix = substr($name, $name_len - 8, 8);
            if ($suffix eq "_DESTROY") {
                $is_destroy = 1;
            }
        }
    }
    $cg->{"is_destroy_method"} = $is_destroy;

    # Check if function body contains any try blocks - if so, local variables need volatile
    # to preserve their values across setjmp/longjmp in exception handling
    my scalar $fn_body = $fn->{"body"};
    if (func_body_has_try($fn_body) == 1) {
        $cg->{"func_has_try"} = 1;
    } else {
        $cg->{"func_has_try"} = 0;
    }

    # Special case for main
    if ($name eq "main") {
        $cg->{"in_main"} = 1;
        $cg->{"has_local"} = 0;
        # Store main's package for function call resolution
        $cg->{"current_fn_package"} = $fn->{"package"};
        emit($cg, "int main(int _argc, char **_argv) {\n");
        emit($cg, "    /* Initialize proctitle support */\n");
        emit($cg, "    strada_init_proctitle(_argc, _argv);\n\n");

        # Push stack frame for stack traces (if enabled)
        my str $src_file = $cg->{"filename"};
        if ($cg->{"enable_stack_trace"} == 1) {
            emit($cg, "    strada_stack_push(\"main\", \"" . $src_file . "\");\n\n");
        }

        # Initialize profiling if enabled
        if ($cg->{"enable_profiling"} == 1) {
            emit($cg, "    /* Initialize function profiling */\n");
            emit($cg, "    strada_profile_init();\n");
            emit($cg, "    atexit(strada_profile_report);\n\n");
        }
        emit($cg, "    /* Populate global ARGV array */\n");
        emit($cg, "    ARGV = strada_new_array();\n");
        emit($cg, "    for (int i = 0; i < _argc; i++) {\n");
        emit($cg, "        strada_array_push(ARGV->value.av, strada_new_str(_argv[i]));\n");
        emit($cg, "    }\n");
        emit($cg, "    ARGC = strada_new_int(_argc);\n\n");

        # Set package if declared at file level
        my str $pkg = $cg->{"package"};
        if ($pkg ne "") {
            emit($cg, "    /* Set package from file-level declaration */\n");
            emit($cg, "    strada_set_package(\"" . $pkg . "\");\n\n");
        }

        # Set up inheritance from file-level declarations
        my scalar $inherits = $cg->{"inherits"};
        my int $inherit_count = $cg->{"inherit_count"};
        if ($inherit_count > 0) {
            emit($cg, "    /* Set up inheritance from file-level declarations */\n");
            my int $inh = 0;
            while ($inh < $inherit_count) {
                my scalar $entry = $inherits->[$inh];
                my str $child = $entry->{"child"};
                my str $parent = $entry->{"parent"};
                emit($cg, "    strada_inherit(\"" . $child . "\", \"" . $parent . "\");\n");
                $inh = $inh + 1;
            }
            emit($cg, "\n");
        }

        # Initialize OOP method registration for all packages that have methods
        my int $num_oop_pkgs = get_oop_pkg_count($cg);
        if ($num_oop_pkgs > 0) {
            my scalar $oop_pkgs = get_oop_packages($cg);
            emit($cg, "    /* Initialize OOP method registration */\n");
            my int $oop_i = 0;
            while ($oop_i < $num_oop_pkgs) {
                my str $oop_pkg = $oop_pkgs->[$oop_i];
                my str $c_oop_pkg = sanitize_name($oop_pkg);
                emit($cg, "    __" . $c_oop_pkg . "_oop_init();\n");
                $oop_i = $oop_i + 1;
            }
            emit($cg, "\n");
        }

        # If main has parameters, bind argc/argv to them
        my scalar $params = $fn->{"params"};
        my int $param_count = $fn->{"param_count"};
        if ($param_count >= 1) {
            # First parameter gets argc
            my scalar $p1 = $params->[0];
            emit($cg, "    StradaValue* " . $p1->{"name"} . " = ARGC;\n");
        }
        if ($param_count >= 2) {
            # Second parameter gets argv array
            my scalar $p2 = $params->[1];
            emit($cg, "    StradaValue* " . $p2->{"name"} . " = ARGV;\n");
        }
        if ($param_count > 0) {
            emit($cg, "\n");
        }

        # Initialize global variables
        my int $global_count = $cg->{"global_count"};
        if ($global_count > 0) {
            emit($cg, "    /* Initialize global variables */\n");
            my scalar $globals = $cg->{"globals"};
            my int $g = 0;
            while ($g < $global_count) {
                my scalar $gvar = $globals->[$g];
                my int $gvar_type = $gvar->{"type"};
                my int $var_type = $gvar->{"var_type"};
                my str $sigil = $gvar->{"sigil"};
                my str $name = $gvar->{"name"};
                my scalar $init = $gvar->{"init"};

                # Handle our declarations - use global registry
                if ($gvar_type == NODE_OUR_DECL()) {
                    if ($init) {
                        my str $pkg = $gvar->{"package"};
                        if (length($pkg) == 0) { $pkg = "main"; }
                        my str $our_key = $pkg . "::" . $name;
                        emit($cg, "    strada_global_set(strada_new_str(\"" . $our_key . "\"), ");
                        gen_expression($cg, $init);
                        emit($cg, ");\n");
                        # Register in our_vars for codegen
                        my scalar $our_vars_ref2 = $cg->{"our_vars"};
                        $our_vars_ref2->{$name} = $our_key;
                    }
                    $g = $g + 1;
                    next;
                }

                # Handle const declarations - initialize static variables
                if ($gvar_type == NODE_CONST_DECL()) {
                    my int $init_type = $init->{"type"};
                    if ($init_type == NODE_INT_LITERAL() || $init_type == NODE_NUM_LITERAL() || $init_type == NODE_STR_LITERAL()) {
                        emit($cg, "    " . $name . " = ");
                        gen_expression($cg, $init);
                        emit($cg, ";\n");
                        $g = $g + 1;
                        next;
                    }
                }

                emit($cg, "    " . $name . " = ");
                if ($sigil eq "%" || $var_type == TYPE_HASH()) {
                    if ($init) {
                        # Handle empty () which parser returns as anon_hash
                        if ($init->{"type"} == NODE_ANON_HASH() && $init->{"pair_count"} == 0) {
                            emit($cg, "strada_new_hash()");
                        } else {
                            gen_expression($cg, $init);
                        }
                    } else {
                        emit($cg, "strada_new_hash()");
                    }
                } elsif ($sigil eq "@" || $var_type == TYPE_ARRAY()) {
                    if ($init) {
                        # Handle empty () which parser returns as anon_hash
                        if ($init->{"type"} == NODE_ANON_HASH() && $init->{"pair_count"} == 0) {
                            emit($cg, "strada_new_array()");
                        } else {
                            gen_expression($cg, $init);
                        }
                    } else {
                        emit($cg, "strada_new_array()");
                    }
                } else {
                    if ($init) {
                        gen_expression($cg, $init);
                    } else {
                        emit($cg, "strada_new_undef()");
                    }
                }
                emit($cg, ";\n");
                $g = $g + 1;
            }
            emit($cg, "\n");
        }

        # Call BEGIN blocks (only if any exist)
        my int $main_begin_count = $cg->{"begin_block_count"};
        if ($main_begin_count > 0) {
            emit($cg, "    /* BEGIN blocks */\n");
            my int $mbi = 0;
            while ($mbi < $main_begin_count) {
                emit($cg, "    __begin_" . $mbi . "();\n");
                $mbi = $mbi + 1;
            }
            emit($cg, "\n");
        }

        # Register END blocks via atexit (LIFO - atexit calls in reverse registration order)
        my int $main_end_count = $cg->{"end_block_count"};
        if ($main_end_count > 0) {
            emit($cg, "    /* Register END blocks (run at exit in LIFO order) */\n");
            my int $mei = 0;
            while ($mei < $main_end_count) {
                emit($cg, "    atexit(__end_" . $mei . ");\n");
                $mei = $mei + 1;
            }
            emit($cg, "\n");
        }

        # Call import() functions (only if any exist)
        my int $main_import_call_count = $cg->{"import_call_count"};
        if ($main_import_call_count > 0) {
            my scalar $import_calls = $cg->{"import_calls"};
            emit($cg, "    /* Module import() calls */\n");
            my int $mic = 0;
            while ($mic < $main_import_call_count) {
                my scalar $call_info = $import_calls->[$mic];
                my str $call_fn = sanitize_name($call_info->{"func_name"});
                my str $call_pkg = $call_info->{"pkg_name"};
                emit($cg, "    " . $call_fn . "(strada_new_str(\"" . $call_pkg . "\"), strada_new_array());\n");
                $mic = $mic + 1;
            }
            emit($cg, "\n");
        }

        # Generate the body statements directly (without the outer braces)
        # Push scope for main's local variables
        scope_push($cg);
        my scalar $body = $fn->{"body"};
        my scalar $stmts = $body->{"statements"};
        my int $i = 0;
        while ($i < $body->{"statement_count"}) {
            gen_statement($cg, $stmts->[$i]);
            $i = $i + 1;
        }
        scope_pop($cg);
        emit($cg, "}\n\n");
        $cg->{"in_main"} = 0;
    } else {
        # Private functions get static prefix (file-scope only)
        my str $static_prefix = "";
        if ($fn->{"is_private"} == 1) {
            $static_prefix = "static ";
        }
        emit($cg, $static_prefix . $ret_type . " " . $name . "(");
        
        my scalar $params = $fn->{"params"};
        my int $i = 0;
        while ($i < $fn->{"param_count"}) {
            if ($i > 0) {
                emit($cg, ", ");
            }
            my scalar $param = $params->[$i];
            my int $ptype = $param->{"param_type"};
            my str $c_param_name = escape_c_keyword($param->{"name"});
            emit($cg, type_to_c($ptype) . " " . $c_param_name);
            $i = $i + 1;
        }

        if ($fn->{"param_count"} == 0) {
            emit($cg, "void");
        }

        emit($cg, ") {\n");

        # Push stack frame for stack traces (if enabled)
        my str $src_file = $cg->{"filename"};
        if ($cg->{"enable_stack_trace"} == 1) {
            emit($cg, "strada_stack_push(\"" . $name . "\", \"" . $src_file . "\");\n");
        }

        # Add profiling entry if enabled
        if ($cg->{"enable_profiling"} == 1) {
            emit($cg, "    strada_profile_enter(\"" . $name . "\");\n");
        }

        # Store current function name for profiling exit in return statements
        $cg->{"current_func_name"} = $name;

        # Reset local() tracking for this function
        $cg->{"has_local"} = 0;

        # Store current function's package for SUPER:: calls
        $cg->{"current_fn_package"} = $fn->{"package"};

        # Generate the function body (without the outer braces, we handle them)
        scope_push($cg);

        # Track function parameters and their C names for proper reference counting
        # We incref each parameter at entry so the function "owns" its reference
        # This allows safe reassignment without affecting the caller's copy
        # EXCEPTION: DESTROY methods should NOT have parameter incref/decref because
        # they are called during object destruction when refcount is already 0
        # We also push parameters to the cleanup stack for exception safety:
        # if a called function throws, cleanup_drain in the catch will decref our params
        $cg->{"func_params"} = {};
        $cg->{"func_param_names"} = [];
        $cg->{"func_param_count"} = 0;
        if ($cg->{"is_destroy_method"} != 1) {
            my int $param_i = 0;
            while ($param_i < $fn->{"param_count"}) {
                my scalar $param = $params->[$param_i];
                my str $c_param_name = escape_c_keyword($param->{"name"});
                $cg->{"func_params"}->{$param->{"name"}} = 1;
                my int $pc = $cg->{"func_param_count"};
                $cg->{"func_param_names"}->[$pc] = $c_param_name;
                $cg->{"func_param_count"} = $pc + 1;
                emit($cg, "strada_incref(" . $c_param_name . ");\n");
                # Push to cleanup stack for exception unwinding
                emit($cg, "strada_cleanup_push(" . $c_param_name . ");\n");
                $param_i = $param_i + 1;
            }
        }

        my scalar $body = $fn->{"body"};
        my scalar $stmts = $body->{"statements"};
        my int $stmt_i = 0;
        while ($stmt_i < $body->{"statement_count"}) {
            gen_statement($cg, $stmts->[$stmt_i]);
            $stmt_i = $stmt_i + 1;
        }
        scope_pop($cg);

        # Pop and decref function parameters for void functions that fall through
        # (functions with return statements handle this in scope_emit_all_cleanup)
        if ($ret_type_id == TYPE_VOID()) {
            my int $pn_count = $cg->{"func_param_count"} + 0;
            if ($pn_count > 0) {
                my scalar $param_names = $cg->{"func_param_names"};
                my int $pn_i = 0;
                while ($pn_i < $pn_count) {
                    my str $pname = $param_names->[$pn_i];
                    emit($cg, "strada_cleanup_pop();\n");
                    emit($cg, "strada_decref(" . $pname . ");\n");
                    $pn_i = $pn_i + 1;
                }
            }
        }

        # Add implicit profiling exit for void functions (no explicit return)
        if ($cg->{"enable_profiling"} == 1 && $ret_type_id == TYPE_VOID()) {
            emit($cg, "    strada_profile_exit(\"" . $name . "\");\n");
        }
        # Restore local() saves for void functions falling through
        if ($cg->{"has_local"} == 1) {
            emit($cg, "strada_local_restore_to(__local_saved_depth);\n");
        }
        # Pop stack frame for void functions falling through
        if ($ret_type_id == TYPE_VOID() && $cg->{"enable_stack_trace"} == 1) {
            emit($cg, "strada_stack_pop();\n");
        }
        emit($cg, "}\n");

        $cg->{"current_func_name"} = "";
        $cg->{"current_fn_package"} = "";

        # Clear func_params
        $cg->{"func_params"} = {};

        emit($cg, "\n\n");
    }
}

# Generate async function (creates inner closure + outer wrapper)
func gen_async_function(scalar $cg, scalar $fn) void {
    my str $name = sanitize_name($fn->{"name"});
    my str $inner_name = "__async_" . $name . "_inner";
    my scalar $params = $fn->{"params"};
    my int $param_count = $fn->{"param_count"};

    # Private functions get static prefix
    my str $static_prefix = "";
    if ($fn->{"is_private"} == 1) {
        $static_prefix = "static ";
    }

    # --- Generate inner closure function ---
    emit($cg, "/* Async inner: " . $name . " */\n");
    emit($cg, "static StradaValue* " . $inner_name . "(StradaValue ***__captures) {\n");

    # Unpack captured parameters
    my int $i = 0;
    while ($i < $param_count) {
        my scalar $p = $params->[$i];
        my str $pname = escape_c_keyword($p->{"name"});
        emit($cg, "    StradaValue *" . $pname . " = (*__captures[" . $i . "]);\n");
        $i = $i + 1;
    }
    if ($param_count > 0) {
        emit($cg, "\n");
    }

    # Save scope state (async inner is a separate function with its own scope)
    my scalar $saved_scope_vars = $cg->{"scope_vars"};
    my scalar $saved_scope_counts = $cg->{"scope_counts"};
    my int $saved_scope_depth = $cg->{"scope_depth"};
    my scalar $saved_func_param_names = $cg->{"func_param_names"};
    my int $saved_func_param_count = $cg->{"func_param_count"};

    # Reset scope for async inner function (it's a new function)
    my array @new_scope_vars = ();
    my array @new_scope_counts = ();
    $cg->{"scope_vars"} = \@new_scope_vars;
    $cg->{"scope_counts"} = \@new_scope_counts;
    $cg->{"scope_depth"} = 0;
    $cg->{"func_param_names"} = [];
    $cg->{"func_param_count"} = 0;

    # Save and check func_has_try for async inner function
    my int $saved_func_has_try = $cg->{"func_has_try"};
    my scalar $async_body = $fn->{"body"};
    if (func_body_has_try($async_body) == 1) {
        $cg->{"func_has_try"} = 1;
    } else {
        $cg->{"func_has_try"} = 0;
    }

    # Generate body
    scope_push($cg);
    my scalar $body = $fn->{"body"};
    my scalar $stmts = $body->{"statements"};
    my int $stmt_i = 0;
    while ($stmt_i < $body->{"statement_count"}) {
        gen_statement($cg, $stmts->[$stmt_i]);
        $stmt_i = $stmt_i + 1;
    }
    scope_pop($cg);

    # Restore scope state
    $cg->{"scope_vars"} = $saved_scope_vars;
    $cg->{"scope_counts"} = $saved_scope_counts;
    $cg->{"scope_depth"} = $saved_scope_depth;
    $cg->{"func_param_names"} = $saved_func_param_names;
    $cg->{"func_param_count"} = $saved_func_param_count;

    # Restore func_has_try
    $cg->{"func_has_try"} = $saved_func_has_try;

    emit($cg, "    return strada_undef_static();\n");
    emit($cg, "}\n\n");

    # --- Generate outer wrapper ---
    emit($cg, "/* Async wrapper: " . $name . " */\n");
    emit($cg, $static_prefix . "StradaValue* " . $name . "(");
    $i = 0;
    while ($i < $param_count) {
        if ($i > 0) { emit($cg, ", "); }
        my scalar $p = $params->[$i];
        my str $c_param_name = escape_c_keyword($p->{"name"});
        my int $ptype = $p->{"param_type"};
        emit($cg, type_to_c($ptype) . " " . $c_param_name);
        $i = $i + 1;
    }
    if ($param_count == 0) { emit($cg, "void"); }
    emit($cg, ") {\n");

    # Build closure with captures
    if ($param_count > 0) {
        emit($cg, "    StradaValue *__closure = strada_closure_new((void*)&" . $inner_name);
        emit($cg, ", 0, " . $param_count . ", (StradaValue**[]){");
        $i = 0;
        while ($i < $param_count) {
            if ($i > 0) { emit($cg, ", "); }
            my str $c_param_name = escape_c_keyword($params->[$i]->{"name"});
            emit($cg, "&" . $c_param_name);
            $i = $i + 1;
        }
        emit($cg, "});\n");
    } else {
        emit($cg, "    StradaValue *__closure = strada_closure_new((void*)&" . $inner_name);
        emit($cg, ", 0, 0, NULL);\n");
    }

    emit($cg, "    return strada_future_new(__closure);\n");
    emit($cg, "}\n\n");
}

func gen_program(scalar $cg, scalar $program) void {
    # First pass: register all functions for default parameter handling
    my scalar $funcs = $program->{"functions"};
    my int $i = 0;
    my int $reg = 0;
    while ($reg < $program->{"function_count"}) {
        codegen_register_function($cg, $funcs->[$reg]);
        $reg = $reg + 1;
    }
    
    # Store package name in codegen context for later use
    $cg->{"package"} = $program->{"package"};

    # Store inherits in codegen context for later use
    $cg->{"inherits"} = $program->{"inherits"};
    $cg->{"inherit_count"} = $program->{"inherit_count"};

    # Store overload info
    $cg->{"has_overloads"} = $program->{"has_overloads"};
    $cg->{"overloads"} = $program->{"overloads"};
    $cg->{"overloaded_ops"} = $program->{"overloaded_ops"};

    # Store method modifiers
    $cg->{"method_modifiers"} = $program->{"method_modifiers"};
    $cg->{"method_modifier_count"} = $program->{"method_modifier_count"};

    # Header
    emit($cg, "/* Generated by Strada Self-Hosting Compiler */\n");

    # Package name
    if ($program->{"package"} ne "") {
        emit($cg, "/* Package: " . $program->{"package"} . " */\n");
    }
    
    emit($cg, "#include \"strada_runtime.h\"\n");
    emit($cg, "#include <string.h>\n");
    emit($cg, "#include <stdint.h>\n");
    emit($cg, "#include <stdbool.h>\n");
    emit($cg, "#include <dlfcn.h>\n");
    emit($cg, "#include <math.h>\n\n");

    # Emit top-level C blocks (includes, typedefs, etc.)
    my int $c_block_count = $program->{"c_block_count"};
    if ($c_block_count > 0) {
        emit($cg, "/* Top-level C code blocks */\n");
        my scalar $c_blocks = $program->{"c_blocks"};
        my int $cb = 0;
        while ($cb < $c_block_count) {
            emit($cg, $c_blocks->[$cb]);
            emit($cg, "\n");
            $cb = $cb + 1;
        }
        emit($cg, "\n");
    }

    # Check if there's a main function
    my int $has_main = 0;
    $i = 0;
    while ($i < $program->{"function_count"}) {
        if ($funcs->[$i]->{"name"} eq "main") {
            $has_main = 1;
            last;
        }
        $i = $i + 1;
    }
    
    # Global ARGV and ARGC (only for files with main)
    if ($has_main == 1) {
        emit($cg, "/* Global command-line argument variables */\n");
        emit($cg, "StradaValue *ARGV = NULL;\n");
        emit($cg, "StradaValue *ARGC = NULL;\n\n");
    } else {
        emit($cg, "/* External globals from main module */\n");
        emit($cg, "extern StradaValue *ARGV;\n");
        emit($cg, "extern StradaValue *ARGC;\n\n");
    }

    # Emit global variable declarations
    my int $global_count = $program->{"global_count"};
    if ($global_count > 0) {
        my scalar $globals = $program->{"globals"};
        emit($cg, "/* Global variables and constants */\n");
        my int $g = 0;
        while ($g < $global_count) {
            my scalar $gvar = $globals->[$g];
            my int $gvar_type = $gvar->{"type"};
            my int $var_type = $gvar->{"var_type"};
            my str $name = $gvar->{"name"};

            # Our declarations don't need C global variables (use registry)
            if ($gvar_type == NODE_OUR_DECL()) {
                $g = $g + 1;
                next;
            }
            # Handle const declarations - emit as global variable (initialized once in main)
            # Using #define with strada_new_* causes leaks since it creates new values on every use
            if ($gvar_type == NODE_CONST_DECL()) {
                emit($cg, "static StradaValue *" . $name . " = NULL;\n");
            } else {
                emit($cg, "StradaValue *" . $name . " = NULL;\n");
            }
            $g = $g + 1;
        }
        emit($cg, "\n");
    }

    # Store globals in codegen context for initialization in main
    $cg->{"globals"} = $program->{"globals"};
    $cg->{"global_count"} = $program->{"global_count"};

    # Pre-register 'our' variables so function codegen can intercept references
    if ($global_count > 0) {
        my scalar $our_globals = $program->{"globals"};
        my int $og = 0;
        while ($og < $global_count) {
            my scalar $ogvar = $our_globals->[$og];
            if ($ogvar->{"type"} == NODE_OUR_DECL()) {
                my str $og_name = $ogvar->{"name"};
                my str $og_pkg = $ogvar->{"package"};
                if (length($og_pkg) == 0) { $og_pkg = "main"; }
                my str $og_key = $og_pkg . "::" . $og_name;
                my scalar $our_vars_pre = $cg->{"our_vars"};
                $our_vars_pre->{$og_name} = $og_key;
            }
            $og = $og + 1;
        }
    }

    # Store BEGIN/END blocks and import calls in codegen context
    $cg->{"begin_blocks"} = $program->{"begin_blocks"};
    $cg->{"begin_block_count"} = $program->{"begin_block_count"};
    $cg->{"end_blocks"} = $program->{"end_blocks"};
    $cg->{"end_block_count"} = $program->{"end_block_count"};
    $cg->{"import_calls"} = $program->{"import_calls"};
    $cg->{"import_call_count"} = $program->{"import_call_count"};

    # Generate enum definitions
    my scalar $enums = $program->{"enums"};
    my int $e = 0;
    while ($e < $program->{"enum_count"}) {
        my scalar $en = $enums->[$e];
        my str $enum_name = $en->{"name"};

        emit($cg, "/* enum " . $enum_name . " */\n");

        # Generate #define constants for enum values
        # This allows Color::RED to be used (converted to Color_RED by parser)
        my scalar $members = $en->{"members"};
        my int $m = 0;
        while ($m < $en->{"member_count"}) {
            my scalar $member = $members->[$m];
            my str $member_name = $member->{"name"};
            my int $member_value = $member->{"value"};
            emit($cg, "#define " . $enum_name . "_" . $member_name . " " . $member_value . "\n");
            $m = $m + 1;
        }
        emit($cg, "\n");
        $e = $e + 1;
    }

    # Generate extern declarations for imported functions
    my int $imp_count = $program->{"import_count"};
    if ($imp_count > 0) {
        emit($cg, "/* Imported function declarations */\n");
        my scalar $imports = $program->{"imports"};
        my int $imp = 0;
        while ($imp < $imp_count) {
            my str $imp_name = $imports->[$imp];
            # Generate generic extern declaration (assume StradaValue* return and variadic params)
            emit($cg, "extern StradaValue* " . $imp_name . "();\n");
            $imp = $imp + 1;
        }
        emit($cg, "\n");
    }
    
    # Generate extern declarations for qualified module function calls
    my int $use_count = $program->{"use_count"};
    if ($use_count > 0) {
        my scalar $uses = $program->{"uses"};
        my int $u = 0;
        while ($u < $use_count) {
            my str $mod_name = $uses->[$u];
            # Skip "lib" pseudo-module
            if ($mod_name ne "lib") {
                # Convert :: to __ for C identifier prefix
                my str $prefix = "";
                my int $p = 0;
                my int $plen = length($mod_name);
                while ($p < $plen) {
                    my str $ch = substr($mod_name, $p, 1);
                    if ($ch eq ":") {
                        $prefix = $prefix . "_";
                    } else {
                        $prefix = $prefix . $ch;
                    }
                    $p = $p + 1;
                }
                $prefix = $prefix . "__";
                
                # Generate extern declarations for imported funcs with qualified names
                emit($cg, "/* Qualified imports from " . $mod_name . " */\n");
                my scalar $imports = $program->{"imports"};
                my int $imp = 0;
                while ($imp < $program->{"import_count"}) {
                    my str $imp_name = $imports->[$imp];
                    emit($cg, "extern StradaValue* " . $prefix . $imp_name . "();\n");
                    $imp = $imp + 1;
                }
                emit($cg, "\n");
            }
            $u = $u + 1;
        }
    }

    # Generate import_lib wrapper infrastructure
    my int $import_lib_count = $program->{"import_lib_count"};
    if ($import_lib_count > 0) {
        my scalar $import_libs = $program->{"import_libs"};

        emit($cg, "/* import_lib: static library handles and function pointers */\n");

        my int $lib_idx = 0;
        while ($lib_idx < $import_lib_count) {
            my scalar $lib_info = $import_libs->[$lib_idx];
            my str $lib_name = $lib_info->{"lib_name"};
            my str $safe_lib = sanitize_name($lib_name);

            # Static handle for the library
            emit($cg, "static void *__import_lib_" . $safe_lib . "_handle = NULL;\n");

            # Static function pointers for each function
            my scalar $lib_funcs = $lib_info->{"functions"};
            my int $fn_idx = 0;
            my int $fn_count = $lib_info->{"function_count"};
            while ($fn_idx < $fn_count) {
                my scalar $fn_info = $lib_funcs->[$fn_idx];
                my str $fn_name = sanitize_name($fn_info->{"name"});
                emit($cg, "static void *__import_lib_" . $safe_lib . "_fn_" . $fn_name . " = NULL;\n");
                $fn_idx = $fn_idx + 1;
            }

            $lib_idx = $lib_idx + 1;
        }
        emit($cg, "\n");

        # Forward declarations for wrapper functions
        emit($cg, "/* import_lib: wrapper function forward declarations */\n");
        $lib_idx = 0;
        while ($lib_idx < $import_lib_count) {
            my scalar $lib_info = $import_libs->[$lib_idx];
            my scalar $lib_funcs = $lib_info->{"functions"};
            my int $fn_idx = 0;
            my int $fn_count = $lib_info->{"function_count"};

            while ($fn_idx < $fn_count) {
                my scalar $fn_info = $lib_funcs->[$fn_idx];
                my str $fn_name = sanitize_name($fn_info->{"name"});
                my int $ret_type = $fn_info->{"return_type"};
                my int $param_count = $fn_info->{"param_count"};
                my scalar $params = $fn_info->{"params"};

                emit($cg, type_to_c($ret_type) . " " . $fn_name . "(");

                my int $p = 0;
                while ($p < $param_count) {
                    if ($p > 0) {
                        emit($cg, ", ");
                    }
                    my scalar $param = $params->[$p];
                    my int $ptype = $param->{"param_type"};
                    emit($cg, type_to_c($ptype) . " " . escape_c_keyword($param->{"name"}));
                    $p = $p + 1;
                }

                if ($param_count == 0) {
                    emit($cg, "void");
                }

                emit($cg, ");\n");

                # Register in functions context so calls work correctly
                my hash %func_info = ();
                $func_info{"name"} = $fn_name;
                $func_info{"return_type"} = $ret_type;
                $func_info{"param_count"} = $param_count;
                $func_info{"params"} = $params;
                $func_info{"is_import_lib"} = 1;
                $func_info{"is_variadic"} = $fn_info->{"is_variadic"};
                $func_info{"variadic_param_idx"} = $fn_info->{"variadic_param_idx"};
                $cg->{"functions"}->{$fn_name} = \%func_info;

                $fn_idx = $fn_idx + 1;
            }

            $lib_idx = $lib_idx + 1;
        }
        emit($cg, "\n");
    }

    # Generate import_object extern declarations (for statically linked object files)
    my int $import_object_count = $program->{"import_object_count"};
    if ($import_object_count > 0) {
        my scalar $import_objects = $program->{"import_objects"};

        emit($cg, "/* import_object: extern declarations for statically linked functions */\n");
        my int $obj_idx = 0;
        while ($obj_idx < $import_object_count) {
            my scalar $obj_info = $import_objects->[$obj_idx];
            my str $obj_name = $obj_info->{"obj_name"};
            my scalar $functions = $obj_info->{"functions"};
            my int $fn_count = $obj_info->{"function_count"};

            emit($cg, "/* Functions from " . $obj_name . ".o */\n");

            my int $fn_idx = 0;
            while ($fn_idx < $fn_count) {
                my scalar $fn_info = $functions->[$fn_idx];
                my str $fn_name = $fn_info->{"name"};
                my int $ret_type = $fn_info->{"return_type"};
                my int $param_count = $fn_info->{"param_count"};
                my scalar $params = $fn_info->{"params"};

                # Generate extern declaration
                emit($cg, "extern " . type_to_c($ret_type) . " " . $fn_name . "(");

                my int $pi = 0;
                while ($pi < $param_count) {
                    if ($pi > 0) {
                        emit($cg, ", ");
                    }
                    my scalar $param = $params->[$pi];
                    my int $ptype = $param->{"type"};
                    emit($cg, type_to_c($ptype));
                    $pi = $pi + 1;
                }
                if ($param_count == 0) {
                    emit($cg, "void");
                }
                emit($cg, ");\n");

                # Register in functions context so calls work
                my hash %func_info = ();
                $func_info{"name"} = $fn_name;
                $func_info{"return_type"} = $ret_type;
                $func_info{"param_count"} = $param_count;
                $func_info{"params"} = $params;
                $func_info{"is_import_object"} = 1;
                $func_info{"is_variadic"} = $fn_info->{"is_variadic"};
                $func_info{"variadic_param_idx"} = $fn_info->{"variadic_param_idx"};
                $cg->{"functions"}->{$fn_name} = \%func_info;

                $fn_idx = $fn_idx + 1;
            }

            $obj_idx = $obj_idx + 1;
        }
        emit($cg, "\n");
    }

    # Generate import_archive extern declarations (for statically linked archive files)
    my int $import_archive_count = $program->{"import_archive_count"};
    if ($import_archive_count > 0) {
        my scalar $import_archives = $program->{"import_archives"};

        emit($cg, "/* import_archive: extern declarations for statically linked functions */\n");
        my int $arch_idx = 0;
        while ($arch_idx < $import_archive_count) {
            my scalar $arch_info = $import_archives->[$arch_idx];
            my str $arch_name = $arch_info->{"lib_name"};
            my scalar $functions = $arch_info->{"functions"};
            my int $fn_count = $arch_info->{"function_count"};

            emit($cg, "/* Functions from " . $arch_name . ".a */\n");

            my int $fn_idx = 0;
            while ($fn_idx < $fn_count) {
                my scalar $fn_info = $functions->[$fn_idx];
                my str $fn_name = $fn_info->{"name"};
                my int $ret_type = $fn_info->{"return_type"};
                my int $param_count = $fn_info->{"param_count"};
                my scalar $params = $fn_info->{"params"};

                # Generate extern declaration
                emit($cg, "extern " . type_to_c($ret_type) . " " . $fn_name . "(");

                my int $pi = 0;
                while ($pi < $param_count) {
                    if ($pi > 0) {
                        emit($cg, ", ");
                    }
                    my scalar $param = $params->[$pi];
                    my int $ptype = $param->{"type"};
                    emit($cg, type_to_c($ptype));
                    $pi = $pi + 1;
                }
                if ($param_count == 0) {
                    emit($cg, "void");
                }
                emit($cg, ");\n");

                # Register in functions context so calls work
                my hash %func_info = ();
                $func_info{"name"} = $fn_name;
                $func_info{"return_type"} = $ret_type;
                $func_info{"param_count"} = $param_count;
                $func_info{"params"} = $params;
                $func_info{"is_import_archive"} = 1;
                $func_info{"is_variadic"} = $fn_info->{"is_variadic"};
                $func_info{"variadic_param_idx"} = $fn_info->{"variadic_param_idx"};
                $cg->{"functions"}->{$fn_name} = \%func_info;

                $fn_idx = $fn_idx + 1;
            }

            $arch_idx = $arch_idx + 1;
        }
        emit($cg, "\n");
    }

    # Forward declarations
    $i = 0;
    while ($i < $program->{"function_count"}) {
        my scalar $fn = $funcs->[$i];
        my str $name = sanitize_name($fn->{"name"});
        my int $fn_type = $fn->{"type"};

        # Skip extern functions (they're declared elsewhere)
        if ($fn_type == NODE_EXTERN_FUNC()) {
            # Generate extern declaration
            emit($cg, "extern ");
            gen_extern_decl($cg, $fn);
            $i = $i + 1;
            next;
        }

        if ($name eq "main") {
            emit($cg, "int main(int _argc, char **_argv);\n");
        } else {
            # Private functions get static prefix
            my str $static_prefix = "";
            if ($fn->{"is_private"} == 1) {
                $static_prefix = "static ";
            }
            emit($cg, $static_prefix . type_to_c($fn->{"return_type"}) . " " . $name . "(");
            
            my scalar $params = $fn->{"params"};
            my int $j = 0;
            while ($j < $fn->{"param_count"}) {
                if ($j > 0) {
                    emit($cg, ", ");
                }
                my scalar $param = $params->[$j];
                my int $ptype = $param->{"param_type"};
                my str $c_pname = escape_c_keyword($param->{"name"});
                emit($cg, type_to_c($ptype) . " " . $c_pname);
                $j = $j + 1;
            }

            if ($fn->{"param_count"} == 0) {
                emit($cg, "void");
            }

            emit($cg, ");\n");
        }
        $i = $i + 1;
    }

    # NOTE: OOP init forward declarations are generated after methods are tracked
    # and stored in oop_fwd_decls for insertion in get_output()

    # Forward declarations for BEGIN/END blocks (only if they exist)
    my int $begin_block_count = $cg->{"begin_block_count"};
    my int $end_block_count = $cg->{"end_block_count"};
    if ($begin_block_count > 0 || $end_block_count > 0) {
        emit($cg, "\n/* BEGIN/END block forward declarations */\n");
        my int $bi = 0;
        while ($bi < $begin_block_count) {
            emit($cg, "static void __begin_" . $bi . "(void);\n");
            $bi = $bi + 1;
        }
        my int $ei = 0;
        while ($ei < $end_block_count) {
            emit($cg, "static void __end_" . $ei . "(void);\n");
            $ei = $ei + 1;
        }
    }

    emit($cg, "\n");

    # Save preamble content and start fresh for function definitions
    $cg->{"preamble_content"} = sb_to_string($cg->{"output_sb"});
    sb_clear($cg->{"output_sb"});

    # Function definitions (skip extern declarations without bodies)
    $i = 0;
    while ($i < $program->{"function_count"}) {
        my scalar $fn = $funcs->[$i];
        my int $fn_type = $fn->{"type"};

        if ($fn_type == NODE_EXTERN_FUNC()) {
            # Extern with body - generate the function
            if ($fn->{"has_body"} == 1) {
                gen_extern_function($cg, $fn);
            }
        } elsif ($fn_type == NODE_ASYNC_FUNC()) {
            gen_async_function($cg, $fn);
        } else {
            gen_function($cg, $fn);
        }

        # Track method for OOP registration using the function's stored package
        # (check package string directly - parser always sets it)
        my str $fn_pkg = $fn->{"package"};
        if (length($fn_pkg) > 0 && $fn_pkg ne "main") {
            codegen_track_method($cg, $fn, $fn_pkg);
        }

        $i = $i + 1;
    }

    # Generate OOP init forward declarations (now that methods are tracked)
    my int $num_fwd_pkgs = get_oop_pkg_count($cg);
    if ($num_fwd_pkgs > 0) {
        my scalar $fwd_pkgs = get_oop_packages($cg);
        my str $fwd_decls = "\n/* OOP method registration forward declarations */\n";
        my int $fwd_i = 0;
        while ($fwd_i < $num_fwd_pkgs) {
            my str $fwd_pkg = $fwd_pkgs->[$fwd_i];
            my str $c_fwd_pkg = sanitize_name($fwd_pkg);
            $fwd_decls = $fwd_decls . "void __" . $c_fwd_pkg . "_oop_init(void);\n";
            $fwd_i = $fwd_i + 1;
        }
        $cg->{"oop_fwd_decls"} = $fwd_decls;
    }

    # Emit anonymous function definitions
    my str $anon_defs = $cg->{"anon_func_defs"};
    if (length($anon_defs) > 0) {
        emit($cg, "\n/* Anonymous function definitions */\n");
        emit($cg, $anon_defs);
    }

    # Emit OOP method wrappers for all packages
    my str $wrappers = gen_all_method_wrappers($cg);
    if (length($wrappers) > 0) {
        emit($cg, "\n");
        emit($cg, $wrappers);
    }

    # Generate import_lib wrapper function implementations
    if ($import_lib_count > 0) {
        my scalar $import_libs = $program->{"import_libs"};
        emit($cg, "\n/* import_lib: wrapper function implementations */\n");

        my int $lib_idx = 0;
        while ($lib_idx < $import_lib_count) {
            my scalar $lib_info = $import_libs->[$lib_idx];
            my str $lib_name = $lib_info->{"lib_name"};
            my str $safe_lib = sanitize_name($lib_name);
            my str $so_path = $lib_info->{"so_path"};

            my scalar $lib_funcs = $lib_info->{"functions"};
            my int $fn_idx = 0;
            my int $fn_count = $lib_info->{"function_count"};

            while ($fn_idx < $fn_count) {
                my scalar $fn_info = $lib_funcs->[$fn_idx];
                my str $fn_name = sanitize_name($fn_info->{"name"});
                my int $ret_type = $fn_info->{"return_type"};
                my int $param_count = $fn_info->{"param_count"};
                my scalar $params = $fn_info->{"params"};

                # Function signature
                emit($cg, type_to_c($ret_type) . " " . $fn_name . "(");

                my int $p = 0;
                while ($p < $param_count) {
                    if ($p > 0) {
                        emit($cg, ", ");
                    }
                    my scalar $param = $params->[$p];
                    my int $ptype = $param->{"param_type"};
                    emit($cg, type_to_c($ptype) . " " . escape_c_keyword($param->{"name"}));
                    $p = $p + 1;
                }

                if ($param_count == 0) {
                    emit($cg, "void");
                }

                emit($cg, ") {\n");

                # Lazy load the library
                emit($cg, "    if (__import_lib_" . $safe_lib . "_handle == NULL) {\n");
                emit($cg, "        __import_lib_" . $safe_lib . "_handle = dlopen(\"" . $so_path . "\", RTLD_LAZY);\n");
                emit($cg, "        if (__import_lib_" . $safe_lib . "_handle == NULL) {\n");
                emit($cg, "            fprintf(stderr, \"import_lib: failed to load " . $so_path . ": %s\\n\", dlerror());\n");
                emit($cg, "            exit(1);\n");
                emit($cg, "        }\n");
                # Call OOP init functions for any packages in this library
                my scalar $oop_inits = $lib_info->{"oop_init_funcs"};
                if ($oop_inits) {
                    my int $oop_count = size($oop_inits);
                    my int $oi = 0;
                    while ($oi < $oop_count) {
                        my str $oop_fn = $oop_inits->[$oi];
                        emit($cg, "        { void (*__oop_init)(void) = (void (*)(void))dlsym(__import_lib_" . $safe_lib . "_handle, \"" . $oop_fn . "\"); if (__oop_init) __oop_init(); }\n");
                        $oi = $oi + 1;
                    }
                }
                emit($cg, "    }\n");

                # Lazy lookup the function pointer
                emit($cg, "    if (__import_lib_" . $safe_lib . "_fn_" . $fn_name . " == NULL) {\n");
                emit($cg, "        __import_lib_" . $safe_lib . "_fn_" . $fn_name . " = dlsym(__import_lib_" . $safe_lib . "_handle, \"" . $fn_name . "\");\n");
                emit($cg, "        if (__import_lib_" . $safe_lib . "_fn_" . $fn_name . " == NULL) {\n");
                emit($cg, "            fprintf(stderr, \"import_lib: symbol not found: " . $fn_name . ": %s\\n\", dlerror());\n");
                emit($cg, "            exit(1);\n");
                emit($cg, "        }\n");
                emit($cg, "    }\n");

                # Generate typedef for the function pointer type
                emit($cg, "    typedef " . type_to_c($ret_type) . " (*__fn_type_" . $fn_name . ")(");
                $p = 0;
                while ($p < $param_count) {
                    if ($p > 0) {
                        emit($cg, ", ");
                    }
                    emit($cg, "StradaValue*");
                    $p = $p + 1;
                }
                if ($param_count == 0) {
                    emit($cg, "void");
                }
                emit($cg, ");\n");

                # Cast and call the function directly
                emit($cg, "    __fn_type_" . $fn_name . " __fn = (__fn_type_" . $fn_name . ")__import_lib_" . $safe_lib . "_fn_" . $fn_name . ";\n");
                if ($ret_type == TYPE_VOID()) {
                    emit($cg, "    __fn(");
                } else {
                    emit($cg, "    return __fn(");
                }
                $p = 0;
                while ($p < $param_count) {
                    if ($p > 0) {
                        emit($cg, ", ");
                    }
                    my scalar $param = $params->[$p];
                    emit($cg, escape_c_keyword($param->{"name"}));
                    $p = $p + 1;
                }
                emit($cg, ");\n");

                emit($cg, "}\n\n");
                $fn_idx = $fn_idx + 1;
            }

            $lib_idx = $lib_idx + 1;
        }
    }

    # Generate import_object: object file list comment (for strada wrapper to parse)
    # NOTE: extern declarations are generated earlier with other forward declarations
    my int $io_count = $program->{"import_object_count"};
    if ($io_count > 0) {
        my scalar $io_objs = $program->{"import_objects"};

        # Emit object file list as a comment for strada wrapper to parse
        emit($cg, "\n/* import_object: required object files\n");
        emit($cg, " * __STRADA_OBJECT_FILES__:");
        my int $io_idx = 0;
        while ($io_idx < $io_count) {
            my scalar $io_info = $io_objs->[$io_idx];
            my str $io_path = $io_info->{"o_path"};
            emit($cg, " " . $io_path);
            $io_idx = $io_idx + 1;
        }
        emit($cg, "\n */\n\n");
    }

    # Generate import_archive: archive file list comment (for strada wrapper to parse)
    my int $ia_count = $program->{"import_archive_count"};
    if ($ia_count > 0) {
        my scalar $ia_archs = $program->{"import_archives"};

        # Emit archive file list as a comment for strada wrapper to parse
        emit($cg, "\n/* import_archive: required archive files\n");
        emit($cg, " * __STRADA_ARCHIVE_FILES__:");
        my int $ia_idx = 0;
        while ($ia_idx < $ia_count) {
            my scalar $ia_info = $ia_archs->[$ia_idx];
            my str $ia_path = $ia_info->{"a_path"};
            emit($cg, " " . $ia_path);
            $ia_idx = $ia_idx + 1;
        }
        emit($cg, "\n * __STRADA_SKIP_RUNTIME__: archives include runtime\n");
        emit($cg, " */\n\n");
    }

    # Generate BEGIN/END block function bodies (only if they exist)
    if ($begin_block_count > 0 || $end_block_count > 0) {
        emit($cg, "\n/* BEGIN/END block implementations */\n");
        if ($begin_block_count > 0) {
            my scalar $begin_blocks = $cg->{"begin_blocks"};
            my int $bi = 0;
            while ($bi < $begin_block_count) {
                emit($cg, "static void __begin_" . $bi . "(void) {\n");
                # Generate statements for this BEGIN block
                my scalar $begin_body = $begin_blocks->[$bi];
                my scalar $begin_stmts = $begin_body->{"statements"};
                my int $begin_stmt_count = $begin_body->{"statement_count"};
                scope_push($cg);
                my int $bs = 0;
                while ($bs < $begin_stmt_count) {
                    gen_statement($cg, $begin_stmts->[$bs]);
                    $bs = $bs + 1;
                }
                scope_pop($cg);
                emit($cg, "}\n\n");
                $bi = $bi + 1;
            }
        }
        if ($end_block_count > 0) {
            my scalar $end_blocks = $cg->{"end_blocks"};
            my int $ei = 0;
            while ($ei < $end_block_count) {
                emit($cg, "static void __end_" . $ei . "(void) {\n");
                # Generate statements for this END block
                my scalar $end_body = $end_blocks->[$ei];
                my scalar $end_stmts = $end_body->{"statements"};
                my int $end_stmt_count = $end_body->{"statement_count"};
                scope_push($cg);
                my int $es = 0;
                while ($es < $end_stmt_count) {
                    gen_statement($cg, $end_stmts->[$es]);
                    $es = $es + 1;
                }
                scope_pop($cg);
                emit($cg, "}\n\n");
                $ei = $ei + 1;
            }
        }
    }

    # Save funcs content and start fresh for remaining code
    $cg->{"funcs_content"} = sb_to_string($cg->{"output_sb"});
    sb_clear($cg->{"output_sb"});

    # Generate qualified name aliases if package is declared
    my str $pkg_alias = $program->{"package"};
    if ($pkg_alias ne "") {
        # Convert :: to __ for C identifier
        my str $prefix = "";
        my int $p = 0;
        my int $plen = length($pkg_alias);
        while ($p < $plen) {
            my str $ch = substr($pkg_alias, $p, 1);
            if ($ch eq ":") {
                $prefix = $prefix . "_";
            } else {
                $prefix = $prefix . $ch;
            }
            $p = $p + 1;
        }
        $prefix = $prefix . "__";

        emit($cg, "/* Qualified name aliases for package " . $pkg_alias . " */\n");
        $i = 0;
        while ($i < $program->{"function_count"}) {
            my scalar $fn = $funcs->[$i];
            my int $fn_type = $fn->{"type"};
            my str $name = sanitize_name($fn->{"name"});

            # Skip main and extern functions
            if ($name ne "main" && $fn_type != NODE_EXTERN_FUNC()) {
                my str $ret = type_to_c($fn->{"return_type"});
                my str $qname = sanitize_name($prefix . $fn->{"name"});

                # Generate: RetType QualifiedName(params) { return UnqualifiedName(params); }
                emit($cg, $ret . " " . $qname . "(");

                my scalar $params = $fn->{"params"};
                my int $j = 0;
                while ($j < $fn->{"param_count"}) {
                    if ($j > 0) {
                        emit($cg, ", ");
                    }
                    my scalar $param = $params->[$j];
                    my int $ptype = $param->{"param_type"};
                    my str $c_pname = escape_c_keyword($param->{"name"});
                    emit($cg, type_to_c($ptype) . " " . $c_pname);
                    $j = $j + 1;
                }
                if ($fn->{"param_count"} == 0) {
                    emit($cg, "void");
                }
                emit($cg, ") { return " . $name . "(");

                $j = 0;
                while ($j < $fn->{"param_count"}) {
                    if ($j > 0) {
                        emit($cg, ", ");
                    }
                    emit($cg, escape_c_keyword($params->[$j]->{"name"}));
                    $j = $j + 1;
                }
                emit($cg, "); }\n");
            }
            $i = $i + 1;
        }
        emit($cg, "\n");
    }

    # Generate __strada_export_info function for shared library metadata
    # This allows import_lib to work without needing the .strada source file
    # Pass has_main flag - for executables (with main), make these static to avoid conflicts
    my int $has_main_fn = 0;
    my int $mi = 0;
    while ($mi < $program->{"function_count"}) {
        if ($funcs->[$mi]->{"name"} eq "main") {
            $has_main_fn = 1;
            last;
        }
        $mi = $mi + 1;
    }
    gen_export_info($cg, $program, $has_main_fn);

    # Generate global initialization constructor for shared libraries (no main)
    if ($has_main_fn == 0) {
        gen_global_constructor($cg);
    }
}

# Generate __strada_export_info function that returns metadata about exported functions
# Format: "func:name:return_type:param_count:param_types:variadic_idx\n" for each function
# variadic_idx: index of variadic param (-1 if not variadic)
# $has_main: if true, make functions static to avoid conflicts when linked with object files
func gen_export_info(scalar $cg, scalar $program, int $has_main) void {
    my str $static_prefix = "";
    if ($has_main == 1) {
        $static_prefix = "static ";
    }
    emit($cg, "\n/* Strada export metadata for import_lib */\n");
    emit($cg, $static_prefix . "const char* __strada_export_info(void) {\n");
    emit($cg, "    return \"");

    my scalar $funcs = $program->{"functions"};
    my int $i = 0;
    my int $count = $program->{"function_count"};

    while ($i < $count) {
        my scalar $fn = $funcs->[$i];
        my str $name = $fn->{"name"};
        my int $fn_type = $fn->{"type"};

        # Skip main function, extern functions, and private functions
        my int $is_private = $fn->{"is_private"};
        if ($name ne "main" && $fn_type != NODE_EXTERN_FUNC() && $is_private != 1) {
            my int $ret_type = $fn->{"return_type"};
            my int $param_count = $fn->{"param_count"};

            # func:name:return_type:param_count:param_types:variadic_idx
            emit($cg, "func:" . sanitize_name($name) . ":" . type_to_export($ret_type) . ":" . $param_count . ":");

            my scalar $params = $fn->{"params"};
            my int $j = 0;
            while ($j < $param_count) {
                if ($j > 0) {
                    emit($cg, ",");
                }
                my scalar $param = $params->[$j];
                emit($cg, type_to_export($param->{"param_type"}));
                $j = $j + 1;
            }

            # Add variadic index
            my int $variadic_idx = -1;
            if ($fn->{"is_variadic"} == 1) {
                my int $k = 0;
                while ($k < $param_count) {
                    if ($params->[$k]->{"is_variadic"} == 1) {
                        $variadic_idx = $k;
                    }
                    $k = $k + 1;
                }
            }
            emit($cg, ":" . $variadic_idx);

            emit($cg, "\\n");
        }
        $i = $i + 1;
    }

    emit($cg, "\";\n");
    emit($cg, "}\n");

    # Also generate version info if specified
    gen_version_info($cg, $program, $has_main);
}

# Generate __strada_version function that returns the module version
func gen_version_info(scalar $cg, scalar $program, int $has_main) void {
    my str $static_prefix = "";
    if ($has_main == 1) {
        $static_prefix = "static ";
    }
    my str $version = "";
    if ($program->{"version"} ne "") {
        $version = $program->{"version"};
    }

    emit($cg, "\n/* Strada module version */\n");
    emit($cg, $static_prefix . "const char* __strada_version(void) {\n");
    emit($cg, "    return \"" . $version . "\";\n");
    emit($cg, "}\n");
}

# Generate global variable initialization constructor for shared libraries
# This runs automatically when the library is loaded (dlopen)
func gen_global_constructor(scalar $cg) void {
    my int $global_count = $cg->{"global_count"};
    my int $num_oop_pkgs = get_oop_pkg_count($cg);
    my int $lib_begin_count = $cg->{"begin_block_count"};
    my int $lib_end_count = $cg->{"end_block_count"};

    # Only generate constructor if there are globals, OOP methods, or BEGIN/END blocks
    if ($global_count == 0 && $num_oop_pkgs == 0 && $lib_begin_count == 0 && $lib_end_count == 0) {
        return;
    }

    emit($cg, "\n/* Shared library global initialization */\n");
    emit($cg, "__attribute__((constructor))\n");
    emit($cg, "static void __strada_init_globals(void) {\n");

    # Initialize OOP method registration for all packages that have methods
    if ($num_oop_pkgs > 0) {
        my scalar $oop_pkgs = get_oop_packages($cg);
        emit($cg, "    /* Initialize OOP method registration */\n");
        my int $oop_i = 0;
        while ($oop_i < $num_oop_pkgs) {
            my str $oop_pkg = $oop_pkgs->[$oop_i];
            my str $c_oop_pkg = sanitize_name($oop_pkg);
            emit($cg, "    __" . $c_oop_pkg . "_oop_init();\n");
            $oop_i = $oop_i + 1;
        }
        emit($cg, "\n");
    }

    # Initialize globals
    if ($global_count > 0) {
        my scalar $globals = $cg->{"globals"};
        my int $g = 0;
        while ($g < $global_count) {
            my scalar $gvar = $globals->[$g];
            my int $gvar_type = $gvar->{"type"};
            my int $var_type = $gvar->{"var_type"};
            my str $sigil = $gvar->{"sigil"};
            my str $name = $gvar->{"name"};
            my scalar $init = $gvar->{"init"};

            # Handle our declarations - use global registry
            if ($gvar_type == NODE_OUR_DECL()) {
                if ($init) {
                    my str $pkg = $gvar->{"package"};
                    if (length($pkg) == 0) { $pkg = "main"; }
                    my str $our_key = $pkg . "::" . $name;
                    emit($cg, "    strada_global_set(strada_new_str(\"" . $our_key . "\"), ");
                    gen_expression($cg, $init);
                    emit($cg, ");\n");
                    # Register in our_vars for codegen
                    my scalar $our_vars_ref3 = $cg->{"our_vars"};
                    $our_vars_ref3->{$name} = $our_key;
                }
                $g = $g + 1;
                next;
            }

            # Handle const declarations - initialize static variables
            if ($gvar_type == NODE_CONST_DECL()) {
                my int $init_type = $init->{"type"};
                if ($init_type == NODE_INT_LITERAL() || $init_type == NODE_NUM_LITERAL() || $init_type == NODE_STR_LITERAL()) {
                    emit($cg, "    if (" . $name . " == NULL) {\n");
                    emit($cg, "        " . $name . " = ");
                    gen_expression($cg, $init);
                    emit($cg, ";\n");
                    emit($cg, "    }\n");
                    $g = $g + 1;
                    next;
                }
            }

            # Skip if already initialized (non-NULL check for safety)
            emit($cg, "    if (" . $name . " == NULL) {\n");
            emit($cg, "        " . $name . " = ");

            if ($sigil eq "%" || $var_type == TYPE_HASH()) {
                if ($init) {
                    # Handle empty () which parser returns as anon_hash
                    if ($init->{"type"} == NODE_ANON_HASH() && $init->{"pair_count"} == 0) {
                        emit($cg, "strada_new_hash()");
                    } else {
                        gen_expression($cg, $init);
                    }
                } else {
                    emit($cg, "strada_new_hash()");
                }
            } elsif ($sigil eq "@" || $var_type == TYPE_ARRAY()) {
                if ($init) {
                    # Handle empty () which parser returns as anon_hash
                    if ($init->{"type"} == NODE_ANON_HASH() && $init->{"pair_count"} == 0) {
                        emit($cg, "strada_new_array()");
                    } else {
                        gen_expression($cg, $init);
                    }
                } else {
                    emit($cg, "strada_new_array()");
                }
            } else {
                if ($init) {
                    gen_expression($cg, $init);
                } else {
                    emit($cg, "strada_new_undef()");
                }
            }
            emit($cg, ";\n");
            emit($cg, "    }\n");
            $g = $g + 1;
        }
    }

    # Call BEGIN blocks in shared library constructor
    if ($lib_begin_count > 0) {
        emit($cg, "\n    /* BEGIN blocks */\n");
        my int $lbi = 0;
        while ($lbi < $lib_begin_count) {
            emit($cg, "    __begin_" . $lbi . "();\n");
            $lbi = $lbi + 1;
        }
    }

    # Register END blocks via atexit in shared library constructor
    if ($lib_end_count > 0) {
        emit($cg, "\n    /* Register END blocks (run at exit in LIFO order) */\n");
        my int $lei = 0;
        while ($lei < $lib_end_count) {
            emit($cg, "    atexit(__end_" . $lei . ");\n");
            $lei = $lei + 1;
        }
    }

    emit($cg, "}\n");
}

# Convert type constant to export string
func type_to_export(int $type) str {
    if ($type == TYPE_INT()) { return "int"; }
    if ($type == TYPE_NUM()) { return "num"; }
    if ($type == TYPE_STR()) { return "str"; }
    if ($type == TYPE_BOOL()) { return "bool"; }
    if ($type == TYPE_ARRAY()) { return "array"; }
    if ($type == TYPE_HASH()) { return "hash"; }
    if ($type == TYPE_SCALAR()) { return "scalar"; }
    if ($type == TYPE_VOID()) { return "void"; }
    # Explicit sized types
    if ($type == TYPE_INT32()) { return "int32"; }
    if ($type == TYPE_INT64()) { return "int64"; }
    if ($type == TYPE_FLOAT32()) { return "float32"; }
    if ($type == TYPE_FLOAT64()) { return "float64"; }
    if ($type == TYPE_INT8()) { return "int8"; }
    if ($type == TYPE_INT16()) { return "int16"; }
    if ($type == TYPE_UINT8()) { return "uint8"; }
    if ($type == TYPE_UINT16()) { return "uint16"; }
    if ($type == TYPE_UINT32()) { return "uint32"; }
    if ($type == TYPE_UINT64()) { return "uint64"; }
    if ($type == TYPE_SIZE_T()) { return "size_t"; }
    if ($type == TYPE_CHAR()) { return "char"; }
    if ($type == TYPE_LONG_DOUBLE()) { return "long_double"; }
    if ($type == TYPE_DYNAMIC()) { return "dynamic"; }
    return "scalar";
}

# Generate extern function with body
func gen_extern_function(scalar $cg, scalar $fn) void {
    my str $ret_type = type_to_c_raw($fn->{"return_type"});
    my str $name = sanitize_name($fn->{"name"});

    emit($cg, $ret_type . " " . $name . "(");

    my scalar $params = $fn->{"params"};
    my int $i = 0;
    while ($i < $fn->{"param_count"}) {
        if ($i > 0) {
            emit($cg, ", ");
        }
        my scalar $param = $params->[$i];
        emit($cg, type_to_c_raw($param->{"param_type"}) . " " . escape_c_keyword($param->{"name"}));
        $i = $i + 1;
    }

    if ($fn->{"param_count"} == 0) {
        emit($cg, "void");
    }

    emit($cg, ") ");
    $cg->{"in_extern"} = 1;  # Enable raw C code generation
    # Track extern function parameter types for string interpolation conversion
    # Use escaped names to match variable references
    my hash %extern_params = ();
    my int $p = 0;
    while ($p < $fn->{"param_count"}) {
        my scalar $param = $params->[$p];
        my str $c_pname = escape_c_keyword($param->{"name"});
        $extern_params{$c_pname} = $param->{"param_type"};
        $p = $p + 1;
    }
    $cg->{"extern_params"} = \%extern_params;
    gen_block($cg, $fn->{"body"});
    $cg->{"in_extern"} = 0;  # Disable raw C code generation
    $cg->{"extern_params"} = {};
    emit($cg, "\n\n");
}

# Generate extern function declaration
func gen_extern_decl(scalar $cg, scalar $fn) void {
    my str $ret_type = type_to_c_raw($fn->{"return_type"});
    emit($cg, $ret_type . " " . sanitize_name($fn->{"name"}) . "(");

    my scalar $params = $fn->{"params"};
    my int $i = 0;
    while ($i < $fn->{"param_count"}) {
        if ($i > 0) {
            emit($cg, ", ");
        }
        my scalar $param = $params->[$i];
        emit($cg, type_to_c_raw($param->{"param_type"}) . " " . escape_c_keyword($param->{"name"}));
        $i = $i + 1;
    }

    if ($fn->{"param_count"} == 0) {
        emit($cg, "void");
    }
    
    emit($cg, ");\n");
}

# Convert type to raw C type (for extern functions)
func type_to_c_raw(int $type) str {
    if ($type == TYPE_INT()) { return "int"; }
    if ($type == TYPE_BOOL()) { return "bool"; }
    if ($type == TYPE_NUM()) { return "double"; }
    if ($type == TYPE_STR()) { return "char*"; }
    if ($type == TYPE_VOID()) { return "void"; }
    # Explicit sized types
    if ($type == TYPE_INT32()) { return "int32_t"; }
    if ($type == TYPE_INT64()) { return "int64_t"; }
    if ($type == TYPE_FLOAT32()) { return "float"; }
    if ($type == TYPE_FLOAT64()) { return "double"; }
    if ($type == TYPE_INT8()) { return "int8_t"; }
    if ($type == TYPE_INT16()) { return "int16_t"; }
    if ($type == TYPE_UINT8()) { return "uint8_t"; }
    if ($type == TYPE_UINT16()) { return "uint16_t"; }
    if ($type == TYPE_UINT32()) { return "uint32_t"; }
    if ($type == TYPE_UINT64()) { return "uint64_t"; }
    if ($type == TYPE_SIZE_T()) { return "size_t"; }
    if ($type == TYPE_CHAR()) { return "char"; }
    if ($type == TYPE_LONG_DOUBLE()) { return "long double"; }
    return "void*";
}

# ============================================================
# Main Entry Point
# ============================================================

func generate(scalar $ast, str $filename, int $debug_info, int $enable_profiling, int $enable_stack_trace) str {
    my scalar $cg = codegen_new($filename, $debug_info, $enable_profiling, $enable_stack_trace);
    gen_program($cg, $ast);
    return get_output($cg);  # Join array into final string
}
