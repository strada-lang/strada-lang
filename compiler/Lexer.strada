/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger
 
 This program is free software: you can redistribute it and/or modify  
 it under the terms of the GNU General Public License as published by  
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but 
 WITHOUT ANY WARRANTY; without even the implied warranty of 
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 General Public License for more details.

 You should have received a copy of the GNU General Public License 
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

# Strada/Lexer.strada - Strada Lexer written in Strada
# This file will be compiled by the bootstrap compiler to create a self-hosting compiler

func lex_new(str $source) scalar {
    my hash %lexer = ();
    $lexer{"source"} = $source;
    $lexer{"pos"} = 0;
    $lexer{"line"} = 1;
    $lexer{"column"} = 1;
    # Use bytes() not length() since char_at() works on byte positions
    $lexer{"length"} = bytes($source);
    $lexer{"expect_regex"} = 0;
    return \%lexer;
}

# Fast char code access - no string allocation
func lex_current_code(scalar $lexer) int {
    my int $pos = $lexer->{"pos"};
    my int $len = $lexer->{"length"};
    if ($pos >= $len) {
        return 0;
    }
    return char_at($lexer->{"source"}, $pos);
}

# Returns current char as string (for compatibility)
func lex_current_char(scalar $lexer) str {
    my int $code = lex_current_code($lexer);
    if ($code == 0) {
        return "";
    }
    return chr($code);
}

func lex_advance(scalar $lexer) void {
    my int $code = lex_current_code($lexer);

    if ($code == 10) {  # '\n'
        $lexer->{"line"} = $lexer->{"line"} + 1;
        $lexer->{"column"} = 1;
    } else {
        $lexer->{"column"} = $lexer->{"column"} + 1;
    }

    $lexer->{"pos"} = $lexer->{"pos"} + 1;
}

func lex_skip_whitespace(scalar $lexer) void {
    while (1) {
        my int $code = lex_current_code($lexer);

        if ($code == 0) {
            return;
        }

        # Space=32, Tab=9, LF=10, CR=13
        if ($code == 32 || $code == 9 || $code == 10 || $code == 13) {
            lex_advance($lexer);
        } else {
            return;
        }
    }
}

func lex_skip_comment(scalar $lexer) void {
    my int $code = lex_current_code($lexer);

    if ($code != 35) {  # '#'
        return;
    }

    # Skip until end of line
    while (1) {
        lex_advance($lexer);
        $code = lex_current_code($lexer);

        if ($code == 0 || $code == 10) {  # EOF or '\n'
            return;
        }
    }
}

func lex_skip_block_comment(scalar $lexer) void {
    # Skip the opening /*
    lex_advance($lexer);
    lex_advance($lexer);

    # Skip until we find */
    while (1) {
        my int $code = lex_current_code($lexer);

        if ($code == 0) {
            die("Unterminated block comment");
        }

        # Check for */  ('*'=42, '/'=47)
        if ($code == 42) {
            my int $next_code = char_at($lexer->{"source"}, $lexer->{"pos"} + 1);
            if ($next_code == 47) {
                lex_advance($lexer);
                lex_advance($lexer);
                return;
            }
        }

        lex_advance($lexer);
    }
}

# Check if current position starts a POD directive
# POD directives: =head1, =head2, =head3, =head4, =over, =item, =back, =pod, =cut, =begin, =end, =for
func lex_is_pod_start(scalar $lexer) int {
    my str $source = $lexer->{"source"};
    my int $pos = $lexer->{"pos"};
    my int $len = length($source);

    # Must start with '=' (61)
    if (char_at($source, $pos) != 61) {
        return 0;
    }

    # Check for POD keywords after '='
    # We need at least 4 chars for shortest: =pod, =for, =cut
    if ($pos + 4 > $len) {
        return 0;
    }

    my str $word = substr($source, $pos + 1, 5);

    # Check prefixes using substr comparison
    if (substr($word, 0, 4) eq "head") { return 1; }
    if (substr($word, 0, 4) eq "over") { return 1; }
    if (substr($word, 0, 4) eq "item") { return 1; }
    if (substr($word, 0, 4) eq "back") { return 1; }
    if (substr($word, 0, 3) eq "pod") { return 1; }
    if (substr($word, 0, 3) eq "cut") { return 1; }
    if (substr($word, 0, 5) eq "begin") { return 1; }
    if (substr($word, 0, 3) eq "end") { return 1; }
    if (substr($word, 0, 3) eq "for") { return 1; }

    return 0;
}

# Skip POD block (from =pod/=head/etc to =cut)
func lex_skip_pod(scalar $lexer) void {
    my str $source = $lexer->{"source"};
    my int $len = length($source);

    # Skip until we find =cut at start of line
    while (1) {
        my int $code = lex_current_code($lexer);

        if ($code == 0) {
            # EOF - POD extends to end of file (valid in Perl)
            return;
        }

        # Check for =cut at start of line
        if ($code == 61) {  # '='
            my int $pos = $lexer->{"pos"};
            if ($pos + 4 <= $len) {
                my str $word = substr($source, $pos + 1, 3);
                if ($word eq "cut") {
                    # Skip "=cut" and rest of line
                    lex_advance($lexer);  # =
                    lex_advance($lexer);  # c
                    lex_advance($lexer);  # u
                    lex_advance($lexer);  # t
                    # Skip to end of line
                    while (1) {
                        $code = lex_current_code($lexer);
                        if ($code == 0 || $code == 10) {
                            if ($code == 10) {
                                lex_advance($lexer);
                            }
                            return;
                        }
                        lex_advance($lexer);
                    }
                }
            }
        }

        # Skip to next line
        while (1) {
            $code = lex_current_code($lexer);
            if ($code == 0) {
                return;
            }
            lex_advance($lexer);
            if ($code == 10) {  # newline
                last;
            }
        }
    }
}

# Helper to check if char code is alphanumeric or underscore
func lex_is_ident_char(int $code) int {
    # a-z: 97-122, A-Z: 65-90, 0-9: 48-57, _: 95
    if ($code >= 97 && $code <= 122) { return 1; }
    if ($code >= 65 && $code <= 90) { return 1; }
    if ($code >= 48 && $code <= 57) { return 1; }
    if ($code == 95) { return 1; }
    return 0;
}

func lex_read_identifier(scalar $lexer) str {
    my scalar $sb = sb_new();

    while (1) {
        my int $code = lex_current_code($lexer);

        if ($code == 0) {
            return sb_to_string($sb);
        }

        if (lex_is_ident_char($code) == 1) {
            sb_append($sb, chr($code));
            lex_advance($lexer);
        } else {
            return sb_to_string($sb);
        }
    }
}

func lex_is_hex_digit_code(int $code) int {
    # 0-9: 48-57, a-f: 97-102, A-F: 65-70
    if ($code >= 48 && $code <= 57) { return 1; }
    if ($code >= 97 && $code <= 102) { return 1; }
    if ($code >= 65 && $code <= 70) { return 1; }
    return 0;
}

func lex_read_number(scalar $lexer) scalar {
    my scalar $sb = sb_new();
    my int $is_float = 0;
    my int $is_hex = 0;
    my int $token_line = $lexer->{"line"};

    # Check for hex prefix 0x or 0X
    my int $first_code = lex_current_code($lexer);
    if ($first_code == 48) {  # '0'
        sb_append($sb, chr($first_code));
        lex_advance($lexer);
        my int $second_code = lex_current_code($lexer);
        if ($second_code == 120 || $second_code == 88) {  # 'x' or 'X'
            $is_hex = 1;
            sb_append($sb, chr($second_code));
            lex_advance($lexer);
        }
    }

    while (1) {
        my int $code = lex_current_code($lexer);

        if ($code == 0) {
            my hash %token = ();
            if ($is_float) {
                $token{"type"} = "NUM_LITERAL";
            } else {
                $token{"type"} = "INT_LITERAL";
            }
            $token{"value"} = sb_to_string($sb);
            return \%token;
        }

        if ($is_hex) {
            if (lex_is_hex_digit_code($code)) {
                sb_append($sb, chr($code));
                lex_advance($lexer);
            } else {
                my hash %token = ();
                $token{"type"} = "INT_LITERAL";
                $token{"value"} = sb_to_string($sb);
                return \%token;
            }
        } else {
            # 0-9: 48-57
            if ($code >= 48 && $code <= 57) {
                sb_append($sb, chr($code));
                lex_advance($lexer);
            } elsif ($code == 46 && $is_float == 0) {  # '.'
                # Check for range operator before consuming dot
                my int $next_code = char_at($lexer->{"source"}, $lexer->{"pos"} + 1);
                if ($next_code == 46) {  # '..'
                    my hash %token = ();
                    $token{"type"} = "INT_LITERAL";
                    $token{"value"} = sb_to_string($sb);
                    $token{"line"} = $token_line;
                    return \%token;
                }
                $is_float = 1;
                sb_append($sb, chr($code));
                lex_advance($lexer);
            } else {
                my hash %token = ();
                if ($is_float) {
                    $token{"type"} = "NUM_LITERAL";
                } else {
                    $token{"type"} = "INT_LITERAL";
                }
                $token{"value"} = sb_to_string($sb);
                return \%token;
            }
        }
    }
}

# Read a single-quoted string (no interpolation) - optimized with char codes
func lex_read_sq_string(scalar $lexer) str {
    lex_advance($lexer); # Skip opening quote
    my scalar $sb = sb_new();
    my str $source = $lexer->{"source"};

    while (1) {
        my int $code = lex_current_code($lexer);
        my int $pos = $lexer->{"pos"};

        if ($code == 0) {
            die("Unterminated string");
        }

        # 39 = single quote
        if ($code == 39) {
            lex_advance($lexer); # Skip closing quote
            return sb_to_string($sb);
        }

        # 92 = backslash
        if ($code == 92) {
            lex_advance($lexer);
            my int $next_code = lex_current_code($lexer);
            my int $next_pos = $lexer->{"pos"};
            # 39 = ', 92 = \
            if ($next_code == 39 || $next_code == 92) {
                sb_append($sb, substr_bytes($source, $next_pos, 1));
            } else {
                # In single quotes, backslash is literal except for \' and \\
                sb_append($sb, "\\");
                sb_append($sb, substr_bytes($source, $next_pos, 1));
            }
            lex_advance($lexer);
        } else {
            # Use substr_bytes for byte-level extraction
            sb_append($sb, substr_bytes($source, $pos, 1));
            lex_advance($lexer);
        }
    }
}

# Read a double-quoted string (with interpolation support) - optimized with char codes
func lex_read_dq_string(scalar $lexer, int $token_line) scalar {
    lex_advance($lexer); # Skip opening quote

    my scalar $sb = sb_new();  # StringBuilder for current part
    my str $source = $lexer->{"source"};
    my array @parts = ();
    my array @vars = ();
    my int $has_interp = 0;
    my int $var_count = 0;

    while (1) {
        my int $code = lex_current_code($lexer);
        my int $pos = $lexer->{"pos"};

        if ($code == 0) {
            die("Unterminated string");
        }

        # 34 = double quote
        if ($code == 34) {
            lex_advance($lexer); # Skip closing quote

            if ($has_interp) {
                # Return interpolated string token
                push(\@parts, sb_to_string($sb));
                my hash %token = ();
                $token{"type"} = "INTERP_STRING";
                $token{"parts"} = \@parts;
                $token{"vars"} = \@vars;
                $token{"var_count"} = $var_count;
                $token{"line"} = $token_line;
                return \%token;
            } else {
                # Return regular string token
                my hash %token = ();
                $token{"type"} = "STR_LITERAL";
                $token{"value"} = sb_to_string($sb);
                $token{"line"} = $token_line;
                return \%token;
            }
        }

        # 92 = backslash
        if ($code == 92) {
            lex_advance($lexer);
            my int $next_code = lex_current_code($lexer);
            my int $next_pos = $lexer->{"pos"};

            # n=110, t=116, r=114, 0=48, a=97, b=98, f=102, v=118, e=101, \=92, "=34, $=36
            if ($next_code == 110) {
                sb_append($sb, "\n");
            } elsif ($next_code == 116) {
                sb_append($sb, "\t");
            } elsif ($next_code == 114) {
                sb_append($sb, "\r");
            } elsif ($next_code == 48) {
                sb_append($sb, chr(0));
            } elsif ($next_code == 97) {
                sb_append($sb, chr(7));
            } elsif ($next_code == 98) {
                sb_append($sb, chr(8));
            } elsif ($next_code == 102) {
                sb_append($sb, chr(12));
            } elsif ($next_code == 118) {
                sb_append($sb, chr(11));
            } elsif ($next_code == 101) {
                sb_append($sb, chr(27));
            } elsif ($next_code == 92) {
                sb_append($sb, "\\");
            } elsif ($next_code == 34) {
                sb_append($sb, "\"");
            } elsif ($next_code == 36) {
                # Escaped dollar sign - literal $
                sb_append($sb, "$");
            } else {
                # Use substr_bytes for byte-level extraction
                sb_append($sb, substr_bytes($source, $next_pos, 1));
            }
            lex_advance($lexer);
        } elsif ($code == 36) {
            # 36 = $ - Check for interpolation ${varname}
            lex_advance($lexer);
            my int $peek_code = lex_current_code($lexer);

            # 123 = {
            if ($peek_code == 123) {
                lex_advance($lexer); # Skip {
                my scalar $ivar_sb = sb_new();

                while (1) {
                    my int $vc = lex_current_code($lexer);
                    if ($vc == 0) {
                        die("Unterminated interpolation in string");
                    }
                    # 125 = }
                    if ($vc == 125) {
                        lex_advance($lexer); # Skip }

                        my str $ivar = sb_to_string($ivar_sb);
                        if (length($ivar) == 0) {
                            die("Empty variable name in interpolation");
                        }

                        # Save current part and variable
                        push(\@parts, sb_to_string($sb));
                        push(\@vars, $ivar);
                        $var_count = $var_count + 1;
                        $sb = sb_new();  # Reset StringBuilder
                        $has_interp = 1;
                        break;
                    }
                    # Variable names are ASCII, so chr() is safe here
                    sb_append($ivar_sb, chr($vc));
                    lex_advance($lexer);
                }
            } else {
                # Just a literal $ not followed by {
                sb_append($sb, "$");
            }
        } else {
            # Use substr_bytes for byte-level extraction
            sb_append($sb, substr_bytes($source, $pos, 1));
            lex_advance($lexer);
        }
    }
}

# Legacy function for compatibility
func lex_read_string(scalar $lexer) str {
    my str $quote = lex_current_char($lexer);
    lex_advance($lexer); # Skip opening quote

    my str $result = "";

    while (1) {
        my str $ch = lex_current_char($lexer);

        if ($ch eq "") {
            die("Unterminated string");
        }

        if ($ch eq $quote) {
            lex_advance($lexer); # Skip closing quote
            return $result;
        }

        if ($ch eq "\\") {
            lex_advance($lexer);
            my str $nextch = lex_current_char($lexer);

            if ($nextch eq "n") {
                $result = $result . "\n";
            } elsif ($nextch eq "t") {
                $result = $result . "\t";
            } elsif ($nextch eq "r") {
                $result = $result . "\r";
            } elsif ($nextch eq "0") {
                # Null character
                $result = $result . chr(0);
            } elsif ($nextch eq "a") {
                # Bell/alert
                $result = $result . chr(7);
            } elsif ($nextch eq "b") {
                # Backspace
                $result = $result . chr(8);
            } elsif ($nextch eq "f") {
                # Form feed
                $result = $result . chr(12);
            } elsif ($nextch eq "v") {
                # Vertical tab
                $result = $result . chr(11);
            } elsif ($nextch eq "e") {
                # Escape character
                $result = $result . chr(27);
            } elsif ($nextch eq "\\") {
                $result = $result . "\\";
            } elsif ($nextch eq $quote) {
                $result = $result . $quote;
            } else {
                # Unknown escape - just include the character as-is
                $result = $result . $nextch;
            }

            lex_advance($lexer);
        } else {
            $result = $result . $ch;
            lex_advance($lexer);
        }
    }
}

func lex_at_end(scalar $lexer) int {
    if ($lexer->{"pos"} >= $lexer->{"length"}) {
        return 1;
    }
    return 0;
}

func lex_current(scalar $lexer) str {
    return lex_current_char($lexer);
}

func lex_peek_char(scalar $lexer, int $offset) str {
    my int $pos = $lexer->{"pos"} + $offset;
    if ($pos >= $lexer->{"length"}) {
        return "";
    }
    return substr($lexer->{"source"}, $pos, 1);
}

func lex_read_regex_literal(scalar $lexer, int $token_line) scalar {
    lex_advance($lexer);  # Skip opening /
    my scalar $sb = sb_new();

    while (!lex_at_end($lexer)) {
        my int $code = lex_current_code($lexer);
        # 47 = /
        if ($code == 47) {
            lex_advance($lexer);
            # Read optional flags
            my scalar $flags_sb = sb_new();
            while (!lex_at_end($lexer)) {
                my int $f = lex_current_code($lexer);
                # g=103, i=105, m=109, s=115, x=120
                if ($f == 103 || $f == 105 || $f == 109 || $f == 115 || $f == 120) {
                    sb_append($flags_sb, chr($f));
                    lex_advance($lexer);
                } else {
                    last;
                }
            }
            my hash %token = ();
            $token{"type"} = "REGEX_LITERAL";
            $token{"pattern"} = sb_to_string($sb);
            $token{"flags"} = sb_to_string($flags_sb);
            $token{"line"} = $token_line;
            return \%token;
        }
        # 92 = backslash
        if ($code == 92) {
            lex_advance($lexer);
            if (!lex_at_end($lexer)) {
                my int $escaped = lex_current_code($lexer);
                # /=47, n=110, t=116, r=114, \=92
                if ($escaped == 47) {
                    # Escaped slash - just add the slash
                    sb_append($sb, "/");
                } elsif ($escaped == 110) {
                    sb_append($sb, "\n");
                } elsif ($escaped == 116) {
                    sb_append($sb, "\t");
                } elsif ($escaped == 114) {
                    sb_append($sb, "\r");
                } elsif ($escaped == 92) {
                    sb_append($sb, "\\");
                } else {
                    # Keep the backslash and next char for regex escapes (e.g., \d, \w, \s)
                    sb_append($sb, "\\");
                    sb_append($sb, chr($escaped));
                }
                lex_advance($lexer);
            }
        } else {
            sb_append($sb, chr($code));
            lex_advance($lexer);
        }
    }
    die("Unterminated regex literal at line " . $token_line);
}

func lex_read_subst_literal(scalar $lexer, int $token_line) scalar {
    lex_advance($lexer);  # Skip 's'
    lex_advance($lexer);  # Skip opening /

    # Read pattern
    my scalar $pattern_sb = sb_new();
    while (!lex_at_end($lexer)) {
        my int $code = lex_current_code($lexer);
        # 47 = /
        if ($code == 47) {
            lex_advance($lexer);
            last;
        }
        # 92 = backslash
        if ($code == 92) {
            lex_advance($lexer);
            if (!lex_at_end($lexer)) {
                my int $escaped = lex_current_code($lexer);
                # /=47, n=110, t=116, r=114, \=92
                if ($escaped == 47) {
                    sb_append($pattern_sb, "/");
                } elsif ($escaped == 110) {
                    sb_append($pattern_sb, "\n");
                } elsif ($escaped == 116) {
                    sb_append($pattern_sb, "\t");
                } elsif ($escaped == 114) {
                    sb_append($pattern_sb, "\r");
                } elsif ($escaped == 92) {
                    sb_append($pattern_sb, "\\");
                } else {
                    # Keep other escapes as-is for regex engine (e.g., \d, \w, \s)
                    sb_append($pattern_sb, "\\");
                    sb_append($pattern_sb, chr($escaped));
                }
                lex_advance($lexer);
            }
        } else {
            sb_append($pattern_sb, chr($code));
            lex_advance($lexer);
        }
    }

    # Read replacement
    my scalar $repl_sb = sb_new();
    while (!lex_at_end($lexer)) {
        my int $code = lex_current_code($lexer);
        # 47 = /
        if ($code == 47) {
            lex_advance($lexer);
            last;
        }
        # 92 = backslash
        if ($code == 92) {
            lex_advance($lexer);
            if (!lex_at_end($lexer)) {
                my int $escaped = lex_current_code($lexer);
                # /=47, n=110, t=116, r=114, \=92
                if ($escaped == 47) {
                    sb_append($repl_sb, "/");
                } elsif ($escaped == 110) {
                    sb_append($repl_sb, "\n");
                } elsif ($escaped == 116) {
                    sb_append($repl_sb, "\t");
                } elsif ($escaped == 114) {
                    sb_append($repl_sb, "\r");
                } elsif ($escaped == 92) {
                    sb_append($repl_sb, "\\");
                } else {
                    sb_append($repl_sb, "\\");
                    sb_append($repl_sb, chr($escaped));
                }
                lex_advance($lexer);
            }
        } else {
            sb_append($repl_sb, chr($code));
            lex_advance($lexer);
        }
    }

    # Read flags
    my scalar $flags_sb = sb_new();
    while (!lex_at_end($lexer)) {
        my int $f = lex_current_code($lexer);
        # g=103, i=105, m=109, s=115, x=120, e=101
        if ($f == 103 || $f == 105 || $f == 109 || $f == 115 || $f == 120 || $f == 101) {
            sb_append($flags_sb, chr($f));
            lex_advance($lexer);
        } else {
            last;
        }
    }

    my hash %token = ();
    $token{"type"} = "SUBST_LITERAL";
    $token{"pattern"} = sb_to_string($pattern_sb);
    $token{"replacement"} = sb_to_string($repl_sb);
    $token{"flags"} = sb_to_string($flags_sb);
    $token{"line"} = $token_line;
    return \%token;
}

func lex_read_tr_literal(scalar $lexer, int $token_line, int $skip_count) scalar {
    # Skip 'tr' or 'y' (skip_count chars) then the opening /
    my int $sc = 0;
    while ($sc < $skip_count) {
        lex_advance($lexer);
        $sc = $sc + 1;
    }
    lex_advance($lexer);  # Skip opening /

    # Read search list
    my scalar $search_sb = sb_new();
    while (!lex_at_end($lexer)) {
        my int $code = lex_current_code($lexer);
        # 47 = /
        if ($code == 47) {
            lex_advance($lexer);
            last;
        }
        # 92 = backslash
        if ($code == 92) {
            lex_advance($lexer);
            if (!lex_at_end($lexer)) {
                my int $escaped = lex_current_code($lexer);
                if ($escaped == 47) {
                    sb_append($search_sb, "/");
                } else {
                    sb_append($search_sb, "\\");
                    sb_append($search_sb, chr($escaped));
                }
                lex_advance($lexer);
            }
        } else {
            sb_append($search_sb, chr($code));
            lex_advance($lexer);
        }
    }

    # Read replacement list
    my scalar $repl_sb = sb_new();
    while (!lex_at_end($lexer)) {
        my int $code = lex_current_code($lexer);
        # 47 = /
        if ($code == 47) {
            lex_advance($lexer);
            last;
        }
        # 92 = backslash
        if ($code == 92) {
            lex_advance($lexer);
            if (!lex_at_end($lexer)) {
                my int $escaped = lex_current_code($lexer);
                if ($escaped == 47) {
                    sb_append($repl_sb, "/");
                } else {
                    sb_append($repl_sb, "\\");
                    sb_append($repl_sb, chr($escaped));
                }
                lex_advance($lexer);
            }
        } else {
            sb_append($repl_sb, chr($code));
            lex_advance($lexer);
        }
    }

    # Read flags (c=99, d=100, s=115, r=114)
    my scalar $flags_sb = sb_new();
    while (!lex_at_end($lexer)) {
        my int $f = lex_current_code($lexer);
        if ($f == 99 || $f == 100 || $f == 115 || $f == 114) {
            sb_append($flags_sb, chr($f));
            lex_advance($lexer);
        } else {
            last;
        }
    }

    my hash %token = ();
    $token{"type"} = "TR_LITERAL";
    $token{"search"} = sb_to_string($search_sb);
    $token{"replace"} = sb_to_string($repl_sb);
    $token{"flags"} = sb_to_string($flags_sb);
    $token{"line"} = $token_line;
    return \%token;
}

# Get matching close delimiter for open delimiter
func lex_get_close_delim(str $open) str {
    if ($open eq "(") { return ")"; }
    if ($open eq "[") { return "]"; }
    if ($open eq "{") { return "}"; }
    if ($open eq "<") { return ">"; }
    # For other delimiters, close is same as open
    return $open;
}

# Read qw() - quote words, returns array of words
func lex_read_qw(scalar $lexer, int $token_line) scalar {
    # Current position should be at the delimiter after 'qw'
    my str $open = lex_current_char($lexer);
    my str $close = lex_get_close_delim($open);
    lex_advance($lexer);  # Skip open delimiter

    my array @words = ();
    my scalar $word_sb = sb_new();
    my int $word_len = 0;
    my int $count = 0;

    while (!lex_at_end($lexer)) {
        my str $ch = lex_current_char($lexer);

        if ($ch eq $close) {
            # End of qw - save last word if any
            if ($word_len > 0) {
                push(@words, sb_to_string($word_sb));
                $count = $count + 1;
            }
            lex_advance($lexer);  # Skip close delimiter

            my hash %token = ();
            $token{"type"} = "QW_LITERAL";
            $token{"words"} = \@words;
            $token{"word_count"} = $count;
            $token{"line"} = $token_line;
            return \%token;
        }

        if ($ch eq " " || $ch eq "\t" || $ch eq "\n" || $ch eq "\r") {
            # Whitespace - save current word if any
            if ($word_len > 0) {
                push(@words, sb_to_string($word_sb));
                $count = $count + 1;
                $word_sb = sb_new();
                $word_len = 0;
            }
            lex_advance($lexer);
        } else {
            # Regular character - add to current word
            sb_append($word_sb, $ch);
            $word_len = $word_len + 1;
            lex_advance($lexer);
        }
    }

    die("Unterminated qw() at line " . $token_line);
}

# Read q() or qq() - single/double quoted string with custom delimiters
# is_qq: 1 for qq() (supports escape sequences like \n, \t), 0 for q() (literal)
func lex_read_q_string(scalar $lexer, int $token_line, int $is_qq) scalar {
    my str $open = lex_current_char($lexer);
    my str $close = lex_get_close_delim($open);
    lex_advance($lexer);  # Skip open delimiter

    my scalar $sb = sb_new();
    my int $depth = 1;  # For nested delimiters like q(a(b)c)
    my int $handled = 0;

    # Interpolation tracking for qq()
    my array @parts = ();
    my array @vars = ();
    my int $has_interp = 0;
    my int $var_count = 0;

    while (!lex_at_end($lexer)) {
        my str $ch = lex_current_char($lexer);
        $handled = 0;

        # Check for closing delimiter
        if ($ch eq $close) {
            $depth = $depth - 1;
            if ($depth == 0) {
                lex_advance($lexer);
                if ($is_qq && $has_interp) {
                    push(\@parts, sb_to_string($sb));
                    my hash %token = ();
                    $token{"type"} = "INTERP_STRING";
                    $token{"parts"} = \@parts;
                    $token{"vars"} = \@vars;
                    $token{"var_count"} = $var_count;
                    $token{"line"} = $token_line;
                    return \%token;
                } else {
                    my hash %token = ();
                    $token{"type"} = "STR_LITERAL";
                    $token{"value"} = sb_to_string($sb);
                    $token{"line"} = $token_line;
                    return \%token;
                }
            }
            sb_append($sb, $ch);
            lex_advance($lexer);
            $handled = 1;
        }

        # Check for nested opening delimiter (paired delimiters only)
        if ($handled == 0 && $open ne $close && $ch eq $open) {
            $depth = $depth + 1;
            sb_append($sb, $ch);
            lex_advance($lexer);
            $handled = 1;
        }

        # Check for escape sequence
        if ($handled == 0 && $ch eq "\\") {
            lex_advance($lexer);
            my str $esc = lex_current_char($lexer);

            if ($is_qq) {
                # qq() supports full escape sequences like double-quoted strings
                if ($esc eq "n") {
                    sb_append($sb, "\n");
                } elsif ($esc eq "t") {
                    sb_append($sb, "\t");
                } elsif ($esc eq "r") {
                    sb_append($sb, "\r");
                } elsif ($esc eq "0") {
                    sb_append($sb, chr(0));
                } elsif ($esc eq "a") {
                    sb_append($sb, chr(7));
                } elsif ($esc eq "b") {
                    sb_append($sb, chr(8));
                } elsif ($esc eq "f") {
                    sb_append($sb, chr(12));
                } elsif ($esc eq "v") {
                    sb_append($sb, chr(11));
                } elsif ($esc eq "e") {
                    sb_append($sb, chr(27));
                } elsif ($esc eq "$") {
                    # Escaped dollar sign - literal $
                    sb_append($sb, "$");
                } elsif ($esc eq "\\" || $esc eq $close) {
                    sb_append($sb, $esc);
                } else {
                    # Unknown escape - include as-is
                    sb_append($sb, $esc);
                }
            } else {
                # q() only escapes \\ and the delimiter
                if ($esc eq $close || $esc eq "\\") {
                    sb_append($sb, $esc);
                } else {
                    sb_append($sb, "\\");
                    sb_append($sb, $esc);
                }
            }
            lex_advance($lexer);
            $handled = 1;
        }

        # Check for interpolation in qq()
        if ($handled == 0 && $is_qq && $ch eq "$") {
            lex_advance($lexer);
            my int $peek_code = lex_current_code($lexer);

            # 123 = {
            if ($peek_code == 123) {
                lex_advance($lexer); # Skip {
                my scalar $ivar_sb = sb_new();

                while (1) {
                    my int $vc = lex_current_code($lexer);
                    if ($vc == 0) {
                        die("Unterminated interpolation in qq string");
                    }
                    # 125 = }
                    if ($vc == 125) {
                        lex_advance($lexer); # Skip }

                        my str $ivar = sb_to_string($ivar_sb);
                        if (length($ivar) == 0) {
                            die("Empty variable name in interpolation");
                        }

                        # Save current part and variable
                        push(\@parts, sb_to_string($sb));
                        push(\@vars, $ivar);
                        $var_count = $var_count + 1;
                        $sb = sb_new();  # Reset StringBuilder
                        $has_interp = 1;
                        break;
                    }
                    sb_append($ivar_sb, chr($vc));
                    lex_advance($lexer);
                }
                $handled = 1;
            } else {
                # Just a literal $ not followed by {
                sb_append($sb, "$");
                $handled = 1;
            }
        }

        # Regular character
        if ($handled == 0) {
            sb_append($sb, $ch);
            lex_advance($lexer);
        }
    }

    die("Unterminated q/qq string at line " . $token_line);
}

# Read a raw C code block __C__ { ... }
# Handles nested braces, C strings, and C comments properly
func lex_read_c_block(scalar $lexer, int $token_line) scalar {
    lex_skip_whitespace($lexer);

    # Expect opening brace  {=123
    my int $code = lex_current_code($lexer);
    if ($code != 123) {
        die("Expected '{' after __C__ at line " . $token_line);
    }
    lex_advance($lexer);  # Skip opening {

    my scalar $sb = sb_new();
    my int $depth = 1;

    while (!lex_at_end($lexer) && $depth > 0) {
        my int $ch = lex_current_code($lexer);

        # Track line numbers for better error messages
        if ($ch == 10) {
            $lexer->{"line"} = $lexer->{"line"} + 1;
        }

        # Handle C-style strings - don't count braces inside strings
        # "=34
        if ($ch == 34) {
            sb_append($sb, lex_current_char($lexer));
            lex_advance($lexer);
            while (!lex_at_end($lexer)) {
                my int $sch = lex_current_code($lexer);
                sb_append($sb, lex_current_char($lexer));
                if ($sch == 10) {
                    $lexer->{"line"} = $lexer->{"line"} + 1;
                }
                lex_advance($lexer);
                # End of string  "=34
                if ($sch == 34) {
                    last;
                }
                # Escape sequence \=92
                if ($sch == 92) {
                    if (!lex_at_end($lexer)) {
                        sb_append($sb, lex_current_char($lexer));
                        lex_advance($lexer);
                    }
                }
            }
        # Handle C-style char literals - don't count braces inside
        # '=39
        } elsif ($ch == 39) {
            sb_append($sb, lex_current_char($lexer));
            lex_advance($lexer);
            while (!lex_at_end($lexer)) {
                my int $sch = lex_current_code($lexer);
                sb_append($sb, lex_current_char($lexer));
                lex_advance($lexer);
                # End of char '=39
                if ($sch == 39) {
                    last;
                }
                # Escape \=92
                if ($sch == 92) {
                    if (!lex_at_end($lexer)) {
                        sb_append($sb, lex_current_char($lexer));
                        lex_advance($lexer);
                    }
                }
            }
        # Handle C block comments /* */
        # /=47, *=42
        } elsif ($ch == 47) {
            my int $nxt = char_at($lexer->{"source"}, $lexer->{"pos"} + 1);
            # Block comment
            if ($nxt == 42) {
                sb_append($sb, "/*");
                lex_advance($lexer);
                lex_advance($lexer);
                while (!lex_at_end($lexer)) {
                    my int $c1 = lex_current_code($lexer);
                    if ($c1 == 10) {
                        $lexer->{"line"} = $lexer->{"line"} + 1;
                    }
                    # *=42
                    if ($c1 == 42) {
                        my int $c2 = char_at($lexer->{"source"}, $lexer->{"pos"} + 1);
                        # /=47
                        if ($c2 == 47) {
                            sb_append($sb, "*/");
                            lex_advance($lexer);
                            lex_advance($lexer);
                            last;
                        }
                    }
                    sb_append($sb, lex_current_char($lexer));
                    lex_advance($lexer);
                }
            # Line comment //
            } elsif ($nxt == 47) {
                sb_append($sb, "//");
                lex_advance($lexer);
                lex_advance($lexer);
                while (!lex_at_end($lexer)) {
                    my int $lc = lex_current_code($lexer);
                    # newline=10
                    if ($lc == 10) {
                        sb_append($sb, "\n");
                        $lexer->{"line"} = $lexer->{"line"} + 1;
                        lex_advance($lexer);
                        last;
                    }
                    sb_append($sb, lex_current_char($lexer));
                    lex_advance($lexer);
                }
            } else {
                # Just a /
                sb_append($sb, "/");
                lex_advance($lexer);
            }
        # Opening brace {=123
        } elsif ($ch == 123) {
            $depth = $depth + 1;
            sb_append($sb, "{");
            lex_advance($lexer);
        # Closing brace }=125
        } elsif ($ch == 125) {
            $depth = $depth - 1;
            if ($depth > 0) {
                sb_append($sb, "}");
            }
            lex_advance($lexer);
        } else {
            # Regular character
            sb_append($sb, lex_current_char($lexer));
            lex_advance($lexer);
        }
    }

    if ($depth > 0) {
        die("Unterminated __C__ block at line " . $token_line);
    }

    my hash %token = ();
    $token{"type"} = "C_BLOCK";
    $token{"value"} = sb_to_string($sb);
    $token{"line"} = $token_line;
    return \%token;
}

func lex_keyword_or_ident(str $text) str {
    if ($text eq "func") { return "FUNC"; }
    if ($text eq "my") { return "MY"; }
    if ($text eq "const") { return "CONST"; }
    if ($text eq "our") { return "OUR"; }
    if ($text eq "if") { return "IF"; }
    if ($text eq "elsif") { return "ELSIF"; }
    if ($text eq "else") { return "ELSE"; }
    if ($text eq "while") { return "WHILE"; }
    if ($text eq "do") { return "DO"; }
    if ($text eq "for") { return "FOR"; }
    if ($text eq "foreach") { return "FOREACH"; }
    if ($text eq "return") { return "RETURN"; }
    if ($text eq "last") { return "LAST"; }
    if ($text eq "break") { return "LAST"; }
    if ($text eq "next") { return "NEXT"; }
    if ($text eq "unless") { return "UNLESS"; }
    if ($text eq "until") { return "UNTIL"; }
    if ($text eq "redo") { return "REDO"; }
    if ($text eq "extern") { return "EXTERN"; }
    if ($text eq "private") { return "PRIVATE"; }
    if ($text eq "async") { return "ASYNC"; }
    if ($text eq "await") { return "AWAIT"; }
    if ($text eq "enum") { return "ENUM"; }
    if ($text eq "package") { return "PACKAGE"; }
    if ($text eq "version") { return "VERSION"; }
    if ($text eq "use") { return "USE"; }
    if ($text eq "import_lib") { return "IMPORT_LIB"; }
    if ($text eq "import_object") { return "IMPORT_OBJECT"; }
    if ($text eq "import_archive") { return "IMPORT_ARCHIVE"; }
    if ($text eq "inherit") { return "INHERIT"; }
    if ($text eq "try") { return "TRY"; }
    if ($text eq "catch") { return "CATCH"; }
    if ($text eq "throw") { return "THROW"; }
    if ($text eq "goto") { return "GOTO"; }
    if ($text eq "switch") { return "SWITCH"; }
    if ($text eq "case") { return "CASE"; }
    if ($text eq "default") { return "DEFAULT"; }
    if ($text eq "__PACKAGE__") { return "DUNDER_PACKAGE"; }
    if ($text eq "__FILE__") { return "DUNDER_FILE"; }
    if ($text eq "__LINE__") { return "DUNDER_LINE"; }
    if ($text eq "__C__") { return "C_BLOCK"; }
    if ($text eq "BEGIN") { return "BEGIN_BLOCK"; }
    if ($text eq "END") { return "END_BLOCK"; }

    # Moose-style OOP keywords
    if ($text eq "has") { return "HAS"; }
    if ($text eq "extends") { return "EXTENDS"; }
    if ($text eq "with") { return "WITH"; }
    if ($text eq "before") { return "BEFORE"; }
    if ($text eq "after") { return "AFTER"; }
    if ($text eq "around") { return "AROUND"; }

    # String comparison operators
    if ($text eq "eq") { return "STR_EQ"; }
    if ($text eq "ne") { return "STR_NE"; }
    if ($text eq "lt") { return "STR_LT"; }
    if ($text eq "gt") { return "STR_GT"; }
    if ($text eq "le") { return "STR_LE"; }
    if ($text eq "ge") { return "STR_GE"; }
    if ($text eq "cmp") { return "STR_CMP"; }
    
    # Types
    if ($text eq "int") { return "TYPE_INT"; }
    if ($text eq "num") { return "TYPE_NUM"; }
    if ($text eq "str") { return "TYPE_STR"; }
    if ($text eq "bool") { return "TYPE_BOOL"; }
    if ($text eq "array") { return "TYPE_ARRAY"; }
    if ($text eq "hash") { return "TYPE_HASH"; }
    if ($text eq "scalar") { return "TYPE_SCALAR"; }
    if ($text eq "void") { return "TYPE_VOID"; }
    if ($text eq "dynamic") { return "TYPE_DYNAMIC"; }
    # Explicit sized types for extern functions (C interop)
    if ($text eq "int32") { return "TYPE_INT32"; }
    if ($text eq "int64") { return "TYPE_INT64"; }
    if ($text eq "float32") { return "TYPE_FLOAT32"; }
    if ($text eq "float64") { return "TYPE_FLOAT64"; }
    if ($text eq "int8") { return "TYPE_INT8"; }
    if ($text eq "int16") { return "TYPE_INT16"; }
    if ($text eq "uint8") { return "TYPE_UINT8"; }
    if ($text eq "byte") { return "TYPE_UINT8"; }
    if ($text eq "uint16") { return "TYPE_UINT16"; }
    if ($text eq "uint32") { return "TYPE_UINT32"; }
    if ($text eq "uint64") { return "TYPE_UINT64"; }
    if ($text eq "size_t") { return "TYPE_SIZE_T"; }
    if ($text eq "char") { return "TYPE_CHAR"; }
    if ($text eq "float") { return "TYPE_FLOAT32"; }
    if ($text eq "double") { return "TYPE_FLOAT64"; }
    if ($text eq "long_double") { return "TYPE_LONG_DOUBLE"; }

    # Built-ins that need special token types
    # undef is a keyword, not a function call
    if ($text eq "undef") { return "UNDEF"; }
    if ($text eq "map") { return "MAP"; }
    if ($text eq "sort") { return "SORT"; }
    if ($text eq "grep") { return "GREP"; }
    # if ($text eq "defined") { return "DEFINED"; }
    # if ($text eq "ref") { return "REF"; }
    # if ($text eq "dump") { return "DUMP"; }
    # if ($text eq "dumper") { return "DUMPER"; }
    # if ($text eq "say") { return "SAY"; }
    # if ($text eq "print") { return "PRINT"; }
    # if ($text eq "die") { return "DIE"; }
    # if ($text eq "push") { return "PUSH"; }
    # if ($text eq "pop") { return "POP"; }
    # if ($text eq "shift") { return "SHIFT"; }
    # if ($text eq "unshift") { return "UNSHIFT"; }
    # if ($text eq "scalar") { return "SCALAR"; }
    # if ($text eq "length") { return "LENGTH"; }
    # if ($text eq "substr") { return "SUBSTR"; }
    
    return "IDENT";
}

func lex_next_token(scalar $lexer) scalar {
    lex_skip_whitespace($lexer);

    my int $code = lex_current_code($lexer);

    # Capture line number at token start (after whitespace)
    my int $token_line = $lexer->{"line"};

    # Check for EOF (code == 0)
    if ($code == 0) {
        my hash %token = ();
        $token{"type"} = "EOF";
        $token{"value"} = "";
        $token{"line"} = $token_line;
        return \%token;
    }

    # Skip line comments (#=35)
    if ($code == 35) {
        lex_skip_comment($lexer);
        return lex_next_token($lexer);
    }

    # Skip block comments (/* ... */)  /=47, *=42
    if ($code == 47) {
        my int $next_code = char_at($lexer->{"source"}, $lexer->{"pos"} + 1);
        if ($next_code == 42) {
            lex_skip_block_comment($lexer);
            return lex_next_token($lexer);
        }
    }

    # Skip POD blocks (=head1, =pod, etc. at start of line)
    # '=' = 61
    if ($code == 61) {
        # Check if we're at start of line (pos 0 or prev char was newline)
        my int $pos = $lexer->{"pos"};
        my int $at_line_start = 0;
        if ($pos == 0) {
            $at_line_start = 1;
        } else {
            my int $prev = char_at($lexer->{"source"}, $pos - 1);
            if ($prev == 10) {  # newline
                $at_line_start = 1;
            }
        }
        if ($at_line_start == 1 && lex_is_pod_start($lexer) == 1) {
            lex_skip_pod($lexer);
            return lex_next_token($lexer);
        }
    }

    # Check for regex/substitution after =~ or !~ BEFORE identifier check
    if ($lexer->{"expect_regex"} == 1) {
        # /=47
        if ($code == 47) {
            $lexer->{"expect_regex"} = 0;
            return lex_read_regex_literal($lexer, $token_line);
        }
        # s=115
        if ($code == 115) {
            my int $peek_code = char_at($lexer->{"source"}, $lexer->{"pos"} + 1);
            # /=47
            if ($peek_code == 47) {
                $lexer->{"expect_regex"} = 0;
                return lex_read_subst_literal($lexer, $token_line);
            }
        }
        # tr=116,114 or y=121 followed by /
        if ($code == 116) {
            my int $peek1 = char_at($lexer->{"source"}, $lexer->{"pos"} + 1);
            # r=114
            if ($peek1 == 114) {
                my int $peek2 = char_at($lexer->{"source"}, $lexer->{"pos"} + 2);
                # /=47
                if ($peek2 == 47) {
                    $lexer->{"expect_regex"} = 0;
                    return lex_read_tr_literal($lexer, $token_line, 2);
                }
            }
        }
        if ($code == 121) {
            my int $peek1 = char_at($lexer->{"source"}, $lexer->{"pos"} + 1);
            # /=47
            if ($peek1 == 47) {
                $lexer->{"expect_regex"} = 0;
                return lex_read_tr_literal($lexer, $token_line, 1);
            }
        }
        # Not a regex/subst/tr - reset flag and continue with normal parsing
        $lexer->{"expect_regex"} = 0;
    }

    # Identifiers and keywords: a-z=97-122, A-Z=65-90, _=95
    if (($code >= 97 && $code <= 122) || ($code >= 65 && $code <= 90) || $code == 95) {
        my str $text = lex_read_identifier($lexer);

        # Check for quote-like operators: qw(), q(), qq()
        if ($text eq "qw") {
            lex_skip_whitespace($lexer);
            my int $delim = lex_current_code($lexer);
            # (=40, [=91, {=123, <=60, /=47, !=33, |=124
            if ($delim == 40 || $delim == 91 || $delim == 123 || $delim == 60 || $delim == 47 || $delim == 33 || $delim == 124) {
                return lex_read_qw($lexer, $token_line);
            }
        }

        if ($text eq "q") {
            lex_skip_whitespace($lexer);
            my int $delim = lex_current_code($lexer);
            if ($delim == 40 || $delim == 91 || $delim == 123 || $delim == 60 || $delim == 47 || $delim == 33 || $delim == 124) {
                return lex_read_q_string($lexer, $token_line, 0);
            }
        }

        if ($text eq "qq") {
            lex_skip_whitespace($lexer);
            my int $delim = lex_current_code($lexer);
            if ($delim == 40 || $delim == 91 || $delim == 123 || $delim == 60 || $delim == 47 || $delim == 33 || $delim == 124) {
                return lex_read_q_string($lexer, $token_line, 1);
            }
        }

        # __C__ { ... } - raw C code block
        if ($text eq "__C__") {
            return lex_read_c_block($lexer, $token_line);
        }

        my str $type = lex_keyword_or_ident($text);

        my hash %token = ();
        $token{"type"} = $type;
        $token{"value"} = $text;
        $token{"line"} = $token_line;
        $token{"is_word"} = 1;
        return \%token;
    }

    # Numbers: 0-9=48-57
    if ($code >= 48 && $code <= 57) {
        my scalar $tok = lex_read_number($lexer);
        $tok->{"line"} = $token_line;
        return $tok;
    }

    # Strings: "=34, '=39
    if ($code == 34) {
        # Double-quoted string with interpolation support
        return lex_read_dq_string($lexer, $token_line);
    }

    if ($code == 39) {
        # Single-quoted string (literal, no interpolation)
        my str $str_val = lex_read_sq_string($lexer);
        my hash %token = ();
        $token{"type"} = "STR_LITERAL";
        $token{"value"} = $str_val;
        $token{"line"} = $token_line;
        return \%token;
    }

    # Two-character operators - use char codes for fast comparison
    # Get second character code for two-char operator detection
    my str $source = $lexer->{"source"};
    my int $pos = $lexer->{"pos"};
    my int $code2 = char_at($source, $pos + 1);

    # ASCII codes: ==61, !=33, <=60, >=62, &&38, ||124, <<60, >>62
    # ::58, ->45>62, =>61>62, +=43=61, -=45=61, ++=43=43, --=45=45
    # .==46=61, =~=61~126, !~=33~126, ...=46, ..=46

    # ==  (=61, =61)
    if ($code == 61 && $code2 == 61) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "EQ";
        $token{"value"} = "==";
        $token{"line"} = $token_line;
        return \%token;
    }

    # !=  (!33, =61)
    if ($code == 33 && $code2 == 61) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "NE";
        $token{"value"} = "!=";
        $token{"line"} = $token_line;
        return \%token;
    }

    # Diamond operator <$fh> for reading from filehandle (<60, $36)
    if ($code == 60 && $code2 == 36) {
        lex_advance($lexer);  # Skip <
        lex_advance($lexer);  # Skip $
        my str $varname = lex_read_identifier($lexer);
        if ($varname eq "") {
            die("Expected variable name in diamond operator at line " . $token_line);
        }
        my int $close = lex_current_code($lexer);
        if ($close != 62) {  # >
            die("Expected '>' to close diamond operator at line " . $token_line);
        }
        lex_advance($lexer);  # Skip >
        my hash %token = ();
        $token{"type"} = "DIAMOND";
        $token{"value"} = $varname;  # Just the variable name without $
        $token{"line"} = $token_line;
        return \%token;
    }

    # Check for <=> (spaceship) before <= (<60, =61, >62)
    if ($code == 60 && $code2 == 61) {
        my int $code3 = char_at($source, $pos + 2);
        if ($code3 == 62) {
            lex_advance($lexer);
            lex_advance($lexer);
            lex_advance($lexer);
            my hash %token = ();
            $token{"type"} = "SPACESHIP";
            $token{"value"} = "<=>";
            $token{"line"} = $token_line;
            return \%token;
        }
        # Just <=
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "LE";
        $token{"value"} = "<=";
        $token{"line"} = $token_line;
        return \%token;
    }

    # >=  (>62, =61)
    if ($code == 62 && $code2 == 61) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "GE";
        $token{"value"} = ">=";
        $token{"line"} = $token_line;
        return \%token;
    }

    # &&  (&38, &38)
    if ($code == 38 && $code2 == 38) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "AND";
        $token{"value"} = "&&";
        $token{"line"} = $token_line;
        return \%token;
    }

    # ||  (|124, |124)
    if ($code == 124 && $code2 == 124) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "OR";
        $token{"value"} = "||";
        $token{"line"} = $token_line;
        return \%token;
    }

    # //  (/47, /47) - defined-or operator
    if ($code == 47 && $code2 == 47) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "DEFINED_OR";
        $token{"value"} = "//";
        $token{"line"} = $token_line;
        return \%token;
    }

    # <<  (<60, <60)
    if ($code == 60 && $code2 == 60) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "LSHIFT";
        $token{"value"} = "<<";
        $token{"line"} = $token_line;
        return \%token;
    }

    # >>  (>62, >62)
    if ($code == 62 && $code2 == 62) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "RSHIFT";
        $token{"value"} = ">>";
        $token{"line"} = $token_line;
        return \%token;
    }

    # ::  (:58, :58)
    if ($code == 58 && $code2 == 58) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "DOUBLE_COLON";
        $token{"value"} = "::";
        $token{"line"} = $token_line;
        return \%token;
    }

    # ->  (-45, >62)
    if ($code == 45 && $code2 == 62) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "ARROW";
        $token{"value"} = "->";
        $token{"line"} = $token_line;
        return \%token;
    }

    # =>  (=61, >62)
    if ($code == 61 && $code2 == 62) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "FAT_ARROW";
        $token{"value"} = "=>";
        $token{"line"} = $token_line;
        return \%token;
    }

    # +=  (+43, =61)
    if ($code == 43 && $code2 == 61) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "PLUS_ASSIGN";
        $token{"value"} = "+=";
        $token{"line"} = $token_line;
        return \%token;
    }

    # -=  (-45, =61)
    if ($code == 45 && $code2 == 61) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "MINUS_ASSIGN";
        $token{"value"} = "-=";
        $token{"line"} = $token_line;
        return \%token;
    }

    # ++  (+43, +43)
    if ($code == 43 && $code2 == 43) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "PLUSPLUS";
        $token{"value"} = "++";
        $token{"line"} = $token_line;
        return \%token;
    }

    # --  (-45, -45)
    if ($code == 45 && $code2 == 45) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "MINUSMINUS";
        $token{"value"} = "--";
        $token{"line"} = $token_line;
        return \%token;
    }

    # **  (*42, *42) - exponentiation
    if ($code == 42 && $code2 == 42) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "POWER";
        $token{"value"} = "**";
        $token{"line"} = $token_line;
        return \%token;
    }

    # .=  (.46, =61)
    if ($code == 46 && $code2 == 61) {
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "DOT_ASSIGN";
        $token{"value"} = ".=";
        $token{"line"} = $token_line;
        return \%token;
    }

    # =~  (=61, ~126)
    if ($code == 61 && $code2 == 126) {
        lex_advance($lexer);
        lex_advance($lexer);
        $lexer->{"expect_regex"} = 1;
        my hash %token = ();
        $token{"type"} = "MATCH_OP";
        $token{"value"} = "=~";
        $token{"line"} = $token_line;
        return \%token;
    }

    # !~  (!33, ~126)
    if ($code == 33 && $code2 == 126) {
        lex_advance($lexer);
        lex_advance($lexer);
        $lexer->{"expect_regex"} = 1;
        my hash %token = ();
        $token{"type"} = "NOT_MATCH_OP";
        $token{"value"} = "!~";
        $token{"line"} = $token_line;
        return \%token;
    }

    # ... (ellipsis) and .. (range) - .=46
    if ($code == 46 && $code2 == 46) {
        my int $code3 = char_at($source, $pos + 2);
        if ($code3 == 46) {
            lex_advance($lexer);
            lex_advance($lexer);
            lex_advance($lexer);
            my hash %token = ();
            $token{"type"} = "ELLIPSIS";
            $token{"value"} = "...";
            $token{"line"} = $token_line;
            return \%token;
        }
        # Just ..
        lex_advance($lexer);
        lex_advance($lexer);
        my hash %token = ();
        $token{"type"} = "RANGE";
        $token{"value"} = "..";
        $token{"line"} = $token_line;
        return \%token;
    }

    # Single-character tokens - use integer comparisons
    lex_advance($lexer);

    my hash %token = ();
    $token{"value"} = chr($code);
    $token{"line"} = $token_line;

    # (=40, )=41, {=123, }=125, [=91, ]=93, ;=59, ,=44, :=58
    # $=36, @=64, %=37, +=43, -=45, *=42, /=47, .=46, ==61
    # <=60, >=62, !=33, \=92, &=38, |=124, ^=94, ~=126, ?=63
    if ($code == 40) { $token{"type"} = "LPAREN"; return \%token; }
    if ($code == 41) { $token{"type"} = "RPAREN"; return \%token; }
    if ($code == 123) { $token{"type"} = "LBRACE"; return \%token; }
    if ($code == 125) { $token{"type"} = "RBRACE"; return \%token; }
    if ($code == 91) { $token{"type"} = "LBRACKET"; return \%token; }
    if ($code == 93) { $token{"type"} = "RBRACKET"; return \%token; }
    if ($code == 59) { $token{"type"} = "SEMI"; return \%token; }
    if ($code == 44) { $token{"type"} = "COMMA"; return \%token; }
    if ($code == 58) { $token{"type"} = "COLON"; return \%token; }
    if ($code == 36) { $token{"type"} = "DOLLAR"; return \%token; }
    if ($code == 64) { $token{"type"} = "AT"; return \%token; }
    if ($code == 37) { $token{"type"} = "PERCENT"; return \%token; }
    if ($code == 43) { $token{"type"} = "PLUS"; return \%token; }
    if ($code == 45) { $token{"type"} = "MINUS"; return \%token; }
    if ($code == 42) { $token{"type"} = "MULT"; return \%token; }
    if ($code == 47) { $token{"type"} = "DIV"; return \%token; }
    if ($code == 46) { $token{"type"} = "DOT"; return \%token; }
    if ($code == 61) { $token{"type"} = "ASSIGN"; return \%token; }
    if ($code == 60) { $token{"type"} = "LT"; return \%token; }
    if ($code == 62) { $token{"type"} = "GT"; return \%token; }
    if ($code == 33) { $token{"type"} = "NOT"; return \%token; }
    if ($code == 92) { $token{"type"} = "BACKSLASH"; return \%token; }
    if ($code == 38) { $token{"type"} = "AMPERSAND"; return \%token; }
    if ($code == 124) { $token{"type"} = "PIPE"; return \%token; }
    if ($code == 94) { $token{"type"} = "CARET"; return \%token; }
    if ($code == 126) { $token{"type"} = "TILDE"; return \%token; }
    if ($code == 63) { $token{"type"} = "QUESTION"; return \%token; }

    die("Unexpected character: " . chr($code) . " at line " . $token_line);
}

func lex_tokenize(str $source) array {
    my hash $lexer = lex_new($source);
    my array @tokens = ();
    my str $prev_type = "";

    while (1) {
        my scalar $token = lex_next_token($lexer);

        # Disambiguate PERCENT (hash sigil) vs MOD (modulo operator)
        # If previous token could end a value expression, % is modulo
        if ($token->{"type"} eq "PERCENT") {
            if (lex_is_value_ending_token($prev_type) == 1) {
                $token->{"type"} = "MOD";
            }
        }

        push(@tokens, $token);
        $prev_type = $token->{"type"};

        if ($token->{"type"} eq "EOF") {
            return \@tokens;
        }
    }
}

# Check if a token type can end a value expression
# These tokens, when followed by %, indicate modulo not hash sigil
func lex_is_value_ending_token(str $type) int {
    # Closing brackets/parens
    if ($type eq "RPAREN") { return 1; }
    if ($type eq "RBRACKET") { return 1; }
    if ($type eq "RBRACE") { return 1; }

    # Literals (actual token types used by lexer)
    if ($type eq "INT_LITERAL") { return 1; }
    if ($type eq "NUM_LITERAL") { return 1; }
    if ($type eq "STR_LITERAL") { return 1; }
    if ($type eq "INTERP_STRING") { return 1; }

    # Identifiers (variable names, function calls)
    if ($type eq "IDENT") { return 1; }

    # Post-increment/decrement
    if ($type eq "PLUSPLUS") { return 1; }
    if ($type eq "MINUSMINUS") { return 1; }

    return 0;
}
