/*
 This file is part of the Strada Language (https://github.com/mjflick/strada-lang).
 Copyright (c) 2026 Michael J. Flickinger

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

# perl2strada - Multi-pass Perl to Strada converter
#
# Usage: ./perl2strada input.pl [output.strada]
#
# Three-pass converter:
#   Pass 1: Pre-scan for sub signatures and package context
#   Pass 2: Convert function signatures using extracted info
#   Pass 3: Line-by-line syntax conversion

# ============================================================
# Configuration
# ============================================================

# Eval backend: "interpreter" (default) or "jit"
# Controls what library is used for Perl eval() conversion.
# - "interpreter": uses Strada::Interpreter::eval_string() (tree-walking, no C compiler needed at runtime)
# - "jit": uses Strada::JIT::eval() (compiles to C at runtime, needs tcc or gcc)
our str $g_eval_backend = "interpreter";

# ============================================================
# Helper functions
# ============================================================

# Check if a character is a word character (a-z, A-Z, 0-9, _)
func is_word_char(str $c) int {
    if ($c eq "") { return 0; }
    if (match($c, "^[A-Za-z0-9_]$")) { return 1; }
    return 0;
}

# Get leading whitespace from a line
func get_indent(str $line) str {
    my str $indent = "";
    my int $i = 0;
    my int $len = length($line);
    while ($i < $len) {
        my str $c = substr($line, $i, 1);
        if ($c eq " " || $c eq "\t") {
            $indent = $indent . $c;
        } else {
            return $indent;
        }
        $i++;
    }
    return $indent;
}

# Trim leading and trailing whitespace
func trim_str(str $s) str {
    my str $r = $s;
    $r =~ s/^\s+//;
    $r =~ s/\s+$//;
    return $r;
}

# Replace a keyword outside of string literals (single and double quoted)
# Walks the string character by character, tracking quote context
func replace_keyword_outside_strings(str $s, str $find, str $repl) str {
    my str $out = "";
    my int $i = 0;
    my int $len = length($s);
    my int $find_len = length($find);

    while ($i < $len) {
        my str $ch = substr($s, $i, 1);

        # Skip over double-quoted strings
        if ($ch eq "\"") {
            $out = $out . $ch;
            $i++;
            while ($i < $len) {
                my str $qch = substr($s, $i, 1);
                $out = $out . $qch;
                if ($qch eq "\\" && $i + 1 < $len) {
                    $i++;
                    $out = $out . substr($s, $i, 1);
                } elsif ($qch eq "\"") {
                    $i++;
                    last;
                }
                $i++;
            }
            next;
        }
        # Skip over single-quoted strings
        if ($ch eq "'") {
            $out = $out . $ch;
            $i++;
            while ($i < $len) {
                my str $qch2 = substr($s, $i, 1);
                $out = $out . $qch2;
                if ($qch2 eq "\\" && $i + 1 < $len) {
                    $i++;
                    $out = $out . substr($s, $i, 1);
                } elsif ($qch2 eq "'") {
                    $i++;
                    last;
                }
                $i++;
            }
            next;
        }

        # Check if we match the find string at this position
        if ($i + $find_len <= $len && substr($s, $i, $find_len) eq $find) {
            $out = $out . $repl;
            $i = $i + $find_len;
            next;
        }

        $out = $out . $ch;
        $i++;
    }
    return $out;
}

# Check if line is inside a string (very basic - checks if odd number of quotes before position)
# This is a heuristic, not perfect
func starts_with(str $s, str $prefix) int {
    if (length($s) < length($prefix)) { return 0; }
    if (substr($s, 0, length($prefix)) eq $prefix) { return 1; }
    return 0;
}

# Insert a closing paren before the first semicolon in the line
# "say(foo;" -> "say(foo);"   "say(foo; }" -> "say(foo); }"
func add_close_paren(str $s) str {
    my int $semi_pos = index($s, ";");
    if ($semi_pos < 0) {
        # No semicolon found, append )
        return $s . ")";
    }
    return substr($s, 0, $semi_pos) . ")" . substr($s, $semi_pos, length($s) - $semi_pos);
}

# Insert closing paren after the argument span of a bare builtin call.
# Handles single-arg builtins like "core::unlink($file" inside conditions:
# "while (core::unlink($to) { 1; }" -> need ) after $to, not before first ;
# Finds the func( we just inserted, then scans forward tracking parens/brackets
# to find where the argument(s) end, and inserts ) there.
func add_close_paren_smart(str $s, str $func_prefix) str {
    my int $fp = index($s, $func_prefix . "(");
    if ($fp < 0) { return add_close_paren($s); }
    my int $start = $fp + length($func_prefix) + 1;
    my int $len = length($s);
    my int $depth = 1;
    my int $pos = $start;
    my int $in_str = 0;  # 34=", 39='
    while ($pos < $len && $depth > 0) {
        my int $ch = char_at($s, $pos);
        if ($in_str > 0) {
            if ($ch == $in_str) { $in_str = 0; }
        } else {
            if ($ch == 34 || $ch == 39) { $in_str = $ch; }
            elsif ($ch == 40) { $depth++; }
            elsif ($ch == 41) { $depth--; }
            elsif ($ch == 91) { $depth++; }  # [
            elsif ($ch == 93) { $depth--; }  # ]
            elsif ($ch == 123) { $depth++; }  # {
            elsif ($ch == 125) { $depth--; }  # }
        }
        if ($depth > 0) { $pos++; }
    }
    if ($depth == 0) {
        # Found matching close - already has a ), don't add another
        return $s;
    }
    # Depth never reached 0 - need to find where to insert )
    # Scan from start to find end of argument: stop before ) ; { that's at depth 0
    $pos = $start;
    $depth = 0;
    my int $insert_pos = -1;
    while ($pos < $len) {
        my int $ch = char_at($s, $pos);
        if ($in_str > 0) {
            if ($ch == $in_str) { $in_str = 0; }
            $pos++;
            next;
        }
        if ($ch == 34 || $ch == 39) { $in_str = $ch; $pos++; next; }
        if ($ch == 40) { $depth++; }
        elsif ($ch == 41) {
            if ($depth > 0) { $depth--; }
            else {
                # Unmatched ) - this closes an outer paren, insert before it
                $insert_pos = $pos;
                last;
            }
        }
        elsif ($ch == 91) { $depth++; }  # [
        elsif ($ch == 93) { if ($depth > 0) { $depth--; } }  # ]
        elsif ($ch == 123) { $depth++; }  # { (hash literal or block â€” track as nesting)
        elsif ($ch == 125) { if ($depth > 0) { $depth--; } }  # }
        elsif ($ch == 59 && $depth == 0) { $insert_pos = $pos; last; }  # ;
        $pos++;
    }
    if ($insert_pos < 0) { $insert_pos = $len; }
    return substr($s, 0, $insert_pos) . ")" . substr($s, $insert_pos, $len - $insert_pos);
}

# Smarter close paren insertion for single-argument builtins like keys, values,
# ref, length, scalar.  Finds the end of the first argument (a sigiled variable
# optionally followed by {key} or [idx]) and inserts ) right after it.
# $func_name is the builtin name (e.g. "keys") so we find the right ( in nested calls.
# e.g. "scalar(keys(%seen) . "\n")" -> "scalar(keys(%seen)) . "\n""
# Falls back to add_close_paren if no argument pattern is found.
func add_close_paren_after_arg(str $s, str $func_name) str {
    # Find the opening ( belonging to $func_name
    my int $open = index($s, $func_name . "(");
    if ($open < 0) { return add_close_paren($s); }
    $open = $open + length($func_name);

    my int $i = $open + 1;
    my int $len = length($s);

    # Skip whitespace after (
    while ($i < $len && (substr($s, $i, 1) eq " " || substr($s, $i, 1) eq "\t")) {
        $i++;
    }

    if ($i >= $len) { return add_close_paren($s); }

    my str $c = substr($s, $i, 1);

    # Expect a sigiled variable: $var, @arr, %hash, or \%hash, \@arr, \$var
    if ($c eq "\\" && $i + 1 < $len) {
        $i++;  # skip backslash
        $c = substr($s, $i, 1);
    }

    if ($c ne "$" && $c ne "@" && $c ne "%") {
        # Not a simple variable argument - fall back
        return add_close_paren($s);
    }

    $i++;  # skip sigil

    # Handle $$ref (scalar deref) - skip second sigil
    if ($i < $len && $c eq "$" && substr($s, $i, 1) eq "$") {
        $i++;
    }

    # Read the variable name
    while ($i < $len && is_word_char(substr($s, $i, 1))) {
        $i++;
    }

    # Optionally consume hash access {key}, array access [idx], and arrow chains ->member->{key}
    my int $keep_consuming = 1;
    while ($keep_consuming == 1 && $i < $len) {
        $keep_consuming = 0;
        if ($i < $len && substr($s, $i, 1) eq "{") {
            my int $depth = 1;
            $i++;
            while ($i < $len && $depth > 0) {
                my str $bc = substr($s, $i, 1);
                if ($bc eq "{") { $depth++; }
                if ($bc eq "}") { $depth--; }
                $i++;
            }
            $keep_consuming = 1;
        }
        if ($i < $len && substr($s, $i, 1) eq "[") {
            my int $depth2 = 1;
            $i++;
            while ($i < $len && $depth2 > 0) {
                my str $bc2 = substr($s, $i, 1);
                if ($bc2 eq "[") { $depth2++; }
                if ($bc2 eq "]") { $depth2--; }
                $i++;
            }
            $keep_consuming = 1;
        }
        # Arrow -> member or ->{key} or ->[idx] or ->method()
        if ($i + 1 < $len && substr($s, $i, 2) eq "->") {
            $i = $i + 2;
            # Read member name
            while ($i < $len && is_word_char(substr($s, $i, 1))) {
                $i++;
            }
            # Consume () if method call
            if ($i < $len && substr($s, $i, 1) eq "(") {
                my int $depth3 = 1;
                $i++;
                while ($i < $len && $depth3 > 0) {
                    my str $bc3 = substr($s, $i, 1);
                    if ($bc3 eq "(") { $depth3++; }
                    if ($bc3 eq ")") { $depth3--; }
                    $i++;
                }
            }
            $keep_consuming = 1;
        }
    }

    # Insert ) at position $i
    return substr($s, 0, $i) . ")" . substr($s, $i, $len - $i);
}

func ends_with(str $s, str $suffix) int {
    if (length($s) < length($suffix)) { return 0; }
    my int $start = length($s) - length($suffix);
    if (substr($s, $start, length($suffix)) eq $suffix) { return 1; }
    return 0;
}

# Quote a bare hash key if needed: key -> "key"
# Returns the key with quotes if it's a bareword, unchanged if already quoted or is a variable
# Replace all occurrences of $@ with $e in a string
# Can't use regex for this because $ is always an anchor in POSIX regex
func replace_dollar_at(str $s) str {
    my str $result = $s;
    my str $target = "$@";
    my str $repl = "$e";
    my int $pos = index($result, $target);
    while ($pos >= 0) {
        $result = substr($result, 0, $pos) . $repl . substr($result, $pos + 2, length($result) - $pos - 2);
        $pos = index($result, $target);
    }
    return $result;
}

# Map Perl overload operator to wrapper method name
func op_name_for_overload(str $op) str {
    if ($op eq "0+" || $op eq "0+") { return "op_numify"; }
    if ($op eq "++") { return "op_increment"; }
    if ($op eq "--") { return "op_decrement"; }
    if ($op eq "+") { return "op_add"; }
    if ($op eq "-") { return "op_subtract"; }
    if ($op eq "*") { return "op_multiply"; }
    if ($op eq "/") { return "op_divide"; }
    if ($op eq "%") { return "op_modulo"; }
    if ($op eq "**") { return "op_pow"; }
    if ($op eq "==") { return "op_num_eq"; }
    if ($op eq "!=") { return "op_num_ne"; }
    if ($op eq "<") { return "op_num_lt"; }
    if ($op eq ">") { return "op_num_gt"; }
    if ($op eq "<=") { return "op_num_le"; }
    if ($op eq ">=") { return "op_num_ge"; }
    if ($op eq "<=>") { return "op_num_cmp"; }
    if ($op eq "eq") { return "op_str_eq"; }
    if ($op eq "ne") { return "op_str_ne"; }
    if ($op eq "lt") { return "op_str_lt"; }
    if ($op eq "gt") { return "op_str_gt"; }
    if ($op eq "le") { return "op_str_le"; }
    if ($op eq "ge") { return "op_str_ge"; }
    if ($op eq "cmp") { return "op_str_cmp"; }
    if ($op eq "bool") { return "op_bool"; }
    if ($op eq "!") { return "op_not"; }
    if ($op eq "neg") { return "op_negate"; }
    if ($op eq "abs") { return "op_abs"; }
    if ($op eq "&") { return "op_bitand"; }
    if ($op eq "|") { return "op_bitor"; }
    if ($op eq "^") { return "op_bitxor"; }
    if ($op eq "~") { return "op_bitnot"; }
    if ($op eq "<<") { return "op_lshift"; }
    if ($op eq ">>") { return "op_rshift"; }
    if ($op eq ".") { return "op_concat"; }
    if ($op eq "x") { return "op_repeat"; }
    # String conversion (two double-quotes in Perl: '""')
    if ($op eq "\"\"") { return "op_stringify"; }
    return "op_" . $op;
}

# Check if a Perl overload operator is unary (takes only $self)
func is_unary_overload(str $op) int {
    if ($op eq "++" || $op eq "--" || $op eq "0+" || $op eq "bool") { return 1; }
    if ($op eq "!" || $op eq "neg" || $op eq "abs" || $op eq "~") { return 1; }
    if ($op eq "\"\"") { return 1; }
    return 0;
}

# Parse overload::import() line and generate wrapper method definitions
# Input: the full single-line overload::import(...) call
# Returns: array of wrapper method definition lines
func generate_overload_wrappers(str $line) array {
    my array @methods = ();

    # Extract the arguments portion: everything between 'overload', and closing );
    # Pattern: overload::import('overload', "op" => sub/func ..., ... );
    # or: use overload ("op" => sub ..., ...);
    my str $args = $line;

    # Strip everything before the first operator mapping
    # Look for first "quoted_op" => pattern
    my int $first_op_pos = -1;
    my int $scan_pos = 0;
    my int $line_len = length($args);
    while ($scan_pos < $line_len) {
        my int $ch = char_at($args, $scan_pos);
        # Check for double-quoted or single-quoted operator name followed by =>
        if ($ch == 34 || $ch == 39) {
            my str $qchar_str = substr($args, $scan_pos, 1);
            my int $close_q = index($args, $qchar_str, $scan_pos + 1);
            if ($close_q > $scan_pos) {
                my str $after_q = substr($args, $close_q + 1, $line_len - $close_q - 1);
                $after_q = replace($after_q, "^\\s+", "");
                if (starts_with($after_q, "=>")) {
                    $first_op_pos = $scan_pos;
                    $scan_pos = $line_len;
                }
            }
        }
        $scan_pos++;
    }

    if ($first_op_pos < 0) {
        return @methods;
    }

    # Now parse operator => handler pairs
    # We look for patterns like: "op" => sub { body }, or "op" => func () void { body },
    my str $remainder = substr($args, $first_op_pos, $line_len - $first_op_pos);

    # Split on the pattern: "op" =>
    # We process sequentially
    my int $pos = 0;
    my int $rem_len = length($remainder);

    while ($pos < $rem_len) {
        # Skip whitespace
        while ($pos < $rem_len && (char_at($remainder, $pos) == 32 || char_at($remainder, $pos) == 9 || char_at($remainder, $pos) == 44)) {
            $pos++;
        }
        if ($pos >= $rem_len) { last; }

        # Check for closing ); or )
        if (char_at($remainder, $pos) == 41) { last; }

        # Check for "op" or 'op'
        my int $qchar = char_at($remainder, $pos);
        if ($qchar == 34 || $qchar == 39) {
            # Find closing quote
            my int $close = index($remainder, substr($remainder, $pos, 1), $pos + 1);
            if ($close < 0) { last; }
            my str $op = substr($remainder, $pos + 1, $close - $pos - 1);
            $pos = $close + 1;

            # Skip whitespace and =>
            while ($pos < $rem_len && (char_at($remainder, $pos) == 32 || char_at($remainder, $pos) == 9)) {
                $pos++;
            }
            if ($pos + 1 < $rem_len && substr($remainder, $pos, 2) eq "=>") {
                $pos = $pos + 2;
            }
            # Skip whitespace
            while ($pos < $rem_len && (char_at($remainder, $pos) == 32 || char_at($remainder, $pos) == 9)) {
                $pos++;
            }

            # Now read the handler: sub { ... } or func () void { ... } or a bare value
            if ($pos < $rem_len) {
                my int $hch = char_at($remainder, $pos);

                # Check for sub/func keyword
                my int $is_sub = 0;
                if ($pos + 3 < $rem_len && substr($remainder, $pos, 4) eq "sub ") {
                    $is_sub = 1;
                }
                if ($pos + 4 < $rem_len && substr($remainder, $pos, 5) eq "func ") {
                    $is_sub = 1;
                }

                if ($is_sub == 1) {
                    # Find opening { and matching closing }
                    my int $open_b = index($remainder, "{", $pos);
                    if ($open_b >= 0) {
                        my int $depth = 1;
                        my int $bi = $open_b + 1;
                        while ($bi < $rem_len && $depth > 0) {
                            my int $bc = char_at($remainder, $bi);
                            if ($bc == 123) { $depth++; }
                            if ($bc == 125) { $depth--; }
                            if ($bc == 34) {
                                # Skip string
                                $bi++;
                                while ($bi < $rem_len && char_at($remainder, $bi) != 34) {
                                    if (char_at($remainder, $bi) == 92) { $bi++; }
                                    $bi++;
                                }
                            }
                            $bi++;
                        }
                        my str $body = substr($remainder, $open_b + 1, $bi - $open_b - 2);
                        $body = replace($body, "^\\s+", "");
                        $body = replace($body, "\\s+$", "");
                        $pos = $bi;

                        # Skip fallback
                        if ($op eq "fallback") { next; }

                        # Generate wrapper method
                        my str $method_name = op_name_for_overload($op);
                        my str $method = "";

                        if (is_unary_overload($op) == 1) {
                            $method = "func " . $method_name . "(scalar $self) scalar {  # REVIEW: overload \"" . $op . "\" wrapper - original body: " . $body;
                            # Generate return with body hint
                            $method = $method . "\n    return $$self;  # REVIEW: adapt from Perl body";
                            $method = $method . "\n}";
                        } else {
                            $method = "func " . $method_name . "(scalar $self, scalar $other) scalar {  # REVIEW: overload \"" . $op . "\" wrapper - original body: " . $body;
                            $method = $method . "\n    return $$self;  # REVIEW: adapt from Perl body";
                            $method = $method . "\n}";
                        }
                        push(@methods, $method);
                    } else {
                        # No opening brace - skip to next comma
                        my int $next_comma = index($remainder, ",", $pos);
                        if ($next_comma >= 0) { $pos = $next_comma + 1; } else { last; }
                    }
                } else {
                    # Not a sub - skip to next comma (e.g. fallback => 1)
                    if ($op ne "fallback") {
                        # Could be a code ref like \&method_name
                        my str $val_end = "";
                        my int $next_comma = index($remainder, ",", $pos);
                        if ($next_comma >= 0) {
                            $val_end = substr($remainder, $pos, $next_comma - $pos);
                            $pos = $next_comma + 1;
                        } else {
                            my int $next_paren = index($remainder, ")", $pos);
                            if ($next_paren >= 0) {
                                $val_end = substr($remainder, $pos, $next_paren - $pos);
                                $pos = $next_paren;
                            } else {
                                last;
                            }
                        }
                        $val_end = replace($val_end, "^\\s+", "");
                        $val_end = replace($val_end, "\\s+$", "");
                        # Generate stub if it references a method
                        if (starts_with($val_end, "\\&")) {
                            my str $ref_name = substr($val_end, 2, length($val_end) - 2);
                            my str $method_name = op_name_for_overload($op);
                            push(@methods, "# " . $method_name . " -> delegates to " . $ref_name . "()  # REVIEW: overload \"" . $op . "\"");
                        }
                    } else {
                        # Skip fallback value
                        my int $next_comma = index($remainder, ",", $pos);
                        if ($next_comma >= 0) { $pos = $next_comma + 1; } else { last; }
                    }
                }
            }
        } else {
            # Bare word like "fallback" without quotes
            my int $word_start = $pos;
            while ($pos < $rem_len && char_at($remainder, $pos) != 32 && char_at($remainder, $pos) != 9 && char_at($remainder, $pos) != 44 && char_at($remainder, $pos) != 61) {
                $pos++;
            }
            my str $bareword = substr($remainder, $word_start, $pos - $word_start);
            # Skip => and value
            while ($pos < $rem_len && (char_at($remainder, $pos) == 32 || char_at($remainder, $pos) == 9)) { $pos++; }
            if ($pos + 1 < $rem_len && substr($remainder, $pos, 2) eq "=>") { $pos = $pos + 2; }
            # Skip value until next comma or closing paren
            my int $next_comma = index($remainder, ",", $pos);
            if ($next_comma >= 0) { $pos = $next_comma + 1; } else { last; }
        }
    }

    return @methods;
}

func quote_bare_key(str $key) str {
    my str $k = trim_str($key);
    if ($k eq "") { return $key; }
    # Already quoted
    if (starts_with($k, "\"") || starts_with($k, "'")) { return $key; }
    # Variable reference - leave alone
    if (starts_with($k, "$")) { return $key; }
    # Number - leave alone
    if (match($k, "^-?[0-9]")) { return $key; }
    # Bareword - quote it
    if (match($k, "^[A-Za-z_][A-Za-z0-9_]*$")) {
        return "\"" . $k . "\"";
    }
    return $key;
}

# ============================================================
# XS Conversion Support
# ============================================================

# Map XS/C types to Strada types
func xs_type_to_strada(str $xstype) str {
    my str $t = $xstype;
    $t = replace($t, "^\\s+", "");
    $t = replace($t, "\\s+$", "");

    # Integer types
    if ($t eq "int" || $t eq "IV" || $t eq "UV" || $t eq "long" || $t eq "short" || $t eq "unsigned int" || $t eq "unsigned long" || $t eq "size_t" || $t eq "ssize_t" || $t eq "SSize_t" || $t eq "bool_t" || $t eq "STRLEN" || $t eq "I32" || $t eq "I16" || $t eq "I8" || $t eq "U32" || $t eq "U16" || $t eq "U8" || $t eq "Off_t" || $t eq "pid_t" || $t eq "uid_t" || $t eq "gid_t" || $t eq "time_t") {
        return "int";
    }
    # Float types
    if ($t eq "double" || $t eq "float" || $t eq "NV" || $t eq "long double") {
        return "num";
    }
    # String types
    if ($t eq "char *" || $t eq "const char *" || $t eq "char*" || $t eq "const char*" || $t eq "unsigned char *" || $t eq "PV") {
        return "str";
    }
    # Perl scalar types -> Strada scalar
    if ($t eq "SV*" || $t eq "SV *" || $t eq "SV") {
        return "scalar";
    }
    # Perl array ref
    if ($t eq "AV*" || $t eq "AV *" || $t eq "AV") {
        return "scalar";
    }
    # Perl hash ref
    if ($t eq "HV*" || $t eq "HV *" || $t eq "HV") {
        return "scalar";
    }
    # void
    if ($t eq "void") {
        return "void";
    }
    # Unknown type - use scalar
    return "scalar";
}

func xs_type_is_known(str $xstype) int {
    my str $t = replace($xstype, "^\\s+", "");
    $t = replace($t, "\\s+$", "");
    if ($t eq "int" || $t eq "IV" || $t eq "UV" || $t eq "long" || $t eq "short" || $t eq "unsigned int" || $t eq "unsigned long" || $t eq "size_t" || $t eq "ssize_t" || $t eq "SSize_t" || $t eq "bool_t" || $t eq "STRLEN" || $t eq "I32" || $t eq "double" || $t eq "float" || $t eq "NV" || $t eq "char *" || $t eq "const char *" || $t eq "char*" || $t eq "const char*" || $t eq "SV*" || $t eq "SV *" || $t eq "void" || $t eq "AV*" || $t eq "AV *" || $t eq "HV*" || $t eq "HV *" || $t eq "time_t" || $t eq "pid_t" || $t eq "Off_t" || $t eq "PV" || $t eq "unsigned char *") {
        return 1;
    }
    return 0;
}

func is_xs_return_type(str $line) int {
    if (match($line, "^\\s")) { return 0; }
    if (match($line, "^#")) { return 0; }
    if (match($line, "^$")) { return 0; }
    if (match($line, ":$")) { return 0; }
    if (match($line, "^MODULE")) { return 0; }
    if (match($line, "^PACKAGE")) { return 0; }
    if (match($line, "^PROTOTYPES")) { return 0; }
    if (match($line, "^PREFIX")) { return 0; }
    if (match($line, "^VERSIONCHECK")) { return 0; }
    if (match($line, "^EXPORT_XSUB")) { return 0; }
    if (match($line, "^SCOPE")) { return 0; }
    if (match($line, "^FALLBACK")) { return 0; }
    if (match($line, "^BOOT:")) { return 0; }
    if (match($line, "^REQUIRE:")) { return 0; }
    if (match($line, "^INCLUDE")) { return 0; }
    if (match($line, "^TYPEMAP")) { return 0; }

    my str $t = replace($line, "^\\s+", "");
    $t = replace($t, "\\s+$", "");

    if ($t eq "void" || $t eq "int" || $t eq "IV" || $t eq "UV" || $t eq "NV" || $t eq "long" || $t eq "short" || $t eq "double" || $t eq "float" || $t eq "bool_t" || $t eq "SV*" || $t eq "SV *" || $t eq "AV*" || $t eq "AV *" || $t eq "HV*" || $t eq "HV *" || $t eq "size_t" || $t eq "ssize_t" || $t eq "time_t" || $t eq "pid_t" || $t eq "Off_t") {
        return 1;
    }
    if (match($t, "^(const\\s+)?(unsigned\\s+)?[a-zA-Z_][a-zA-Z0-9_]*\\s*\\*$")) {
        return 1;
    }
    if (match($t, "^[A-Z][a-zA-Z0-9_]*$")) {
        return 1;
    }
    return 0;
}

func is_section_keyword(str $line) int {
    if (match($line, "^\\s*(CODE|PPCODE|PREINIT|INIT|INPUT|OUTPUT|CLEANUP|POSTCALL|ALIAS|OVERLOAD|INTERFACE|INTERFACE_MACRO|PROTOTYPE|CASE|C_ARGS|NO_OUTPUT)\\s*:")) {
        return 1;
    }
    return 0;
}

func get_section_name(str $line) str {
    my array @cap = capture($line, "^\\s*(CODE|PPCODE|PREINIT|INIT|INPUT|OUTPUT|CLEANUP|POSTCALL|ALIAS|OVERLOAD|INTERFACE|INTERFACE_MACRO|PROTOTYPE|CASE|C_ARGS|NO_OUTPUT)\\s*:");
    if (scalar(@cap) > 1) {
        return $cap[1];
    }
    return "";
}

func convert_c_body(str $code, str $ret_type, hash %param_types) str {
    my str $result = $code;

    if (match($result, "RETVAL")) {
        $result = replace_all($result, "RETVAL", "__retval");
    }
    if (match($result, "SvIV")) {
        $result = replace_all($result, "SvIV", "strada_to_int");
    }
    if (match($result, "SvNV")) {
        $result = replace_all($result, "SvNV", "strada_to_num_c");
    }
    if (match($result, "SvPV_nolen")) {
        $result = replace_all($result, "SvPV_nolen", "strada_to_str");
    }
    if (match($result, "SvPVbyte_nolen")) {
        $result = replace_all($result, "SvPVbyte_nolen", "strada_to_str");
    }
    if (match($result, "newSViv")) {
        $result = replace_all($result, "newSViv", "strada_new_int");
    }
    if (match($result, "newSVnv")) {
        $result = replace_all($result, "newSVnv", "strada_new_num");
    }
    if (match($result, "newSVpvn")) {
        $result = replace_all($result, "newSVpvn", "strada_new_str /* REVIEW: was newSVpvn, len arg may need removal */");
    }
    if (match($result, "newSVpv")) {
        $result = replace_all($result, "newSVpv", "strada_new_str");
    }
    if (match($result, "croak\\(")) {
        $result = replace_all($result, "croak(", "/* REVIEW: was croak() */ die(");
    }
    if (match($result, "XSRETURN_UNDEF")) {
        $result = replace_all($result, "XSRETURN_UNDEF", "return strada_new_undef() /* was XSRETURN_UNDEF */");
    }
    if (match($result, "XSRETURN_YES")) {
        $result = replace_all($result, "XSRETURN_YES", "return strada_new_int(1) /* was XSRETURN_YES */");
    }
    if (match($result, "XSRETURN_NO")) {
        $result = replace_all($result, "XSRETURN_NO", "return strada_new_int(0) /* was XSRETURN_NO */");
    }
    if (match($result, "XSRETURN_EMPTY")) {
        $result = replace_all($result, "XSRETURN_EMPTY", "return /* was XSRETURN_EMPTY */");
    }
    if (match($result, "XSRETURN\\(")) {
        $result = replace_all($result, "XSRETURN(", "/* REVIEW: multi-return */ XSRETURN(");
    }
    if (match($result, "aTHX_ ")) {
        $result = replace_all($result, "aTHX_ ", "");
    }
    if (match($result, "aTHX_,")) {
        $result = replace_all($result, "aTHX_,", ",");
    }
    if (match($result, "pTHX_ ")) {
        $result = replace_all($result, "pTHX_ ", "");
    }
    if (match($result, "dTHX;")) {
        $result = replace_all($result, "dTHX;", "/* dTHX removed */");
    }
    if (match($result, "dXSARGS;")) {
        $result = replace_all($result, "dXSARGS;", "/* dXSARGS removed - params are StradaValue* */");
    }
    if (match($result, "dXSARGS")) {
        $result = replace_all($result, "dXSARGS", "/* dXSARGS removed */");
    }
    if (match($result, "dXSTARG;")) {
        $result = replace_all($result, "dXSTARG;", "/* dXSTARG removed */");
    }
    if (match($result, "SvOK\\(")) {
        $result = replace_all($result, "SvOK(", "/* REVIEW: SvOK = not undef */ strada_is_defined(");
    }
    if (match($result, "SvROK\\(")) {
        $result = replace_all($result, "SvROK(", "/* REVIEW: SvROK = is reference */ strada_is_ref(");
    }
    if (match($result, "SvTRUE\\(")) {
        $result = replace_all($result, "SvTRUE(", "/* REVIEW: SvTRUE = truthy */ strada_is_true(");
    }
    if (match($result, "SvIOK\\(")) {
        $result = replace_all($result, "SvIOK(", "/* REVIEW: SvIOK = is integer */ strada_is_int(");
    }
    if (match($result, "SvNOK\\(")) {
        $result = replace_all($result, "SvNOK(", "/* REVIEW: SvNOK = is number */ strada_is_num(");
    }
    if (match($result, "&PL_sv_undef")) {
        $result = replace_all($result, "&PL_sv_undef", "strada_new_undef()");
    }
    if (match($result, "ST\\(")) {
        $result = replace_all($result, "ST(", "/* REVIEW: use named params instead */ ST(");
    }
    if (match($result, "sv_2mortal\\(")) {
        $result = replace_all($result, "sv_2mortal(", "/* REVIEW: sv_2mortal not needed in Strada */ (");
    }

    return $result;
}

func generate_param_extraction(str $param_name, str $c_type) str {
    my str $st = replace($c_type, "^\\s+", "");
    $st = replace($st, "\\s+$", "");

    if ($st eq "int" || $st eq "IV" || $st eq "long" || $st eq "short" || $st eq "unsigned int" || $st eq "unsigned long" || $st eq "size_t" || $st eq "ssize_t" || $st eq "SSize_t" || $st eq "bool_t" || $st eq "STRLEN" || $st eq "I32" || $st eq "I16" || $st eq "I8" || $st eq "U32" || $st eq "U16" || $st eq "U8" || $st eq "Off_t" || $st eq "pid_t" || $st eq "uid_t" || $st eq "gid_t" || $st eq "time_t" || $st eq "UV") {
        return "        " . $st . " " . $param_name . "_c = (" . $st . ")strada_to_int(" . $param_name . ");";
    }
    if ($st eq "double" || $st eq "float" || $st eq "NV" || $st eq "long double") {
        return "        " . $st . " " . $param_name . "_c = (" . $st . ")strada_to_num_c(" . $param_name . ");";
    }
    if ($st eq "char *" || $st eq "const char *" || $st eq "char*" || $st eq "const char*" || $st eq "unsigned char *") {
        return "        char *" . $param_name . "_c = strada_to_str(" . $param_name . ");  /* free() when done */";
    }
    if (match($st, "^[SAH]V")) {
        return "        /* " . $param_name . " is already StradaValue* (was " . $st . ") */";
    }
    return "        /* REVIEW: extract " . $param_name . " from StradaValue* (was " . $st . ") */";
}

func generate_str_free(str $param_name, str $c_type) str {
    my str $st = replace($c_type, "^\\s+", "");
    $st = replace($st, "\\s+$", "");
    if ($st eq "char *" || $st eq "const char *" || $st eq "char*" || $st eq "const char*" || $st eq "unsigned char *") {
        return "        free(" . $param_name . "_c);";
    }
    return "";
}

# Convert a .xs file to Strada with __C__ blocks
func convert_xs_file(str $input_path, str $output_path) int {
    my str $content = core::slurp($input_path);
    if (length($content) == 0) {
        say("Error: Cannot read or empty file: " . $input_path);
        return 1;
    }

    my array @lines = split("\n", $content);
    my int $total_lines = scalar(@lines);
    say("Read " . $total_lines . " lines from " . $input_path);

    # ---- PHASE 1: Find MODULE line, extract package name ----
    my int $module_line = -1;
    my str $module_name = "";
    my str $package_name = "";

    my int $mi = 0;
    while ($mi < $total_lines) {
        my str $mline = $lines[$mi];
        $mline = replace($mline, "\\n$", "");
        $lines[$mi] = $mline;

        if (match($mline, "^MODULE\\s*=")) {
            if ($module_line == -1) {
                $module_line = $mi;
            }
            my array @mcap = capture($mline, "MODULE\\s*=\\s*(\\S+)");
            if (scalar(@mcap) > 1) {
                $module_name = $mcap[1];
            }
            my array @pcap = capture($mline, "PACKAGE\\s*=\\s*(\\S+)");
            if (scalar(@pcap) > 1) {
                $package_name = $pcap[1];
            }
        }
        $mi++;
    }

    if ($module_line == -1) {
        say("Error: no MODULE declaration found in " . $input_path);
        say("This doesn't appear to be an XS file.");
        return 1;
    }

    say("Found MODULE = " . $module_name . "  PACKAGE = " . $package_name . " at line " . ($module_line + 1));

    # ---- PHASE 2: Extract C preamble ----
    my array @preamble_lines = ();
    my int $pi = 0;
    while ($pi < $module_line) {
        my str $pline = $lines[$pi];
        if (match($pline, "#define\\s+PERL_NO_GET_CONTEXT")) { $pi++; next; }
        if (match($pline, "#include\\s+\"EXTERN\\.h\"")) { $pi++; next; }
        if (match($pline, "#include\\s+\"perl\\.h\"")) { $pi++; next; }
        if (match($pline, "#include\\s+\"XSUB\\.h\"")) { $pi++; next; }
        if (match($pline, "#include\\s+\"ppport\\.h\"")) { $pi++; next; }
        push(@preamble_lines, $pline);
        $pi++;
    }

    # Trim trailing blank lines from preamble
    while (scalar(@preamble_lines) > 0) {
        my str $plast = $preamble_lines[scalar(@preamble_lines) - 1];
        if (match($plast, "^\\s*$")) {
            pop(@preamble_lines);
        } else {
            last;
        }
    }

    # ---- PHASE 3: Parse XS function definitions ----
    my array @functions = ();
    my int $xi = $module_line + 1;
    my str $current_package = $package_name;
    my array @boot_lines = ();

    while ($xi < $total_lines) {
        my str $xline = $lines[$xi];

        if (match($xline, "^\\s*$")) { $xi++; next; }
        if (match($xline, "^\\s*#")) { $xi++; next; }

        if (match($xline, "^MODULE\\s*=")) {
            my array @pcap2 = capture($xline, "PACKAGE\\s*=\\s*(\\S+)");
            if (scalar(@pcap2) > 1) {
                $current_package = $pcap2[1];
            }
            $xi++;
            next;
        }

        if (match($xline, "^PROTOTYPES\\s*:") || match($xline, "^PREFIX\\s*=") || match($xline, "^VERSIONCHECK\\s*:") || match($xline, "^EXPORT_XSUB") || match($xline, "^SCOPE\\s*:") || match($xline, "^FALLBACK\\s*:")) {
            $xi++;
            next;
        }

        # BOOT: section
        if (match($xline, "^BOOT:")) {
            $xi++;
            while ($xi < $total_lines) {
                my str $bline = $lines[$xi];
                if (!match($bline, "^\\s") && !match($bline, "^#") && !match($bline, "^$")) {
                    last;
                }
                push(@boot_lines, $bline);
                $xi++;
            }
            next;
        }

        # Check for return type
        if (is_xs_return_type($xline) == 1 && ($xi + 1) < $total_lines) {
            my str $next_line = $lines[$xi + 1];
            if (match($next_line, "^[a-zA-Z_][a-zA-Z0-9_:]*\\s*\\(")) {
                my str $ret_type = replace($xline, "^\\s+", "");
                $ret_type = replace($ret_type, "\\s+$", "");

                my array @fncap = capture($next_line, "^([a-zA-Z_][a-zA-Z0-9_:]*)\\s*\\(([^)]*)\\)");
                my str $func_name = "";
                my str $param_str = "";
                if (scalar(@fncap) > 2) {
                    $func_name = $fncap[1];
                    $param_str = $fncap[2];
                } elsif (scalar(@fncap) > 1) {
                    $func_name = $fncap[1];
                }

                my int $is_variadic = 0;
                if (match($param_str, "\\.\\.\\.")) {
                    $is_variadic = 1;
                    $param_str = replace($param_str, ",?\\s*\\.\\.\\.", "");
                    $param_str = replace($param_str, "^\\s+", "");
                    $param_str = replace($param_str, "\\s+$", "");
                }

                my array @param_names = ();
                if (length($param_str) > 0) {
                    my array @raw_params = split(",", $param_str);
                    my int $rpi = 0;
                    while ($rpi < scalar(@raw_params)) {
                        my str $pname = replace($raw_params[$rpi], "^\\s+", "");
                        $pname = replace($pname, "\\s+$", "");
                        if (match($pname, "=")) {
                            my array @dp = split("=", $pname);
                            $pname = replace($dp[0], "\\s+$", "");
                        }
                        if (length($pname) > 0) {
                            push(@param_names, $pname);
                        }
                        $rpi++;
                    }
                }

                $xi = $xi + 2;

                # Parse parameter type declarations
                my hash %param_types = ();
                my array @param_defaults = ();

                while ($xi < $total_lines) {
                    my str $ptline = $lines[$xi];
                    if (match($ptline, "^\\s*$")) { $xi++; next; }
                    if (is_section_keyword($ptline) == 1) { last; }
                    if (match($ptline, "^\\s+")) {
                        my str $decl = replace($ptline, "^\\s+", "");
                        $decl = replace($decl, "\\s+$", "");
                        $decl = replace($decl, ";$", "");
                        my str $default_val = "";
                        if (match($decl, "=\\s*NO_INIT")) {
                            $decl = replace($decl, "\\s*=\\s*NO_INIT", "");
                        } elsif (match($decl, "=")) {
                            my int $eq_pos = index($decl, "=");
                            $default_val = substr($decl, $eq_pos + 1, length($decl) - $eq_pos - 1);
                            $default_val = replace($default_val, "^\\s+", "");
                            $decl = substr($decl, 0, $eq_pos);
                            $decl = replace($decl, "\\s+$", "");
                        }
                        $decl = replace($decl, "\\s*&\\s*", " ");
                        my str $ptype = "";
                        my str $ppname = "";
                        if (match($decl, "\\*\\s*[a-zA-Z_]")) {
                            my array @ptcap = capture($decl, "^(.+\\*)\\s*([a-zA-Z_][a-zA-Z0-9_]*)$");
                            if (scalar(@ptcap) > 2) {
                                $ptype = $ptcap[1];
                                $ppname = $ptcap[2];
                            }
                        }
                        if (length($ppname) == 0) {
                            my array @words = split("\\s+", $decl);
                            my int $nw = scalar(@words);
                            if ($nw >= 2) {
                                $ppname = $words[$nw - 1];
                                my str $tparts = "";
                                my int $wi = 0;
                                while ($wi < $nw - 1) {
                                    if (length($tparts) > 0) { $tparts = $tparts . " "; }
                                    $tparts = $tparts . $words[$wi];
                                    $wi++;
                                }
                                $ptype = $tparts;
                            } elsif ($nw == 1) {
                                $ppname = $words[0];
                                $ptype = "SV*";
                            }
                        }

                        if (length($ppname) > 0 && length($ptype) > 0) {
                            $param_types{$ppname} = $ptype;
                            if (length($default_val) > 0) {
                                push(@param_defaults, $ppname . "=" . $default_val);
                            }
                        }
                        $xi++;
                    } else {
                        last;
                    }
                }

                # Parse sections
                my hash %sections = ();
                my str $current_section = "";

                while ($xi < $total_lines) {
                    my str $sline = $lines[$xi];

                    if (is_section_keyword($sline) == 1) {
                        $current_section = get_section_name($sline);
                        $sections{$current_section} = "";
                        my str $after = replace($sline, "^\\s*(CODE|PPCODE|PREINIT|INIT|INPUT|OUTPUT|CLEANUP|POSTCALL|ALIAS|OVERLOAD|C_ARGS|NO_OUTPUT)\\s*:\\s*", "");
                        if (length($after) > 0 && !match($after, "^\\s*$")) {
                            $sections{$current_section} = $after . "\n";
                        }
                        $xi++;
                        next;
                    }

                    if (!match($sline, "^\\s") && !match($sline, "^$")) {
                        if (match($sline, "^# ") || match($sline, "^#$")) {
                            last;
                        }
                        if (!match($sline, "^#")) {
                            if (is_xs_return_type($sline) == 1 || match($sline, "^MODULE") || match($sline, "^BOOT:")) {
                                last;
                            }
                        }
                    }

                    if (length($current_section) > 0) {
                        my str $scode = $sline;
                        if (match($scode, "^    ")) {
                            $scode = substr($scode, 4, length($scode) - 4);
                        } elsif (match($scode, "^\t")) {
                            $scode = substr($scode, 1, length($scode) - 1);
                        }
                        $sections{$current_section} = $sections{$current_section} . $scode . "\n";
                    }

                    $xi++;
                }

                # Store function info
                my hash %func_info = ();
                $func_info{"name"} = $func_name;
                $func_info{"ret_type"} = $ret_type;
                $func_info{"package"} = $current_package;
                $func_info{"variadic"} = "" . $is_variadic;

                my str $pn_str = "";
                my int $pni = 0;
                while ($pni < scalar(@param_names)) {
                    if (length($pn_str) > 0) { $pn_str = $pn_str . ","; }
                    $pn_str = $pn_str . $param_names[$pni];
                    $pni++;
                }
                $func_info{"param_names"} = $pn_str;

                my str $pt_str = "";
                $pni = 0;
                while ($pni < scalar(@param_names)) {
                    if (length($pt_str) > 0) { $pt_str = $pt_str . ","; }
                    my str $pt = "";
                    if (exists($param_types{$param_names[$pni]})) {
                        $pt = $param_types{$param_names[$pni]};
                    } else {
                        $pt = "SV*";
                    }
                    $pt_str = $pt_str . $param_names[$pni] . ":" . $pt;
                    $pni++;
                }
                $func_info{"param_types"} = $pt_str;

                if (exists($sections{"CODE"})) { $func_info{"code"} = $sections{"CODE"}; }
                if (exists($sections{"PPCODE"})) { $func_info{"ppcode"} = $sections{"PPCODE"}; }
                if (exists($sections{"PREINIT"})) { $func_info{"preinit"} = $sections{"PREINIT"}; }
                if (exists($sections{"INIT"})) { $func_info{"init"} = $sections{"INIT"}; }
                if (exists($sections{"OUTPUT"})) { $func_info{"output"} = $sections{"OUTPUT"}; }
                if (exists($sections{"CLEANUP"})) { $func_info{"cleanup"} = $sections{"CLEANUP"}; }
                if (exists($sections{"POSTCALL"})) { $func_info{"postcall"} = $sections{"POSTCALL"}; }
                if (exists($sections{"ALIAS"})) { $func_info{"alias"} = $sections{"ALIAS"}; }

                my str $def_str = "";
                my int $di = 0;
                while ($di < scalar(@param_defaults)) {
                    if (length($def_str) > 0) { $def_str = $def_str . ","; }
                    $def_str = $def_str . $param_defaults[$di];
                    $di++;
                }
                $func_info{"defaults"} = $def_str;

                push(@functions, \%func_info);
                next;
            }
        }

        $xi++;
    }

    say("Found " . scalar(@functions) . " XS function(s)");

    # ---- PHASE 4: Generate Strada output ----
    my scalar $out = core::open($output_path, "w");

    say($out, "# Converted from XS: " . $input_path);
    say($out, "# Generated by perl2strada (XS mode)");
    say($out, "# NOTE: Check lines marked for review (grep for TODO)");
    say($out, "# NOTE: C code in __C__ blocks uses StradaValue* for all Strada variables");
    say($out, "# NOTE: Use strada_to_int/str/num() to extract C values, strada_new_int/str/num() to create");
    say($out, "");

    if (length($package_name) > 0) {
        say($out, "package " . $package_name . ";");
        say($out, "");
    }

    if (scalar(@preamble_lines) > 0) {
        say($out, "# C preamble from XS (includes, helper functions, typedefs)");
        say($out, "__C__ {");
        my int $pli = 0;
        while ($pli < scalar(@preamble_lines)) {
            say($out, $preamble_lines[$pli]);
            $pli++;
        }
        say($out, "}");
        say($out, "");
    }

    if (scalar(@boot_lines) > 0) {
        say($out, "# BOOT section - runs at module load time");
        say($out, "# REVIEW: move this code into an init function or module-level __C__ block");
        say($out, "__C__ {");
        my int $bli = 0;
        while ($bli < scalar(@boot_lines)) {
            say($out, $boot_lines[$bli]);
            $bli++;
        }
        say($out, "}");
        say($out, "");
    }

    my str $last_package = $package_name;

    my int $fi = 0;
    while ($fi < scalar(@functions)) {
        my scalar $fref = $functions[$fi];
        my hash %f = %{$fref};
        my str $fname = $f{"name"};
        my str $ret = $f{"ret_type"};
        my str $pkg = $f{"package"};
        my str $var_str = $f{"variadic"};
        my int $is_var = 0;
        if ($var_str eq "1") { $is_var = 1; }

        if ($pkg ne $last_package) {
            say($out, "");
            say($out, "package " . $pkg . ";");
            say($out, "");
            $last_package = $pkg;
        }

        my str $strada_ret = xs_type_to_strada($ret);
        my int $ret_known = xs_type_is_known($ret);

        # Parse param types
        my array @pnames = ();
        my hash %ptypes = ();
        if (length($f{"param_types"}) > 0) {
            my array @pt_parts = split(",", $f{"param_types"});
            my int $ppi = 0;
            while ($ppi < scalar(@pt_parts)) {
                my str $ppt = $pt_parts[$ppi];
                my int $colon = index($ppt, ":");
                if ($colon >= 0) {
                    my str $pn = substr($ppt, 0, $colon);
                    my str $pptype = substr($ppt, $colon + 1, length($ppt) - $colon - 1);
                    push(@pnames, $pn);
                    $ptypes{$pn} = $pptype;
                }
                $ppi++;
            }
        }

        my str $clean_name = $fname;
        if (match($fname, "::")) {
            $clean_name = replace($fname, ".*::", "");
        }

        # Build parameter list
        my str $param_list = "";
        my int $pli2 = 0;
        while ($pli2 < scalar(@pnames)) {
            if (length($param_list) > 0) { $param_list = $param_list . ", "; }
            my str $ct = "SV*";
            if (exists($ptypes{$pnames[$pli2]})) {
                $ct = $ptypes{$pnames[$pli2]};
            }
            my str $st = xs_type_to_strada($ct);
            $param_list = $param_list . $st . " $" . $pnames[$pli2];
            $pli2++;
        }

        if ($is_var == 1) {
            if (length($param_list) > 0) {
                $param_list = $param_list . "  # REVIEW: was variadic (...)";
            } else {
                $param_list = "# REVIEW: was variadic (...)";
            }
        }

        my str $type_review = "";
        if ($ret_known == 0) {
            $type_review = "  # REVIEW: return type was " . $ret;
        }

        if (exists($f{"alias"})) {
            say($out, "# ALIAS: " . replace($f{"alias"}, "\\n$", ""));
        }

        say($out, "func " . $clean_name . "(" . $param_list . ") " . $strada_ret . " {" . $type_review);

        my int $needs_retval = 0;
        if ($strada_ret ne "void") {
            $needs_retval = 1;
        }

        my str $code_body = "";
        my int $is_ppcode = 0;
        if (exists($f{"code"})) {
            $code_body = $f{"code"};
        } elsif (exists($f{"ppcode"})) {
            $code_body = $f{"ppcode"};
            $is_ppcode = 1;
        }

        my str $preinit_body = "";
        if (exists($f{"preinit"})) {
            $preinit_body = $f{"preinit"};
        }

        my str $init_body = "";
        if (exists($f{"init"})) {
            $init_body = $f{"init"};
        }

        my str $cleanup_body = "";
        if (exists($f{"cleanup"})) {
            $cleanup_body = $f{"cleanup"};
        }

        my str $postcall_body = "";
        if (exists($f{"postcall"})) {
            $postcall_body = $f{"postcall"};
        }

        # Declare return variable
        if ($needs_retval == 1) {
            if ($strada_ret eq "int") {
                say($out, "    my int $__retval = 0;");
            } elsif ($strada_ret eq "num") {
                say($out, "    my num $__retval = 0.0;");
            } elsif ($strada_ret eq "str") {
                say($out, "    my str $__retval = \"\";");
            } else {
                say($out, "    my scalar $__retval = undef;");
            }
        }

        # Emit __C__ block
        if (length($code_body) > 0 || length($preinit_body) > 0 || length($init_body) > 0) {
            if ($is_ppcode == 1) {
                say($out, "    # REVIEW: PPCODE section - returns multiple values via stack");
            }

            say($out, "    __C__ {");

            my int $epi = 0;
            while ($epi < scalar(@pnames)) {
                my str $epct = "SV*";
                if (exists($ptypes{$pnames[$epi]})) { $epct = $ptypes{$pnames[$epi]}; }
                my str $extraction = generate_param_extraction($pnames[$epi], $epct);
                if (length($extraction) > 0) {
                    say($out, $extraction);
                }
                $epi++;
            }
            if (scalar(@pnames) > 0) {
                say($out, "");
            }

            if (length($preinit_body) > 0) {
                say($out, "        /* PREINIT */");
                my array @pre_lines = split("\n", $preinit_body);
                my int $prli = 0;
                while ($prli < scalar(@pre_lines)) {
                    if (!match($pre_lines[$prli], "^\\s*$")) {
                        say($out, "        " . $pre_lines[$prli]);
                    }
                    $prli++;
                }
                say($out, "");
            }

            if (length($init_body) > 0) {
                say($out, "        /* INIT */");
                my array @init_lines = split("\n", $init_body);
                my int $inli = 0;
                while ($inli < scalar(@init_lines)) {
                    if (!match($init_lines[$inli], "^\\s*$")) {
                        say($out, "        " . $init_lines[$inli]);
                    }
                    $inli++;
                }
                say($out, "");
            }

            my str $converted = convert_c_body($code_body, $ret, %ptypes);
            my array @code_lines = split("\n", $converted);
            my int $cli = 0;
            while ($cli < scalar(@code_lines)) {
                if (!match($code_lines[$cli], "^\\s*$")) {
                    say($out, "        " . $code_lines[$cli]);
                }
                $cli++;
            }

            if (length($postcall_body) > 0) {
                say($out, "");
                say($out, "        /* POSTCALL */");
                my array @post_lines = split("\n", $postcall_body);
                my int $poli = 0;
                while ($poli < scalar(@post_lines)) {
                    if (!match($post_lines[$poli], "^\\s*$")) {
                        say($out, "        " . $post_lines[$poli]);
                    }
                    $poli++;
                }
            }

            # Cleanup string params
            my int $fri = 0;
            while ($fri < scalar(@pnames)) {
                my str $frct = "SV*";
                if (exists($ptypes{$pnames[$fri]})) { $frct = $ptypes{$pnames[$fri]}; }
                my str $fr = generate_str_free($pnames[$fri], $frct);
                if (length($fr) > 0) {
                    say($out, $fr);
                }
                $fri++;
            }

            if (length($cleanup_body) > 0) {
                say($out, "");
                say($out, "        /* CLEANUP */");
                my array @clean_lines = split("\n", $cleanup_body);
                my int $clli = 0;
                while ($clli < scalar(@clean_lines)) {
                    if (!match($clean_lines[$clli], "^\\s*$")) {
                        say($out, "        " . $clean_lines[$clli]);
                    }
                    $clli++;
                }
            }

            if ($needs_retval == 1 && !match($code_body, "__retval") && !match($code_body, "RETVAL")) {
                say($out, "        /* REVIEW: no RETVAL found - add return value assignment */");
            }

            say($out, "    }");
        } else {
            # No CODE section - direct C function call
            say($out, "    # REVIEW: no CODE section - was a direct C function call");
            say($out, "    __C__ {");
            my int $epi2 = 0;
            while ($epi2 < scalar(@pnames)) {
                my str $epct2 = "SV*";
                if (exists($ptypes{$pnames[$epi2]})) { $epct2 = $ptypes{$pnames[$epi2]}; }
                my str $extraction2 = generate_param_extraction($pnames[$epi2], $epct2);
                if (length($extraction2) > 0) {
                    say($out, $extraction2);
                }
                $epi2++;
            }
            # Generate direct call
            my str $call_args = "";
            my int $cai = 0;
            while ($cai < scalar(@pnames)) {
                if (length($call_args) > 0) { $call_args = $call_args . ", "; }
                my str $cact = "SV*";
                if (exists($ptypes{$pnames[$cai]})) { $cact = $ptypes{$pnames[$cai]}; }
                if (match($cact, "char") || match($cact, "int") || match($cact, "IV") || match($cact, "long") || match($cact, "double") || match($cact, "float") || match($cact, "NV") || match($cact, "size_t") || match($cact, "time_t") || match($cact, "pid_t") || match($cact, "Off_t") || match($cact, "UV")) {
                    $call_args = $call_args . $pnames[$cai] . "_c";
                } else {
                    $call_args = $call_args . $pnames[$cai];
                }
                $cai++;
            }
            if ($needs_retval == 1) {
                say($out, "        strada_decref(__retval);");
                if ($strada_ret eq "int") {
                    say($out, "        __retval = strada_new_int(" . $fname . "(" . $call_args . "));");
                } elsif ($strada_ret eq "num") {
                    say($out, "        __retval = strada_new_num(" . $fname . "(" . $call_args . "));");
                } elsif ($strada_ret eq "str") {
                    say($out, "        __retval = strada_new_str(" . $fname . "(" . $call_args . "));");
                } else {
                    say($out, "        /* REVIEW: convert return value */ " . $fname . "(" . $call_args . ");");
                }
            } else {
                say($out, "        " . $fname . "(" . $call_args . ");");
            }
            # Free string params
            my int $fri2 = 0;
            while ($fri2 < scalar(@pnames)) {
                my str $frct2 = "SV*";
                if (exists($ptypes{$pnames[$fri2]})) { $frct2 = $ptypes{$pnames[$fri2]}; }
                my str $fr2 = generate_str_free($pnames[$fri2], $frct2);
                if (length($fr2) > 0) {
                    say($out, $fr2);
                }
                $fri2++;
            }
            say($out, "    }");
        }

        if ($needs_retval == 1) {
            say($out, "    return $__retval;");
        }

        say($out, "}");
        say($out, "");

        $fi++;
    }

    core::close($out);

    say("Converted XS: " . $input_path . " -> " . $output_path);
    say("Functions: " . scalar(@functions));
    if (scalar(@boot_lines) > 0) {
        say("BOOT section: " . scalar(@boot_lines) . " lines");
    }

    return 0;
}

# ============================================================
# Pass 1: Pre-scan - extract sub signatures and package info
# ============================================================

# Scan for sub definitions and extract parameter info from @_ unpacking
# Returns a hash mapping sub_name -> param info string (e.g. "scalar $self, str $name")
func pass1_prescan(array @lines) hash {
    my hash %subs = ();
    my hash %sub_returns = ();
    my str $current_package = "main";
    my int $i = 0;
    my int $num_lines = scalar(@lines);

    while ($i < $num_lines) {
        my str $line = $lines[$i];
        my str $trimmed = trim_str($line);

        # Track package declarations
        if (match($trimmed, "^package\\s+")) {
            my array @pcap = capture($trimmed, "^package\\s+([A-Za-z_:][A-Za-z0-9_:]*)");
            if (scalar(@pcap) > 1) {
                $current_package = $pcap[1];
            }
        }

        # Find sub declarations
        if (match($trimmed, "^sub\\s+[A-Za-z_]")) {
            my array @scap = capture($trimmed, "^sub\\s+([A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@scap) > 1) {
                my str $sub_name = $scap[1];
                my array @params = ();
                my int $has_return = 0;
                my int $has_wantarray = 0;

                # Scan inside the sub body for @_ unpacking, return, and wantarray
                my int $brace_depth = 0;
                # Count braces on the sub line itself
                my int $ci = 0;
                my int $clen = length($trimmed);
                while ($ci < $clen) {
                    my str $ch = substr($trimmed, $ci, 1);
                    if ($ch eq "{") { $brace_depth++; }
                    if ($ch eq "}") { $brace_depth--; }
                    $ci++;
                }

                my int $j = $i + 1;
                while ($j < $num_lines && $brace_depth > 0) {
                    my str $body_line = trim_str($lines[$j]);

                    # Count braces (simplified - ignoring strings/comments)
                    my int $bi = 0;
                    my int $blen = length($body_line);
                    while ($bi < $blen) {
                        my str $bch = substr($body_line, $bi, 1);
                        if ($bch eq "{") { $brace_depth++; }
                        if ($bch eq "}") { $brace_depth--; }
                        $bi++;
                    }

                    # Check for return statements
                    if (match($body_line, "\\breturn\\b")) {
                        # Check if it returns a value (not just bare "return;")
                        if (match($body_line, "\\breturn\\s+[^;]")) {
                            $has_return = 1;
                        }
                    }

                    # Check for wantarray (context-sensitive function call)
                    # Match bare wantarray or wantarray() but not just $wantarray as a variable
                    if (match($body_line, "\\bwantarray\\b")) {
                        # Has wantarray â€” check if it's a function call (bare or with parens)
                        # Even if $wantarray var exists on same line, the function is context-sensitive
                        $has_wantarray = 1;
                    }

                    # Pattern: my ($a, $b, $c) = @_;
                    if (match($body_line, "my\\s*\\([^)]+\\)\\s*=\\s*@_")) {
                        my array @pcap2 = capture($body_line, "my\\s*\\(([^)]+)\\)\\s*=\\s*@_");
                        if (scalar(@pcap2) > 1) {
                            my str $param_str = $pcap2[1];
                            my array @raw_params = split(",", $param_str);
                            my int $pi = 0;
                            while ($pi < scalar(@raw_params)) {
                                my str $p = trim_str($raw_params[$pi]);
                                # Remove leading sigil ($ or % or @) or my + sigil
                                $p =~ s/^my\s+//;
                                my str $sigil = "$";
                                if (match($p, "^%")) {
                                    $sigil = "%";
                                }
                                if (match($p, "^@")) {
                                    $sigil = "@";
                                }
                                $p =~ s/^[\$%@]//;
                                if ($p ne "") {
                                    push(@params, $sigil . $p);
                                }
                                $pi++;
                            }
                        }
                    }

                    # Pattern: my $x = shift;  or  my $x = shift @_;  or  my $x = shift(@_);
                    if (match($body_line, "my\\s+\\$[A-Za-z_][A-Za-z0-9_]*\\s*=\\s*shift")) {
                        my array @scap2 = capture($body_line, "my\\s+\\$([A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*shift");
                        if (scalar(@scap2) > 1) {
                            push(@params, $scap2[1]);
                        }
                    }

                    # Pattern: my ($self) = @_;  or  my $self = shift;  (already handled above)

                    $j++;
                }

                # Build parameter type string
                my str $param_sig = "";
                my int $pi2 = 0;
                while ($pi2 < scalar(@params)) {
                    if ($pi2 > 0) { $param_sig = $param_sig . ", "; }
                    my str $praw = $params[$pi2];
                    # Check if it has a sigil prefix from our extraction
                    my str $psigil = substr($praw, 0, 1);
                    my str $pname = $praw;
                    if ($psigil eq "%" || $psigil eq "@" || $psigil eq "$") {
                        $pname = substr($praw, 1, length($praw) - 1);
                    } else {
                        $psigil = "$";
                    }
                    # Infer type based on sigil and name
                    if ($psigil eq "%") {
                        $param_sig = $param_sig . "hash %" . $pname;
                    } elsif ($psigil eq "@") {
                        # If this is the last param, make it variadic with ...
                        if ($pi2 == scalar(@params) - 1) {
                            $param_sig = $param_sig . "scalar ...@" . $pname;
                        } else {
                            $param_sig = $param_sig . "array @" . $pname;
                        }
                    } elsif ($pname eq "self") {
                        $param_sig = $param_sig . "scalar $" . $pname;
                    } else {
                        $param_sig = $param_sig . "scalar $" . $pname;
                    }
                    $pi2++;
                }

                # Use package-qualified name to avoid collisions
                my str $qualified_name = $current_package . "::" . $sub_name;
                $subs{$qualified_name} = $param_sig;
                # Also store under bare name for fallback lookup
                $subs{$sub_name} = $param_sig;

                # Store return type info
                # Perl subs always return a value (last expression), so default to scalar.
                # If wantarray is used, the function is context-sensitive -> dynamic.
                if ($has_wantarray == 1) {
                    $sub_returns{$qualified_name} = "dynamic";
                    $sub_returns{$sub_name} = "dynamic";
                } else {
                    $sub_returns{$qualified_name} = "scalar";
                    $sub_returns{$sub_name} = "scalar";
                }
            }
        }

        # Track use Module qw(func1 func2) imports
        if (match($trimmed, "^use\\s+[A-Z]") && match($trimmed, "qw")) {
            my array @imp_cap = capture($trimmed, "^use\\s+([A-Za-z_:][A-Za-z0-9_:]*)\\s+qw[\\(\\[]\\s*([^)\\]]+)\\s*[)\\]]");
            if (scalar(@imp_cap) > 2) {
                my str $imp_mod = $imp_cap[1];
                my array @imp_funcs = split("\\s+", trim_str($imp_cap[2]));
                my int $ifi = 0;
                while ($ifi < scalar(@imp_funcs)) {
                    my str $imp_fn = trim_str($imp_funcs[$ifi]);
                    if (length($imp_fn) > 0) {
                        $subs{"import:" . $imp_fn} = $imp_mod;
                    }
                    $ifi++;
                }
                $subs{"module:" . $imp_mod} = "1";
            }
        }
        # Also track use Module 'func' or use Module "func" (single import)
        if (match($trimmed, "^use\\s+[A-Z]") && !match($trimmed, "qw") && match($trimmed, "['\"][a-z_]")) {
            my array @simp_cap = capture($trimmed, "^use\\s+([A-Za-z_:][A-Za-z0-9_:]*)\\s+['\"]([a-z_][a-z0-9_]*)['\"]");
            if (scalar(@simp_cap) > 2) {
                my str $simp_mod = $simp_cap[1];
                my str $simp_fn = $simp_cap[2];
                $subs{"import:" . $simp_fn} = $simp_mod;
                $subs{"module:" . $simp_mod} = "1";
            }
        }

        # Track typeglob variable aliases: *alias = \$original, *alias = \@original, *alias = \%original
        my str $tg_star = "*";
        if (match($trimmed, "^\\*[A-Za-z_][A-Za-z0-9_:]*\\s*=\\s*\\\\[\\$@%]")) {
            my array @tg_cap = capture($trimmed, "^\\*([A-Za-z_][A-Za-z0-9_:]*)\\s*=\\s*\\\\([\\$@%])([A-Za-z_][A-Za-z0-9_:]*)");
            if (scalar(@tg_cap) > 3) {
                my str $tg_alias = $tg_cap[1];
                my str $tg_sigil = $tg_cap[2];
                my str $tg_orig = $tg_cap[3];
                # Store as varalias:sigil:alias = original
                $subs{"varalias:" . $tg_sigil . ":" . $tg_alias} = $tg_orig;
            }
        }

        # Track bareword filehandles from open() calls
        # open(LOG, ">", "file") or open(FH, "<file")
        if (match($trimmed, "^open\\s*\\(\\s*[A-Z][A-Z0-9_]*\\s*,")) {
            my array @bfh_cap = capture($trimmed, "^open\\s*\\(\\s*([A-Z][A-Z0-9_]*)\\s*,");
            if (scalar(@bfh_cap) > 1) {
                my str $bfh_name = $bfh_cap[1];
                # Skip STDIN/STDOUT/STDERR - those are special
                if ($bfh_name ne "STDIN" && $bfh_name ne "STDOUT" && $bfh_name ne "STDERR") {
                    my str $bfh_var = lc($bfh_name);
                    $subs{"bareword_fh:" . $bfh_name} = $bfh_var;
                }
            }
        }

        # Track @EXPORT and @EXPORT_OK lists for import() generation
        if (match($trimmed, "@EXPORT_OK") && match($trimmed, "qw")) {
            my array @eok_cap = capture($trimmed, "qw[\\(\\[]\\s*([^)\\]]+)\\s*[)\\]]");
            if (scalar(@eok_cap) > 1) {
                my str $prev_ok = "";
                if (length("" . $subs{"export_ok:" . $current_package}) > 0) {
                    $prev_ok = "" . $subs{"export_ok:" . $current_package} . " ";
                }
                $subs{"export_ok:" . $current_package} = $prev_ok . trim_str($eok_cap[1]);
            }
        } elsif (match($trimmed, "@EXPORT\\b") && match($trimmed, "qw")) {
            my array @exp_cap = capture($trimmed, "qw[\\(\\[]\\s*([^)\\]]+)\\s*[)\\]]");
            if (scalar(@exp_cap) > 1) {
                my str $prev_ex = "";
                if (length("" . $subs{"export:" . $current_package}) > 0) {
                    $prev_ex = "" . $subs{"export:" . $current_package} . " ";
                }
                $subs{"export:" . $current_package} = $prev_ex . trim_str($exp_cap[1]);
            }
        }
        # Track if module uses Exporter
        if (match($trimmed, "\\bExporter\\b") || match($trimmed, "@EXPORT")) {
            $subs{"uses_exporter:" . $current_package} = "1";
        }

        $i++;
    }

    # Combine subs and returns into one hash using prefixed keys
    my hash %result = ();
    my array @sub_names = keys(%subs);
    my int $si = 0;
    while ($si < scalar(@sub_names)) {
        my str $name = $sub_names[$si];
        # Pass through keys that already have their own prefix
        if (starts_with($name, "varalias:") || starts_with($name, "bareword_fh:") || starts_with($name, "import:") || starts_with($name, "module:") || starts_with($name, "export:") || starts_with($name, "export_ok:") || starts_with($name, "uses_exporter:")) {
            $result{$name} = $subs{$name};
        } else {
            $result{"sig:" . $name} = $subs{$name};
        }
        $si++;
    }
    my array @ret_names = keys(%sub_returns);
    my int $ri = 0;
    while ($ri < scalar(@ret_names)) {
        my str $name = $ret_names[$ri];
        $result{"ret:" . $name} = $sub_returns{$name};
        $ri++;
    }

    return %result;
}

# ============================================================
# Pass 2: Convert function signatures
# ============================================================

# Convert sub declarations to func with typed parameters
# Uses signatures extracted by pass1_prescan when available
# Also removes @_ unpacking lines that were absorbed into the signature
func pass2_signatures(array @lines, hash %sub_info) array {
    my array @out = ();
    my int $i = 0;
    my int $num_lines = scalar(@lines);
    my str $current_sub = "";
    my str $current_pkg = "main";
    my int $in_sub = 0;
    my int $skip_unpacking = 0;

    while ($i < $num_lines) {
        my str $line = $lines[$i];
        my str $trimmed = trim_str($line);
        my str $indent = get_indent($line);

        # Track package declarations
        if (match($trimmed, "^package\\s+")) {
            my array @pkg_cap = capture($trimmed, "^package\\s+([A-Za-z_:][A-Za-z0-9_:]*)");
            if (scalar(@pkg_cap) > 1) {
                $current_pkg = $pkg_cap[1];
            }
        }

        # Skip @_ unpacking lines when signature was extracted
        if ($skip_unpacking == 1) {
            # Skip: my ($a, $b) = @_;  or  my $x = shift;  or  my $x = shift @_;  or  my $x = shift(@_);
            if (match($trimmed, "^my\\s*\\([^)]+\\)\\s*=\\s*@_") || match($trimmed, "^my\\s+\\$[A-Za-z_][A-Za-z0-9_]*\\s*=\\s*shift")) {
                $i++;
                next;
            }
            # Skip blank lines between func header and unpacking
            if ($trimmed eq "") {
                push(@out, $line);
                $i++;
                next;
            }
            # First non-blank, non-unpacking line: stop skipping
            $skip_unpacking = 0;
        }

        # Convert sub declaration
        # Forward declarations: sub name; or sub name(@); (no body) -> comment out
        if (match($trimmed, "^sub\\s+[A-Za-z_][A-Za-z0-9_]*\\s*;\\s*$") || match($trimmed, "^sub\\s+[A-Za-z_][A-Za-z0-9_]*\\s*\\([^)]*\\)\\s*;\\s*$")) {
            push(@out, $indent . "# " . $trimmed . "  # Forward declaration (not needed in Strada)");
            $i++;
            next;
        }
        if (match($trimmed, "^sub\\s+[A-Za-z_]")) {
            # Check for parens after sub name: could be prototype OR native signature
            my str $native_sig = "";
            if (match($trimmed, "^sub\\s+[A-Za-z_][A-Za-z0-9_]*\\s*\\([^)]*\\)\\s*\\{")) {
                # Extract paren content to distinguish signature from prototype
                my array @paren_cap = capture($trimmed, "^sub\\s+[A-Za-z_][A-Za-z0-9_]*\\s*\\(([^)]*)\\)");
                my str $paren_content = "";
                if (scalar(@paren_cap) > 1) {
                    $paren_content = $paren_cap[1];
                }
                if (match($paren_content, "\\$[a-zA-Z_]") || match($paren_content, "@[a-zA-Z_]") || match($paren_content, "%[a-zA-Z_]")) {
                    # Native Perl signature: sub foo ($self, $name, $age = 0, @rest)
                    # Parse into Strada typed params
                    my array @sig_parts = split(",", $paren_content);
                    my str $strada_sig = "";
                    my int $spi = 0;
                    while ($spi < scalar(@sig_parts)) {
                        my str $sp = trim_str($sig_parts[$spi]);
                        if (length($sp) > 0) {
                            if (length($strada_sig) > 0) {
                                $strada_sig = $strada_sig . ", ";
                            }
                            # Strip default value for type inference
                            my str $sp_name = $sp;
                            my str $sp_default = "";
                            if (match($sp, "=")) {
                                my array @sp_parts = capture($sp, "^([^=]+)=(.+)$");
                                if (scalar(@sp_parts) > 2) {
                                    $sp_name = trim_str($sp_parts[1]);
                                    $sp_default = trim_str($sp_parts[2]);
                                }
                            }
                            # Determine type from sigil and default
                            if (match($sp_name, "^@")) {
                                $strada_sig = $strada_sig . "array " . $sp_name;
                            } elsif (match($sp_name, "^%")) {
                                $strada_sig = $strada_sig . "hash " . $sp_name;
                            } else {
                                # Scalar param - infer type from default if present
                                my str $sp_type = "scalar";
                                if (match($sp_default, "^-?[0-9]+$")) {
                                    $sp_type = "int";
                                } elsif (match($sp_default, "^-?[0-9]+\\.[0-9]")) {
                                    $sp_type = "num";
                                } elsif (match($sp_default, "^['\"]") || match($sp_default, "^\"")) {
                                    $sp_type = "str";
                                }
                                $strada_sig = $strada_sig . $sp_type . " " . $sp_name;
                            }
                        }
                        $spi++;
                    }
                    $native_sig = $strada_sig;
                    # Strip the signature parens from the line: "sub name (...) {" -> "sub name {"
                    my array @sig_name_cap = capture($trimmed, "^sub\\s+([A-Za-z_][A-Za-z0-9_]*)");
                    if (scalar(@sig_name_cap) > 1) {
                        $trimmed = "sub " . $sig_name_cap[1] . " {";
                        $line = $indent . $trimmed;
                    }
                } else {
                    # Prototype: sub foo (&@) or sub foo ($$$) - strip it
                    $trimmed = replace($trimmed, "(^sub\\s+[A-Za-z_][A-Za-z0-9_]*)\\s*\\([^)]*\\)", "$1");
                    $line = $indent . $trimmed;
                }
            }
            # Check for :lvalue attribute and strip it, adding TODO
            my int $is_lvalue = 0;
            if (match($trimmed, ":\\s*lvalue")) {
                $is_lvalue = 1;
                $trimmed = replace($trimmed, "\\s*:\\s*lvalue\\b", "");
                $line = $indent . $trimmed;
            }

            my array @scap = capture($trimmed, "^sub\\s+([A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@scap) > 1) {
                my str $sub_name = $scap[1];
                $current_sub = $sub_name;
                $in_sub = 1;

                # Try to find Pass 1 signature: qualified name first, then bare
                my str $qualified = $current_pkg . "::" . $sub_name;
                my str $sig = "";
                my str $ret = "";

                # Try qualified lookup
                my str $sig_key_q = "sig:" . $qualified;
                my str $ret_key_q = "ret:" . $qualified;
                my str $sig_key_b = "sig:" . $sub_name;
                my str $ret_key_b = "ret:" . $sub_name;

                if (length("" . $sub_info{$sig_key_q}) > 0) {
                    $sig = "" . $sub_info{$sig_key_q};
                    $ret = "" . $sub_info{$ret_key_q};
                } elsif (length("" . $sub_info{$sig_key_b}) > 0) {
                    $sig = "" . $sub_info{$sig_key_b};
                    $ret = "" . $sub_info{$ret_key_b};
                }

                if (length($ret) == 0) {
                    $ret = "scalar";
                }

                my str $new_line = "";
                # Special subs with known Strada signatures
                if ($sub_name eq "import") {
                    $new_line = $indent . "func import(str $pkg, array @list) void {";
                    $skip_unpacking = 1;
                } elsif (length($native_sig) > 0) {
                    # Native Perl signature detected - use it directly
                    $new_line = $indent . "func " . $sub_name . "(" . $native_sig . ") " . $ret . " {";
                    $skip_unpacking = 1;
                } elsif (length($sig) > 0) {
                    # Use extracted signature from @_ unpacking
                    $new_line = $indent . "func " . $sub_name . "(" . $sig . ") " . $ret . " {";
                    $skip_unpacking = 1;
                } else {
                    # No signature found - check if body uses $_[0] (OOP method)
                    my str $peek_sig = "(scalar ...@_) dynamic";
                    my str $dol_peek0 = "$" . "_[0]";
                    my str $dol_peek1 = "$" . "_[1]";
                    my int $found_self = 0;
                    my int $found_arg1 = 0;
                    # Check if single-line sub first (body on same line)
                    my int $is_single_line = 0;
                    my int $bp2 = index($trimmed, "{");
                    if ($bp2 >= 0) {
                        my int $bd2 = 0;
                        my int $bi2 = $bp2;
                        my int $bl2 = length($trimmed);
                        while ($bi2 < $bl2) {
                            my str $bc2 = substr($trimmed, $bi2, 1);
                            if ($bc2 eq "{") { $bd2++; }
                            if ($bc2 eq "}") { $bd2--; }
                            $bi2++;
                        }
                        if ($bd2 == 0) { $is_single_line = 1; }
                    }
                    if ($is_single_line == 0) {
                        # Multi-line sub: peek ahead to check body for $_[0]
                        my int $peek_k = $i + 1;
                        my int $peek_depth = 1;
                        while ($peek_k < $num_lines && $peek_depth > 0) {
                            my str $pk_line = $lines[$peek_k];
                            my str $pk_trim = trim_str($pk_line);
                            my int $pki = 0;
                            my int $pklen = length($pk_trim);
                            while ($pki < $pklen) {
                                my str $pkc = substr($pk_trim, $pki, 1);
                                if ($pkc eq "{") { $peek_depth++; }
                                if ($pkc eq "}") { $peek_depth--; }
                                $pki++;
                            }
                            if (index($pk_line, $dol_peek0) >= 0) { $found_self = 1; }
                            if (index($pk_line, $dol_peek1) >= 0) { $found_arg1 = 1; }
                            $peek_k++;
                        }
                    }
                    # Single-line subs: $_[0] conversion handled below in body extraction
                    if ($found_self == 1) {
                        if ($found_arg1 == 1) {
                            $peek_sig = "(scalar $" . "self, scalar $" . "__arg1) void";
                        } else {
                            $peek_sig = "(scalar $" . "self) scalar";
                        }
                    }
                    $new_line = $indent . "func " . $sub_name . $peek_sig . " {";
                }

                # Check if original line is a single-line sub: sub name { body; }
                # If so, extract body and emit on same or next line
                my str $body_after = "";
                my int $brace_pos = index($trimmed, "{");
                if ($brace_pos >= 0) {
                    my str $after_brace = substr($trimmed, $brace_pos + 1, length($trimmed) - $brace_pos - 1);
                    # Check if there's a closing brace (single-line body)
                    my int $last_close = -1;
                    my int $body_depth = 1;
                    my int $bci = 0;
                    my int $ablen = length($after_brace);
                    while ($bci < $ablen) {
                        my str $bcc = substr($after_brace, $bci, 1);
                        if ($bcc eq "{") { $body_depth++; }
                        if ($bcc eq "}") {
                            $body_depth--;
                            if ($body_depth == 0) {
                                $last_close = $bci;
                            }
                        }
                        $bci++;
                    }
                    if ($last_close >= 0) {
                        # Single-line sub - extract body content
                        $body_after = trim_str(substr($after_brace, 0, $last_close));
                        if (length($body_after) > 0) {
                            # Check if body uses $_[0] (OOP self pattern)
                            my str $dol_bracket0 = "$" . "_[0]";
                            my str $dol_bracket1 = "$" . "_[1]";
                            if (index($body_after, $dol_bracket0) >= 0) {
                                my int $has_arg1 = 0;
                                if (index($body_after, $dol_bracket1) >= 0) { $has_arg1 = 1; }
                                # Replace $_[0] -> $self, $_[1] -> $value in body
                                $body_after = replace_all($body_after, $dol_bracket0, "$" . "self");
                                if ($has_arg1 == 1) {
                                    $body_after = replace_all($body_after, $dol_bracket1, "$" . "value");
                                }
                                # Update the signature in $new_line
                                my str $self_sig = "scalar $" . "self";
                                my str $self_ret = "scalar";
                                if ($has_arg1 == 1) {
                                    $self_sig = "scalar $" . "self, scalar $" . "value";
                                    $self_ret = "void";
                                }
                                # Replace (scalar ...@_) dynamic with proper sig
                                $new_line = replace_all($new_line, "(scalar ...@_) dynamic {", "(" . $self_sig . ") " . $self_ret . " {");
                            }
                            # Emit: func name(...) type { body; }
                            $new_line = $new_line . " " . $body_after . " }";
                            $in_sub = 0;
                        }
                    }
                }

                if ($is_lvalue == 1) {
                    $new_line = $new_line . "  # REVIEW: lvalue sub â€” Strada has no lvalue function support; refactor callers to use setter methods";
                }
                push(@out, $new_line);
                # Skip redundant standalone { on next line (Perl style: sub name\n{ )
                if ($i + 1 < $num_lines) {
                    my str $next_peek = trim_str($lines[$i + 1]);
                    if ($next_peek eq "{") {
                        $i++;
                    } elsif (starts_with($next_peek, "{ ") || starts_with($next_peek, "{#")) {
                        # K&R style: sub name\n  { body â€” strip the leading { from next line
                        # since func header already has opening {
                        my int $brace_idx = index($lines[$i + 1], "{");
                        if ($brace_idx >= 0) {
                            my str $before = substr($lines[$i + 1], 0, $brace_idx);
                            my str $after = substr($lines[$i + 1], $brace_idx + 1, length($lines[$i + 1]) - $brace_idx - 1);
                            # Strip optional space after the removed {
                            if (length($after) > 0 && substr($after, 0, 1) eq " ") {
                                $after = substr($after, 1, length($after) - 1);
                            }
                            $lines[$i + 1] = $before . $after;
                        }
                    }
                }
                $i++;
                next;
            }
        }

        push(@out, $line);
        $i++;
    }

    return @out;
}


# ============================================================
# Pass 2b: Multi-line block conversions (eval -> try/catch)
# ============================================================

# Convert eval { ... }; if ($@) { ... } patterns to try/catch
# Also handles: eval { ... }; $@ and ... or die patterns
func pass2b_eval_to_try(array @lines) array {
    my array @out = ();
    my int $i = 0;
    my int $num_lines = scalar(@lines);

    while ($i < $num_lines) {
        my str $line = $lines[$i];
        my str $trimmed = trim_str($line);
        my str $indent = get_indent($line);

        # Detect "eval {" opening
        if (match($trimmed, "^eval\\s*\\{") || match($trimmed, "=\\s*eval\\s*\\{")) {
            # Check if this is eval { ... } on a single line
            if (match($trimmed, "eval\\s*\\{.*\\}")) {
                # Detect eval-as-expression: my $var = eval { ... };
                my str $sl_assign_var = "";
                my str $sl_assign_prefix = "";
                if (match($trimmed, "=\\s*eval\\s*\\{")) {
                    my array @sla_cap = capture($trimmed, "^((?:my\\s+(?:scalar\\s+)?)?\\$[A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*eval");
                    if (scalar(@sla_cap) > 1) {
                        $sl_assign_prefix = $sla_cap[1];
                        # Extract just the variable name
                        my array @slv_cap = capture($sl_assign_prefix, "(\\$[A-Za-z_][A-Za-z0-9_]*)$");
                        if (scalar(@slv_cap) > 1) {
                            $sl_assign_var = $slv_cap[1];
                        }
                    }
                }
                # Single-line eval { ... };
                # Use brace counting to find matching } for eval {
                my int $ev_pos = index($trimmed, "eval");
                # Find the opening { after eval
                my int $ev_open = index($trimmed, "{", $ev_pos + 4);
                my str $eval_body = "";
                my str $eval_after = "";
                if ($ev_open >= 0) {
                    my int $ev_depth = 1;
                    my int $ev_ci = $ev_open + 1;
                    my int $ev_len = length($trimmed);
                    while ($ev_ci < $ev_len && $ev_depth > 0) {
                        my str $ev_ch = substr($trimmed, $ev_ci, 1);
                        if ($ev_ch eq "{") { $ev_depth++; }
                        if ($ev_ch eq "}") { $ev_depth--; }
                        $ev_ci++;
                    }
                    # ev_ci is now just past the matching }
                    $eval_body = trim_str(substr($trimmed, $ev_open + 1, $ev_ci - $ev_open - 2));
                    $eval_after = trim_str(substr($trimmed, $ev_ci));
                } else {
                    $eval_body = $trimmed;
                    $eval_body =~ s/^.*eval\s*\{//;
                }

                # Check for ternary: eval { } ? true : false -> try/catch with flag
                if (match($eval_after, "^\\?")) {
                    my array @tern_cap = capture($eval_after, "^\\?\\s*(.+)\\s*:\\s*(.+)$");
                    if (scalar(@tern_cap) > 2) {
                        my str $tern_true = trim_str($tern_cap[1]);
                        my str $tern_false = trim_str($tern_cap[2]);
                        # Remove trailing semicolon from false branch
                        if (ends_with($tern_false, ";")) {
                            $tern_false = substr($tern_false, 0, length($tern_false) - 1);
                        }
                        # Check if there's an assignment prefix: my $var = eval { ... } ? ...
                        my array @tern_asgn = capture($trimmed, "^(my\\s+(?:scalar\\s+)?)?(.+?)\\s*=\\s*eval\\s*\\{");
                        if (scalar(@tern_asgn) > 2 && length(trim_str($tern_asgn[2])) > 0) {
                            my str $tern_decl = "";
                            if (scalar(@tern_asgn) > 1 && length(trim_str($tern_asgn[1])) > 0) {
                                $tern_decl = trim_str($tern_asgn[1]) . " ";
                            }
                            my str $tern_var = trim_str($tern_asgn[2]);
                            push(@out, $indent . "my int $_eval_ok = 0;");
                            push(@out, $indent . "try { " . $eval_body . " $_eval_ok = 1; } catch ($e) { }");
                            push(@out, $indent . $tern_decl . $tern_var . " = ($_eval_ok) ? " . $tern_true . " : " . $tern_false . ";");
                        } else {
                            push(@out, $indent . "my int $_eval_ok = 0;");
                            push(@out, $indent . "try { " . $eval_body . " $_eval_ok = 1; } catch ($e) { }");
                            push(@out, $indent . "if ($_eval_ok) { " . $tern_true . " } else { " . $tern_false . " }");
                        }
                    } else {
                        push(@out, $indent . $trimmed . "  # REVIEW: eval {} ternary â€” convert to try/catch with success flag");
                    }
                    $i++;
                    next;
                }

                # Handle "eval { ... } or do { ... }" pattern
                if (match($eval_after, "^or\\s+do\\s*\\{")) {
                    my array @ordo_cap = capture($eval_after, "^or\\s+do\\s*\\{(.*)\\}\\s*;?\\s*$");
                    if (scalar(@ordo_cap) > 1) {
                        # Remove trailing "1;" from eval body (common pattern)
                        $eval_body =~ s/\s*1\s*;\s*$//;
                        $eval_body = trim_str($eval_body);
                        my str $or_do_body = trim_str($ordo_cap[1]);
                        $or_do_body = replace_dollar_at($or_do_body);
                        push(@out, $indent . "try {");
                        if ($eval_body ne "") {
                            push(@out, $indent . "    " . $eval_body);
                        }
                        push(@out, $indent . "} catch ($e) {");
                        if ($or_do_body ne "") {
                            push(@out, $indent . "    " . $or_do_body);
                        }
                        push(@out, $indent . "}");
                        $i++;
                        next;
                    }
                }
                # Also handle "eval { ... } or die ..." pattern
                if (match($eval_after, "^or\\s+die")) {
                    my str $die_msg = $eval_after;
                    $die_msg = replace($die_msg, "^or\\s+die\\s*", "");
                    $die_msg =~ s/;\s*$//;
                    $die_msg = trim_str($die_msg);
                    # Remove trailing "1;" from eval body
                    $eval_body =~ s/\s*1\s*;\s*$//;
                    $eval_body = trim_str($eval_body);
                    push(@out, $indent . "try {");
                    if ($eval_body ne "") {
                        push(@out, $indent . "    " . $eval_body);
                    }
                    push(@out, $indent . "} catch ($e) {");
                    if ($die_msg ne "") {
                        push(@out, $indent . "    die(" . $die_msg . ");");
                    } else {
                        push(@out, $indent . "    die($e);");
                    }
                    push(@out, $indent . "}");
                    $i++;
                    next;
                }
                # Strip trailing semicolon from eval body
                $eval_body =~ s/;\s*$//;
                $eval_body = trim_str($eval_body);

                # Check next line(s) for if ($@)
                my int $peek_sl = $i + 1;
                while ($peek_sl < $num_lines && trim_str($lines[$peek_sl]) eq "") {
                    $peek_sl++;
                }
                if ($peek_sl < $num_lines && match(trim_str($lines[$peek_sl]), "^if\\s*\\(\\$@")) {
                    my str $if_line = trim_str($lines[$peek_sl]);
                    push(@out, $indent . "try {");
                    if ($eval_body ne "") {
                        push(@out, $indent . "    " . $eval_body);
                    }

                    # Check if single-line: if ($@) { body }
                    if (match($if_line, "\\{.*\\}\\s*$")) {
                        my str $cb = $if_line;
                        $cb = replace($cb, "^if\\s*\\(\\$@\\)\\s*\\{", "");
                        $cb =~ s/\}\s*$//;
                        $cb = trim_str($cb);
                        $cb = replace_dollar_at($cb);
                        push(@out, $indent . "} catch ($e) {");
                        if ($cb ne "") {
                            push(@out, $indent . "    " . $cb);
                        }
                        push(@out, $indent . "}");
                        $i = $peek_sl + 1;
                    } else {
                        # Multi-line if ($@) { ... }
                        push(@out, $indent . "} catch ($e) {");
                        $i = $peek_sl + 1;
                        my int $cd = 0;
                        my int $cli = 0;
                        my int $cll = length($if_line);
                        while ($cli < $cll) {
                            my str $cc = substr($if_line, $cli, 1);
                            if ($cc eq "{") { $cd++; }
                            if ($cc eq "}") { $cd--; }
                            $cli++;
                        }
                        while ($i < $num_lines && $cd > 0) {
                            my str $cbl = $lines[$i];
                            my str $cbt = trim_str($cbl);
                            my int $cbi = 0;
                            my int $cblen = length($cbt);
                            while ($cbi < $cblen) {
                                my str $cbc = substr($cbt, $cbi, 1);
                                if ($cbc eq "{") { $cd++; }
                                if ($cbc eq "}") { $cd--; }
                                $cbi++;
                            }
                            $cbl = replace_dollar_at($cbl);
                            push(@out, $cbl);
                            $i++;
                        }
                    }
                    next;
                }

                # Check for: my $err = $@; if ($err) { ... } pattern
                if ($peek_sl < $num_lines && match(trim_str($lines[$peek_sl]), "^my\\s+.*=\\s*\\$@")) {
                    my str $err_line = trim_str($lines[$peek_sl]);
                    # Extract error variable name
                    my array @err_cap = capture($err_line, "my\\s+\\S*\\s*\\$([A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*\\$@");
                    if (scalar(@err_cap) > 1) {
                        my str $err_var = $err_cap[1];
                        # Look for if ($err_var) on next non-empty line
                        my int $peek_if = $peek_sl + 1;
                        while ($peek_if < $num_lines && trim_str($lines[$peek_if]) eq "") {
                            $peek_if++;
                        }
                        if ($peek_if < $num_lines && match(trim_str($lines[$peek_if]), "^if\\s*\\(\\$" . $err_var . "\\b")) {
                            my str $if_line2 = trim_str($lines[$peek_if]);
                            push(@out, $indent . "try {");
                            if ($eval_body ne "") {
                                push(@out, $indent . "    " . $eval_body);
                            }
                            push(@out, $indent . "} catch ($" . $err_var . ") {");
                            # Check if single-line
                            if (match($if_line2, "\\{.*\\}\\s*$")) {
                                my str $cb2 = $if_line2;
                                $cb2 = replace($cb2, "^if\\s*\\(\\$" . $err_var . "\\)\\s*\\{", "");
                                $cb2 =~ s/\}\s*$//;
                                $cb2 = trim_str($cb2);
                                push(@out, $indent . "    " . $cb2);
                                push(@out, $indent . "}");
                                $i = $peek_if + 1;
                            } else {
                                # Multi-line if block
                                $i = $peek_if + 1;
                                my int $cd2 = 0;
                                my int $cli2 = 0;
                                my int $cll2 = length($if_line2);
                                while ($cli2 < $cll2) {
                                    my str $cc2 = substr($if_line2, $cli2, 1);
                                    if ($cc2 eq "{") { $cd2++; }
                                    if ($cc2 eq "}") { $cd2--; }
                                    $cli2++;
                                }
                                while ($i < $num_lines && $cd2 > 0) {
                                    my str $cbl2 = $lines[$i];
                                    my str $cbt2 = trim_str($cbl2);
                                    my int $cbi2 = 0;
                                    my int $cblen2 = length($cbt2);
                                    while ($cbi2 < $cblen2) {
                                        my str $cbc2 = substr($cbt2, $cbi2, 1);
                                        if ($cbc2 eq "{") { $cd2++; }
                                        if ($cbc2 eq "}") { $cd2--; }
                                        $cbi2++;
                                    }
                                    push(@out, $cbl2);
                                    $i++;
                                }
                            }
                            next;
                        }
                    }
                }

                # No if ($@) follows - just wrap in try with empty catch
                if (length($sl_assign_var) > 0) {
                    # eval-as-expression: my $x = eval { body };
                    # Emit: my scalar $x = undef; try { $x = body; } catch ($e) { }
                    if (match($sl_assign_prefix, "^my\\s+")) {
                        push(@out, $indent . "my scalar " . $sl_assign_var . " = undef;");
                    }
                    push(@out, $indent . "try {");
                    if ($eval_body ne "") {
                        push(@out, $indent . "    " . $sl_assign_var . " = " . $eval_body);
                    }
                    push(@out, $indent . "} catch ($e) {");
                    push(@out, $indent . "    # eval failed - " . $sl_assign_var . " remains undef");
                    push(@out, $indent . "}");
                } else {
                    push(@out, $indent . "try {");
                    if ($eval_body ne "") {
                        push(@out, $indent . "    " . $eval_body);
                    }
                    push(@out, $indent . "} catch ($e) {");
                    push(@out, $indent . "    # eval failed");
                    push(@out, $indent . "}");
                }
                $i++;
                next;
            }

            # Multi-line eval { ... }
            # Collect lines until closing }; at proper depth
            my array @eval_lines = ();
            my int $brace_depth = 0;
            my int $is_assignment = 0;
            my str $assign_var = "";

            # Check for $result = eval { pattern
            my str $ml_assign_prefix = "";
            if (match($trimmed, "=\\s*eval\\s*\\{")) {
                $is_assignment = 1;
                my array @acap = capture($trimmed, "^((?:my\\s+(?:scalar\\s+)?)?\\$[A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*eval");
                if (scalar(@acap) > 1) {
                    $ml_assign_prefix = $acap[1];
                    my array @acap2 = capture($ml_assign_prefix, "(\\$[A-Za-z_][A-Za-z0-9_]*)$");
                    if (scalar(@acap2) > 1) {
                        $assign_var = $acap2[1];
                    }
                }
            }

            # Count braces on the eval line
            my int $ci = 0;
            my int $clen = length($trimmed);
            while ($ci < $clen) {
                my str $ch = substr($trimmed, $ci, 1);
                if ($ch eq "{") { $brace_depth++; }
                if ($ch eq "}") { $brace_depth--; }
                $ci++;
            }

            # For eval-as-expression, emit variable declaration before try
            if ($is_assignment == 1 && length($assign_var) > 0) {
                if (match($ml_assign_prefix, "^my\\s+")) {
                    push(@out, $indent . "my scalar " . $assign_var . " = undef;");
                }
            }
            push(@out, $indent . "try {");
            $i++;

            # Collect body lines
            while ($i < $num_lines && $brace_depth > 0) {
                my str $bl = $lines[$i];
                my str $bt = trim_str($bl);

                my int $bi2 = 0;
                my int $blen2 = length($bt);
                my int $eval_hit_zero = 0;
                while ($bi2 < $blen2) {
                    my str $bch = substr($bt, $bi2, 1);
                    if ($bch eq "{") { $brace_depth++; }
                    if ($bch eq "}") { $brace_depth--; }
                    if ($brace_depth == 0 && $eval_hit_zero == 0) { $eval_hit_zero = 1; }
                    $bi2++;
                }

                if ($eval_hit_zero == 1) {
                    # This is the closing }; line - don't add it
                    # But look ahead for if ($@) pattern
                    $i++;

                    # Skip blank lines between eval close and if ($@)
                    my int $peek = $i;
                    while ($peek < $num_lines && trim_str($lines[$peek]) eq "") {
                        $peek++;
                    }

                    # Check for "} or do {" on the closing brace line itself
                    if (match($bt, "\\}\\s+or\\s+do\\s*\\{")) {
                        push(@out, $indent . "} catch ($e) {");
                        # The close brace line had "} or do {" - the do block is now open at depth 1
                        my int $do_depth = 1;
                        while ($i < $num_lines && $do_depth > 0) {
                            my str $dbl = $lines[$i];
                            my str $dbt = trim_str($dbl);
                            my int $dbi = 0;
                            my int $dblen = length($dbt);
                            while ($dbi < $dblen) {
                                my str $dbc = substr($dbt, $dbi, 1);
                                if ($dbc eq "{") { $do_depth++; }
                                if ($dbc eq "}") { $do_depth--; }
                                $dbi++;
                            }
                            if ($do_depth > 0) {
                                $dbl = replace_dollar_at($dbl);
                                push(@out, $dbl);
                            }
                            $i++;
                        }
                        push(@out, $indent . "}");
                        $brace_depth = 0;
                        next;
                    }
                    # Check for "or die" on the closing brace line
                    if (match($bt, "\\}\\s+or\\s+die")) {
                        my array @mldie = capture($bt, "\\}\\s+or\\s+die\\s*(.*)$");
                        my str $die_arg = "";
                        if (scalar(@mldie) > 1) { $die_arg = trim_str($mldie[1]); }
                        $die_arg =~ s/;\s*$//;
                        $die_arg = replace_dollar_at($die_arg);
                        push(@out, $indent . "} catch ($e) {");
                        if (length($die_arg) > 0) {
                            push(@out, $indent . "    die(" . $die_arg . ");");
                        } else {
                            push(@out, $indent . "    die($e);");
                        }
                        push(@out, $indent . "}");
                        $brace_depth = 0;
                        next;
                    }
                    if ($peek < $num_lines && match(trim_str($lines[$peek]), "^or\\s+do\\s*\\{")) {
                        # "or do {" on next line after eval close
                        push(@out, $indent . "} catch ($e) {");
                        $i = $peek + 1;
                        my int $ordo_depth = 1;
                        while ($i < $num_lines && $ordo_depth > 0) {
                            my str $odl = $lines[$i];
                            my str $odt = trim_str($odl);
                            my int $odi = 0;
                            my int $odlen = length($odt);
                            while ($odi < $odlen) {
                                my str $odc = substr($odt, $odi, 1);
                                if ($odc eq "{") { $ordo_depth++; }
                                if ($odc eq "}") { $ordo_depth--; }
                                $odi++;
                            }
                            if ($ordo_depth > 0) {
                                $odl = replace_dollar_at($odl);
                                push(@out, $odl);
                            }
                            $i++;
                        }
                        push(@out, $indent . "}");
                        next;
                    }
                    if ($peek < $num_lines && match(trim_str($lines[$peek]), "^or\\s+die")) {
                        my str $ordie_line = trim_str($lines[$peek]);
                        my array @mldie2 = capture($ordie_line, "^or\\s+die\\s*(.*)$");
                        my str $die_a2 = "";
                        if (scalar(@mldie2) > 1) { $die_a2 = trim_str($mldie2[1]); }
                        $die_a2 =~ s/;\s*$//;
                        $die_a2 = replace_dollar_at($die_a2);
                        push(@out, $indent . "} catch ($e) {");
                        if (length($die_a2) > 0) {
                            push(@out, $indent . "    die(" . $die_a2 . ");");
                        } else {
                            push(@out, $indent . "    die($e);");
                        }
                        push(@out, $indent . "}");
                        $i = $peek + 1;
                        next;
                    }
                    if ($peek < $num_lines && match(trim_str($lines[$peek]), "^if\\s*\\(\\$@")) {
                        # Found if ($@) - start catch block
                        my str $catch_trimmed = trim_str($lines[$peek]);

                        # Extract body or just emit the catch header
                        if (match($catch_trimmed, "\\{.*\\}")) {
                            # Single-line if ($@) { ... }
                            my str $catch_body = $catch_trimmed;
                            $catch_body =~ s/^if\s*\(\$@\)\s*\{//;
                            $catch_body =~ s/\}\s*$//;
                            $catch_body = trim_str($catch_body);
                            push(@out, $indent . "} catch ($e) {");
                            # Replace $@ references with $e in the body
                            $catch_body = replace_dollar_at($catch_body);
                            push(@out, $indent . "    " . $catch_body);
                            push(@out, $indent . "}");
                            $i = $peek + 1;
                        } else {
                            # Multi-line catch block
                            push(@out, $indent . "} catch ($e) {  # was: if ($@)");
                            $i = $peek + 1;

                            # Collect catch body
                            my int $catch_depth = 0;
                            my int $ci2 = 0;
                            my int $ct_len = length($catch_trimmed);
                            while ($ci2 < $ct_len) {
                                my str $cch = substr($catch_trimmed, $ci2, 1);
                                if ($cch eq "{") { $catch_depth++; }
                                if ($cch eq "}") { $catch_depth--; }
                                $ci2++;
                            }

                            while ($i < $num_lines && $catch_depth > 0) {
                                my str $cl = $lines[$i];
                                my str $ct2 = trim_str($cl);

                                my int $ci3 = 0;
                                my int $ct2_len = length($ct2);
                                while ($ci3 < $ct2_len) {
                                    my str $cch2 = substr($ct2, $ci3, 1);
                                    if ($cch2 eq "{") { $catch_depth++; }
                                    if ($cch2 eq "}") { $catch_depth--; }
                                    $ci3++;
                                }

                                # Replace $@ with $e in catch body
                                $cl = replace_dollar_at($cl);
                                push(@out, $cl);
                                $i++;
                            }
                        }
                    } else {
                        # No if ($@) - add empty catch
                        push(@out, $indent . "} catch ($e) {");
                        if ($is_assignment == 1 && length($assign_var) > 0) {
                            push(@out, $indent . "    # eval failed - " . $assign_var . " remains undef");
                        } else {
                            push(@out, $indent . "    # eval error in $e");
                        }
                        push(@out, $indent . "}");
                    }
                } else {
                    push(@out, $bl);
                    $i++;
                }
            }
            next;
        }

        push(@out, $line);
        $i++;
    }

    # Post-process: inside catch ($e) { } blocks, replace bare $_ with $e
    # This handles Try::Tiny style where $_ is the exception variable
    my array @out2 = ();
    my int $in_catch = 0;
    my int $catch_depth = 0;
    my str $catch_var = "$" . "e";
    my int $j = 0;
    my int $out_len = scalar(@out);
    while ($j < $out_len) {
        my str $oline = $out[$j];
        my str $otrim = trim_str($oline);
        if (match($otrim, "catch\\s*\\(\\$[A-Za-z_][A-Za-z0-9_]*\\)\\s*\\{") || match($otrim, "\\}\\s*catch\\s*\\{") || match($otrim, "^\\s*catch\\s*\\{")) {
            # Extract catch variable name if present
            if (match($otrim, "catch\\s*\\(\\$[A-Za-z_]")) {
                my array @cv_cap = capture($otrim, "catch\\s*\\(\\$([A-Za-z_][A-Za-z0-9_]*)\\)\\s*\\{");
                if (scalar(@cv_cap) > 1) {
                    $catch_var = "$" . $cv_cap[1];
                }
            } else {
                # Try::Tiny bare catch { } - will use $e
                $catch_var = "$" . "e";
            }
            $in_catch = 1;
            $catch_depth = 1;
            push(@out2, $oline);
            $j++;
            next;
        }
        if ($in_catch == 1) {
            my int $ck = 0;
            my int $olen = length($otrim);
            while ($ck < $olen) {
                my str $och = substr($otrim, $ck, 1);
                if ($och eq "{") { $catch_depth++; }
                if ($och eq "}") { $catch_depth--; }
                $ck++;
            }
            if ($catch_depth <= 0) {
                $in_catch = 0;
            } else {
                # Replace bare $_ with catch var (but not $_[0], $_{key}, $_->)
                my str $dol_us = "$" . "_";
                if (index($oline, $dol_us) >= 0) {
                    # Check it's bare $_ (not $_[, $_{, $_->)
                    my int $dpos = index($oline, $dol_us);
                    while ($dpos >= 0) {
                        my int $after_pos = $dpos + 2;
                        my int $is_bare = 1;
                        if ($after_pos < length($oline)) {
                            my str $next_ch = substr($oline, $after_pos, 1);
                            if ($next_ch eq "[" || $next_ch eq "{" || $next_ch eq "-") {
                                $is_bare = 0;
                            }
                            if (match($next_ch, "[A-Za-z0-9_]")) {
                                $is_bare = 0;
                            }
                        }
                        if ($is_bare == 1) {
                            $oline = substr($oline, 0, $dpos) . $catch_var . substr($oline, $after_pos, length($oline) - $after_pos);
                            $dpos = index($oline, $dol_us, $dpos + length($catch_var));
                        } else {
                            $dpos = index($oline, $dol_us, $dpos + 2);
                        }
                    }
                }
            }
        }
        push(@out2, $oline);
        $j++;
    }

    return @out2;
}

# ============================================================
# Pass 2c: Remove POD blocks and handle DESTROY/AUTOLOAD/SUPER
# ============================================================

func pass2c_pod_and_special(array @lines) array {
    my array @out = ();
    my int $i = 0;
    my int $num_lines = scalar(@lines);
    my int $in_pod = 0;
    my str $current_pkg = "main";
    my hash %parent_map = ();

    # Pre-scan for inheritance declarations to resolve SUPER::
    my int $ps = 0;
    my str $ps_pkg = "main";
    while ($ps < $num_lines) {
        my str $ps_line = trim_str($lines[$ps]);
        if (match($ps_line, "^package\\s+")) {
            my array @ps_cap = capture($ps_line, "^package\\s+([A-Za-z_:][A-Za-z0-9_:]*)");
            if (scalar(@ps_cap) > 1) {
                $ps_pkg = $ps_cap[1];
            }
        }
        # extends Parent;
        if (match($ps_line, "^extends\\s+")) {
            my array @ps_ext = capture($ps_line, "^extends\\s+([A-Za-z_:][A-Za-z0-9_:]*)");
            if (scalar(@ps_ext) > 1) {
                $parent_map{$ps_pkg} = $ps_ext[1];
            }
        }
        # use parent 'Parent' / use parent "Parent" / use parent -norequire, 'Parent'
        if (match($ps_line, "^use\\s+parent\\b") || match($ps_line, "^use\\s+base\\b")) {
            my array @ps_par = capture($ps_line, "['\"]([A-Za-z_:][A-Za-z0-9_:]*)['\"]");
            if (scalar(@ps_par) > 1) {
                my str $ps_parent = $ps_par[1];
                if ($ps_parent ne "Exporter") {
                    $parent_map{$ps_pkg} = $ps_parent;
                }
            }
        }
        # @ISA = ('Parent') or @ISA = ("Parent")
        if (match($ps_line, "@ISA") && match($ps_line, "=")) {
            my array @ps_isa = capture($ps_line, "['\"]([A-Za-z_:][A-Za-z0-9_:]*)['\"]");
            if (scalar(@ps_isa) > 1) {
                my str $ps_parent = $ps_isa[1];
                if ($ps_parent ne "Exporter") {
                    $parent_map{$ps_pkg} = $ps_parent;
                }
            }
        }
        $ps++;
    }

    while ($i < $num_lines) {
        my str $line = $lines[$i];
        my str $trimmed = trim_str($line);
        my str $indent = get_indent($line);

        # Track current package
        if (match($trimmed, "^package\\s+")) {
            my array @pkg_cap = capture($trimmed, "^package\\s+([A-Za-z_:][A-Za-z0-9_:]*)");
            if (scalar(@pkg_cap) > 1) {
                $current_pkg = $pkg_cap[1];
            }
        }

        # Detect POD start: =pod, =head1, =head2, =over, =item, =begin, =for, =encoding
        if (match($trimmed, "^=(pod|head[1-4]|over|item|begin|for|encoding)\\b")) {
            $in_pod = 1;
            push(@out, $indent . "# " . $trimmed . "  # POD documentation");
            $i++;
            next;
        }

        # Detect POD end: =cut
        if ($trimmed eq "=cut") {
            $in_pod = 0;
            push(@out, $indent . "# " . $trimmed);
            $i++;
            next;
        }

        if ($in_pod == 1) {
            # Comment out POD content
            if ($trimmed eq "") {
                push(@out, "");
            } else {
                push(@out, $indent . "# " . $trimmed);
            }
            $i++;
            next;
        }

        # Detect DESTROY sub - Strada supports DESTROY (called when refcount reaches 0)
        # Just pass through - the normal subâ†’func conversion will handle it
        # sub DESTROY { ... } â†’ func DESTROY(scalar $self) void { ... }
        if (match($trimmed, "^sub\\s+DESTROY\\b")) {
            # Don't add the misleading TODO comment - Strada fully supports DESTROY
            push(@out, $line);
            $i++;
            next;
        }

        # Detect BUILDARGS sub - convert to around "new" hook
        if (match($trimmed, "^sub\\s+BUILDARGS\\b") || match($trimmed, "^func\\s+BUILDARGS\\b")) {
            push(@out, $indent . "around \"new\" func(scalar $self, scalar $orig, scalar ...@args) scalar {");
            push(@out, $indent . "    # REVIEW: BUILDARGS â€” verify argument transformation");
            $i++;
            # Consume and transform the function body
            my int $ba_depth = 1;
            while ($i < $num_lines && $ba_depth > 0) {
                my str $ba_l = $lines[$i];
                my str $ba_t = trim_str($ba_l);
                my str $ba_i = get_indent($ba_l);
                # Track braces
                my int $ba_j = 0;
                my int $ba_len = length($ba_t);
                while ($ba_j < $ba_len) {
                    my int $ba_ch = char_at($ba_t, $ba_j);
                    if ($ba_ch == 123) { $ba_depth++; }
                    if ($ba_ch == 125) { $ba_depth--; }
                    $ba_j++;
                }
                if ($ba_depth == 0) {
                    push(@out, $ba_i . "}");
                    $i++;
                    next;
                }
                # Skip Perl boilerplate: my ($class, ...) = @_;  my $class = shift;
                if (match($ba_t, "^my.*class.*@_") || match($ba_t, "^my.*class.*shift") || match($ba_t, "^my.*self.*@_") || match($ba_t, "^my.*self.*shift")) {
                    $i++;
                    next;
                }
                # Convert $class->SUPER::new(%args) -> $orig->(%args)
                if (match($ba_l, "SUPER::new")) {
                    $ba_l = replace($ba_l, "\\$[A-Za-z_][A-Za-z0-9_]*->SUPER::new\\(", "$orig->(");
                }
                # Replace @_ with @args
                if (match($ba_l, "@_")) {
                    $ba_l = replace_all($ba_l, "@_", "@args");
                }
                push(@out, $ba_l);
                $i++;
            }
            next;
        }

        # Detect BUILD sub - convert to after "new" hook
        if (match($trimmed, "^sub\\s+BUILD\\b") || match($trimmed, "^func\\s+BUILD\\b")) {
            push(@out, $indent . "after \"new\" func(scalar $self) void {");
            $i++;
            # Consume and transform the function body
            my int $bd_depth = 1;
            while ($i < $num_lines && $bd_depth > 0) {
                my str $bd_l = $lines[$i];
                my str $bd_t = trim_str($bd_l);
                my str $bd_i = get_indent($bd_l);
                # Track braces
                my int $bd_j = 0;
                my int $bd_len = length($bd_t);
                while ($bd_j < $bd_len) {
                    my int $bd_ch = char_at($bd_t, $bd_j);
                    if ($bd_ch == 123) { $bd_depth++; }
                    if ($bd_ch == 125) { $bd_depth--; }
                    $bd_j++;
                }
                if ($bd_depth == 0) {
                    push(@out, $bd_i . "}");
                    $i++;
                    next;
                }
                # Skip Perl boilerplate: my ($self) = @_;  my $self = shift;
                if (match($bd_t, "^my.*self.*@_") || match($bd_t, "^my.*self.*shift")) {
                    $i++;
                    next;
                }
                push(@out, $bd_l);
                $i++;
            }
            next;
        }

        # Detect INIT/CHECK/UNITCHECK blocks -> convert to BEGIN
        if (match($trimmed, "^INIT\\s*\\{") || match($trimmed, "^CHECK\\s*\\{") || match($trimmed, "^UNITCHECK\\s*\\{")) {
            # Determine block type for comment
            my str $ic_type = "INIT";
            if (match($trimmed, "^CHECK")) { $ic_type = "CHECK"; }
            if (match($trimmed, "^UNITCHECK")) { $ic_type = "UNITCHECK"; }
            # Replace block name with BEGIN
            my str $ic_converted = replace($trimmed, "^(INIT|CHECK|UNITCHECK)", "BEGIN");
            push(@out, $indent . $ic_converted . "  # was " . $ic_type);
            # Consume the block body (pass through unchanged)
            my int $ic_depth = 0;
            my int $ici = 0;
            my int $iclen = length($trimmed);
            while ($ici < $iclen) {
                my int $icch = char_at($trimmed, $ici);
                if ($icch == 123) { $ic_depth++; }
                if ($icch == 125) { $ic_depth--; }
                $ici++;
            }
            $i++;
            while ($i < $num_lines && $ic_depth > 0) {
                my str $icline = $lines[$i];
                my str $ict = trim_str($icline);
                my int $icj = 0;
                my int $ictlen = length($ict);
                while ($icj < $ictlen) {
                    my int $icch2 = char_at($ict, $icj);
                    if ($icch2 == 123) { $ic_depth++; }
                    if ($icch2 == 125) { $ic_depth--; }
                    $icj++;
                }
                push(@out, $icline);
                $i++;
            }
            next;
        }

        # Detect AUTOLOAD sub - convert to Strada AUTOLOAD
        if (match($trimmed, "^sub\\s+AUTOLOAD\\b") || match($trimmed, "^func\\s+AUTOLOAD\\b")) {
            # Emit the Strada-native AUTOLOAD signature
            push(@out, $indent . "func AUTOLOAD(scalar $self, str $method, scalar ...@args) scalar {");
            $i++;

            # Consume and transform the function body
            my int $brace_depth = 1;
            while ($i < $num_lines && $brace_depth > 0) {
                my str $bl = $lines[$i];
                my str $bt = trim_str($bl);
                my str $bi = get_indent($bl);

                # Track braces
                my int $bj = 0;
                my int $blen = length($bt);
                while ($bj < $blen) {
                    my int $bch = char_at($bt, $bj);
                    if ($bch == 123) { $brace_depth++; }
                    if ($bch == 125) { $brace_depth--; }
                    $bj++;
                }

                if ($brace_depth == 0) {
                    # Closing brace of the function
                    push(@out, $bl);
                    $i++;
                    next;
                }

                # Skip Perl AUTOLOAD boilerplate lines:
                # - my ($self) = @_;  or  my $self = shift;
                if (match($bt, "^my.*self.*@_") || match($bt, "^my.*self.*shift")) {
                    $i++;
                    next;
                }
                # - our $AUTOLOAD;
                if (match($bt, "^our.*AUTOLOAD")) {
                    $i++;
                    next;
                }
                # - my $method = $AUTOLOAD;  or  (my $method = $AUTOLOAD)
                if (match($bt, "method.*=.*AUTOLOAD")) {
                    $i++;
                    next;
                }
                # - $method =~ s/.*:://;  (strip package prefix - not needed in Strada)
                if (match($bt, "method.*=~.*s/\\.\\*:://")) {
                    $i++;
                    next;
                }
                # - return if $method eq 'DESTROY';  or  return if $method =~ /DESTROY/
                if (match($bt, "return.*method.*DESTROY")) {
                    $i++;
                    next;
                }

                # Replace @_ with @args in remaining lines
                if (match($bl, "@_")) {
                    $bl = replace_all($bl, "@_", "@args");
                }

                # Convert $self->$method(@args) dynamic dispatch within AUTOLOAD
                # In Strada's AUTOLOAD, $method is already a parameter, so this dispatch
                # is handled natively by the AUTOLOAD mechanism itself
                if (match($bt, "->\\$method") || match($bt, "->\\$AUTOLOAD")) {
                    # $self->$method(@args) is the dispatch line â€” Strada AUTOLOAD handles this
                    $bl = $bi . "# " . $bt . "  # Strada AUTOLOAD dispatches automatically via $method parameter";
                }

                push(@out, $bl);
                $i++;
            }
            next;
        }

        # Detect SUPER:: calls - convert to parent package call
        if (match($line, "SUPER::")) {
            # Check if we know the parent class for the current package
            my str $parent_class = "" . $parent_map{$current_pkg};
            if (length($parent_class) > 0) {
                # Handle $self->SUPER::method(args) -> Parent::method($self, args)
                if (match($line, "\\$[A-Za-z_][A-Za-z0-9_]*->SUPER::")) {
                    my array @sup_cap = capture($line, "(\\$[A-Za-z_][A-Za-z0-9_]*)->SUPER::([A-Za-z_][A-Za-z0-9_]*)\\(([^)]*)\\)");
                    if (scalar(@sup_cap) > 3) {
                        my str $sup_self = $sup_cap[1];
                        my str $sup_method = $sup_cap[2];
                        my str $sup_args = trim_str($sup_cap[3]);
                        if (length($sup_args) > 0) {
                            $line = replace($line, "\\$[A-Za-z_][A-Za-z0-9_]*->SUPER::" . $sup_method . "\\([^)]*\\)", $parent_class . "::" . $sup_method . "(" . $sup_self . ", " . $sup_args . ")");
                        } else {
                            $line = replace($line, "\\$[A-Za-z_][A-Za-z0-9_]*->SUPER::" . $sup_method . "\\([^)]*\\)", $parent_class . "::" . $sup_method . "(" . $sup_self . ")");
                        }
                    } else {
                        # Simpler pattern: just replace SUPER:: with parent class
                        $line = replace_all($line, "SUPER::", $parent_class . "::");
                    }
                } else {
                    # Non-method SUPER:: call: SUPER::func(...) -> Parent::func($self, ...)
                    # Add $self as first arg if inside a method body
                    my array @sup_bare = capture($line, "SUPER::([A-Za-z_][A-Za-z0-9_]*)\\(([^)]*)\\)");
                    if (scalar(@sup_bare) > 2) {
                        my str $sb_method = $sup_bare[1];
                        my str $sb_args = trim_str($sup_bare[2]);
                        my str $sb_self = "$" . "self";
                        if (length($sb_args) > 0) {
                            $line = replace($line, "SUPER::" . $sb_method . "\\([^)]*\\)", $parent_class . "::" . $sb_method . "(" . $sb_self . ", " . $sb_args . ")");
                        } else {
                            $line = replace($line, "SUPER::" . $sb_method . "\\([^)]*\\)", $parent_class . "::" . $sb_method . "(" . $sb_self . ")");
                        }
                    } else {
                        $line = replace_all($line, "SUPER::", $parent_class . "::");
                    }
                }
            } else {
                # Parent unknown - use SUPER_ placeholder with REVIEW
                $line = replace_all($line, "SUPER::", "SUPER_");
                $line = $line . "  # REVIEW: SUPER:: â€” call parent method directly (e.g., Parent::method($self, ...))";
            }
        }

        # Detect heredocs: <<EOF, <<"EOF", <<'EOF', <<~EOF, <<\EOF
        if (match($trimmed, "<<[~\\\\]?\\s*['\"]?[A-Za-z_][A-Za-z0-9_]*['\"]?") && !match($trimmed, "^#")) {
            # Extract the terminator
            my array @hd_cap = capture($trimmed, "<<[~\\\\]?\\s*['\"]?([A-Za-z_][A-Za-z0-9_]*)['\"]?");
            if (scalar(@hd_cap) > 1) {
                my str $hd_term = $hd_cap[1];
                my int $hd_indented = 0;
                if (match($trimmed, "<<~")) {
                    $hd_indented = 1;
                }
                my int $hd_interp = 1;
                # <<'EOF' or <<\EOF = non-interpolating
                if (match($trimmed, "<<[~]?\\s*'") || match($trimmed, "<<\\\\")) {
                    $hd_interp = 0;
                }

                # Get the trailing part after <<TERM (e.g., ". $suffix;" or ",")
                my str $hd_suffix = "";
                my int $hd_marker_pos = index($trimmed, "<<");
                if ($hd_marker_pos >= 0) {
                    # Find end of heredoc marker (after terminator and optional quotes/semicolons)
                    my int $hd_after = $hd_marker_pos + 2;
                    # Skip ~, \, whitespace
                    while ($hd_after < length($trimmed) && match(substr($trimmed, $hd_after, 1), "[~\\\\\\s]")) {
                        $hd_after++;
                    }
                    # Skip quotes and terminator
                    if ($hd_after < length($trimmed) && match(substr($trimmed, $hd_after, 1), "['\"]")) {
                        $hd_after++;
                    }
                    $hd_after = $hd_after + length($hd_term);
                    if ($hd_after < length($trimmed) && match(substr($trimmed, $hd_after, 1), "['\"]")) {
                        $hd_after++;
                    }
                    my str $hd_trail = trim_str(substr($trimmed, $hd_after, length($trimmed) - $hd_after));
                    # Remove trailing semicolon (we'll add our own)
                    if (ends_with($hd_trail, ";")) {
                        $hd_trail = substr($hd_trail, 0, length($hd_trail) - 1);
                        $hd_trail = trim_str($hd_trail);
                    }
                    # Remove leading comma if it was a function arg separator
                    if (starts_with($hd_trail, ",") || starts_with($hd_trail, ")")) {
                        $hd_suffix = $hd_trail;
                    } elsif (length($hd_trail) > 0) {
                        # Trailing expression like . " suffix" or . $var
                        $hd_suffix = " " . $hd_trail;
                    }
                }

                # Collect heredoc body lines
                my str $hd_body = "";
                $i++;
                while ($i < $num_lines) {
                    my str $hd_line = $lines[$i];
                    my str $hd_trimmed = trim_str($hd_line);
                    if ($hd_trimmed eq $hd_term) {
                        $i++;
                        last;
                    }
                    # Escape: do a single pass â€” escape backslashes and double quotes together
                    my str $hd_escaped = $hd_line;
                    if ($hd_indented == 1) {
                        $hd_escaped = trim_str($hd_escaped);
                    }
                    # Single-pass escaping: iterate character by character
                    my str $hd_esc_out = "";
                    my int $hd_ei = 0;
                    my int $hd_elen = length($hd_escaped);
                    while ($hd_ei < $hd_elen) {
                        my str $hd_ech = substr($hd_escaped, $hd_ei, 1);
                        if ($hd_ech eq "\\") {
                            $hd_esc_out = $hd_esc_out . "\\\\";
                        } elsif ($hd_ech eq "\"") {
                            $hd_esc_out = $hd_esc_out . "\\\"";
                        } else {
                            $hd_esc_out = $hd_esc_out . $hd_ech;
                        }
                        $hd_ei++;
                    }
                    $hd_escaped = $hd_esc_out;
                    if (length($hd_body) > 0) {
                        $hd_body = $hd_body . "\\n";
                    }
                    $hd_body = $hd_body . $hd_escaped;
                    $i++;
                }

                # Replace the heredoc syntax with a string literal
                my str $hd_prefix = "";
                # Get everything before <<TERM on the assignment line
                my int $hd_arrow_pos = index($trimmed, "<<");
                if ($hd_arrow_pos >= 0) {
                    $hd_prefix = substr($trimmed, 0, $hd_arrow_pos);
                }

                my str $hd_new_line = "";
                if ($hd_interp == 1 && match($hd_body, "\\$")) {
                    # Interpolating heredoc: expand $var references
                    # Body already has backslashes and double-quotes escaped from single-pass above
                    # Wrap in quotes so convert_interp_in_dquote can process it
                    my str $hd_interp_result = convert_interp_in_dquote("\"" . $hd_body . "\\n\"");
                    $hd_new_line = $indent . $hd_prefix . $hd_interp_result . $hd_suffix;
                } else {
                    # Non-interpolating heredoc or no variables: just use string literal
                    if ($hd_interp == 0) {
                        # Use single quotes to prevent Strada from interpolating $vars
                        my str $hd_sq_escaped = replace_all($hd_body, "'", "\\'");
                        $hd_new_line = $indent . $hd_prefix . "'" . $hd_sq_escaped . "\\n'" . $hd_suffix;
                    } else {
                        $hd_new_line = $indent . $hd_prefix . "\"" . $hd_body . "\\n\"" . $hd_suffix;
                    }
                }
                # Add semicolon if the original had one after the terminator
                if (!match($hd_new_line, ";\\s*$")) {
                    $hd_new_line = $hd_new_line . ";";
                }
                push(@out, $hd_new_line);
                next;
            }
        }

        # Detect Perl format blocks: format NAME = ... .
        # Convert to commented-out block with sprintf() equivalent guidance
        if (match($trimmed, "^format\\s+") && !match($trimmed, "#")) {
            # Extract format name for reference
            my array @fmt_cap = capture($trimmed, "^format\\s+(\\S+)\\s*=");
            my str $fmt_name = "STDOUT";
            if (scalar(@fmt_cap) > 1) {
                $fmt_name = $fmt_cap[1];
            }
            push(@out, $indent . "# " . $trimmed . "  # Perl format block (" . $fmt_name . ") â€” use sprintf() for formatted output");
            $i++;
            # Collect format fields to generate sprintf() hint
            my str $fmt_fields = "";
            my int $fmt_field_count = 0;
            while ($i < $num_lines) {
                my str $fmt_line = trim_str($lines[$i]);
                if ($fmt_line eq ".") {
                    push(@out, $indent . "# .  # end of format block");
                    $i++;
                    last;
                }
                push(@out, $indent . "# " . $fmt_line);
                # Count @<<< / @>>> / @||| fields (Perl format picture lines)
                if (match($fmt_line, "@[<>|#]+")) {
                    $fmt_field_count++;
                }
                $i++;
            }
            if ($fmt_field_count > 0) {
                push(@out, $indent . "# Hint: replace write() calls with: say(sprintf(\"%-20s %10s\", $field1, $field2));");
            }
            next;
        }

        push(@out, $line);
        $i++;
    }

    return @out;
}

# Pass 2d: Join continuation lines (multiline postfix if/unless, multiline statements)
# Perl allows statements like:
#   return $x
#       if $cond;
# or:
#   push @arr,
#       { key => value };
# We join these back into single lines for Pass 3 to handle correctly.
func pass2d_join_continuations(array @lines) array {
    my array @out = ();
    my int $i = 0;
    my int $num = scalar(@lines);

    while ($i < $num) {
        my str $line = $lines[$i];
        my str $trimmed = trim_str($line);

        # Join multi-line use constant { ... }; into one line
        if (match($trimmed, "^use\\s+constant\\s*\\{") && !match($trimmed, "\\}\\s*;")) {
            my str $joined = $trimmed;
            $i++;
            my int $uc_done = 0;
            while ($i < $num && $uc_done == 0) {
                my str $jt = trim_str($lines[$i]);
                $joined = $joined . " " . $jt;
                $i++;
                if (match($jt, "\\}\\s*;")) {
                    $uc_done = 1;
                }
            }
            push(@out, $joined);
            next;
        }

        # Join multi-line use constant NAME => value; (non-hashref form)
        # e.g.: use constant FOO =>\n  "bar" . "baz"\n  . "qux";
        # Skip if line ends with comment containing ; (e.g., "use constant FOO => 1; # comment")
        if (match($trimmed, "^use\\s+constant\\s+[A-Za-z_]") && !match($trimmed, ";\\s*$") && !match($trimmed, ";\\s*#")) {
            my str $joined2 = $trimmed;
            $i++;
            my int $uc2_done = 0;
            my int $uc2_safety = 0;
            while ($i < $num && $uc2_done == 0 && $uc2_safety < 50) {
                my str $jt2 = trim_str($lines[$i]);
                $joined2 = $joined2 . " " . $jt2;
                $i++;
                if (match($jt2, ";\\s*$")) {
                    $uc2_done = 1;
                }
                $uc2_safety++;
            }
            push(@out, $joined2);
            next;
        }

        # Check if next line starts with postfix if/unless/while/until/for/foreach
        if ($i + 1 < $num) {
            my str $next_trimmed = trim_str($lines[$i + 1]);

            # do { ... } while (cond); - join closing } with while
            if (match($trimmed, "\\}\\s*$") && match($next_trimmed, "^while\\s*\\(") && match($next_trimmed, ";\\s*$")) {
                # Check if this is part of a do { } while pattern
                # Look backwards for a "do {" line
                my int $bk = scalar(@out) - 1;
                my int $bd = 1;
                my int $found_do = 0;
                while ($bk >= 0 && $bd > 0) {
                    my str $bkt = trim_str($out[$bk]);
                    my int $bki = 0;
                    my int $bklen = length($bkt);
                    while ($bki < $bklen) {
                        if (substr($bkt, $bki, 1) eq "{") { $bd++; }
                        if (substr($bkt, $bki, 1) eq "}") { $bd--; }
                        $bki++;
                    }
                    if (match($bkt, "\\bdo\\s*\\{")) {
                        $found_do = 1;
                    }
                    $bk--;
                }
                if ($found_do == 1) {
                    my str $joined = $line . " " . $next_trimmed;
                    push(@out, $joined);
                    $i = $i + 2;
                    next;
                }
            }

            # Multiline postfix: statement\n    if/unless/while/until/for/foreach cond;
            if (match($next_trimmed, "^(if|unless|while|until|for|foreach)\\s+") && !match($next_trimmed, "^(if|unless|while|until|for|foreach)\\s*\\(.*\\)\\s*\\{")) {
                # Make sure current line doesn't end with ; (would mean it's a complete statement)
                if (!match($trimmed, ";\\s*$") && !match($trimmed, "\\{\\s*$") && !match($trimmed, "\\}\\s*$") && $trimmed ne "" && !starts_with($trimmed, "#")) {
                    # Join the lines
                    my str $joined = $line . " " . $next_trimmed;
                    push(@out, $joined);
                    $i = $i + 2;
                    next;
                }
            }
        }

        # use overload without semicolon: join continuation lines until closing ;
        # e.g. use overload\n    "+" => \&add,\n    "-" => \&sub;\n
        if (match($trimmed, "^use\\s+overload") && !match($trimmed, ";\\s*$")) {
            my str $joined = $line;
            $i++;
            my int $uo_safety = 0;
            while ($i < $num && $uo_safety < 50 && length($joined) <= 800) {
                my str $next = trim_str($lines[$i]);
                $joined = $joined . " " . $next;
                $i++;
                $uo_safety++;
                if (match($next, ";\\s*$") || match($next, "\\)\\s*;\\s*$")) {
                    last;
                }
            }
            push(@out, $joined);
            next;
        }

        # Multi-line qw(): detect qw( without closing delimiter on same line, join until found
        if (match($trimmed, "\\bqw\\s*[({/\\[]") && !match($trimmed, "\\bqw\\s*\\([^)]*\\)") && !match($trimmed, "\\bqw\\s*\\{[^}]*\\}") && !match($trimmed, "\\bqw\\s*\\[[^]]*\\]") && !match($trimmed, "\\bqw\\s*/[^/]*/")) {
            my str $joined = $line;
            $i++;
            my int $qw_safety = 0;
            while ($i < $num && $qw_safety < 50 && length($joined) <= 800) {
                my str $qw_next = trim_str($lines[$i]);
                $joined = $joined . " " . $qw_next;
                $i++;
                $qw_safety++;
                # Check for closing delimiter: ), }, ], /
                if (match($qw_next, "[)\\}\\]/]") || match($qw_next, ";\\s*$")) {
                    last;
                }
            }
            push(@out, $joined);
            next;
        }

        # Moose/Moo has 'attr' => ( multiline: join until closing );
        if (match($trimmed, "^has\\s+['\"][a-z_]") && !match($trimmed, "\\)\\s*;\\s*$")) {
            my str $joined = $line;
            $i++;
            my int $has_safety = 0;
            while ($i < $num && $has_safety < 50 && length($joined) <= 800) {
                my str $next = trim_str($lines[$i]);
                $joined = $joined . " " . $next;
                $i++;
                $has_safety++;
                if (match($next, "\\)\\s*;\\s*$")) {
                    last;
                }
            }
            push(@out, $joined);
            next;
        }

        # GetOptions( multiline: join until closing );
        if (match($trimmed, "\\bGetOptions\\s*\\(") && !match($trimmed, "\\)\\s*;?\\s*$")) {
            my str $joined = $line;
            $i++;
            my int $go_safety = 0;
            while ($i < $num && $go_safety < 50 && length($joined) <= 800) {
                my str $next = trim_str($lines[$i]);
                $joined = $joined . " " . $next;
                $i++;
                $go_safety++;
                if (match($next, "\\)\\s*;?\\s*$")) {
                    last;
                }
            }
            push(@out, $joined);
            next;
        }

        # Check if current line ends with a comma or operator suggesting continuation
        # e.g. push @arr,\n    value;
        if ($i + 1 < $num && match($trimmed, ",$") && !match($trimmed, ";\\s*$")) {
            my str $next_trimmed2 = trim_str($lines[$i + 1]);
            # Only join if next line doesn't start a new statement
            if (!match($next_trimmed2, "^(my|our|local|sub|func|if|unless|while|for|foreach|return|#)") && $next_trimmed2 ne "" && !starts_with($next_trimmed2, "#")) {
                # Could be multi-line, keep joining
                my str $joined = $line . " " . $next_trimmed2;
                $i = $i + 2;
                my int $join7_safety = 0;
                # Continue joining if still ends with comma
                while ($i < $num && match(trim_str($joined), ",$") && !match(trim_str($joined), ";\\s*$") && $join7_safety < 20 && length($joined) <= 500) {
                    my str $next_cont = trim_str($lines[$i]);
                    if (match($next_cont, "^(my|our|local|sub|func|if|unless|while|for|foreach|return|#)") || $next_cont eq "" || starts_with($next_cont, "#")) {
                        push(@out, $joined);
                        push(@out, $lines[$i]);
                        $i++;
                        $joined = "";
                        next;
                    }
                    $joined = $joined . " " . $next_cont;
                    $i++;
                    $join7_safety++;
                }
                if ($joined ne "") {
                    push(@out, $joined);
                }
                next;
            }
        }

        # Join method chain continuations: current line + next starts with ->
        if ($i + 1 < $num && !match($trimmed, ";\\s*$") && !match($trimmed, "\\{\\s*$") && !match($trimmed, "\\}\\s*$") && $trimmed ne "" && !starts_with($trimmed, "#")) {
            my str $next_trimmed3 = trim_str($lines[$i + 1]);
            if (starts_with($next_trimmed3, "->")) {
                my str $joined = $line . " " . $next_trimmed3;
                $i = $i + 2;
                my int $join8_safety = 0;
                # Continue joining while subsequent lines also start with ->
                while ($i < $num && $join8_safety < 20 && length($joined) <= 500) {
                    my str $more = trim_str($lines[$i]);
                    if (starts_with($more, "->")) {
                        $joined = $joined . " " . $more;
                        $i++;
                        $join8_safety++;
                    } else {
                        last;
                    }
                }
                push(@out, $joined);
                next;
            }
        }

        # Join lines ending with concatenation operator (.) but not range (..)
        if ($i + 1 < $num && match($trimmed, "\\.\\s*$") && !match($trimmed, "\\.\\.\\s*$") && !match($trimmed, ";\\s*$") && !match($trimmed, "\\{\\s*$") && !match($trimmed, "\\}\\s*$") && $trimmed ne "" && !starts_with($trimmed, "#")) {
            my str $next_trimmed4 = trim_str($lines[$i + 1]);
            if (!match($next_trimmed4, "^(my|our|local|sub|func|if|unless|while|for|foreach|return|#)") && $next_trimmed4 ne "" && !starts_with($next_trimmed4, "#")) {
                my str $joined = $line . " " . $next_trimmed4;
                $i = $i + 2;
                my int $join9_safety = 0;
                # Continue joining while the line still ends with .
                while ($i < $num && match(trim_str($joined), "\\.\\s*$") && !match(trim_str($joined), "\\.\\.\\s*$") && !match(trim_str($joined), ";\\s*$") && $join9_safety < 20 && length($joined) <= 500) {
                    my str $more_dot = trim_str($lines[$i]);
                    if (match($more_dot, "^(my|our|local|sub|func|if|unless|while|for|foreach|return|#)") || $more_dot eq "" || starts_with($more_dot, "#")) {
                        last;
                    }
                    $joined = $joined . " " . $more_dot;
                    $i++;
                    $join9_safety++;
                }
                push(@out, $joined);
                next;
            }
        }

        # Join when next line starts with . (concat), ? (ternary), : (ternary), and, or, or binary op
        if ($i + 1 < $num && !match($trimmed, ";\\s*$") && !match($trimmed, "\\{\\s*$") && !match($trimmed, "\\}\\s*$") && $trimmed ne "" && !starts_with($trimmed, "#")) {
            my str $next_trimmed6 = trim_str($lines[$i + 1]);
            if (starts_with($next_trimmed6, ". ") || starts_with($next_trimmed6, ".\"") || starts_with($next_trimmed6, ".$") || starts_with($next_trimmed6, "? ") || starts_with($next_trimmed6, ": ") || starts_with($next_trimmed6, "and ") || starts_with($next_trimmed6, "or ")) {
                my str $joined = $line . " " . $next_trimmed6;
                $i = $i + 2;
                my int $join10_safety = 0;
                # Continue joining while subsequent lines also start with these operators
                while ($i < $num && !match(trim_str($joined), ";\\s*$") && $join10_safety < 20 && length($joined) <= 500) {
                    my str $more_op = trim_str($lines[$i]);
                    if (starts_with($more_op, ". ") || starts_with($more_op, ".\"") || starts_with($more_op, ".$") || starts_with($more_op, "? ") || starts_with($more_op, ": ") || starts_with($more_op, "and ") || starts_with($more_op, "or ")) {
                        $joined = $joined . " " . $more_op;
                        $i++;
                        $join10_safety++;
                    } else {
                        last;
                    }
                }
                push(@out, $joined);
                next;
            }
        }

        # Join lines ending with binary operators (&&, ||, //, ?, :, +, -, *, /, ==, !=, =~, and, or)
        if ($i + 1 < $num && !match($trimmed, ";\\s*$") && !match($trimmed, "\\{\\s*$") && !match($trimmed, "\\}\\s*$") && $trimmed ne "" && !starts_with($trimmed, "#")) {
            if (match($trimmed, "(&&|\\|\\||//|\\?|==|!=|=~|<=|>=)\\s*$") || match($trimmed, "[+\\-\\*/:]\\s*$") || match($trimmed, "\\b(and|or)\\s*$")) {
                my str $next_trimmed5 = trim_str($lines[$i + 1]);
                if (!match($next_trimmed5, "^(my|our|local|sub|func|if|unless|while|for|foreach|return|#)") && $next_trimmed5 ne "" && !starts_with($next_trimmed5, "#")) {
                    my str $joined = $line . " " . $next_trimmed5;
                    $i = $i + 2;
                    my int $join11_safety = 0;
                    # Continue joining while line still ends with a binary operator
                    while ($i < $num && !match(trim_str($joined), ";\\s*$") && $join11_safety < 20 && length($joined) <= 500) {
                        my str $more_bin = trim_str($lines[$i]);
                        if (match(trim_str($joined), "(&&|\\|\\||//|\\?|==|!=|=~|<=|>=)\\s*$") || match(trim_str($joined), "[+\\-\\*/:]\\s*$") || match(trim_str($joined), "\\b(and|or)\\s*$")) {
                            if (!match($more_bin, "^(my|our|local|sub|func|if|unless|while|for|foreach|return|#)") && $more_bin ne "" && !starts_with($more_bin, "#")) {
                                $joined = $joined . " " . $more_bin;
                                $i++;
                                $join11_safety++;
                            } else {
                                last;
                            }
                        } else {
                            last;
                        }
                    }
                    push(@out, $joined);
                    next;
                }
            }
        }

        # ---- Multi-line paren-balanced constructs ----
        # my %hash = (...), my @arr = (...), func_call(...), my ($a, $b) = @_
        # Detect unbalanced open paren at end of line and join until balanced
        # Skip lines with tr/// or y/// â€” parens inside operands are not real parens
        if ($i + 1 < $num && !match($trimmed, ";\\s*$") && $trimmed ne "" && !starts_with($trimmed, "#") && !match($trimmed, "\\b(tr|y)\\s*/") && !match($trimmed, "=~\\s*(tr|y)\\s*[/\\{\\[\\(]")) {
            # Count parens on the current line (skip chars inside strings)
            my int $ml_opens = 0;
            my int $ml_closes = 0;
            my int $mli = 0;
            my int $ml_len = length($trimmed);
            my int $ml_in_str = 0;
            my int $ml_in_sq = 0;
            while ($mli < $ml_len) {
                my str $mlc = substr($trimmed, $mli, 1);
                if ($mlc eq "\"" && $ml_in_sq == 0 && ($mli == 0 || substr($trimmed, $mli - 1, 1) ne "\\")) { $ml_in_str = 1 - $ml_in_str; }
                if ($mlc eq "'" && $ml_in_str == 0 && ($mli == 0 || substr($trimmed, $mli - 1, 1) ne "\\")) { $ml_in_sq = 1 - $ml_in_sq; }
                if ($ml_in_str == 0 && $ml_in_sq == 0) {
                    if ($mlc eq "(") { $ml_opens++; }
                    if ($mlc eq ")") { $ml_closes++; }
                }
                $mli++;
            }
            # If more opens than closes, join lines until balanced
            if ($ml_opens > $ml_closes && $ml_opens > 0) {
                my int $ml_depth = $ml_opens - $ml_closes;
                my str $joined = $line;
                $i++;
                my int $ml_safety = 0;
                while ($i < $num && $ml_depth > 0 && $ml_safety < 50 && length($joined) <= 500) {
                    my str $ml_next = trim_str($lines[$i]);
                    $joined = $joined . " " . $ml_next;
                    # Count parens in the next line (skip chars inside strings)
                    my int $mlni = 0;
                    my int $mlnlen = length($ml_next);
                    my int $mln_in_str = 0;
                    my int $mln_in_sq = 0;
                    while ($mlni < $mlnlen) {
                        my str $mlnc = substr($ml_next, $mlni, 1);
                        if ($mlnc eq "\"" && $mln_in_sq == 0 && ($mlni == 0 || substr($ml_next, $mlni - 1, 1) ne "\\")) { $mln_in_str = 1 - $mln_in_str; }
                        if ($mlnc eq "'" && $mln_in_str == 0 && ($mlni == 0 || substr($ml_next, $mlni - 1, 1) ne "\\")) { $mln_in_sq = 1 - $mln_in_sq; }
                        if ($mln_in_str == 0 && $mln_in_sq == 0) {
                            if ($mlnc eq "(") { $ml_depth++; }
                            if ($mlnc eq ")") { $ml_depth--; }
                        }
                        $mlni++;
                    }
                    $i++;
                    $ml_safety++;
                }
                push(@out, $joined);
                next;
            }
        }

        # ---- Multi-line brace-balanced constructs (hash/array refs) ----
        # my $config = { ... }, my $list = [ ... ]
        if ($i + 1 < $num && !match($trimmed, ";\\s*$") && $trimmed ne "" && !starts_with($trimmed, "#")) {
            # Check for unbalanced square brackets (skip chars inside strings)
            my int $sq_opens = 0;
            my int $sq_closes = 0;
            my int $sqi = 0;
            my int $sq_len = length($trimmed);
            my int $sq_in_str = 0;
            my int $sq_in_sq = 0;
            while ($sqi < $sq_len) {
                my str $sqc = substr($trimmed, $sqi, 1);
                if ($sqc eq "\"" && $sq_in_sq == 0 && ($sqi == 0 || substr($trimmed, $sqi - 1, 1) ne "\\")) { $sq_in_str = 1 - $sq_in_str; }
                if ($sqc eq "'" && $sq_in_str == 0 && ($sqi == 0 || substr($trimmed, $sqi - 1, 1) ne "\\")) { $sq_in_sq = 1 - $sq_in_sq; }
                if ($sq_in_str == 0 && $sq_in_sq == 0) {
                    if ($sqc eq "[") { $sq_opens++; }
                    if ($sqc eq "]") { $sq_closes++; }
                }
                $sqi++;
            }
            if ($sq_opens > $sq_closes && $sq_opens > 0 && match($trimmed, "=\\s*\\[")) {
                my int $sq_depth = $sq_opens - $sq_closes;
                my str $joined = $line;
                $i++;
                my int $sq_safety = 0;
                while ($i < $num && $sq_depth > 0 && $sq_safety < 50 && length($joined) <= 500) {
                    my str $sq_next = trim_str($lines[$i]);
                    $joined = $joined . " " . $sq_next;
                    my int $sqni = 0;
                    my int $sqnlen = length($sq_next);
                    my int $sqn_in_str = 0;
                    my int $sqn_in_sq = 0;
                    while ($sqni < $sqnlen) {
                        my str $sqnc = substr($sq_next, $sqni, 1);
                        if ($sqnc eq "\"" && $sqn_in_sq == 0 && ($sqni == 0 || substr($sq_next, $sqni - 1, 1) ne "\\")) { $sqn_in_str = 1 - $sqn_in_str; }
                        if ($sqnc eq "'" && $sqn_in_str == 0 && ($sqni == 0 || substr($sq_next, $sqni - 1, 1) ne "\\")) { $sqn_in_sq = 1 - $sqn_in_sq; }
                        if ($sqn_in_str == 0 && $sqn_in_sq == 0) {
                            if ($sqnc eq "[") { $sq_depth++; }
                            if ($sqnc eq "]") { $sq_depth--; }
                        }
                        $sqni++;
                    }
                    $i++;
                    $sq_safety++;
                }
                push(@out, $joined);
                next;
            }

            # Check for unbalanced curly braces in hash ref assignments: my $x = { ... }
            if (match($trimmed, "=\\s*\\{") && !match($trimmed, "\\}") && !match($trimmed, "\\bsub\\s") && !match($trimmed, "\\bfunc\\s") && !match($trimmed, "\\bif\\s") && !match($trimmed, "\\bwhile\\s") && !match($trimmed, "\\bfor\\s") && !match($trimmed, "\\bforeach\\s")) {
                my int $br_opens = 0;
                my int $br_closes = 0;
                my int $bri = 0;
                my int $br_len = length($trimmed);
                my int $br_in_str = 0;
                my int $br_in_sq = 0;
                while ($bri < $br_len) {
                    my str $brc = substr($trimmed, $bri, 1);
                    if ($brc eq "\"" && $br_in_sq == 0 && ($bri == 0 || substr($trimmed, $bri - 1, 1) ne "\\")) { $br_in_str = 1 - $br_in_str; }
                    if ($brc eq "'" && $br_in_str == 0 && ($bri == 0 || substr($trimmed, $bri - 1, 1) ne "\\")) { $br_in_sq = 1 - $br_in_sq; }
                    if ($br_in_str == 0 && $br_in_sq == 0) {
                        if ($brc eq "{") { $br_opens++; }
                        if ($brc eq "}") { $br_closes++; }
                    }
                    $bri++;
                }
                if ($br_opens > $br_closes) {
                    my int $br_depth = $br_opens - $br_closes;
                    my str $joined = $line;
                    $i++;
                    my int $br_safety = 0;
                    while ($i < $num && $br_depth > 0 && $br_safety < 50 && length($joined) <= 500) {
                        my str $br_next = trim_str($lines[$i]);
                        $joined = $joined . " " . $br_next;
                        my int $brni = 0;
                        my int $brnlen = length($br_next);
                        my int $brn_in_str = 0;
                        my int $brn_in_sq = 0;
                        while ($brni < $brnlen) {
                            my str $brnc = substr($br_next, $brni, 1);
                            if ($brnc eq "\"" && $brn_in_sq == 0 && ($brni == 0 || substr($br_next, $brni - 1, 1) ne "\\")) { $brn_in_str = 1 - $brn_in_str; }
                            if ($brnc eq "'" && $brn_in_str == 0 && ($brni == 0 || substr($br_next, $brni - 1, 1) ne "\\")) { $brn_in_sq = 1 - $brn_in_sq; }
                            if ($brn_in_str == 0 && $brn_in_sq == 0) {
                                if ($brnc eq "{") { $br_depth++; }
                                if ($brnc eq "}") { $br_depth--; }
                            }
                            $brni++;
                        }
                        $i++;
                        $br_safety++;
                    }
                    push(@out, $joined);
                    next;
                }
            }
        }

        push(@out, $line);
        $i++;
    }

    return @out;
}

# ============================================================
# Pass 3: Line-by-line syntax conversion
# ============================================================

# Convert Perl string interpolation to Strada concatenation
# "Hello $name, you are $age years old" -> "Hello " . $name . ", you are " . $age . " years old"
func convert_interpolation(str $s) str {
    # Only process double-quoted strings
    # Find double-quoted regions and convert variables within them
    my str $result = "";
    my int $i = 0;
    my int $len = length($s);
    my int $in_dquote = 0;
    my str $current = "";

    while ($i < $len) {
        my str $c = substr($s, $i, 1);

        if ($c eq "\\" && $i + 1 < $len) {
            # Escaped character - pass through
            $current = $current . $c . substr($s, $i + 1, 1);
            $i = $i + 2;
            next;
        }

        if ($c eq "\"" && $in_dquote == 0) {
            $result = $result . $current;
            $current = "\"";
            $in_dquote = 1;
            $i++;
            next;
        }

        if ($c eq "\"" && $in_dquote == 1) {
            $current = $current . "\"";
            # Now process the quoted string for interpolation
            my str $processed = convert_interp_in_dquote($current);
            $result = $result . $processed;
            $current = "";
            $in_dquote = 0;
            $i++;
            next;
        }

        $current = $current . $c;
        $i++;
    }

    $result = $result . $current;
    return $result;
}

# Process interpolation within a double-quoted string (including the quotes)
func convert_interp_in_dquote(str $quoted) str {
    # Strip quotes
    my int $len = length($quoted);
    if ($len < 2) { return $quoted; }
    my str $inner = substr($quoted, 1, $len - 2);

    # Check if there are any variables to interpolate
    if (!match($inner, "\\$[A-Za-z_0-9{]") && !match($inner, "@[A-Za-z_{]")) {
        return $quoted;
    }

    # Build concatenation expression
    my array @parts = ();
    my str $text = "";
    my int $i = 0;
    my int $ilen = length($inner);

    while ($i < $ilen) {
        my str $c = substr($inner, $i, 1);

        if ($c eq "\\" && $i + 1 < $ilen) {
            $text = $text . $c . substr($inner, $i + 1, 1);
            $i = $i + 2;
            next;
        }

        # Variable interpolation: $name or $hash{key} or $ref->{key}
        if ($c eq "$" && $i + 1 < $ilen && is_word_char(substr($inner, $i + 1, 1))) {
            # Flush accumulated text
            if ($text ne "") {
                push(@parts, "\"" . $text . "\"");
                $text = "";
            }
            # Extract variable name
            my str $var = "$";
            $i++;
            while ($i < $ilen && is_word_char(substr($inner, $i, 1))) {
                $var = $var . substr($inner, $i, 1);
                $i++;
            }
            # Check for array access: $var[idx]
            if ($i < $ilen && substr($inner, $i, 1) eq "[") {
                my str $idx_str = "";
                $i++;  # skip [
                while ($i < $ilen && substr($inner, $i, 1) ne "]") {
                    $idx_str = $idx_str . substr($inner, $i, 1);
                    $i++;
                }
                if ($i < $ilen) { $i++; }  # skip ]
                push(@parts, $var . "[" . $idx_str . "]");
            }
            # Check for hash access: $var{key}
            elsif ($i < $ilen && substr($inner, $i, 1) eq "{") {
                my str $key = "";
                $i++;  # skip {
                while ($i < $ilen && substr($inner, $i, 1) ne "}") {
                    $key = $key . substr($inner, $i, 1);
                    $i++;
                }
                if ($i < $ilen) { $i++; }  # skip }
                push(@parts, $var . "{" . quote_bare_key($key) . "}");
            }
            # Check for arrow access: $var->{key} or $var->[idx] (with chaining)
            elsif ($i + 1 < $ilen && substr($inner, $i, 1) eq "-" && substr($inner, $i + 1, 1) eq ">") {
                my str $chain = $var;
                # Loop to handle chained access: $var->{a}->{b}->[0]
                while ($i + 1 < $ilen && substr($inner, $i, 1) eq "-" && substr($inner, $i + 1, 1) eq ">") {
                    $i = $i + 2;  # skip ->
                    if ($i < $ilen && substr($inner, $i, 1) eq "{") {
                        my str $key = "";
                        $i++;
                        while ($i < $ilen && substr($inner, $i, 1) ne "}") {
                            $key = $key . substr($inner, $i, 1);
                            $i++;
                        }
                        if ($i < $ilen) { $i++; }
                        $chain = $chain . "->{" . quote_bare_key($key) . "}";
                    }
                    elsif ($i < $ilen && substr($inner, $i, 1) eq "[") {
                        my str $aidx = "";
                        $i++;
                        while ($i < $ilen && substr($inner, $i, 1) ne "]") {
                            $aidx = $aidx . substr($inner, $i, 1);
                            $i++;
                        }
                        if ($i < $ilen) { $i++; }
                        $chain = $chain . "->[" . $aidx . "]";
                    } else {
                        last;
                    }
                }
                push(@parts, $chain);
            } else {
                push(@parts, $var);
            }
            next;
        }

        # @{[expr]} interpolation: evaluate expression inline
        if ($c eq "@" && $i + 1 < $ilen && substr($inner, $i + 1, 1) eq "{" && $i + 2 < $ilen && substr($inner, $i + 2, 1) eq "[") {
            # Flush accumulated text
            if ($text ne "") {
                push(@parts, "\"" . $text . "\"");
                $text = "";
            }
            # Skip @{[
            $i = $i + 3;
            my str $expr = "";
            my int $bracket_d = 1;
            while ($i < $ilen && $bracket_d > 0) {
                my str $ec = substr($inner, $i, 1);
                if ($ec eq "[") { $bracket_d++; }
                if ($ec eq "]") { $bracket_d--; }
                if ($bracket_d > 0) {
                    $expr = $expr . $ec;
                }
                $i++;
            }
            # Skip closing }
            if ($i < $ilen && substr($inner, $i, 1) eq "}") { $i++; }
            push(@parts, "(" . trim_str($expr) . ")");
            next;
        }

        # ${\(expr)} interpolation: scalar dereference of expression
        if ($c eq "$" && $i + 1 < $ilen && substr($inner, $i + 1, 1) eq "{" && $i + 2 < $ilen && substr($inner, $i + 2, 1) eq "\\") {
            # Flush accumulated text
            if ($text ne "") {
                push(@parts, "\"" . $text . "\"");
                $text = "";
            }
            # Skip ${\
            $i = $i + 3;
            my str $sexpr = "";
            my int $sbrace_d = 1;
            while ($i < $ilen && $sbrace_d > 0) {
                my str $sc = substr($inner, $i, 1);
                if ($sc eq "{") { $sbrace_d++; }
                if ($sc eq "}") { $sbrace_d--; }
                if ($sbrace_d > 0) {
                    $sexpr = $sexpr . $sc;
                }
                $i++;
            }
            # Remove surrounding parens if present
            $sexpr = trim_str($sexpr);
            if (starts_with($sexpr, "(") && match($sexpr, "\\)$")) {
                $sexpr = substr($sexpr, 1, length($sexpr) - 2);
            }
            push(@parts, "(" . trim_str($sexpr) . ")");
            next;
        }

        # @array interpolation: @name -> join(" ", @name)
        if ($c eq "@" && $i + 1 < $ilen && is_word_char(substr($inner, $i + 1, 1))) {
            # Flush accumulated text
            if ($text ne "") {
                push(@parts, "\"" . $text . "\"");
                $text = "";
            }
            # Extract array name
            my str $arr_name = "@";
            $i++;
            while ($i < $ilen && is_word_char(substr($inner, $i, 1))) {
                $arr_name = $arr_name . substr($inner, $i, 1);
                $i++;
            }
            push(@parts, "join(\" \", " . $arr_name . ")");
            next;
        }

        $text = $text . $c;
        $i++;
    }

    # Flush remaining text
    if ($text ne "") {
        push(@parts, "\"" . $text . "\"");
    }

    if (scalar(@parts) == 0) { return "\"\""; }
    if (scalar(@parts) == 1) { return $parts[0]; }

    return join(" . ", @parts);
}


# Convert qw(a b c) to ("a", "b", "c")
# Handles qw(), qw//, qw[], qw{}, qw!!
func convert_qw(str $line) str {
    if (!match($line, "\\bqw\\s*[\\(/\\[\\{!<]")) { return $line; }

    my str $result = $line;
    my int $qw_safety = 0;
    while (match($result, "\\bqw\\s*[\\(/\\[\\{!<]") && $qw_safety < 10) {
        # Find qw position
        my int $qw_pos = index($result, "qw");
        if ($qw_pos < 0) { last; }
        # Skip to delimiter
        my int $di = $qw_pos + 2;
        while ($di < length($result) && substr($result, $di, 1) eq " ") { $di++; }
        if ($di >= length($result)) { last; }
        my str $open_ch = substr($result, $di, 1);
        my str $close_ch = ")";
        if ($open_ch eq "(") { $close_ch = ")"; }
        elsif ($open_ch eq "[") { $close_ch = "]"; }
        elsif ($open_ch eq "{") { $close_ch = "}"; }
        elsif ($open_ch eq "<") { $close_ch = ">"; }
        else { $close_ch = $open_ch; }
        # Find closing delimiter
        my int $end = index($result, $close_ch, $di + 1);
        if ($end < 0) { last; }
        # Extract words
        my str $words_str = substr($result, $di + 1, $end - $di - 1);
        my array @words = split("\\s+", trim_str($words_str));
        my str $replacement = "(";
        my int $wi = 0;
        while ($wi < scalar(@words)) {
            if (length($words[$wi]) > 0) {
                if ($wi > 0) { $replacement = $replacement . ", "; }
                $replacement = $replacement . "\"" . $words[$wi] . "\"";
            }
            $wi++;
        }
        $replacement = $replacement . ")";
        # Replace: everything from qw_pos through end (inclusive)
        my str $before = substr($result, 0, $qw_pos);
        my str $after = substr($result, $end + 1, length($result) - $end - 1);
        $result = $before . $replacement . $after;
        $qw_safety++;
    }
    return $result;
}

# Convert postfix if/unless: "expr if cond;" -> "if (cond) { expr; }"
func convert_postfix_conditional(str $line) str {
    my str $trimmed = trim_str($line);
    my str $indent = get_indent($line);

    # Postfix if: "statement if condition;"
    # But NOT: lines that start with if/unless/elsif (those are normal conditionals)
    if (starts_with($trimmed, "if ") || starts_with($trimmed, "if(")) { return $line; }
    if (starts_with($trimmed, "unless ") || starts_with($trimmed, "unless(")) { return $line; }
    if (starts_with($trimmed, "elsif")) { return $line; }

    # Check for postfix if
    if (match($trimmed, "\\s+if\\s+") && !starts_with($trimmed, "#")) {
        my array @cap = capture($trimmed, "^(.+?)\\s+if\\s+(.+);\\s*$");
        if (scalar(@cap) > 2) {
            my str $expr = $cap[1];
            my str $cond = $cap[2];
            # Only strip wrapping parens if the whole condition is parenthesized
            # e.g. "(x > 0)" -> "x > 0" but NOT "defined($result)" -> "defined$result)"
            if (match($cond, "^\\(") && match($cond, "\\)$")) {
                # Count parens to make sure they're balanced wrapping parens
                my int $pd = 0;
                my int $pk = 0;
                my int $plen = length($cond);
                my int $strip_ok = 1;
                while ($pk < $plen - 1) {
                    my int $pc = char_at($cond, $pk);
                    if ($pc == 40) { $pd++; }
                    if ($pc == 41) { $pd--; }
                    if ($pd == 0 && $pk > 0) { $strip_ok = 0; }
                    $pk++;
                }
                if ($strip_ok == 1) {
                    $cond = substr($cond, 1, length($cond) - 2);
                }
            }
            return $indent . "if (" . $cond . ") { " . $expr . "; }";
        }
    }

    # Check for postfix unless
    if (match($trimmed, "\\s+unless\\s+") && !starts_with($trimmed, "#")) {
        my array @cap2 = capture($trimmed, "^(.+?)\\s+unless\\s+(.+);\\s*$");
        if (scalar(@cap2) > 2) {
            my str $expr = $cap2[1];
            my str $cond = $cap2[2];
            # Only strip wrapping parens if balanced
            if (match($cond, "^\\(") && match($cond, "\\)$")) {
                my int $pd2 = 0;
                my int $pk2 = 0;
                my int $plen2 = length($cond);
                my int $strip_ok2 = 1;
                while ($pk2 < $plen2 - 1) {
                    my int $pc2 = char_at($cond, $pk2);
                    if ($pc2 == 40) { $pd2++; }
                    if ($pc2 == 41) { $pd2--; }
                    if ($pd2 == 0 && $pk2 > 0) { $strip_ok2 = 0; }
                    $pk2++;
                }
                if ($strip_ok2 == 1) {
                    $cond = substr($cond, 1, length($cond) - 2);
                }
            }
            return $indent . "if (!(" . $cond . ")) { " . $expr . "; }";
        }
    }

    # Check for postfix while: "expr while cond;" (but NOT "} while (cond);" which is do-while)
    if (match($trimmed, "\\s+while\\s+") && !starts_with($trimmed, "#") && !starts_with($trimmed, "while") && !match($trimmed, "^\\}\\s*while\\s*\\(")) {
        my array @cap3 = capture($trimmed, "^(.+?)\\s+while\\s+(.+);\\s*$");
        if (scalar(@cap3) > 2) {
            my str $expr = $cap3[1];
            my str $cond = $cap3[2];
            # Skip if the keyword is inside a quoted string (odd number of quotes in expr)
            my int $qcount = 0;
            my int $qi = 0;
            while ($qi < length($expr)) {
                if (substr($expr, $qi, 1) eq "\"") { $qcount++; }
                $qi++;
            }
            if ($qcount % 2 == 0) {
                if (match($cond, "^\\(") && match($cond, "\\)$")) {
                    my int $pd3 = 0;
                    my int $pk3 = 0;
                    my int $plen3 = length($cond);
                    my int $strip_ok3 = 1;
                    while ($pk3 < $plen3 - 1) {
                        my int $pc3 = char_at($cond, $pk3);
                        if ($pc3 == 40) { $pd3++; }
                        if ($pc3 == 41) { $pd3--; }
                        if ($pd3 == 0 && $pk3 > 0) { $strip_ok3 = 0; }
                        $pk3++;
                    }
                    if ($strip_ok3 == 1) {
                        $cond = substr($cond, 1, length($cond) - 2);
                    }
                }
                return $indent . "while (" . $cond . ") { " . $expr . "; }";
            }
        }
    }

    # Check for postfix for: "expr for @arr;" or "expr for 1..10;"
    if (match($trimmed, "\\s+for\\s+") && !starts_with($trimmed, "#") && !starts_with($trimmed, "for")) {
        my array @cap4 = capture($trimmed, "^(.+?)\\s+for\\s+(.+);\\s*$");
        if (scalar(@cap4) > 2) {
            my str $expr = $cap4[1];
            my str $list = $cap4[2];
            # Skip if the keyword is inside a quoted string
            my int $qcount2 = 0;
            my int $qi2 = 0;
            while ($qi2 < length($expr)) {
                if (substr($expr, $qi2, 1) eq "\"") { $qcount2++; }
                $qi2++;
            }
            if ($qcount2 % 2 == 0) {
                return $indent . "foreach my scalar $_ (" . $list . ") { " . $expr . "; }";
            }
        }
    }

    # Check for postfix foreach: "expr foreach @arr;" or "expr foreach (LIST);"
    if (match($trimmed, "\\s+foreach\\s+") && !starts_with($trimmed, "#") && !starts_with($trimmed, "foreach")) {
        my array @cap5 = capture($trimmed, "^(.+?)\\s+foreach\\s+(.+);\\s*$");
        if (scalar(@cap5) > 2) {
            my str $expr5 = $cap5[1];
            my str $list5 = $cap5[2];
            my int $qcount5 = 0;
            my int $qi5 = 0;
            while ($qi5 < length($expr5)) {
                if (substr($expr5, $qi5, 1) eq "\"") { $qcount5++; }
                $qi5++;
            }
            if ($qcount5 % 2 == 0) {
                return $indent . "foreach my scalar $_ (" . $list5 . ") { " . $expr5 . "; }";
            }
        }
    }

    return $line;
}

# Quote bare hash keys in a line: $h{key} -> $h{"key"}
func quote_hash_keys(str $line) str {
    my str $result = "";
    my int $i = 0;
    my int $len = length($line);

    while ($i < $len) {
        my str $c = substr($line, $i, 1);

        # Look for { after $ variable or ->
        if ($c eq "{") {
            # Check if preceded by a variable access pattern ($ followed by word chars, then {)
            # or -> pattern
            my int $is_hash_access = 0;
            if ($i > 0) {
                my str $prev = substr($line, $i - 1, 1);
                if (is_word_char($prev) || $prev eq "}" || $prev eq ">") {
                    $is_hash_access = 1;
                }
            }

            if ($is_hash_access == 1) {
                $result = $result . "{";
                $i++;
                # Extract the key
                my str $key = "";
                while ($i < $len && substr($line, $i, 1) ne "}") {
                    $key = $key . substr($line, $i, 1);
                    $i++;
                }
                $result = $result . quote_bare_key($key);
                if ($i < $len) {
                    $result = $result . "}";
                    $i++;
                }
                next;
            }
        }

        $result = $result . $c;
        $i++;
    }

    return $result;
}


# ============================================================
# Pass 2e: Expand typeglob method-generation loops
# ============================================================
# Detects patterns like:
#   for my $attr (qw(name age email)) {
#       no strict 'refs';
#       *{$attr} = sub { return $_[0]->{$attr} };
#       *{"set_$attr"} = sub { $_[0]->{$attr} = $_[1] };
#   }
# and expands to explicit func declarations for each attribute.
# Also handles single-line *{name} = sub { ... } outside loops.
func pass2e_typeglob_methods(array @lines) array {
    my array @out = ();
    my int $i = 0;
    my int $num_lines = scalar(@lines);
    my str $tge_star = "*";

    while ($i < $num_lines) {
        my str $line = $lines[$i];
        my str $trimmed = trim_str($line);
        my str $indent = get_indent($line);

        # Function alias: *alias = \&original -> wrapper function
        if (match($trimmed, "^\\*[A-Za-z_][A-Za-z0-9_:]*\\s*=\\s*\\\\&[A-Za-z_]")) {
            my array @fa2_cap = capture($trimmed, "^\\*([A-Za-z_][A-Za-z0-9_:]*)\\s*=\\s*\\\\&([A-Za-z_][A-Za-z0-9_:]*)");
            if (scalar(@fa2_cap) > 2) {
                my str $fa2_alias = $fa2_cap[1];
                my str $fa2_orig = $fa2_cap[2];
                push(@out, $indent . "func " . $fa2_alias . "(scalar ...@_) dynamic { return " . $fa2_orig . "(@_); }");
                $i++;
                next;
            }
        }

        # Detect: for/foreach my $var (qw(...)) { containing *{...} = sub
        if (match($trimmed, "^(for|foreach)\\s+my\\s+\\$[a-zA-Z_][a-zA-Z0-9_]*\\s*\\(\\s*qw")) {
            # Extract loop variable name
            my array @lv_cap = capture($trimmed, "^(?:for|foreach)\\s+my\\s+\\$([a-zA-Z_][a-zA-Z0-9_]*)");
            # Extract qw list
            my array @qw_cap = capture($trimmed, "qw[\\(\\[]\\s*([^)\\]]+)\\s*[)\\]]");
            if (scalar(@lv_cap) > 1 && scalar(@qw_cap) > 1) {
                my str $loop_var = $lv_cap[1];
                my str $qw_str = trim_str($qw_cap[1]);
                my array @qw_items = split("\\s+", $qw_str);

                # Collect the loop body lines (track braces)
                my int $tge_depth = 0;
                my int $ci2 = 0;
                my int $clen2 = length($trimmed);
                while ($ci2 < $clen2) {
                    my str $tge_ch = substr($trimmed, $ci2, 1);
                    if ($tge_ch eq "{") { $tge_depth++; }
                    if ($tge_ch eq "}") { $tge_depth--; }
                    $ci2++;
                }
                my array @loop_body = ();
                my int $j2 = $i + 1;
                while ($j2 < $num_lines && $tge_depth > 0) {
                    my str $bline = $lines[$j2];
                    my str $btrim = trim_str($bline);
                    my int $bi2 = 0;
                    my int $blen2 = length($btrim);
                    while ($bi2 < $blen2) {
                        my str $bch2 = substr($btrim, $bi2, 1);
                        if ($bch2 eq "{") { $tge_depth++; }
                        if ($bch2 eq "}") { $tge_depth--; }
                        $bi2++;
                    }
                    if ($tge_depth > 0) {
                        push(@loop_body, $btrim);
                    }
                    $j2++;
                }

                # Check if the body contains typeglob assignments
                my int $has_typeglob = 0;
                my int $lb = 0;
                while ($lb < scalar(@loop_body)) {
                    if (match($loop_body[$lb], "\\*\\{") && match($loop_body[$lb], "=\\s*sub\\s*\\{")) {
                        $has_typeglob = 1;
                    }
                    $lb++;
                }

                if ($has_typeglob == 1) {
                    # Expand: for each qw item, generate func declarations
                    push(@out, $indent . "# Expanded from: " . $trimmed);
                    my int $qi = 0;
                    while ($qi < scalar(@qw_items)) {
                        my str $attr = trim_str($qw_items[$qi]);
                        if (length($attr) > 0) {
                            # Process each body line, substituting the loop variable
                            my int $lb2 = 0;
                            while ($lb2 < scalar(@loop_body)) {
                                my str $bl = $loop_body[$lb2];
                                # Skip "no strict 'refs'" lines
                                if (match($bl, "^no\\s+strict")) {
                                    $lb2++;
                                    next;
                                }
                                # Detect getter: *{$var} = sub { return $_[0]->{$var} };
                                # or *{$var} = sub { $_[0]->{$var} };
                                if (match($bl, "\\*\\{\\$" . $loop_var . "\\}\\s*=\\s*sub")) {
                                    # Extract the sub body between { and }
                                    my array @sb_cap = capture($bl, "sub\\s*\\{(.+)\\}\\s*;");
                                    if (scalar(@sb_cap) > 1) {
                                        my str $sbody = trim_str($sb_cap[1]);
                                        # Replace $_[0] with $self, $_[1] with $value, $var references with attr name
                                        $sbody = replace_all($sbody, "$" . "_[0]", "$" . "self");
                                        $sbody = replace_all($sbody, "$" . "_[1]", "$" . "value");
                                        # Replace {$var} hash access with {attr}
                                        $sbody = replace_all($sbody, "{$" . $loop_var . "}", "{\"" . $attr . "\"}");
                                        $sbody = replace_all($sbody, "$" . $loop_var, "\"" . $attr . "\"");
                                        push(@out, $indent . "func " . $attr . "(scalar $" . "self) scalar { " . $sbody . " }");
                                    }
                                }
                                # Detect setter: *{"set_$var"} = sub { ... }
                                # or *{$prefix . $var} = sub { ... }
                                elsif (match($bl, "\\*\\{[\"']set_") && match($bl, "=\\s*sub")) {
                                    my array @sb2_cap = capture($bl, "sub\\s*\\{(.+)\\}\\s*;");
                                    if (scalar(@sb2_cap) > 1) {
                                        my str $sbody2 = trim_str($sb2_cap[1]);
                                        $sbody2 = replace_all($sbody2, "$" . "_[0]", "$" . "self");
                                        $sbody2 = replace_all($sbody2, "$" . "_[1]", "$" . "value");
                                        $sbody2 = replace_all($sbody2, "{$" . $loop_var . "}", "{\"" . $attr . "\"}");
                                        $sbody2 = replace_all($sbody2, "$" . $loop_var, "\"" . $attr . "\"");
                                        push(@out, $indent . "func set_" . $attr . "(scalar $" . "self, scalar $" . "value) void { " . $sbody2 . " }");
                                    }
                                }
                                # Other typeglob with prefix: *{"prefix_$var"} = sub { ... }
                                elsif (match($bl, "\\*\\{[\"']") && match($bl, "=\\s*sub")) {
                                    my array @pfx_cap = capture($bl, "\\*\\{[\"']([a-z_]+)\\$" . $loop_var . "[\"']\\}");
                                    my array @sb3_cap = capture($bl, "sub\\s*\\{(.+)\\}\\s*;");
                                    if (scalar(@pfx_cap) > 1 && scalar(@sb3_cap) > 1) {
                                        my str $prefix = $pfx_cap[1];
                                        my str $sbody3 = trim_str($sb3_cap[1]);
                                        $sbody3 = replace_all($sbody3, "$" . "_[0]", "$" . "self");
                                        $sbody3 = replace_all($sbody3, "$" . "_[1]", "$" . "value");
                                        $sbody3 = replace_all($sbody3, "{$" . $loop_var . "}", "{\"" . $attr . "\"}");
                                        $sbody3 = replace_all($sbody3, "$" . $loop_var, "\"" . $attr . "\"");
                                        push(@out, $indent . "func " . $prefix . $attr . "(scalar $" . "self, scalar $" . "value) void { " . $sbody3 . " }");
                                    }
                                }
                                $lb2++;
                            }
                        }
                        $qi++;
                    }
                    $i = $j2;
                    next;
                }
            }
        }

        # Typeglob constant: *NAME = sub () { VALUE }; -> const TYPE NAME = VALUE;
        # This is the Perl idiom for compile-time constants (used by constant.pm)
        if (match($trimmed, "^\\*[A-Za-z_][A-Za-z0-9_:]*\\s*=\\s*sub\\s*\\(\\s*\\)\\s*\\{")) {
            my array @tc_cap = capture($trimmed, "^\\*([A-Za-z_][A-Za-z0-9_:]*)\\s*=\\s*sub\\s*\\(\\s*\\)\\s*\\{\\s*(.+?)\\s*;?\\s*\\}\\s*;");
            if (scalar(@tc_cap) > 2) {
                my str $tc_name = $tc_cap[1];
                my str $tc_value = trim_str($tc_cap[2]);
                # Determine type from value
                my str $tc_type = "scalar";
                if (match($tc_value, "^-?[0-9]+$")) {
                    $tc_type = "int";
                } elsif (match($tc_value, "^-?[0-9]*\\.[0-9]+$")) {
                    $tc_type = "num";
                } elsif (match($tc_value, "^[\"']") || match($tc_value, "^qq")) {
                    $tc_type = "str";
                }
                push(@out, $indent . "const " . $tc_type . " " . $tc_name . " = " . $tc_value . ";");
                $i++;
                next;
            }
        }

        # Single-line typeglob method: *func_name = sub { body };
        # Outside of a for loop â€” emit as a standalone function
        if (match($trimmed, "^\\*[A-Za-z_][A-Za-z0-9_]*\\s*=\\s*sub\\s*\\{")) {
            my array @stg_cap = capture($trimmed, "^\\*([A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*sub\\s*\\{(.+)\\}\\s*;");
            if (scalar(@stg_cap) > 2) {
                my str $stg_name = $stg_cap[1];
                my str $stg_body = trim_str($stg_cap[2]);
                my int $stg_has_arg1 = 0;
                if (match($stg_body, "\\$_\\[1\\]")) { $stg_has_arg1 = 1; }
                $stg_body = replace_all($stg_body, "$" . "_[0]", "$" . "self");
                $stg_body = replace_all($stg_body, "$" . "_[1]", "$" . "value");
                my str $stg_sig = "scalar $" . "self";
                my str $stg_ret = "scalar";
                if ($stg_has_arg1 == 1) {
                    $stg_sig = "scalar $" . "self, scalar $" . "value";
                    $stg_ret = "void";
                }
                push(@out, $indent . "func " . $stg_name . "(" . $stg_sig . ") " . $stg_ret . " { " . $stg_body . " }");
                $i++;
                next;
            }
        }

        # Single-line: *{"func_name"} = sub { body };
        if (match($trimmed, "^\\*\\{[\"'][A-Za-z_][A-Za-z0-9_]*[\"']\\}\\s*=\\s*sub\\s*\\{")) {
            my array @stg2_cap = capture($trimmed, "^\\*\\{[\"']([A-Za-z_][A-Za-z0-9_]*)[\"']\\}\\s*=\\s*sub\\s*\\{(.+)\\}\\s*;");
            if (scalar(@stg2_cap) > 2) {
                my str $stg2_name = $stg2_cap[1];
                my str $stg2_body = trim_str($stg2_cap[2]);
                my int $stg2_has_arg1 = 0;
                if (match($stg2_body, "\\$_\\[1\\]")) { $stg2_has_arg1 = 1; }
                $stg2_body = replace_all($stg2_body, "$" . "_[0]", "$" . "self");
                $stg2_body = replace_all($stg2_body, "$" . "_[1]", "$" . "value");
                my str $stg2_sig = "scalar $" . "self";
                my str $stg2_ret = "scalar";
                if ($stg2_has_arg1 == 1) {
                    $stg2_sig = "scalar $" . "self, scalar $" . "value";
                    $stg2_ret = "void";
                }
                push(@out, $indent . "func " . $stg2_name . "(" . $stg2_sig . ") " . $stg2_ret . " { " . $stg2_body . " }");
                $i++;
                next;
            }
        }

        # Dynamic typeglob: *{$var} = sub { ... }; (not in a for loop)
        # Generate an AUTOLOAD dispatch table entry
        if (match($trimmed, "^\\*\\{\\$[a-zA-Z_]") && match($trimmed, "=\\s*sub\\s*\\{")) {
            my array @dtg_cap = capture($trimmed, "^\\*\\{\\$([a-zA-Z_][a-zA-Z0-9_]*)\\}\\s*=\\s*sub\\s*\\{(.+)\\}\\s*;");
            if (scalar(@dtg_cap) > 2) {
                my str $dtg_var = $dtg_cap[1];
                my str $dtg_body = trim_str($dtg_cap[2]);
                $dtg_body = replace_all($dtg_body, "$" . "_[0]", "$" . "self");
                $dtg_body = replace_all($dtg_body, "$" . "_[1]", "$" . "value");
                push(@out, $indent . "# Dynamic method: " . $tge_star . "{$" . $dtg_var . "} installed at runtime");
                push(@out, $indent . "# AUTOLOAD will dispatch based on $" . $dtg_var . " value");
                push(@out, $indent . "$" . "__dispatch{$" . $dtg_var . "} = func (scalar $" . "self) scalar { " . $dtg_body . " };");
                $i++;
                next;
            }
        }

        push(@out, $line);
        $i++;
    }

    return @out;
}


# Helper: generate full Strada has declaration + extra methods for one attribute
# Given an attribute name and Moose options string, produces the same output
# as the single-attribute handler (lines 4615+).
func generate_has_decl(str $attr_name, str $attr_opts, str $indent) str {
    my str $is_mode = "ro";
    my str $isa_type = "scalar";
    my str $default_val = "";
    my int $is_required = 0;
    my int $is_lazy = 0;
    my str $builder = "";

    if (match($attr_opts, "is\\s*=>\\s*['\"]rw['\"]")) { $is_mode = "rw"; }
    if (match($attr_opts, "isa\\s*=>\\s*['\"]Str['\"]")) { $isa_type = "str"; }
    if (match($attr_opts, "isa\\s*=>\\s*['\"]Int['\"]")) { $isa_type = "int"; }
    if (match($attr_opts, "isa\\s*=>\\s*['\"]Num['\"]")) { $isa_type = "num"; }
    if (match($attr_opts, "isa\\s*=>\\s*['\"]Bool['\"]")) { $isa_type = "int"; }
    if (match($attr_opts, "isa\\s*=>\\s*['\"]ArrayRef")) { $isa_type = "scalar"; }
    if (match($attr_opts, "isa\\s*=>\\s*['\"]HashRef")) { $isa_type = "scalar"; }
    if (match($attr_opts, "isa\\s*=>\\s*['\"]CodeRef['\"]")) { $isa_type = "scalar"; }
    if (match($attr_opts, "isa\\s*=>\\s*['\"]ClassName['\"]")) { $isa_type = "str"; }
    if (match($attr_opts, "isa\\s*=>\\s*['\"]Object['\"]")) { $isa_type = "scalar"; }
    if (match($attr_opts, "isa\\s*=>\\s*['\"]Maybe\\[")) { $isa_type = "scalar"; }
    if (match($attr_opts, "required\\s*=>\\s*1")) { $is_required = 1; }
    if (match($attr_opts, "lazy\\s*=>\\s*1")) { $is_lazy = 1; }

    # Extract default value
    my array @gdef_cap = capture($attr_opts, "default\\s*=>\\s*([^,)]+)");
    if (scalar(@gdef_cap) > 1) {
        $default_val = trim_str($gdef_cap[1]);
        if (match($default_val, "^sub\\s*\\{")) {
            if (match($attr_opts, "default\\s*=>\\s*sub\\s*\\{\\s*\\[\\]\\s*\\}")) {
                $default_val = "[]";
            } elsif (match($attr_opts, "default\\s*=>\\s*sub\\s*\\{\\s*\\{\\}\\s*\\}")) {
                $default_val = "{}";
            } elsif (match($attr_opts, "default\\s*=>\\s*sub\\s*\\{\\s*['\"]([^'\"]*)['\"]\\s*\\}")) {
                my array @gsdef_cap = capture($attr_opts, "default\\s*=>\\s*sub\\s*\\{\\s*['\"]([^'\"]*)['\"]\\s*\\}");
                if (scalar(@gsdef_cap) > 1) {
                    $default_val = "\"" . $gsdef_cap[1] . "\"";
                } else {
                    $default_val = "";
                }
            } elsif (match($attr_opts, "default\\s*=>\\s*sub\\s*\\{\\s*(-?[0-9]+\\.?[0-9]*)\\s*\\}")) {
                my array @gndef_cap = capture($attr_opts, "default\\s*=>\\s*sub\\s*\\{\\s*(-?[0-9]+\\.?[0-9]*)\\s*\\}");
                if (scalar(@gndef_cap) > 1) {
                    $default_val = $gndef_cap[1];
                } else {
                    $default_val = "";
                }
            } else {
                $default_val = "";
            }
        }
    }

    # Extract builder
    my array @gbld_cap = capture($attr_opts, "builder\\s*=>\\s*['\"]([^'\"]+)['\"]");
    if (scalar(@gbld_cap) > 1) {
        $builder = $gbld_cap[1];
    }

    # Build the has declaration
    my str $has_decl = $indent . "has " . $is_mode . " " . $isa_type . " $" . $attr_name;
    if (length($default_val) > 0) {
        $has_decl = $has_decl . " = " . $default_val;
    }
    if ($is_required == 1) {
        $has_decl = $has_decl . " (required)";
    } elsif ($is_lazy == 1) {
        if (length($builder) > 0) {
            $has_decl = $has_decl . " (lazy, builder => \"" . $builder . "\")";
        } else {
            $has_decl = $has_decl . " (lazy)";
        }
    } elsif (length($builder) > 0) {
        $has_decl = $has_decl . " (builder => \"" . $builder . "\")";
    }
    $has_decl = $has_decl . ";";

    # Generate extra methods for options
    my str $extra_methods = "";

    if (match($attr_opts, "\\btrigger\\b")) {
        my str $trigger_body = "# trigger callback body";
        my array @gtrig_cap = capture($attr_opts, "trigger\\s*=>\\s*sub\\s*\\{([^}]*)\\}");
        if (scalar(@gtrig_cap) > 1) {
            $trigger_body = trim_str($gtrig_cap[1]);
            $trigger_body = replace($trigger_body, "^my\\s*\\([^)]*\\)\\s*=\\s*@_;?\\s*", "");
            if (length($trigger_body) == 0) {
                $trigger_body = "# trigger callback was empty";
            }
        }
        $extra_methods = $extra_methods . "\n" . $indent . "after \"set_" . $attr_name . "\" func(scalar $self) void { " . $trigger_body . " }";
    }
    if (match($attr_opts, "\\bcoerce\\b")) {
        $has_decl = $has_decl . "  # Note: had coerce => 1 â€” Strada handles basic type coercion natively";
    }
    if (match($attr_opts, "\\bhandles\\b")) {
        my array @ghdl_cap = capture($attr_opts, "handles\\s*=>\\s*\\[([^\\]]+)\\]");
        if (scalar(@ghdl_cap) > 1) {
            my str $ghdl_list = $ghdl_cap[1];
            if (match($ghdl_list, "^qw")) {
                $ghdl_list = replace($ghdl_list, "^qw[\\(\\[]\\s*", "");
                $ghdl_list = replace($ghdl_list, "\\s*[)\\]]\\s*$", "");
            }
            $ghdl_list = replace_all($ghdl_list, "'", "");
            $ghdl_list = replace_all($ghdl_list, "\"", "");
            $ghdl_list = replace_all($ghdl_list, ",", " ");
            my array @ghdl_methods = split("\\s+", trim_str($ghdl_list));
            my int $ghmi = 0;
            while ($ghmi < scalar(@ghdl_methods)) {
                my str $ghm_name = trim_str($ghdl_methods[$ghmi]);
                if (length($ghm_name) > 0) {
                    $extra_methods = $extra_methods . "\n" . $indent . "func " . $ghm_name . "(scalar $self, scalar ...@_) dynamic { return $self->" . $attr_name . "()->" . $ghm_name . "(@_); }";
                }
                $ghmi++;
            }
            $has_decl = $has_decl . "  # handles delegation via " . $attr_name;
        } else {
            my array @ghdl_hash_cap = capture($attr_opts, "handles\\s*=>\\s*\\{([^}]+)\\}");
            if (scalar(@ghdl_hash_cap) > 1) {
                my str $ghdl_hash_body = $ghdl_hash_cap[1];
                my array @ghdl_pairs = split(",", $ghdl_hash_body);
                my int $ghpi = 0;
                while ($ghpi < scalar(@ghdl_pairs)) {
                    my str $ghp = trim_str($ghdl_pairs[$ghpi]);
                    if (length($ghp) > 0) {
                        my array @ghp_cap = capture($ghp, "([A-Za-z_][A-Za-z0-9_]*)\\s*=>\\s*['\"]?([A-Za-z_][A-Za-z0-9_]*)['\"]?");
                        if (scalar(@ghp_cap) > 2) {
                            my str $ghp_alias = $ghp_cap[1];
                            my str $ghp_method = $ghp_cap[2];
                            $extra_methods = $extra_methods . "\n" . $indent . "func " . $ghp_alias . "(scalar $self, scalar ...@_) dynamic { return $self->" . $attr_name . "()->" . $ghp_method . "(@_); }";
                        }
                    }
                    $ghpi++;
                }
                $has_decl = $has_decl . "  # handles delegation (aliased) via " . $attr_name;
            } else {
                $has_decl = $has_decl . "  # REVIEW: had delegation via handles â€” implement wrapper methods";
            }
        }
    }
    if (match($attr_opts, "\\bclearer\\b")) {
        my array @gclr_cap = capture($attr_opts, "clearer\\s*=>\\s*['\"]([^'\"]+)['\"]");
        my str $gclr_name = "clear_" . $attr_name;
        if (scalar(@gclr_cap) > 1) {
            $gclr_name = $gclr_cap[1];
        }
        $extra_methods = $extra_methods . "\n" . $indent . "func " . $gclr_name . "(scalar $self) void { $self->{\"" . $attr_name . "\"} = undef; }";
    }
    if (match($attr_opts, "\\bpredicate\\b")) {
        my array @gpred_cap = capture($attr_opts, "predicate\\s*=>\\s*['\"]([^'\"]+)['\"]");
        my str $gpred_name = "has_" . $attr_name;
        if (scalar(@gpred_cap) > 1) {
            $gpred_name = $gpred_cap[1];
        }
        $extra_methods = $extra_methods . "\n" . $indent . "func " . $gpred_name . "(scalar $self) int { return defined($self->{\"" . $attr_name . "\"}); }";
    }
    if (match($attr_opts, "\\bweak_ref\\b")) {
        $extra_methods = $extra_methods . "\n" . $indent . "after \"new\" func(scalar $self) void { if (defined($self->{\"" . $attr_name . "\"})) { core::weaken($self->{\"" . $attr_name . "\"}); } }";
    }
    return $has_decl . $extra_methods;
}

# Main line conversion for Pass 3
func convert_line(str $line, hash %sub_info) str {
    my str $trimmed = trim_str($line);
    my str $indent = get_indent($line);
    my str $result = $line;

    # Skip empty lines and pure comments
    if ($trimmed eq "" || starts_with($trimmed, "#")) {
        return $result;
    }

    # ---- Shebang line ----
    if (starts_with($trimmed, "#!/")) {
        return $indent . $trimmed;
    }

    # ---- Reserved word variable renaming ----
    # Strada type keywords cannot be used as variable names: $str, $int, $num, $hash, $array, $scalar, $void
    # Rename them to $str_v, $int_v, etc. to avoid compile errors
    # Also rename @str, @int, etc. and %str, %int, etc.
    # Uses regex \b to avoid matching $string, $integer, $stringify, etc.
    if (match($result, "[\\$@%](str|int|num|hash|array|scalar|void)\\b") && !match($result, "^\\s*#")) {
        my int $rw_safety = 0;
        while (match($result, "\\$str\\b") && !match($result, "\\$str_v") && $rw_safety < 5) {
            $result = replace($result, "\\$str\\b", "$" . "str_v");
            $rw_safety++;
        }
        $rw_safety = 0;
        while (match($result, "@str\\b") && !match($result, "@str_v") && $rw_safety < 5) {
            $result = replace($result, "@str\\b", "@str_v");
            $rw_safety++;
        }
        $rw_safety = 0;
        while (match($result, "%str\\b") && !match($result, "%str_v") && $rw_safety < 5) {
            $result = replace($result, "%str\\b", "%str_v");
            $rw_safety++;
        }
        $rw_safety = 0;
        while (match($result, "\\$int\\b") && !match($result, "\\$int_v") && $rw_safety < 5) {
            $result = replace($result, "\\$int\\b", "$" . "int_v");
            $rw_safety++;
        }
        $rw_safety = 0;
        while (match($result, "@int\\b") && !match($result, "@int_v") && $rw_safety < 5) {
            $result = replace($result, "@int\\b", "@int_v");
            $rw_safety++;
        }
        $rw_safety = 0;
        while (match($result, "\\$num\\b") && !match($result, "\\$num_v") && $rw_safety < 5) {
            $result = replace($result, "\\$num\\b", "$" . "num_v");
            $rw_safety++;
        }
        $rw_safety = 0;
        while (match($result, "\\$hash\\b") && !match($result, "\\$hash_v") && $rw_safety < 5) {
            $result = replace($result, "\\$hash\\b", "$" . "hash_v");
            $rw_safety++;
        }
        $rw_safety = 0;
        while (match($result, "\\$array\\b") && !match($result, "\\$array_v") && $rw_safety < 5) {
            $result = replace($result, "\\$array\\b", "$" . "array_v");
            $rw_safety++;
        }
        $rw_safety = 0;
        while (match($result, "\\$scalar\\b") && !match($result, "\\$scalar_v") && $rw_safety < 5) {
            $result = replace($result, "\\$scalar\\b", "$" . "scalar_v");
            $rw_safety++;
        }
        $rw_safety = 0;
        while (match($result, "\\$void\\b") && !match($result, "\\$void_v") && $rw_safety < 5) {
            $result = replace($result, "\\$void\\b", "$" . "void_v");
            $rw_safety++;
        }
        $trimmed = trim_str($result);
    }

    # ---- Perl 5.38 class keyword ----
    if (match($trimmed, "^class\\s+[A-Z]")) {
        my array @cls_cap = capture($trimmed, "^class\\s+([A-Za-z_:][A-Za-z0-9_:]*)");
        if (scalar(@cls_cap) > 1) {
            my str $cls_name = $cls_cap[1];
            if (match($trimmed, "\\{")) {
                return $indent . "package " . $cls_name . ";  # was: class " . $cls_name;
            }
            return $indent . "package " . $cls_name . ";  # was: class " . $cls_name;
        }
    }
    # field $x = default -> has rw scalar $x = default
    if (match($trimmed, "^field\\s+\\$")) {
        my str $field_line = $trimmed;
        $field_line = replace($field_line, "^field\\s+", "has rw scalar ");
        # Remove :param attribute if present
        $field_line = replace($field_line, "\\s*:param\\s*", " ");
        $field_line =~ s/\s+;/;/;
        return $indent . $field_line . "  # was: field";
    }
    # method name -> func name(scalar $self)
    if (match($trimmed, "^method\\s+[A-Za-z_]")) {
        my str $meth_line = $trimmed;
        $meth_line = replace($meth_line, "^method\\s+([A-Za-z_][A-Za-z0-9_]*)", "func $1(scalar $" . "self)");
        # If no return type, add scalar
        if (match($meth_line, "\\)\\s*\\{")) {
            $meth_line = replace($meth_line, "\\)\\s*\\{", ") scalar {");
        }
        return $indent . $meth_line;
    }
    # ADJUST block
    if (match($trimmed, "^ADJUST\\s*\\{") && !match($result, "#")) {
        return $indent . "# " . $trimmed . "  # REVIEW: ADJUST block â€” use after \"new\" hook in Strada";
    }

    # ---- Lvalue sub attribute ----
    # sub name : lvalue -> func name (strip :lvalue)
    if (match($trimmed, "^sub\\s+[A-Za-z_].*:\\s*lvalue")) {
        $result = replace($result, "\\s*:\\s*lvalue\\b", "");
        $result = $result . "  # REVIEW: lvalue sub â€” Strada has no lvalue function support; refactor callers to use setter methods";
        # Fall through for normal sub->func conversion
    }

    # ---- Pragmas and use statements ----

    # Remove use strict/warnings/feature
    if (match($trimmed, "^use\\s+strict")) {
        return $indent . "# " . $trimmed . "  # Not needed in Strada";
    }
    if (match($trimmed, "^use\\s+warnings")) {
        return $indent . "# " . $trimmed . "  # Not needed in Strada";
    }
    # no strict / no warnings -> comment out with category-specific notes
    if (match($trimmed, "^no\\s+strict")) {
        if (match($trimmed, "no\\s+strict\\s+['\"]refs['\"]")) {
            return $indent . "# " . $trimmed . "\n" . $indent . "# REVIEW: symbolic refs below â€” Strada alternatives:\n" . $indent . "#   Method dispatch: my scalar $__fn = $obj->can($name); $__fn->($obj, args);\n" . $indent . "#   Func dispatch: my hash %dispatch = (\"name\" => \\&func, ...); $dispatch{$key}->(args);\n" . $indent . "#   Pkg vars: core::global_get(\"Pkg::var\"), core::global_set(\"Pkg::var\", val);";
        }
        if (match($trimmed, "no\\s+strict\\s+['\"]subs['\"]")) {
            return $indent . "# " . $trimmed . "  # Not needed in Strada (barewords are not an issue)";
        }
        return $indent . "# " . $trimmed . "  # Not needed in Strada";
    }
    if (match($trimmed, "^no\\s+warnings")) {
        if (match($trimmed, "no\\s+warnings\\s+['\"]redefine['\"]")) {
            return $indent . "# " . $trimmed . "  # Strada allows function redefinition without warnings";
        }
        if (match($trimmed, "no\\s+warnings\\s+['\"]once['\"]")) {
            return $indent . "# " . $trimmed . "  # Strada does not warn on single-use variables";
        }
        if (match($trimmed, "no\\s+warnings\\s+['\"]uninitialized['\"]")) {
            return $indent . "# " . $trimmed . "  # Strada initializes variables; undef access returns undef safely";
        }
        if (match($trimmed, "no\\s+warnings\\s+['\"]numeric['\"]")) {
            return $indent . "# " . $trimmed . "  # Not needed in Strada (type system handles numeric context)";
        }
        if (match($trimmed, "no\\s+warnings\\s+['\"]experimental")) {
            return $indent . "# " . $trimmed . "  # Not needed in Strada";
        }
        return $indent . "# " . $trimmed . "  # Not needed in Strada";
    }
    if (match($trimmed, "^use\\s+feature")) {
        return $indent . "# " . $trimmed . "  # Strada has these built-in";
    }
    # use if $condition, 'Module' -> extract module, comment with conditional note
    if (match($trimmed, "^use\\s+if\\s")) {
        my array @uif_cap = capture($trimmed, "^use\\s+if\\s+(.+?),\\s*['\"]?([A-Z][A-Za-z0-9_:]*)['\"]?");
        if (scalar(@uif_cap) > 2) {
            my str $uif_cond = trim_str($uif_cap[1]);
            my str $uif_mod = $uif_cap[2];
            return $indent . "# use " . $uif_mod . ";  # REVIEW: was conditional (if " . $uif_cond . ") - enable if needed";
        }
        return $indent . "# " . $trimmed . "  # REVIEW: conditional use - check if module is needed";
    }
    if (match($trimmed, "^use\\s+utf8")) {
        return $indent . "# " . $trimmed;
    }
    # use mro 'c3' -> comment out (Strada uses C3 by default)
    if (match($trimmed, "^use\\s+mro")) {
        return $indent . "# " . $trimmed . "  # Not needed - Strada uses C3 method resolution by default";
    }
    # use vars qw($x @y %z) -> our scalar $x; my array @y; my hash %z;
    if (match($trimmed, "^use\\s+vars\\s")) {
        # Extract variable list from qw() or quoted list
        my str $vars_str = "";
        if (match($trimmed, "qw[\\(/\\[!{]")) {
            my str $uv_converted = convert_qw($trimmed);
            my array @uv_cap = capture($uv_converted, "\\((.*)\\)");
            if (scalar(@uv_cap) > 1) {
                $vars_str = $uv_cap[1];
            }
        } elsif (match($trimmed, "\\(.*\\)")) {
            my array @uv_cap2 = capture($trimmed, "\\((.*)\\)");
            if (scalar(@uv_cap2) > 1) {
                $vars_str = $uv_cap2[1];
            }
        } elsif (match($trimmed, "^use\\s+vars\\s+[@%\\$]")) {
            # Bare list form: use vars @EXPORT, @EXPORT_OK;
            my array @uv_cap3 = capture($trimmed, "^use\\s+vars\\s+(.+);");
            if (scalar(@uv_cap3) > 1) {
                # Split by comma, items are bare variable names (no quotes needed)
                my str $bare_list = trim_str($uv_cap3[1]);
                my array @bare_vars = split(",", $bare_list);
                my str $uv_result3 = "";
                my int $bvi = 0;
                while ($bvi < scalar(@bare_vars)) {
                    my str $bvar = trim_str($bare_vars[$bvi]);
                    if (length($bvar) > 0) {
                        if ($bvar eq "@ISA") {
                            $uv_result3 = $uv_result3 . $indent . "# " . $bvar . " â€” not needed in Strada (use extends)\n";
                        } elsif ($bvar eq "@EXPORT" || $bvar eq "@EXPORT_OK" || $bvar eq "@EXPORT_FAIL") {
                            $uv_result3 = $uv_result3 . $indent . "# " . $bvar . " â€” not needed in Strada (callers use Package::func())\n";
                        } elsif (starts_with($bvar, "@")) {
                            $uv_result3 = $uv_result3 . $indent . "my array " . $bvar . ";\n";
                        } elsif (starts_with($bvar, "%")) {
                            $uv_result3 = $uv_result3 . $indent . "my hash " . $bvar . ";\n";
                        } else {
                            $uv_result3 = $uv_result3 . $indent . "our scalar " . $bvar . ";\n";
                        }
                    }
                    $bvi++;
                }
                if (length($uv_result3) > 0) {
                    $uv_result3 = substr($uv_result3, 0, length($uv_result3) - 1);
                }
                return $uv_result3;
            }
        }
        if (length($vars_str) > 0) {
            # Remove quotes and split by comma
            $vars_str = replace_all($vars_str, "\"", "");
            $vars_str = replace_all($vars_str, "'", "");
            my array @vars = split(",", $vars_str);
            my str $uv_result = "";
            my int $uvi = 0;
            while ($uvi < scalar(@vars)) {
                my str $uvar = trim_str($vars[$uvi]);
                if (length($uvar) > 0) {
                    if ($uvar eq "@ISA") {
                        $uv_result = $uv_result . $indent . "# " . $uvar . " â€” not needed in Strada (use extends)\n";
                    } elsif ($uvar eq "@EXPORT" || $uvar eq "@EXPORT_OK" || $uvar eq "@EXPORT_FAIL") {
                        $uv_result = $uv_result . $indent . "# " . $uvar . " â€” not needed in Strada (callers use Package::func())\n";
                    } elsif (starts_with($uvar, "@")) {
                        $uv_result = $uv_result . $indent . "my array " . $uvar . ";\n";
                    } elsif (starts_with($uvar, "%")) {
                        $uv_result = $uv_result . $indent . "my hash " . $uvar . ";\n";
                    } else {
                        $uv_result = $uv_result . $indent . "our scalar " . $uvar . ";\n";
                    }
                }
                $uvi++;
            }
            # Remove trailing newline
            if (length($uv_result) > 0) {
                $uv_result = substr($uv_result, 0, length($uv_result) - 1);
            }
            return $uv_result;
        }
        return $indent . "# " . $trimmed . "  # REVIEW: use vars â€” convert to 'our' declarations";
    }
    # use lib 'path' -> use lib "path"  (convert single quotes to double quotes)
    if (match($trimmed, "^use\\s+lib\\s+")) {
        my str $lib_line = $trimmed;
        $lib_line = replace_all($lib_line, "'", "\"");
        return $indent . $lib_line;
    }
    # use VERSION (e.g. use 5.006;) or require VERSION -> comment out
    if (match($trimmed, "^use\\s+[0-9]") || match($trimmed, "^use\\s+v[0-9]")) {
        return $indent . "# " . $trimmed . "  # Perl version requirement";
    }
    if (match($trimmed, "^require\\s+[0-9]") || match($trimmed, "^require\\s+v[0-9]")) {
        return $indent . "# " . $trimmed . "  # Perl version requirement";
    }
    # require Module; -> use Module; with REVIEW (runtime loading)
    if (match($trimmed, "^require\\s+[A-Z][A-Za-z0-9_:]*\\s*;")) {
        my array @req_cap = capture($trimmed, "^require\\s+([A-Z][A-Za-z0-9_:]*)");
        if (scalar(@req_cap) > 1) {
            my str $req_mod = $req_cap[1];
            $result = $indent . "use " . $req_mod . ";";
            return $result;
        }
    }
    # require $variable; -> TODO (dynamic module loading)
    if (match($trimmed, "^require\\s+\\$[A-Za-z_]") && !match($trimmed, "#")) {
        my array @reqv_cap = capture($trimmed, "^require\\s+(\\$[A-Za-z_][A-Za-z0-9_]*)");
        if (scalar(@reqv_cap) > 1) {
            my str $reqv_var = $reqv_cap[1];
            return $indent . "# require " . $reqv_var . ";  # REVIEW: dynamic module loading - use import_lib(" . $reqv_var . ") or load at compile time with 'use'";
        }
    }

    # use Moose / use Moo / use Mouse -> Strada has native declarative OOP
    if (match($trimmed, "^use\\s+Moose\\b") || match($trimmed, "^use\\s+Moo\\b") || match($trimmed, "^use\\s+Mouse\\b")) {
        return $indent . "# " . $trimmed . "  # Strada has native declarative OOP (has/extends/with/before/after/around)";
    }
    # Moose type constraints module
    if (match($trimmed, "^use\\s+Moose::") || match($trimmed, "^use\\s+MooseX::") || match($trimmed, "^use\\s+Moo::") || match($trimmed, "^use\\s+Mouse::")) {
        return $indent . "# " . $trimmed . "  # Not needed in Strada";
    }
    # use namespace::autoclean / use namespace::clean -> not needed
    if (match($trimmed, "^use\\s+namespace::")) {
        return $indent . "# " . $trimmed . "  # Not needed in Strada";
    }
    # use Types::Standard / use Type::Tiny -> not needed (Strada has native types)
    if (match($trimmed, "^use\\s+Types?::")) {
        return $indent . "# " . $trimmed . "  # Strada has native type system";
    }

    # Moose has [qw(attr1 attr2)] => (...) -> multiple has declarations (full option support)
    if (match($trimmed, "^has\\s+\\[")) {
        my array @mha_cap = capture($trimmed, "^has\\s+\\[qw[\\(\\[]\\s*([^)\\]]+)\\s*[)\\]]\\]\\s*=>\\s*\\((.*)\\)\\s*;");
        if (scalar(@mha_cap) > 2) {
            my array @mha_attrs = split("\\s+", trim_str($mha_cap[1]));
            my str $mha_opts = $mha_cap[2];
            my str $mha_result = "";
            my int $mhai = 0;
            while ($mhai < scalar(@mha_attrs)) {
                my str $mha_name = trim_str($mha_attrs[$mhai]);
                if (length($mha_name) > 0) {
                    if (length($mha_result) > 0) {
                        $mha_result = $mha_result . "\n";
                    }
                    $mha_result = $mha_result . generate_has_decl($mha_name, $mha_opts, $indent);
                }
                $mhai++;
            }
            if (length($mha_result) > 0) {
                return $mha_result;
            }
        }
        # Also try quoted list form: has ['attr1', 'attr2'] => (...)
        my array @mhq_cap = capture($trimmed, "^has\\s+\\[([^\\]]+)\\]\\s*=>\\s*\\((.*)\\)\\s*;");
        if (scalar(@mhq_cap) > 2) {
            my str $mhq_list = $mhq_cap[1];
            # Strip quotes: 'attr1', 'attr2' -> attr1 attr2
            $mhq_list = replace_all($mhq_list, "'", "");
            $mhq_list = replace_all($mhq_list, "\"", "");
            $mhq_list = replace_all($mhq_list, ",", " ");
            my array @mhq_attrs = split("\\s+", trim_str($mhq_list));
            my str $mhq_opts = $mhq_cap[2];
            my str $mhq_result = "";
            my int $mhqi = 0;
            while ($mhqi < scalar(@mhq_attrs)) {
                my str $mhq_name = trim_str($mhq_attrs[$mhqi]);
                if (length($mhq_name) > 0) {
                    if (length($mhq_result) > 0) {
                        $mhq_result = $mhq_result . "\n";
                    }
                    $mhq_result = $mhq_result . generate_has_decl($mhq_name, $mhq_opts, $indent);
                }
                $mhqi++;
            }
            if (length($mhq_result) > 0) {
                return $mhq_result;
            }
        }
        return $result . "  # REVIEW: convert multi-attr has [...] to individual Strada has declarations";
    }

    # Moose has '+attr' => (...) -> subclass attribute override â†’ redefine has
    if (match($trimmed, "^has\\s+['\"]\\+")) {
        my array @hplus_cap = capture($trimmed, "^has\\s+['\"]\\+([a-z_][a-z0-9_]*)['\"]\\s*=>\\s*\\((.*)\\)\\s*;");
        if (scalar(@hplus_cap) > 2) {
            my str $hp_name = $hplus_cap[1];
            my str $hp_opts = $hplus_cap[2];
            my str $hp_decl = generate_has_decl($hp_name, $hp_opts, $indent);
            # Append override comment
            if (match($hp_decl, "\n")) {
                # Multi-line (has extra methods) â€” add comment to first line
                my int $hp_nl = index($hp_decl, "\n");
                my str $hp_first = substr($hp_decl, 0, $hp_nl);
                my str $hp_rest = substr($hp_decl, $hp_nl, length($hp_decl) - $hp_nl);
                $hp_decl = $hp_first . "  # overrides parent attribute '" . $hp_name . "'" . $hp_rest;
            } else {
                $hp_decl = $hp_decl . "  # overrides parent attribute '" . $hp_name . "'";
            }
            return $hp_decl;
        }
        return $indent . "# " . $trimmed . "  # REVIEW: subclass attribute override (has '+attr')";
    }

    # Moose 'has' attribute declaration -> Strada has declaration
    # has 'name' => (is => 'ro', isa => 'Str', default => 'value');
    # has 'name' => (is => 'rw', required => 1);
    if (match($trimmed, "^has\\s+['\"]?[a-z_]")) {
        my array @has_cap = capture($trimmed, "^has\\s+['\"]([a-z_][a-z0-9_]*)['\"]\\s*=>\\s*\\((.*)\\)\\s*;");
        if (scalar(@has_cap) > 2) {
            my str $attr_name = $has_cap[1];
            my str $attr_opts = $has_cap[2];
            # Parse options
            my str $is_mode = "ro";
            my str $isa_type = "scalar";
            my str $default_val = "";
            my int $is_required = 0;
            my int $is_lazy = 0;
            my str $builder = "";

            if (match($attr_opts, "is\\s*=>\\s*['\"]rw['\"]")) { $is_mode = "rw"; }
            if (match($attr_opts, "isa\\s*=>\\s*['\"]Str['\"]")) { $isa_type = "str"; }
            if (match($attr_opts, "isa\\s*=>\\s*['\"]Int['\"]")) { $isa_type = "int"; }
            if (match($attr_opts, "isa\\s*=>\\s*['\"]Num['\"]")) { $isa_type = "num"; }
            if (match($attr_opts, "isa\\s*=>\\s*['\"]Bool['\"]")) { $isa_type = "int"; }
            if (match($attr_opts, "isa\\s*=>\\s*['\"]ArrayRef")) { $isa_type = "scalar"; }
            if (match($attr_opts, "isa\\s*=>\\s*['\"]HashRef")) { $isa_type = "scalar"; }
            if (match($attr_opts, "isa\\s*=>\\s*['\"]CodeRef['\"]")) { $isa_type = "scalar"; }
            if (match($attr_opts, "isa\\s*=>\\s*['\"]ClassName['\"]")) { $isa_type = "str"; }
            if (match($attr_opts, "isa\\s*=>\\s*['\"]Object['\"]")) { $isa_type = "scalar"; }
            if (match($attr_opts, "isa\\s*=>\\s*['\"]Maybe\\[")) { $isa_type = "scalar"; }
            if (match($attr_opts, "required\\s*=>\\s*1")) { $is_required = 1; }
            if (match($attr_opts, "lazy\\s*=>\\s*1")) { $is_lazy = 1; }

            # Extract default value
            my array @def_cap = capture($attr_opts, "default\\s*=>\\s*([^,)]+)");
            if (scalar(@def_cap) > 1) {
                $default_val = trim_str($def_cap[1]);
                # Convert sub { ... } -> extract the value
                if (match($default_val, "^sub\\s*\\{")) {
                    # sub { [] } -> []
                    if (match($attr_opts, "default\\s*=>\\s*sub\\s*\\{\\s*\\[\\]\\s*\\}")) {
                        $default_val = "[]";
                    }
                    # sub { {} } -> {}
                    elsif (match($attr_opts, "default\\s*=>\\s*sub\\s*\\{\\s*\\{\\}\\s*\\}")) {
                        $default_val = "{}";
                    }
                    # sub { "value" } or sub { 'value' } -> "value"
                    elsif (match($attr_opts, "default\\s*=>\\s*sub\\s*\\{\\s*['\"]([^'\"]*)['\"]\\s*\\}")) {
                        my array @sdef_cap = capture($attr_opts, "default\\s*=>\\s*sub\\s*\\{\\s*['\"]([^'\"]*)['\"]\\s*\\}");
                        if (scalar(@sdef_cap) > 1) {
                            $default_val = "\"" . $sdef_cap[1] . "\"";
                        } else {
                            $default_val = "";
                        }
                    }
                    # sub { NUMBER } -> NUMBER
                    elsif (match($attr_opts, "default\\s*=>\\s*sub\\s*\\{\\s*(-?[0-9]+\\.?[0-9]*)\\s*\\}")) {
                        my array @ndef_cap = capture($attr_opts, "default\\s*=>\\s*sub\\s*\\{\\s*(-?[0-9]+\\.?[0-9]*)\\s*\\}");
                        if (scalar(@ndef_cap) > 1) {
                            $default_val = $ndef_cap[1];
                        } else {
                            $default_val = "";
                        }
                    }
                    else {
                        $default_val = "";  # Complex defaults need manual conversion
                    }
                }
            }

            # Extract builder
            my array @bld_cap = capture($attr_opts, "builder\\s*=>\\s*['\"]([^'\"]+)['\"]");
            if (scalar(@bld_cap) > 1) {
                $builder = $bld_cap[1];
            }

            # Build Strada has declaration
            my str $has_decl = $indent . "has " . $is_mode . " " . $isa_type . " $" . $attr_name;
            if (length($default_val) > 0) {
                $has_decl = $has_decl . " = " . $default_val;
            }
            if ($is_required == 1) {
                $has_decl = $has_decl . " (required)";
            } elsif ($is_lazy == 1) {
                if (length($builder) > 0) {
                    $has_decl = $has_decl . " (lazy, builder => \"" . $builder . "\")";
                } else {
                    $has_decl = $has_decl . " (lazy)";
                }
            } elsif (length($builder) > 0) {
                $has_decl = $has_decl . " (builder => \"" . $builder . "\")";
            }
            $has_decl = $has_decl . ";";

            # Generate code for Moose options
            my str $extra_methods = "";

            if (match($attr_opts, "\\btrigger\\b")) {
                # trigger => sub { my ($self, $new, $old) = @_; ... }
                # Generate an after hook on set_NAME
                my str $trigger_body = "# trigger callback body";
                # Try to extract simple trigger body
                my array @trig_cap = capture($attr_opts, "trigger\\s*=>\\s*sub\\s*\\{([^}]*)\\}");
                if (scalar(@trig_cap) > 1) {
                    $trigger_body = trim_str($trig_cap[1]);
                    # Remove the my ($self, ...) = @_; unpacking
                    $trigger_body = replace($trigger_body, "^my\\s*\\([^)]*\\)\\s*=\\s*@_;?\\s*", "");
                    if (length($trigger_body) == 0) {
                        $trigger_body = "# trigger callback was empty";
                    }
                }
                $extra_methods = $extra_methods . "\n" . $indent . "after \"set_" . $attr_name . "\" func(scalar $self) void { " . $trigger_body . " }";
            }
            if (match($attr_opts, "\\bcoerce\\b")) {
                # coerce => 1 â€” Strada's type system handles basic coercion
                $has_decl = $has_decl . "  # Note: had coerce => 1 â€” Strada handles basic type coercion natively";
            }
            if (match($attr_opts, "\\bhandles\\b")) {
                # Extract handles array: handles => [qw(method1 method2)]
                # or handles => ['method1', 'method2']
                my array @hdl_cap = capture($attr_opts, "handles\\s*=>\\s*\\[([^\\]]+)\\]");
                if (scalar(@hdl_cap) > 1) {
                    my str $hdl_list = $hdl_cap[1];
                    # Strip qw() wrapper if present
                    if (match($hdl_list, "^qw")) {
                        $hdl_list = replace($hdl_list, "^qw[\\(\\[]\\s*", "");
                        $hdl_list = replace($hdl_list, "\\s*[)\\]]\\s*$", "");
                    }
                    # Strip quotes: 'method1', 'method2' -> method1 method2
                    $hdl_list = replace_all($hdl_list, "'", "");
                    $hdl_list = replace_all($hdl_list, "\"", "");
                    $hdl_list = replace_all($hdl_list, ",", " ");
                    my array @hdl_methods = split("\\s+", trim_str($hdl_list));
                    my int $hmi = 0;
                    while ($hmi < scalar(@hdl_methods)) {
                        my str $hm_name = trim_str($hdl_methods[$hmi]);
                        if (length($hm_name) > 0) {
                            $extra_methods = $extra_methods . "\n" . $indent . "func " . $hm_name . "(scalar $self, scalar ...@_) dynamic { return $self->" . $attr_name . "()->" . $hm_name . "(@_); }";
                        }
                        $hmi++;
                    }
                    $has_decl = $has_decl . "  # handles delegation via " . $attr_name;
                } else {
                    # Try hash form: handles => { alias => 'method', ... }
                    my array @hdl_hash_cap = capture($attr_opts, "handles\\s*=>\\s*\\{([^}]+)\\}");
                    if (scalar(@hdl_hash_cap) > 1) {
                        my str $hdl_hash_body = $hdl_hash_cap[1];
                        # Parse alias => 'method' pairs
                        my array @hdl_pairs = split(",", $hdl_hash_body);
                        my int $hpi = 0;
                        while ($hpi < scalar(@hdl_pairs)) {
                            my str $hp = trim_str($hdl_pairs[$hpi]);
                            if (length($hp) > 0) {
                                my array @hp_cap = capture($hp, "([A-Za-z_][A-Za-z0-9_]*)\\s*=>\\s*['\"]?([A-Za-z_][A-Za-z0-9_]*)['\"]?");
                                if (scalar(@hp_cap) > 2) {
                                    my str $hp_alias = $hp_cap[1];
                                    my str $hp_method = $hp_cap[2];
                                    $extra_methods = $extra_methods . "\n" . $indent . "func " . $hp_alias . "(scalar $self, scalar ...@_) dynamic { return $self->" . $attr_name . "()->" . $hp_method . "(@_); }";
                                }
                            }
                            $hpi++;
                        }
                        $has_decl = $has_decl . "  # handles delegation (aliased) via " . $attr_name;
                    } else {
                        $has_decl = $has_decl . "  # REVIEW: had delegation via handles â€” implement wrapper methods that call delegated object";
                    }
                }
            }
            if (match($attr_opts, "\\bclearer\\b")) {
                # Extract clearer method name
                my array @clr_cap = capture($attr_opts, "clearer\\s*=>\\s*['\"]([^'\"]+)['\"]");
                my str $clr_name = "clear_" . $attr_name;
                if (scalar(@clr_cap) > 1) {
                    $clr_name = $clr_cap[1];
                }
                $extra_methods = $extra_methods . "\n" . $indent . "func " . $clr_name . "(scalar $self) void { $self->{\"" . $attr_name . "\"} = undef; }";
            }
            if (match($attr_opts, "\\bpredicate\\b")) {
                # Extract predicate method name
                my array @pred_cap = capture($attr_opts, "predicate\\s*=>\\s*['\"]([^'\"]+)['\"]");
                my str $pred_name = "has_" . $attr_name;
                if (scalar(@pred_cap) > 1) {
                    $pred_name = $pred_cap[1];
                }
                $extra_methods = $extra_methods . "\n" . $indent . "func " . $pred_name . "(scalar $self) int { return defined($self->{\"" . $attr_name . "\"}); }";
            }
            if (match($attr_opts, "\\bweak_ref\\b")) {
                $extra_methods = $extra_methods . "\n" . $indent . "after \"new\" func(scalar $self) void { if (defined($self->{\"" . $attr_name . "\"})) { core::weaken($self->{\"" . $attr_name . "\"}); } }";
            }
            return $has_decl . $extra_methods;
        }
        # Simpler has: has 'name' => (...) without successful parse
        return $result . "  # REVIEW: convert Moose/Moo 'has' to Strada 'has ro|rw type $name'";
    }

    # Class::Accessor mk_accessors/mk_ro_accessors -> has rw/ro scalar declarations
    if (match($trimmed, "mk_accessors\\s*\\(") || match($trimmed, "mk_ro_accessors\\s*\\(") || match($trimmed, "mk_wo_accessors\\s*\\(")) {
        my str $ca_rw = "rw";
        if (match($trimmed, "mk_ro_accessors")) { $ca_rw = "ro"; }
        if (match($trimmed, "mk_wo_accessors")) { $ca_rw = "rw"; }
        # Extract qw() list
        my str $ca_line = $trimmed;
        if (match($ca_line, "qw")) {
            $ca_line = convert_qw($ca_line);
        }
        # Now extract names from parenthesized list
        my array @ca_outer = capture($ca_line, "\\((.*)\\)");
        if (scalar(@ca_outer) > 1) {
            my str $ca_inner = $ca_outer[1];
            # Clean up: remove quotes and commas, split on whitespace
            $ca_inner = replace_all($ca_inner, "'", "");
            $ca_inner = replace_all($ca_inner, "\"", "");
            $ca_inner = replace_all($ca_inner, ",", " ");
            $ca_inner = trim_str($ca_inner);
            if (length($ca_inner) > 0) {
                my array @ca_names = split(" ", $ca_inner);
                my str $ca_result = "";
                my int $cai = 0;
                while ($cai < length($ca_inner)) {
                    # Manual split on spaces
                    $cai = length($ca_inner);
                }
                # Use split result
                $ca_result = "";
                $cai = 0;
                while ($cai < scalar(@ca_names)) {
                    my str $ca_name = trim_str($ca_names[$cai]);
                    if (length($ca_name) > 0) {
                        if (length($ca_result) > 0) { $ca_result = $ca_result . "\n"; }
                        $ca_result = $ca_result . $indent . "has " . $ca_rw . " scalar " . chr(36) . $ca_name . ";";
                    }
                    $cai++;
                }
                if (length($ca_result) > 0) { return $ca_result; }
            }
        }
        return $indent . "# " . $trimmed . "  # REVIEW: convert mk_accessors to 'has rw|ro scalar'";
    }

    # Moose/Moo extends -> Strada extends (supports multiple parents)
    if (match($trimmed, "^extends\\s+['\"]")) {
        # Extract all quoted names: extends 'A', 'B', 'C';
        my str $ext_rest = $trimmed;
        $ext_rest = replace($ext_rest, "^extends\\s+", "");
        my str $ext_result = "";
        my int $ext_safety = 0;
        while (match($ext_rest, "['\"]([A-Za-z_:][A-Za-z0-9_:]*)['\"]") && $ext_safety < 20) {
            my array @ep = capture($ext_rest, "['\"]([A-Za-z_:][A-Za-z0-9_:]*)['\"]");
            if (scalar(@ep) > 1) {
                if (length($ext_result) > 0) {
                    $ext_result = $ext_result . "\n";
                }
                $ext_result = $ext_result . $indent . "extends " . $ep[1] . ";";
                $ext_rest = replace($ext_rest, "['\"]" . $ep[1] . "['\"]", "");
            } else {
                $ext_safety = 20;
            }
            $ext_safety++;
        }
        if (length($ext_result) > 0) {
            return $ext_result;
        }
    }

    # Moose/Moo with -> Strada with (supports multiple roles)
    if (match($trimmed, "^with\\s+['\"]")) {
        # Extract all quoted names: with 'A', 'B', 'C';
        my str $with_rest = $trimmed;
        $with_rest = replace($with_rest, "^with\\s+", "");
        my str $with_result = "";
        my int $with_safety = 0;
        while (match($with_rest, "['\"]([A-Za-z_:][A-Za-z0-9_:]*)['\"]") && $with_safety < 20) {
            my array @wp = capture($with_rest, "['\"]([A-Za-z_:][A-Za-z0-9_:]*)['\"]");
            if (scalar(@wp) > 1) {
                if (length($with_result) > 0) {
                    $with_result = $with_result . "\n";
                }
                $with_result = $with_result . $indent . "with " . $wp[1] . ";";
                $with_rest = replace($with_rest, "['\"]" . $wp[1] . "['\"]", "");
            } else {
                $with_safety = 20;
            }
            $with_safety++;
        }
        if (length($with_result) > 0) {
            return $with_result;
        }
    }

    # Moose::Role requires -> Strada requires (pass through)
    if (match($trimmed, "^requires\\s+")) {
        # requires 'method_name'; or requires qw(method1 method2);
        if (match($trimmed, "^requires\\s+qw")) {
            # requires qw(m1 m2 m3); -> multiple requires lines
            my array @rq_cap = capture($trimmed, "^requires\\s+qw[\\(\\[]\\s*([^)\\]]+)\\s*[)\\]]");
            if (scalar(@rq_cap) > 1) {
                my array @rq_methods = split("\\s+", trim_str($rq_cap[1]));
                my str $rq_result = "";
                my int $rqi = 0;
                while ($rqi < scalar(@rq_methods)) {
                    my str $rq_m = trim_str($rq_methods[$rqi]);
                    if (length($rq_m) > 0) {
                        if (length($rq_result) > 0) {
                            $rq_result = $rq_result . "\n";
                        }
                        $rq_result = $rq_result . $indent . "requires \"" . $rq_m . "\";";
                    }
                    $rqi++;
                }
                if (length($rq_result) > 0) {
                    return $rq_result;
                }
            }
        }
        # requires 'method_name';
        my array @rqs_cap = capture($trimmed, "^requires\\s+['\"]([A-Za-z_][A-Za-z0-9_]*)['\"]");
        if (scalar(@rqs_cap) > 1) {
            return $indent . "requires \"" . $rqs_cap[1] . "\";";
        }
    }

    # Moose before/after/around -> Strada before/after/around
    if (match($trimmed, "^(before|after|around)\\s+['\"]")) {
        my array @hook_cap = capture($trimmed, "^(before|after|around)\\s+['\"]([A-Za-z_]+)['\"]\\s*=>\\s*sub\\s*\\{");
        if (scalar(@hook_cap) > 2) {
            my str $hook_type = $hook_cap[1];
            my str $hook_method = $hook_cap[2];
            if ($hook_type eq "around") {
                return $indent . $hook_type . " \"" . $hook_method . "\" func(scalar $self, scalar $orig, scalar ...@args) scalar {";
            } else {
                return $indent . $hook_type . " \"" . $hook_method . "\" func(scalar $self) void {";
            }
        }
    }

    # override 'method' => sub { ... } -> func method(scalar $self, ...) { ... }
    # Moose 'override' just redefines the parent method; in Strada, just declare func
    if (match($trimmed, "^override\\s+['\"]")) {
        my array @ovr_cap = capture($trimmed, "^override\\s+['\"]([A-Za-z_][A-Za-z0-9_]*)['\"]\\s*=>\\s*sub\\s*\\{");
        if (scalar(@ovr_cap) > 1) {
            my str $ovr_method = $ovr_cap[1];
            return $indent . "func " . $ovr_method . "(scalar $self) scalar {  # override";
        }
    }
    # augment 'method' => sub { ... } -> func method(scalar $self, ...) { ... }
    # Moose 'augment' is the inverse of override; in Strada, just declare func
    if (match($trimmed, "^augment\\s+['\"]")) {
        my array @aug_cap = capture($trimmed, "^augment\\s+['\"]([A-Za-z_][A-Za-z0-9_]*)['\"]\\s*=>\\s*sub\\s*\\{");
        if (scalar(@aug_cap) > 1) {
            my str $aug_method = $aug_cap[1];
            return $indent . "func " . $aug_method . "(scalar $self) scalar {  # augment";
        }
    }

    # __PACKAGE__->meta->make_immutable -> comment out (Moose optimization)
    if (match($trimmed, "meta->make_immutable")) {
        return $indent . "# " . $trimmed . "  # Not needed in Strada";
    }

    # no Moose / no Moo -> comment out
    if (match($trimmed, "^no\\s+Moose") || match($trimmed, "^no\\s+Moo\\b") || match($trimmed, "^no\\s+Mouse")) {
        return $indent . "# " . $trimmed . "  # Not needed in Strada";
    }

    # Moose subtype/coerce declarations -> TODO
    if (match($trimmed, "^subtype\\s+['\"]") && !match($result, "#")) {
        return $indent . "# " . $trimmed . "  # REVIEW: Moose subtype - Strada uses native types; add validation in constructor or setter";
    }
    if (match($trimmed, "^coerce\\s+['\"]") && !match($result, "#")) {
        return $indent . "# " . $trimmed . "  # REVIEW: Moose coerce - add coercion logic in constructor or setter";
    }

    # use Getopt::Std -> comment (use core::argv() directly)
    if (match($trimmed, "^use\\s+Getopt::Std")) {
        return $indent . "# " . $trimmed . "  # Use core::argv() directly in Strada";
    }
    # use Getopt::Long -> pass through (native Strada module planned)
    if (match($trimmed, "^use\\s+Getopt::Long")) {
        return $indent . "use Getopt::Long;  # REVIEW: native Strada module planned";
    }
    # Catch any other Getopt variants
    if (match($trimmed, "^use\\s+Getopt")) {
        return $indent . "# " . $trimmed . "  # REVIEW: use core::argv() or Getopt::Long in Strada";
    }
    # use Exporter / require Exporter - not needed in Strada
    if (match($trimmed, "^use\\s+Exporter")) {
        return $indent . "# " . $trimmed . "  # Not needed in Strada (callers use Package::func())";
    }
    if (match($trimmed, "^require\\s+Exporter")) {
        return $indent . "# " . $trimmed . "  # Not needed in Strada";
    }
    # use base/parent 'Exporter' - comment out if Exporter is the ONLY parent
    # If there are other parents (e.g., use parent qw(Exporter Base::Class)), let it
    # fall through to the use parent -> extends handler which strips Exporter from the list
    if ((match($trimmed, "^use\\s+base\\b") || match($trimmed, "^use\\s+parent\\b")) && match($trimmed, "Exporter")) {
        # Check if Exporter is the only class listed
        if (match($trimmed, "['\"]Exporter['\"]\\s*;") || match($trimmed, "qw[\\(\\[]\\s*Exporter\\s*[)\\]]")) {
            return $indent . "# " . $trimmed . "  # Not needed in Strada (callers use Package::func())";
        }
        # Multiple parents including Exporter â€” fall through to use parent -> extends handler
    }
    # use subs qw(...) -> remove (Perl compile-time forward declaration hint)
    if (match($trimmed, "^use\\s+subs\\b")) {
        return $indent . "# " . $trimmed . "  # Not needed in Strada (all subs visible within package)";
    }
    # use base / use parent -> extends
    if (match($trimmed, "^use\\s+base\\b") || match($trimmed, "^use\\s+parent\\b")) {
        # Strip -norequire option
        my str $use_line = $trimmed;
        $use_line = replace_all($use_line, "-norequire,", "");
        $use_line = replace_all($use_line, "-norequire ,", "");
        # Try qw() form: use base qw(Foo Bar)
        if (match($use_line, "qw[\\(\\[]")) {
            my array @qw_cap = capture($use_line, "qw[\\(\\[]\\s*([^)\\]]+)\\s*[)\\]]");
            if (scalar(@qw_cap) > 1) {
                my array @parents = split("\\s+", trim_str($qw_cap[1]));
                if (scalar(@parents) > 0) {
                    my str $ext_out = "";
                    my int $pi = 0;
                    while ($pi < scalar(@parents)) {
                        my str $par = trim_str($parents[$pi]);
                        if (length($par) > 0 && $par ne "Exporter") {
                            if (length($ext_out) > 0) { $ext_out = $ext_out . "\n"; }
                            $ext_out = $ext_out . $indent . "extends " . $par . ";";
                        }
                        $pi++;
                    }
                    if (length($ext_out) > 0) {
                        return $ext_out;
                    }
                }
            }
        }
        # Try quoted form: use base 'Foo::Bar' or "Foo::Bar"
        my array @q_cap = capture($use_line, "['\"]([A-Za-z_:][A-Za-z0-9_:]*)['\"]");
        if (scalar(@q_cap) > 1) {
            return $indent . "extends " . $q_cap[1] . ";";
        }
        # Fallback: comment it out
        return $indent . "# " . $trimmed . "  # REVIEW: could not parse parent class";
    }
    # use Carp
    if (match($trimmed, "^use\\s+Carp")) {
        return $indent . "# " . $trimmed . "  # Strada has die/warn with stack traces";
    }
    # use Fcntl -> comment with flock constants
    if (match($trimmed, "^use\\s+Fcntl")) {
        return $indent . "# " . $trimmed . "  # flock constants: LOCK_SH=1, LOCK_EX=2, LOCK_UN=8, LOCK_NB=4";
    }
    # use POSIX -> comment with note
    if (match($trimmed, "^use\\s+POSIX")) {
        return $indent . "# " . $trimmed . "  # REVIEW: POSIX functions â€” use core:: or __C__ equivalents";
    }
    # use overload -> natively supported in Strada, pass through
    if (match($trimmed, "^use\\s+overload")) {
        # Strada supports use overload natively with same syntax
        # Preserve '""' (stringify) as-is â€” don't convert its quotes
        my str $ol = $trimmed;
        # Temporarily protect '""' from quote conversion
        $ol = replace_all($ol, "'\"\"'", "STRADA_STRINGIFY_OP");
        $ol = replace_all($ol, "'", "\"");
        $ol = replace_all($ol, "STRADA_STRINGIFY_OP", "'\"\"'");
        # Convert \&method_name to "method_name" (Strada uses string method names)
        my int $ol_safety = 0;
        while (match($ol, "\\\\&[A-Za-z_][A-Za-z0-9_]*") && $ol_safety < 20) {
            my array @ol_cap = capture($ol, "\\\\&([A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@ol_cap) > 1) {
                my str $mname = $ol_cap[1];
                # Map to the Strada overload method name
                # Most methods keep their name; just wrap in quotes
                $ol = replace_all($ol, "\\&" . $mname, "\"" . $mname . "\"");
            } else {
                $ol_safety = 20;
            }
            $ol_safety++;
        }
        # Extract inline sub { ... } blocks and replace with named methods
        my str $extra_ol_methods = "";
        my int $sub_safety = 0;
        while (match($ol, "\\bsub\\s*\\{") && $sub_safety < 10) {
            # Find the operator name before this sub: "op" => sub {
            my array @sub_op_cap = capture($ol, "\"([^\"]+)\"\\s*=>\\s*sub\\s*\\{");
            if (scalar(@sub_op_cap) <= 1) { $sub_safety = 10; next; }
            my str $sub_op = $sub_op_cap[1];
            my str $sub_mname = op_name_for_overload($sub_op);

            # Find the matching closing brace
            my int $sub_start = index($ol, "sub {");
            if ($sub_start < 0) { $sub_start = index($ol, "sub{"); }
            if ($sub_start < 0) { $sub_safety = 10; next; }
            my int $brace_start = index($ol, "{", $sub_start);
            my int $sub_depth = 1;
            my int $sub_i = $brace_start + 1;
            my int $ol_len = length($ol);
            while ($sub_i < $ol_len && $sub_depth > 0) {
                my int $sub_ch = char_at($ol, $sub_i);
                if ($sub_ch == 123) { $sub_depth++; }
                if ($sub_ch == 125) { $sub_depth--; }
                if ($sub_ch == 34) {
                    $sub_i++;
                    while ($sub_i < $ol_len && char_at($ol, $sub_i) != 34) {
                        if (char_at($ol, $sub_i) == 92) { $sub_i++; }
                        $sub_i++;
                    }
                }
                $sub_i++;
            }
            # Extract the sub body
            my str $sub_body = substr($ol, $brace_start + 1, $sub_i - $brace_start - 2);
            $sub_body = replace($sub_body, "^\\s+", "");
            $sub_body = replace($sub_body, "\\s+$", "");
            # Strip leading my ($self, ...) = @_; from body
            $sub_body = replace($sub_body, "^my\\s*\\([^)]*\\)\\s*=\\s*@_\\s*;\\s*", "");

            # Generate the method
            my str $gen_method = "";
            if (is_unary_overload($sub_op) == 1) {
                $gen_method = "func " . $sub_mname . "(scalar $self) scalar {  # REVIEW: converted from inline overload sub\n    " . $sub_body . "\n}";
            } else {
                $gen_method = "func " . $sub_mname . "(scalar $self, scalar $other, int $reversed) scalar {  # REVIEW: converted from inline overload sub\n    " . $sub_body . "\n}";
            }
            $extra_ol_methods = $extra_ol_methods . "\n" . $gen_method . "\n";

            # Replace the sub { ... } with "method_name" using position-based approach
            # Find "op" => before sub_start to get the start of the value portion
            my str $before_sub = substr($ol, 0, $sub_start);
            my str $after_sub = substr($ol, $sub_i, length($ol) - $sub_i);
            # Trim trailing whitespace from before_sub
            $ol = $before_sub . "\"" . $sub_mname . "\"" . $after_sub;
            $sub_safety++;
        }
        if (length($extra_ol_methods) > 0) {
            return $extra_ol_methods . "\n" . $indent . $ol;
        }
        return $indent . $ol;
    }
    # overload::import() -> use overload equivalent
    if (match($trimmed, "^overload::import\\(")) {
        return $indent . "# " . $trimmed . "  # REVIEW: use 'use overload' syntax instead in Strada";
    }
    # overload::unimport() -> comment out
    if (match($trimmed, "^overload::unimport\\(")) {
        return $indent . "# " . $trimmed . "  # Not needed in Strada";
    }
    # use builtin qw(true false is_bool) - Perl 5.36+
    if (match($trimmed, "^use\\s+builtin\\b")) {
        return $indent . "# " . $trimmed . "  # Not needed in Strada - true/false converted to 1/0";
    }

    # use Data::Dumper
    if (match($trimmed, "^use\\s+Data::Dumper")) {
        return $indent . "# " . $trimmed . "  # use dumper() in Strada â€” built-in";
    }
    # use Module; -> keep but suggest import_lib
    if (match($trimmed, "^use\\s+[A-Z]") && !match($trimmed, "^use\\s+constant")) {
        my array @mcap = capture($trimmed, "^use\\s+([A-Za-z_:][A-Za-z0-9_:]*)");
        if (scalar(@mcap) > 1) {
            my str $mod = $mcap[1];
            # Known modules with specific Strada equivalents
            if ($mod eq "Digest::MD5" || $mod eq "Digest::SHA") {
                return $indent . "use crypt;  # " . $trimmed . " â€” provides core::md5(), core::sha256(), etc.";
            }
            if ($mod eq "File::Basename") {
                return $indent . "# " . $trimmed . "  # Use core::basename() and core::dirname() in Strada";
            }
            if ($mod eq "File::Path") {
                return $indent . "# " . $trimmed . "  # Use core::mkdir() in Strada (no recursive mkdir)";
            }
            if ($mod eq "File::Find") {
                return $indent . "# " . $trimmed . "  # Use core::readdir() with recursion in Strada";
            }
            if ($mod eq "POSIX") {
                return $indent . "# " . $trimmed . "  # Many POSIX functions available as core:: in Strada";
            }
            if ($mod eq "Scalar::Util") {
                return $indent . "# " . $trimmed . "  # Use ref(), isa(), defined() in Strada";
            }
            if ($mod eq "List::Util") {
                return $indent . "use List::Util;  # Strada has a native List::Util module";
            }
            if ($mod eq "Storable") {
                return $indent . "# " . $trimmed . "  # No Storable in Strada - use JSON or custom serialization";
            }
            if ($mod eq "YAML" || $mod eq "YAML::XS" || $mod eq "YAML::Tiny") {
                return $indent . "# " . $trimmed . "  # REVIEW: no YAML library in Strada yet â€” use JSON or import_lib";
            }
            if ($mod eq "JSON" || $mod eq "JSON::XS" || $mod eq "JSON::PP") {
                return $indent . "use JSON;  # " . $trimmed;
            }
            if ($mod eq "Time::HiRes") {
                return $indent . "# " . $trimmed . "  # Use core::time(), core::usleep() in Strada";
            }
            if ($mod eq "IO::Socket::INET" || $mod eq "IO::Socket") {
                return $indent . "# " . $trimmed . "  # Use core::socket_client/core::socket_server in Strada";
            }
            if ($mod eq "Encode") {
                return $indent . "# " . $trimmed . "  # Strada strings are UTF-8 by default; encode/decode calls will be simplified";
            }
            # DBI -> use DBI
            if ($mod eq "DBI") {
                return $indent . "use DBI;  # " . $trimmed;
            }
            # Text::CSV -> use TextCSV
            if ($mod eq "Text::CSV") {
                return $indent . "use TextCSV;  # " . $trimmed;
            }
            # File::Copy -> comment with core:: hints
            if ($mod eq "File::Copy") {
                return $indent . "# " . $trimmed . "  # Use core::rename() or core::system(\"cp ...\") in Strada";
            }
            # File::Temp -> comment with core:: hints
            if ($mod eq "File::Temp") {
                return $indent . "# " . $trimmed . "  # Use core::tmpfile() or core::open(\"/tmp/...\") in Strada";
            }
            # File::Spec -> comment
            if ($mod eq "File::Spec") {
                return $indent . "# " . $trimmed . "  # Use string path operations with \"/\" in Strada";
            }
            # Cwd -> comment
            if ($mod eq "Cwd") {
                return $indent . "# " . $trimmed . "  # Use core::getcwd(), core::realpath() in Strada";
            }
            # IO::File -> comment
            if ($mod eq "IO::File") {
                return $indent . "# " . $trimmed . "  # Use core::open() in Strada";
            }
            # IO::Handle -> comment
            if ($mod eq "IO::Handle") {
                return $indent . "# " . $trimmed . "  # Not needed - Strada auto-flushes";
            }
            # IO::Select -> comment
            if ($mod eq "IO::Select") {
                return $indent . "# " . $trimmed . "  # REVIEW: use core::select() or poll in Strada";
            }
            # Socket -> comment
            if ($mod eq "Socket") {
                return $indent . "# " . $trimmed . "  # Use core::socket_client()/core::socket_server() in Strada";
            }
            # HTTP::Tiny / LWP::UserAgent -> comment
            if ($mod eq "HTTP::Tiny" || $mod eq "LWP::UserAgent") {
                return $indent . "# " . $trimmed . "  # REVIEW: use core::http_get() or import_lib for HTTP in Strada";
            }
            # MIME::Base64 -> comment
            if ($mod eq "MIME::Base64") {
                return $indent . "# " . $trimmed . "  # Use core::base64_encode()/core::base64_decode() in Strada";
            }
            # Sys::Hostname -> comment with core::gethostname hint
            if ($mod eq "Sys::Hostname") {
                return $indent . "# " . $trimmed . "  # Use core::gethostname() in Strada";
            }
            # Getopt::Std -> comment
            if ($mod eq "Getopt::Std") {
                return $indent . "# " . $trimmed . "  # Use core::argv() directly in Strada";
            }
            # Getopt::Long -> pass through (native module)
            if ($mod eq "Getopt::Long") {
                return $indent . "use Getopt::Long;  # REVIEW: native Strada module planned";
            }
            # Test::More -> comment
            if ($mod eq "Test::More") {
                return $indent . "# " . $trimmed . "  # REVIEW: no test framework in Strada yet";
            }
            # Config -> comment
            if ($mod eq "Config") {
                return $indent . "# " . $trimmed . "  # REVIEW: use core::getenv() or __C__ for config in Strada";
            }
            # IO::Socket::UNIX / IO::Socket::INET -> comment
            if ($mod eq "IO::Socket::UNIX" || $mod eq "IO::Socket::INET" || $mod eq "IO::Socket" || $mod eq "IO::Socket::SSL") {
                return $indent . "# " . $trimmed . "  # Use core::socket_client()/core::socket_server() in Strada";
            }
            # Net::DNS / Net::SMTP / Net::FTP -> comment
            if ($mod eq "Net::DNS" || $mod eq "Net::SMTP" || $mod eq "Net::FTP" || $mod eq "Net::HTTP") {
                return $indent . "# " . $trimmed . "  # REVIEW: use core::socket_client() or import_lib for networking in Strada";
            }
            # Data::Dumper -> comment
            if ($mod eq "Data::Dumper") {
                return $indent . "# " . $trimmed . "  # use dumper() in Strada â€” built-in";
            }
            # Try::Tiny -> comment (eval/try already handled)
            if ($mod eq "Try::Tiny") {
                return $indent . "# " . $trimmed . "  # Not needed - Strada has native try/catch";
            }
            # Carp -> comment
            if ($mod eq "Carp") {
                return $indent . "# " . $trimmed . "  # Strada has die/warn with stack traces (croak->die, carp->warn, confess->die)";
            }
            # File::Find -> comment
            if ($mod eq "File::Find") {
                return $indent . "# " . $trimmed . "  # REVIEW: use core::readdir() with recursion, or core::system(\"find ...\")";
            }
            # File::Path -> comment
            if ($mod eq "File::Path") {
                return $indent . "# " . $trimmed . "  # Use core::mkdir() and core::system(\"rm -rf ...\") in Strada";
            }
            # Digest::MD5 / Digest::SHA -> use crypt module
            if (match($mod, "^Digest::")) {
                return $indent . "use crypt;  # " . $trimmed . " â€” provides core::md5(), core::sha256(), etc.";
            }
            # Fcntl -> comment
            if ($mod eq "Fcntl") {
                return $indent . "# " . $trimmed . "  # REVIEW: use core::flock() and numeric constants in Strada";
            }
            # Errno -> comment
            if ($mod eq "Errno") {
                return $indent . "# " . $trimmed . "  # Use core::errno() in Strada";
            }
            # IPC::Open3 / IPC::Run -> comment
            if (match($mod, "^IPC::")) {
                return $indent . "# " . $trimmed . "  # REVIEW: use core::popen() or core::system() in Strada";
            }
            # Params::Validate / Params::Util -> comment
            if (match($mod, "^Params::")) {
                return $indent . "# " . $trimmed . "  # Not needed - Strada has native type annotations on parameters";
            }
            # Type::Tiny / Types::Standard -> comment
            if (match($mod, "^Type::") || match($mod, "^Types::")) {
                return $indent . "# " . $trimmed . "  # Not needed - Strada has native type annotations";
            }
            # Moo::Role / Moose::Role -> keep as with
            if ($mod eq "Moo::Role" || $mod eq "Moose::Role" || $mod eq "Mouse::Role" || $mod eq "Role::Tiny") {
                return $indent . "# " . $trimmed . "  # Strada supports roles natively with 'with'";
            }
            # File::Slurp -> comment with core:: hints
            if ($mod eq "File::Slurp") {
                return $indent . "# " . $trimmed . "  # Use core::slurp() and core::spew() in Strada";
            }
            # File::Slurper -> comment with core:: hints
            if ($mod eq "File::Slurper") {
                return $indent . "# " . $trimmed . "  # Use core::slurp() and core::spew() in Strada";
            }
            # File::Glob -> comment with core::glob hint
            if ($mod eq "File::Glob") {
                return $indent . "# " . $trimmed . "  # Use core::glob() in Strada";
            }
            # Sys::Syslog -> comment with core::syslog hint
            if ($mod eq "Sys::Syslog") {
                return $indent . "# " . $trimmed . "  # Use core::openlog(), core::syslog(), core::closelog() in Strada";
            }
            # Path::Tiny -> comment with core:: hints
            if ($mod eq "Path::Tiny") {
                return $indent . "# " . $trimmed . "  # REVIEW: use core::slurp(), core::spew(), core::basename(), core::dirname(), core::realpath()";
            }
            # Log::Any / Log::Log4perl / Log::Tiny -> comment
            if (match($mod, "^Log::")) {
                return $indent . "# " . $trimmed . "  # REVIEW: use say()/warn() or core::syslog() for logging in Strada";
            }
            # Term::ANSIColor / Term::ReadKey -> comment
            if (match($mod, "^Term::")) {
                return $indent . "# " . $trimmed . "  # REVIEW: use __C__ for terminal control in Strada";
            }
            # Class::Accessor / Class::Tiny -> comment
            if (match($mod, "^Class::")) {
                return $indent . "# " . $trimmed . "  # Not needed - Strada has native OOP with has/extends";
            }
            # URI::Escape -> core::url_encode/core::url_decode
            if ($mod eq "URI::Escape") {
                return $indent . "# " . $trimmed . "  # Use core::url_encode() and core::url_decode() in Strada";
            }
            # HTML::Entities -> REVIEW with replace_all guidance
            if ($mod eq "HTML::Entities") {
                return $indent . "# " . $trimmed . "  # REVIEW: use replace_all() for entity encoding, e.g. replace_all($s, \"&\", \"&amp;\") then <, >, \"";
            }
            # DateTime -> core::time + core::strftime
            if ($mod eq "DateTime") {
                return $indent . "# " . $trimmed . "  # Use core::time(), core::localtime(), core::strftime() in Strada";
            }
            # XML::* -> REVIEW with libxml2 guidance
            if (match($mod, "^XML::")) {
                return $indent . "# " . $trimmed . "  # REVIEW: no XML library in Strada â€” use __C__ with libxml2 or convert to JSON";
            }
            # List::MoreUtils -> REVIEW with loop expansion
            if ($mod eq "List::MoreUtils" || $mod eq "List::MoreUtils::XS") {
                return $indent . "# " . $trimmed . "  # REVIEW: use loop-based equivalents for any/all/none/uniq in Strada";
            }
            # Text::Wrap -> REVIEW with manual line-breaking
            if ($mod eq "Text::Wrap") {
                return $indent . "# " . $trimmed . "  # REVIEW: no Text::Wrap in Strada â€” implement manual line-breaking with substr/index";
            }
            # Module::Load / Module::Runtime -> REVIEW
            if ($mod eq "Module::Load" || $mod eq "Module::Runtime") {
                return $indent . "# " . $trimmed . "  # REVIEW: dynamic module loading â€” use 'use' at compile time in Strada";
            }
            # Generic fallback for unknown modules
            if (match($mod, "::") || match($mod, "^[A-Z]")) {
                return $result . "  # REVIEW: may need import_lib \"" . $mod . ".so\";";
            }
        }
    }
    if (match($trimmed, "^use\\s+constant")) {
        # use constant { FOO => 1, BAR => 2 }; (hashref form)
        if (match($trimmed, "^use\\s+constant\\s*\\{")) {
            my array @hc_cap = capture($trimmed, "^use\\s+constant\\s*\\{\\s*(.*)\\s*\\}\\s*;");
            if (scalar(@hc_cap) > 1) {
                my str $hc_body = $hc_cap[1];
                # Split on comma, each item is "NAME => value"
                my array @hc_items = split(",", $hc_body);
                my str $hc_result = "";
                my int $hci = 0;
                while ($hci < scalar(@hc_items)) {
                    my str $hc_item = trim_str($hc_items[$hci]);
                    if (length($hc_item) > 0) {
                        my array @hc_pair = capture($hc_item, "([A-Za-z_][A-Za-z0-9_]*)\\s*=>\\s*(.+)");
                        if (scalar(@hc_pair) > 2) {
                            my str $hc_name = $hc_pair[1];
                            my str $hc_val = trim_str($hc_pair[2]);
                            if (length($hc_result) > 0) {
                                $hc_result = $hc_result . "\n";
                            }
                            $hc_result = $hc_result . $indent . "const scalar " . $hc_name . " = " . $hc_val . ";";
                        }
                    }
                    $hci++;
                }
                if (length($hc_result) > 0) {
                    return $hc_result;
                }
            }
            return $indent . "# REVIEW: " . $trimmed . "  # multi-line use constant {} â€” split into individual const declarations";
        }
        # use constant FOO => 42;
        my array @ccap = capture($trimmed, "^use\\s+constant\\s+([A-Za-z_][A-Za-z0-9_]*)\\s*=>\\s*(.+);");
        if (scalar(@ccap) > 2) {
            my str $cname = $ccap[1];
            my str $cval = $ccap[2];
            return $indent . "const scalar " . $cname . " = " . $cval . ";";
        }
        return $indent . "# REVIEW: " . $trimmed . "  # could not parse use constant â€” convert manually";
    }

    # 1; at end of module file
    if ($trimmed eq "1;") {
        return $indent . "# " . $trimmed . "  # Not needed in Strada";
    }

    # __END__ / __DATA__
    if ($trimmed eq "__END__" || $trimmed eq "__DATA__") {
        return $indent . "# " . $trimmed;
    }

    # ---- CORE:: prefix stripping ----
    if (match($result, "CORE::")) {
        # Map known CORE:: functions to Strada equivalents
        if (match($result, "CORE::fork")) { $result = replace_all($result, "CORE::fork", "core::fork"); }
        elsif (match($result, "CORE::print")) { $result = replace_all($result, "CORE::print", "print"); }
        elsif (match($result, "CORE::say")) { $result = replace_all($result, "CORE::say", "say"); }
        elsif (match($result, "CORE::sprintf")) { $result = replace_all($result, "CORE::sprintf", "sprintf"); }
        elsif (match($result, "CORE::die")) { $result = replace_all($result, "CORE::die", "die"); }
        elsif (match($result, "CORE::warn")) { $result = replace_all($result, "CORE::warn", "warn"); }
        elsif (match($result, "CORE::exit")) { $result = replace_all($result, "CORE::exit", "exit"); }
        elsif (match($result, "CORE::open")) { $result = replace_all($result, "CORE::open", "core::open"); }
        elsif (match($result, "CORE::close")) { $result = replace_all($result, "CORE::close", "core::close"); }
        elsif (match($result, "CORE::unlink")) { $result = replace_all($result, "CORE::unlink", "core::unlink"); }
        elsif (match($result, "CORE::rename")) { $result = replace_all($result, "CORE::rename", "core::rename"); }
        elsif (match($result, "CORE::mkdir")) { $result = replace_all($result, "CORE::mkdir", "core::mkdir"); }
        elsif (match($result, "CORE::rmdir")) { $result = replace_all($result, "CORE::rmdir", "core::rmdir"); }
        elsif (match($result, "CORE::chmod")) { $result = replace_all($result, "CORE::chmod", "core::chmod"); }
        elsif (match($result, "CORE::chown")) { $result = replace_all($result, "CORE::chown", "core::chown"); }
        elsif (match($result, "CORE::stat")) { $result = replace_all($result, "CORE::stat", "core::stat"); }
        elsif (match($result, "CORE::read")) { $result = replace_all($result, "CORE::read", "core::read"); }
        elsif (match($result, "CORE::seek")) { $result = replace_all($result, "CORE::seek", "core::seek"); }
        elsif (match($result, "CORE::chdir")) { $result = replace_all($result, "CORE::chdir", "core::chdir"); }
        elsif (match($result, "CORE::getenv")) { $result = replace_all($result, "CORE::getenv", "core::getenv"); }
        elsif (match($result, "CORE::write")) {
            $result = replace_all($result, "CORE::write", "write");
            $result = $result . "  # REVIEW: CORE::write (Perl report format) â€” use say(sprintf(...)) instead";
        }
        else {
            # Generic: strip CORE:: prefix
            $result = replace($result, "CORE::", "");
        }
    }

    # ---- Indirect object syntax: new ClassName(args) -> ClassName::new(args) ----
    if (match($result, "\\bnew\\s+[A-Z]") && !match($result, "#") && !match($result, "->new")) {
        # new Class::Name(args) or new ClassName(args)
        if (match($result, "\\bnew\\s+([A-Z][A-Za-z0-9_]*(::[A-Z][A-Za-z0-9_]*)*)\\s*\\(")) {
            my array @newcap = capture($result, "\\bnew\\s+([A-Z][A-Za-z0-9_]*(::[A-Z][A-Za-z0-9_]*)*)\\s*\\(");
            if (scalar(@newcap) > 1) {
                my str $class_name = $newcap[1];
                $result = replace($result, "\\bnew\\s+" . $class_name . "\\s*\\(", $class_name . "::new(");
            }
        }
        # new ClassName without parens (followed by space, ;, or end) -> ClassName::new()
        elsif (match($result, "\\bnew\\s+([A-Z][A-Za-z0-9_]*(::[A-Z][A-Za-z0-9_]*)*)\\s*[;,)]")) {
            my array @newcap2 = capture($result, "\\bnew\\s+([A-Z][A-Za-z0-9_]*(::[A-Z][A-Za-z0-9_]*)*)\\s*([;,)])");
            if (scalar(@newcap2) > 1) {
                my str $class_name = $newcap2[1];
                my str $after_char = $newcap2[3];
                $result = replace($result, "\\bnew\\s+" . $class_name . "\\s*[;,)]", $class_name . "::new()" . $after_char);
            }
        }
    }

    # ---- $ENV{} handling (before variable declarations to avoid mangling) ----

    # delete $ENV{KEY} -> core::unsetenv("KEY")
    if (match($result, "\\bdelete\\s+\\$ENV\\{")) {
        my array @delenvcap = capture($result, "\\bdelete\\s+\\$ENV\\{[\"']?([^}\"']+)[\"']?\\}");
        if (scalar(@delenvcap) > 1) {
            my str $delkey = $delenvcap[1];
            # If key is a variable ($var), keep as-is; otherwise quote it
            if (starts_with($delkey, "$")) {
                $result = replace($result, "delete\\s+\\$ENV\\{[\"']?[^}\"']+[\"']?\\}", "core::unsetenv(" . $delkey . ")");
            } else {
                $result = replace($result, "delete\\s+\\$ENV\\{[\"']?[^}\"']+[\"']?\\}", "core::unsetenv(\"" . $delkey . "\")");
            }
        }
    }
    # $ENV{KEY} = "val" -> core::setenv("KEY", "val")
    elsif (match($result, "\\$ENV\\{[^}]+\\}\\s*=\\s*")) {
        my array @setenvcap = capture($result, "\\$ENV\\{[\"']?([^}\"']+)[\"']?\\}\\s*=\\s*(.+);");
        if (scalar(@setenvcap) > 2) {
            my str $setkey = $setenvcap[1];
            my str $setval = trim_str($setenvcap[2]);
            if (starts_with($setkey, "$")) {
                $result = $indent . "core::setenv(" . $setkey . ", " . $setval . ");";
            } else {
                $result = $indent . "core::setenv(\"" . $setkey . "\", " . $setval . ");";
            }
        }
    }
    # $ENV{KEY} in expressions -> core::getenv("KEY")
    elsif (match($result, "\\$ENV\\{")) {
        # Replace all $ENV{KEY} occurrences with core::getenv("KEY")
        # Handle both $ENV{KEY} and $ENV{"KEY"} and $ENV{$var}
        my int $env_safety = 0;
        while (match($result, "\\$ENV\\{") && $env_safety < 10) {
            my array @getenvcap = capture($result, "\\$ENV\\{[\"']?([^}\"']+)[\"']?\\}");
            if (scalar(@getenvcap) > 1) {
                my str $getkey = $getenvcap[1];
                if (starts_with($getkey, "$")) {
                    $result = replace($result, "\\$ENV\\{[\"']?[^}\"']+[\"']?\\}", "core::getenv(" . $getkey . ")");
                } else {
                    $result = replace($result, "\\$ENV\\{[\"']?[^}\"']+[\"']?\\}", "core::getenv(\"" . $getkey . "\")");
                }
            } else {
                $env_safety = 10;
            }
            $env_safety++;
        }
    }

    # ---- @ARGV and $0 handling ----
    # scalar(@ARGV) -> scalar(core::argv())
    if (match($result, "scalar\\s*\\(\\s*@ARGV\\s*\\)")) {
        $result = replace($result, "scalar\\s*\\(\\s*@ARGV\\s*\\)", "scalar(core::argv())");
    }
    # $ARGV[N] -> core::argv()[N]
    if (index($result, "$ARGV[") >= 0 && index($result, "#") < 0) {
        my int $av_pos = index($result, "$ARGV[");
        while ($av_pos >= 0) {
            my str $before_av = substr($result, 0, $av_pos);
            my str $after_av = substr($result, $av_pos + 5, length($result) - $av_pos - 5);
            $result = $before_av . "core::argv()" . $after_av;
            $av_pos = index($result, "$ARGV[", $av_pos + 11);
        }
    }
    # @ARGV (whole array) -> core::argv()
    if (match($result, "@ARGV") && !match($result, "#") && !match($result, "core::argv")) {
        $result = replace_all($result, "@ARGV", "core::argv()");
    }
    # $0 -> core::argv()[0] (program name) â€” only standalone $0, not in regex context
    if (index($result, "$0") >= 0 && index($result, "#") < 0 && !match($result, "=~") && !match($result, "captures")) {
        my int $d0_pos = index($result, "$0");
        while ($d0_pos >= 0) {
            # Make sure it's not $0x (hex), $01, etc - only standalone $0
            my int $d0_after = $d0_pos + 2;
            my int $d0_ok = 1;
            if ($d0_after < length($result)) {
                my int $d0_nch = char_at($result, $d0_after);
                # If followed by a digit or word char, it's not standalone $0
                if (($d0_nch >= 48 && $d0_nch <= 57) || ($d0_nch >= 65 && $d0_nch <= 90) || ($d0_nch >= 97 && $d0_nch <= 122) || $d0_nch == 95) {
                    $d0_ok = 0;
                }
            }
            # Check not preceded by \ (escaped)
            if ($d0_pos > 0 && char_at($result, $d0_pos - 1) == 92) {
                $d0_ok = 0;
            }
            if ($d0_ok == 1) {
                $result = substr($result, 0, $d0_pos) . "core::argv()[0]" . substr($result, $d0_after, length($result) - $d0_after);
                $d0_pos = index($result, "$0", $d0_pos + 14);
            } else {
                $d0_pos = index($result, "$0", $d0_pos + 1);
            }
        }
    }

    # ---- $SIG{} handling ----
    # local $SIG{__DIE__} and local $SIG{__WARN__} â€” used to suppress die/warn during eval
    # In Strada, try/catch handles this naturally â€” comment out
    if (match($result, "\\blocal\\s+\\$SIG\\{") && (match($result, "__DIE__") || match($result, "__WARN__"))) {
        $result = $indent . "# " . $trimmed . "  # Not needed â€” Strada try/catch handles exception suppression";
        return $result;
    }
    # Strip "local" prefix from $SIG assignments for real signals (Strada doesn't need dynamic scope for signals)
    if (match($result, "\\blocal\\s+\\$SIG\\{")) {
        $result = replace($result, "\\blocal\\s+\\$SIG", chr(36) . "SIG");
        $result = $result . "  # REVIEW: was local $SIG - signal handler restored on scope exit in Perl";
    }
    if (match($result, "\\$SIG\\{")) {
        # __DIE__ and __WARN__ are Perl pseudo-signals, not real Unix signals
        # core::signal() only works with real signals â€” handle these specially
        if (match($result, "__DIE__") || match($result, "__WARN__")) {
            if (match($result, "__DIE__")) {
                $result = $indent . "# " . $trimmed . "  # REVIEW: Perl __DIE__ handler â€” use try/catch for exception handling in Strada";
            } else {
                $result = $indent . "# " . $trimmed . "  # REVIEW: Perl __WARN__ handler â€” no direct equivalent in Strada";
            }
            return $result;
        }
        # Extract signal name (supports INT, TERM, HUP, etc.)
        my str $__sig_name_pat = "[A-Z_][A-Z0-9_]*";
        # $SIG{INT} = 'IGNORE' -> core::signal("INT", "IGNORE")
        if (match($result, "\\$SIG\\{[\"']?[A-Z_][A-Z0-9_]*[\"']?\\}\\s*=\\s*['\"]IGNORE['\"]")) {
            my array @sigcap = capture($result, "\\$SIG\\{[\"']?([A-Z_][A-Z0-9_]*)[\"']?\\}");
            if (scalar(@sigcap) > 1) {
                $result = $indent . "core::signal(\"" . $sigcap[1] . "\", \"IGNORE\");";
            }
        }
        # $SIG{INT} = 'DEFAULT' -> core::signal("INT", "DEFAULT")
        elsif (match($result, "\\$SIG\\{[\"']?[A-Z_][A-Z0-9_]*[\"']?\\}\\s*=\\s*['\"]DEFAULT['\"]")) {
            my array @sigcap2 = capture($result, "\\$SIG\\{[\"']?([A-Z_][A-Z0-9_]*)[\"']?\\}");
            if (scalar(@sigcap2) > 1) {
                $result = $indent . "core::signal(\"" . $sigcap2[1] . "\", \"DEFAULT\");";
            }
        }
        # $SIG{INT} = \&handler -> core::signal("INT", \&handler)
        elsif (match($result, "\\$SIG\\{[\"']?[A-Z_][A-Z0-9_]*[\"']?\\}\\s*=\\s*\\\\&")) {
            my array @sigcap3 = capture($result, "\\$SIG\\{[\"']?([A-Z_][A-Z0-9_]*)[\"']?\\}\\s*=\\s*(\\\\&[A-Za-z_][A-Za-z0-9_:]*)");
            if (scalar(@sigcap3) > 2) {
                my str $sig3_name = $sigcap3[1];
                $result = $indent . "core::signal(\"" . $sig3_name . "\", " . $sigcap3[2] . ");";
            }
        }
        # $SIG{INT} = sub { ... } -> core::signal("INT", func () void { ... })
        elsif (match($result, "\\$SIG\\{[\"']?[A-Z_][A-Z0-9_]*[\"']?\\}\\s*=\\s*(sub|func)")) {
            my array @sigcap4 = capture($result, "\\$SIG\\{[\"']?([A-Z_][A-Z0-9_]*)[\"']?\\}");
            if (scalar(@sigcap4) > 1) {
                my str $signame = $sigcap4[1];
                # Extract everything after the = sign
                my array @sigbody = capture($result, "\\$SIG\\{[^}]+\\}\\s*=\\s*(.+)$");
                if (scalar(@sigbody) > 1) {
                    my str $handler = $sigbody[1];
                    # sub { -> func (scalar ...@_) scalar {
                    $handler = replace($handler, "\\bsub\\s*\\{", "func (scalar ...@_) scalar {");
                    # Remove trailing ; if present (we'll add our own)
                    $handler = replace($handler, ";\\s*$", "");
                    # Wrap: core::signal("SIG", handler);
                    $result = $indent . "core::signal(\"" . $signame . "\", " . $handler . ");";
                }
            }
        }
        # $SIG{SIGNAL} = $variable -> core::signal("SIGNAL", $variable)
        elsif (match($result, "\\$SIG\\{[\"']?[A-Z_][A-Z0-9_]*[\"']?\\}\\s*=\\s*\\$[A-Za-z_]")) {
            my array @sigcap5 = capture($result, "\\$SIG\\{[\"']?([A-Z_][A-Z0-9_]*)[\"']?\\}\\s*=\\s*(\\$[A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@sigcap5) > 2) {
                $result = $indent . "core::signal(\"" . $sigcap5[1] . "\", " . $sigcap5[2] . ");";
            } else {
                $result = $result . "  # REVIEW: convert " . chr(36) . "SIG to core::signal()";
            }
        }
        # $SIG{SIGNAL} = undef or $SIG{SIGNAL} = 0 -> core::signal("SIGNAL", "DEFAULT")
        elsif (match($result, "\\$SIG\\{[\"']?[A-Z_][A-Z0-9_]*[\"']?\\}\\s*=\\s*(undef|0)\\s*;")) {
            my array @sigcap6 = capture($result, "\\$SIG\\{[\"']?([A-Z_][A-Z0-9_]*)[\"']?\\}");
            if (scalar(@sigcap6) > 1) {
                $result = $indent . "core::signal(\"" . $sigcap6[1] . "\", \"DEFAULT\");";
            }
        }
        # delete $SIG{SIGNAL} -> core::signal("SIGNAL", "DEFAULT")
        elsif (match($result, "\\bdelete\\s+\\$SIG\\{[\"']?[A-Z_][A-Z0-9_]*[\"']?\\}")) {
            my array @sigcap7 = capture($result, "\\bdelete\\s+\\$SIG\\{[\"']?([A-Z_][A-Z0-9_]*)[\"']?\\}");
            if (scalar(@sigcap7) > 1) {
                $result = $indent . "core::signal(\"" . $sigcap7[1] . "\", \"DEFAULT\");";
            }
        }
        # $SIG{$variable} = handler -> core::signal with variable signal name
        elsif (match($result, "\\$SIG\\{\\$[A-Za-z_][A-Za-z0-9_]*\\}\\s*=")) {
            my array @sigcap8 = capture($result, "\\$SIG\\{(\\$[A-Za-z_][A-Za-z0-9_]*)\\}\\s*=\\s*(.+?)\\s*;?$");
            if (scalar(@sigcap8) > 2) {
                my str $sig8_var = $sigcap8[1];
                my str $sig8_handler = $sigcap8[2];
                $sig8_handler = replace($sig8_handler, "\\bsub\\s*\\{", "func (scalar ...@_) scalar {");
                $sig8_handler = replace($sig8_handler, ";\\s*$", "");
                if ($sig8_handler eq "'IGNORE'" || $sig8_handler eq "\"IGNORE\"") {
                    $result = $indent . "core::signal(" . $sig8_var . ", \"IGNORE\");";
                } elsif ($sig8_handler eq "'DEFAULT'" || $sig8_handler eq "\"DEFAULT\"") {
                    $result = $indent . "core::signal(" . $sig8_var . ", \"DEFAULT\");";
                } else {
                    $result = $indent . "core::signal(" . $sig8_var . ", " . $sig8_handler . ");";
                }
            } else {
                $result = $result . "  # REVIEW: convert " . chr(36) . "SIG to core::signal()";
            }
        }
        # Other $SIG patterns -> add REVIEW
        else {
            $result = $result . "  # REVIEW: convert " . chr(36) . "SIG to core::signal()";
        }
    }

    # ---- Typeglob handling ----
    my str $tg_star2 = "*";

    # 1. Function alias: *alias = \&original -> handled in Pass 2e
    # (moved to Pass 2e so wrapper funcs are at package level, not inside main())

    # 2. Variable alias: *alias = \$original -> handled via Pass 1 rename
    #    Emit the alias line as a comment (the actual renaming happens below)
    if (match($result, "^\\s*\\*[A-Za-z_][A-Za-z0-9_:]*\\s*=\\s*\\\\\\$[A-Za-z_]")) {
        my array @va_cap = capture($result, "^\\s*\\*([A-Za-z_][A-Za-z0-9_:]*)\\s*=\\s*\\\\\\$([A-Za-z_][A-Za-z0-9_:]*)");
        if (scalar(@va_cap) > 2) {
            $result = $indent . "# Variable alias: " . $tg_star2 . $va_cap[1] . " = \\$" . $va_cap[2] . " (all references to $" . $va_cap[1] . " use $" . $va_cap[2] . " instead)";
            return $result;
        }
    }
    # Array alias: *alias = \@original
    if (match($result, "^\\s*\\*[A-Za-z_][A-Za-z0-9_:]*\\s*=\\s*\\\\@[A-Za-z_]")) {
        my array @aa_cap = capture($result, "^\\s*\\*([A-Za-z_][A-Za-z0-9_:]*)\\s*=\\s*\\\\@([A-Za-z_][A-Za-z0-9_:]*)");
        if (scalar(@aa_cap) > 2) {
            $result = $indent . "# Array alias: " . $tg_star2 . $aa_cap[1] . " = \\@" . $aa_cap[2] . " (all references to @" . $aa_cap[1] . " use @" . $aa_cap[2] . " instead)";
            return $result;
        }
    }
    # Hash alias: *alias = \%original
    if (match($result, "^\\s*\\*[A-Za-z_][A-Za-z0-9_:]*\\s*=\\s*\\\\%[A-Za-z_]")) {
        my array @ha_cap = capture($result, "^\\s*\\*([A-Za-z_][A-Za-z0-9_:]*)\\s*=\\s*\\\\%([A-Za-z_][A-Za-z0-9_:]*)");
        if (scalar(@ha_cap) > 2) {
            $result = $indent . "# Hash alias: " . $tg_star2 . $ha_cap[1] . " = \\%" . $ha_cap[2] . " (all references to %" . $ha_cap[1] . " use %" . $ha_cap[2] . " instead)";
            return $result;
        }
    }

    # 3. Full typeglob alias: *name = *other -> comment
    if (match($result, "^\\s*\\*[A-Za-z_][A-Za-z0-9_:]*\\s*=\\s*\\*[A-Za-z_]")) {
        my array @ftg_cap = capture($result, "^\\s*\\*([A-Za-z_][A-Za-z0-9_:]*)\\s*=\\s*\\*([A-Za-z_][A-Za-z0-9_:]*)");
        if (scalar(@ftg_cap) > 2) {
            $result = $indent . "# Full typeglob alias: " . $tg_star2 . $ftg_cap[1] . " = " . $tg_star2 . $ftg_cap[2] . " - use " . $ftg_cap[2] . " directly or create wrapper functions";
            return $result;
        }
    }

    # 4. local *FH -> comment (bareword filehandle localization)
    if (match($result, "^\\s*local\\s+\\*[A-Z][A-Z0-9_]*")) {
        my array @lfh_cap = capture($result, "^\\s*local\\s+\\*([A-Z][A-Z0-9_]*)");
        if (scalar(@lfh_cap) > 1) {
            my str $lfh_name = $lfh_cap[1];
            my str $lfh_var = lc($lfh_name);
            $result = $indent . "my scalar $" . $lfh_var . ";  # was: local " . $tg_star2 . $lfh_name;
            return $result;
        }
    }

    # 5. Bareword filehandle normalization (uses Pass 1 tracking)
    # open(LOG, ">", "file") -> my scalar $log = core::open("file", "w");
    if (match($result, "^\\s*open\\s*\\(\\s*[A-Z][A-Z0-9_]*\\s*,")) {
        my array @bfh2_cap = capture($result, "^\\s*open\\s*\\(\\s*([A-Z][A-Z0-9_]*)\\s*,");
        if (scalar(@bfh2_cap) > 1) {
            my str $bfh2_name = $bfh2_cap[1];
            if ($bfh2_name ne "STDIN" && $bfh2_name ne "STDOUT" && $bfh2_name ne "STDERR") {
                my str $bfh2_key = "bareword_fh:" . $bfh2_name;
                my str $bfh2_var = lc($bfh2_name);
                if (length("" . $sub_info{$bfh2_key}) > 0) {
                    $bfh2_var = "" . $sub_info{$bfh2_key};
                }
                # Try to extract the file path and mode from 3-arg open
                if (match($result, "open\\s*\\(\\s*[A-Z]+\\s*,\\s*['\"]([<>]+)['\"]\\s*,\\s*")) {
                    my array @bfh3_cap = capture($result, "open\\s*\\(\\s*[A-Z]+\\s*,\\s*['\"]([<>]+)['\"]\\s*,\\s*(.+?)\\s*\\)");
                    if (scalar(@bfh3_cap) > 2) {
                        my str $bfh3_mode = $bfh3_cap[1];
                        my str $bfh3_path = $bfh3_cap[2];
                        my str $bfh3_smode = "r";
                        if ($bfh3_mode eq ">") { $bfh3_smode = "w"; }
                        elsif ($bfh3_mode eq ">>") { $bfh3_smode = "a"; }
                        $result = $indent . "my scalar $" . $bfh2_var . " = core::open(" . $bfh3_path . ", \"" . $bfh3_smode . "\");";
                        # Check for "or die" in original line
                        if (match($line, " or die") || match($line, " \\|\\| die")) {
                            my str $ordie_msg3 = "";
                            my array @od3_cap = capture($line, "die\\s*\\(([^)]*)\\)");
                            if (scalar(@od3_cap) > 1) { $ordie_msg3 = $od3_cap[1]; }
                            else {
                                my array @od3b_cap = capture($line, "die\\s+([^;]+)");
                                if (scalar(@od3b_cap) > 1) { $ordie_msg3 = "\"" . trim_str($od3b_cap[1]) . "\""; }
                            }
                            if (length($ordie_msg3) > 0) {
                                $result = $result . "\n" . $indent . "if (!defined($" . $bfh2_var . ")) { die(" . $ordie_msg3 . "); }";
                            } else {
                                $result = $result . "\n" . $indent . "if (!defined($" . $bfh2_var . ")) { die(\"open failed\"); }";
                            }
                        }
                        return $result;
                    }
                }
                # 2-arg open: open(FH, ">file") or open(FH, "file")
                if (match($result, "open\\s*\\(\\s*[A-Z]+\\s*,\\s*['\"]")) {
                    my array @bfh2a_cap = capture($result, "open\\s*\\(\\s*[A-Z]+\\s*,\\s*['\"]([<>]*)([^'\"]+)['\"]\\s*\\)");
                    if (scalar(@bfh2a_cap) > 2) {
                        my str $bfh2a_mode = $bfh2a_cap[1];
                        my str $bfh2a_path = $bfh2a_cap[2];
                        my str $bfh2a_smode = "r";
                        if ($bfh2a_mode eq ">") { $bfh2a_smode = "w"; }
                        elsif ($bfh2a_mode eq ">>") { $bfh2a_smode = "a"; }
                        $result = $indent . "my scalar $" . $bfh2_var . " = core::open(\"" . $bfh2a_path . "\", \"" . $bfh2a_smode . "\");";
                        return $result;
                    }
                }
                # Fallback: replace just the bareword with $var
                $result = replace_all($result, $bfh2_name, "$" . $bfh2_var);
            }
        }
    }

    # Replace bareword FH in print/close/eof/read/sysread/syswrite/seek/tell/binmode
    # print LOG "msg" -> say($log, "msg")
    # close LOG -> core::close($log)
    if (match($result, "\\b(print|close|eof|binmode|truncate)\\s+[A-Z][A-Z0-9_]*[\\s;]") && !match($result, "^\\s*#")) {
        my array @pfh_cap = capture($result, "\\b(print|close|eof|binmode|truncate)\\s+([A-Z][A-Z0-9_]*)");
        if (scalar(@pfh_cap) > 2) {
            my str $pfh_cmd = $pfh_cap[1];
            my str $pfh_name = $pfh_cap[2];
            if ($pfh_name ne "STDIN" && $pfh_name ne "STDOUT" && $pfh_name ne "STDERR") {
                my str $pfh_var = lc($pfh_name);
                my str $pfh_key = "bareword_fh:" . $pfh_name;
                if (length("" . $sub_info{$pfh_key}) > 0) {
                    $pfh_var = "" . $sub_info{$pfh_key};
                }
                if ($pfh_cmd eq "close") {
                    $result = $indent . "core::close($" . $pfh_var . ");";
                    return $result;
                } elsif ($pfh_cmd eq "print") {
                    # print LOG "msg" -> say($log, "msg")
                    my array @pmsg_cap = capture($result, "\\bprint\\s+[A-Z][A-Z0-9_]*\\s+(.+);");
                    if (scalar(@pmsg_cap) > 1) {
                        $result = $indent . "say($" . $pfh_var . ", " . $pmsg_cap[1] . ");";
                        return $result;
                    }
                } else {
                    # eof/binmode/truncate - replace bareword with $var
                    $result = replace($result, "(\\b" . $pfh_cmd . "\\s+)" . $pfh_name, "$1" . "$" . $pfh_var);
                }
            }
        }
    }

    # Apply variable alias renaming from Pass 1
    # For each varalias entry, replace the alias variable with the original
    my array @info_keys2 = keys(%sub_info);
    my int $ik2 = 0;
    while ($ik2 < scalar(@info_keys2)) {
        my str $ik2_key = $info_keys2[$ik2];
        if (starts_with($ik2_key, "varalias:")) {
            # varalias:$:alias = original -> replace $alias with $original
            my str $va_rest = substr($ik2_key, 9, length($ik2_key) - 9);
            my str $va_sigil = substr($va_rest, 0, 1);
            my str $va_alias_name = substr($va_rest, 2, length($va_rest) - 2);
            my str $va_orig_name = "" . $sub_info{$ik2_key};
            if (length($va_orig_name) > 0 && length($va_alias_name) > 0) {
                # Replace sigil+alias with sigil+original
                if (match($result, "\\" . $va_sigil . $va_alias_name . "\\b")) {
                    $result = replace_all($result, $va_sigil . $va_alias_name, $va_sigil . $va_orig_name);
                }
                # For hash aliases (%hash), also replace $alias{ with $original{
                # because Perl uses $hash{key} for element access
                if ($va_sigil eq "%") {
                    my str $dol = "$";
                    if (match($result, "\\" . $dol . $va_alias_name . "\\{")) {
                        $result = replace_all($result, $dol . $va_alias_name, $dol . $va_orig_name);
                    }
                }
                # For array aliases (@array), also replace $alias[ with $original[
                if ($va_sigil eq "@") {
                    my str $dol2 = "$";
                    if (match($result, "\\" . $dol2 . $va_alias_name . "\\[")) {
                        $result = replace_all($result, $dol2 . $va_alias_name, $dol2 . $va_orig_name);
                    }
                }
            }
        }
        $ik2++;
    }

    # ---- File test operators ----
    # -e $file -> core::file_exists($file)  /  -e "str" -> core::file_exists("str")
    # -f -> core::is_file, -d -> core::is_dir, -s -> core::file_size
    # Use capture+replace since replace_all doesn't support backreferences
    if (match($result, "-[efds]\\s+[\"\\$]") && !match($result, "core::file_exists") && !match($result, "core::is_file") && !match($result, "core::is_dir") && !match($result, "core::file_size")) {
        my int $ft_safety = 0;
        while (match($result, "-[efds]\\s+[\"\\$]") && $ft_safety < 10) {
            if (match($result, "-e\\s+\\$[A-Za-z_]")) {
                my array @ftcap = capture($result, "-e\\s+(\\$[A-Za-z_][A-Za-z0-9_]*)");
                if (scalar(@ftcap) > 1) {
                    $result = replace($result, "-e\\s+\\" . $ftcap[1], "core::file_exists(" . $ftcap[1] . ")");
                } else { $ft_safety = 10; }
            } elsif (match($result, "-e\\s+\"")) {
                my array @ftcap2 = capture($result, "-e\\s+(\"[^\"]*\")");
                if (scalar(@ftcap2) > 1) {
                    $result = replace($result, "-e\\s+\"[^\"]*\"", "core::file_exists(" . $ftcap2[1] . ")");
                } else { $ft_safety = 10; }
            } elsif (match($result, "-f\\s+\\$[A-Za-z_]")) {
                my array @ftcap3 = capture($result, "-f\\s+(\\$[A-Za-z_][A-Za-z0-9_]*)");
                if (scalar(@ftcap3) > 1) {
                    $result = replace($result, "-f\\s+\\" . $ftcap3[1], "core::is_file(" . $ftcap3[1] . ")");
                } else { $ft_safety = 10; }
            } elsif (match($result, "-f\\s+\"")) {
                my array @ftcap4 = capture($result, "-f\\s+(\"[^\"]*\")");
                if (scalar(@ftcap4) > 1) {
                    $result = replace($result, "-f\\s+\"[^\"]*\"", "core::is_file(" . $ftcap4[1] . ")");
                } else { $ft_safety = 10; }
            } elsif (match($result, "-d\\s+\\$[A-Za-z_]")) {
                my array @ftcap5 = capture($result, "-d\\s+(\\$[A-Za-z_][A-Za-z0-9_]*)");
                if (scalar(@ftcap5) > 1) {
                    $result = replace($result, "-d\\s+\\" . $ftcap5[1], "core::is_dir(" . $ftcap5[1] . ")");
                } else { $ft_safety = 10; }
            } elsif (match($result, "-d\\s+\"")) {
                my array @ftcap6 = capture($result, "-d\\s+(\"[^\"]*\")");
                if (scalar(@ftcap6) > 1) {
                    $result = replace($result, "-d\\s+\"[^\"]*\"", "core::is_dir(" . $ftcap6[1] . ")");
                } else { $ft_safety = 10; }
            } elsif (match($result, "-s\\s+\\$[A-Za-z_]")) {
                my array @ftcap7 = capture($result, "-s\\s+(\\$[A-Za-z_][A-Za-z0-9_]*)");
                if (scalar(@ftcap7) > 1) {
                    $result = replace($result, "-s\\s+\\" . $ftcap7[1], "core::file_size(" . $ftcap7[1] . ")");
                } else { $ft_safety = 10; }
            } elsif (match($result, "-s\\s+\"")) {
                my array @ftcap8 = capture($result, "-s\\s+(\"[^\"]*\")");
                if (scalar(@ftcap8) > 1) {
                    $result = replace($result, "-s\\s+\"[^\"]*\"", "core::file_size(" . $ftcap8[1] . ")");
                } else { $ft_safety = 10; }
            } else {
                $ft_safety = 10;
            }
            $ft_safety++;
        }
    }
    # -z -> (core::file_size($file) == 0)
    if (match($result, "-z\\s+[\"\\$]") && !match($result, "core::file_size")) {
        if (match($result, "-z\\s+\\$[A-Za-z_]")) {
            my array @zvar_cap = capture($result, "-z\\s+(\\$[A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@zvar_cap) > 1) {
                $result = replace($result, "-z\\s+\\" . $zvar_cap[1], "(core::file_size(" . $zvar_cap[1] . ") == 0)");
            }
        } elsif (match($result, "-z\\s+\"")) {
            my array @zstr_cap = capture($result, "-z\\s+(\"[^\"]*\")");
            if (scalar(@zstr_cap) > 1) {
                $result = replace($result, "-z\\s+\"[^\"]*\"", "(core::file_size(" . $zstr_cap[1] . ") == 0)");
            }
        }
    }
    # -r, -w, -x -> core::access() conversions
    if (match($result, "-[rwx]\\s+[\"\\$]") && !match($result, "#") && !match($result, "core::access")) {
        if (match($result, "-r\\s+\\$[A-Za-z_]")) {
            my array @r_cap = capture($result, "-r\\s+(\\$[A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@r_cap) > 1) {
                $result = replace($result, "-r\\s+\\" . $r_cap[1], "(core::access(" . $r_cap[1] . ", 4) == 0)");
            }
        } elsif (match($result, "-r\\s+\"")) {
            my array @r_cap2 = capture($result, "-r\\s+(\"[^\"]*\")");
            if (scalar(@r_cap2) > 1) {
                $result = replace($result, "-r\\s+\"[^\"]*\"", "(core::access(" . $r_cap2[1] . ", 4) == 0)");
            }
        }
        if (match($result, "-w\\s+\\$[A-Za-z_]")) {
            my array @w_cap = capture($result, "-w\\s+(\\$[A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@w_cap) > 1) {
                $result = replace($result, "-w\\s+\\" . $w_cap[1], "(core::access(" . $w_cap[1] . ", 2) == 0)");
            }
        } elsif (match($result, "-w\\s+\"")) {
            my array @w_cap2 = capture($result, "-w\\s+(\"[^\"]*\")");
            if (scalar(@w_cap2) > 1) {
                $result = replace($result, "-w\\s+\"[^\"]*\"", "(core::access(" . $w_cap2[1] . ", 2) == 0)");
            }
        }
        if (match($result, "-x\\s+\\$[A-Za-z_]")) {
            my array @x_cap = capture($result, "-x\\s+(\\$[A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@x_cap) > 1) {
                $result = replace($result, "-x\\s+\\" . $x_cap[1], "(core::access(" . $x_cap[1] . ", 1) == 0)");
            }
        } elsif (match($result, "-x\\s+\"")) {
            my array @x_cap2 = capture($result, "-x\\s+(\"[^\"]*\")");
            if (scalar(@x_cap2) > 1) {
                $result = replace($result, "-x\\s+\"[^\"]*\"", "(core::access(" . $x_cap2[1] . ", 1) == 0)");
            }
        }
    }
    # -l (symlink test) -> (length(core::readlink($f)) > 0)
    if (match($result, "-l\\s+[\"\\$]") && !match($result, "#") && !match($result, "core::readlink")) {
        if (match($result, "-l\\s+\\$[A-Za-z_]")) {
            my array @l_cap = capture($result, "-l\\s+(\\$[A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@l_cap) > 1) {
                $result = replace($result, "-l\\s+\\" . $l_cap[1], "(length(core::readlink(" . $l_cap[1] . ")) > 0)");
                $result = $result . "  # was: -l (symlink test)";
            }
        } elsif (match($result, "-l\\s+\"")) {
            my array @l_cap2 = capture($result, "-l\\s+(\"[^\"]*\")");
            if (scalar(@l_cap2) > 1) {
                $result = replace($result, "-l\\s+\"[^\"]*\"", "(length(core::readlink(" . $l_cap2[1] . ")) > 0)");
                $result = $result . "  # was: -l (symlink test)";
            }
        }
    }
    # -u (setuid test) -> REVIEW: stat mode check
    if (match($result, "-u\\s+[\"\\$]") && !match($result, "#")) {
        $result = $result . "  # REVIEW: -u (setuid test) â€” check core::stat($f){\"mode\"} & 04000";
    }
    # -g (setgid test) -> REVIEW: stat mode check
    if (match($result, "-g\\s+[\"\\$]") && !match($result, "#") && !match($result, "-ge\\b") && !match($result, "-gt\\b")) {
        $result = $result . "  # REVIEW: -g (setgid test) â€” check core::stat($f){\"mode\"} & 02000";
    }
    # -k (sticky bit test) -> REVIEW: stat mode check
    if (match($result, "-k\\s+[\"\\$]") && !match($result, "#")) {
        $result = $result . "  # REVIEW: -k (sticky bit test) â€” check core::stat($f){\"mode\"} & 01000";
    }
    # -p (named pipe test) -> REVIEW: stat mode check
    if (match($result, "-p\\s+[\"\\$]") && !match($result, "#")) {
        $result = $result . "  # REVIEW: -p (named pipe test) â€” check via core::stat()";
    }
    # -T, -B (text/binary file test) -> REVIEW (no runtime equivalent)
    if (match($result, "-[TB]\\s+[\"\\$]") && !match($result, "#")) {
        if (match($result, "-T\\s+[\"\\$]")) {
            $result = $result . "  # REVIEW: -T (text file test) â€” no direct equivalent; check first bytes for non-printable characters";
        }
        if (match($result, "-B\\s+[\"\\$]")) {
            $result = $result . "  # REVIEW: -B (binary file test) â€” no direct equivalent; check first bytes for non-printable characters";
        }
    }
    # -M, -A, -C (file modification/access/change time) -> core::stat
    if (match($result, "-[MAC]\\s+[\"\\$]") && !match($result, "#")) {
        if (match($result, "-M\\s+\\$[A-Za-z_]")) {
            my array @m_cap = capture($result, "-M\\s+(\\$[A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@m_cap) > 1) {
                $result = replace($result, "-M\\s+\\" . $m_cap[1], "(core::time() - core::stat(" . $m_cap[1] . "){\"mtime\"})");
            }
        } elsif (match($result, "-M\\s+\"")) {
            my array @m_cap2 = capture($result, "-M\\s+(\"[^\"]*\")");
            if (scalar(@m_cap2) > 1) {
                $result = replace($result, "-M\\s+\"[^\"]*\"", "(core::time() - core::stat(" . $m_cap2[1] . "){\"mtime\"})");
            }
        }
        if (match($result, "-A\\s+\\$[A-Za-z_]")) {
            my array @a_cap = capture($result, "-A\\s+(\\$[A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@a_cap) > 1) {
                $result = replace($result, "-A\\s+\\" . $a_cap[1], "(core::time() - core::stat(" . $a_cap[1] . "){\"atime\"})");
            }
        } elsif (match($result, "-A\\s+\"")) {
            my array @a_cap2 = capture($result, "-A\\s+(\"[^\"]*\")");
            if (scalar(@a_cap2) > 1) {
                $result = replace($result, "-A\\s+\"[^\"]*\"", "(core::time() - core::stat(" . $a_cap2[1] . "){\"atime\"})");
            }
        }
        if (match($result, "-C\\s+\\$[A-Za-z_]")) {
            my array @c_cap = capture($result, "-C\\s+(\\$[A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@c_cap) > 1) {
                $result = replace($result, "-C\\s+\\" . $c_cap[1], "(core::time() - core::stat(" . $c_cap[1] . "){\"ctime\"})");
            }
        } elsif (match($result, "-C\\s+\"")) {
            my array @c_cap2 = capture($result, "-C\\s+(\"[^\"]*\")");
            if (scalar(@c_cap2) > 1) {
                $result = replace($result, "-C\\s+\"[^\"]*\"", "(core::time() - core::stat(" . $c_cap2[1] . "){\"ctime\"})");
            }
        }
    }

    # ---- Heredocs ----
    # Handled in pass2c (multi-line processing). Any remaining ones get a TODO.
    if (match($trimmed, "<<[~]?['\"]?[A-Z_]+['\"]?")) {
        return $result . "  # REVIEW: heredoc may not have been fully converted";
    }

    # ---- Convert anonymous sub ----
    # Use (scalar ...@_) so anonymous subs can receive arguments via @_
    # Note: must use replace() (regex), not replace_all() (plain string)
    # First handle sub with prototypes: sub ($) { }, sub (&@) { }, sub () { }
    if (match($result, "\\bsub\\s*\\([^)]*\\)\\s*\\{") && !match($result, "\\bsub\\s+[A-Za-z_]")) {
        my int $anon_proto_safety = 0;
        while (match($result, "\\bsub\\s*\\([^)]*\\)\\s*\\{") && $anon_proto_safety < 10) {
            $result = replace($result, "\\bsub\\s*\\([^)]*\\)\\s*\\{", "func (scalar ...@_) scalar {");
            $anon_proto_safety++;
        }
    }
    # Then handle plain sub { }
    if (match($result, "\\bsub\\s*\\{") && !match($result, "\\bsub\\s+[A-Za-z_]")) {
        my int $anon_safety = 0;
        while (match($result, "\\bsub\\s*\\{") && $anon_safety < 10) {
            $result = replace($result, "\\bsub\\s*\\{", "func (scalar ...@_) scalar {");
            $anon_safety++;
        }
    }

    # ---- unless/until pass through (native Strada keywords) ----

    # ---- Postfix conditionals ----
    $result = convert_postfix_conditional($result);

    # ---- foreach / for with arrays (BEFORE variable decl conversion) ----

    # for my $x (@arr) -> foreach my $x (@arr)  (convert for->foreach first)
    if (match($result, "\\bfor\\s+my\\s+\\$") && match($result, "\\(@")) {
        $result = replace($result, "\\bfor\\s+my\\s+(\\$)", "foreach my $1");
    }
    # foreach my $x (@arr) -> foreach my scalar $x (@arr)
    if (match($result, "\\bforeach\\s+my\\s+\\$")) {
        if (!match($result, "\\bforeach\\s+my\\s+(scalar|int|str|num)\\s+\\$")) {
            $result = replace($result, "\\bforeach\\s+my\\s+(\\$)", "foreach my scalar $1");
        }
    }
    # foreach $var (@list) (no 'my') -> foreach my scalar $var (@list)
    if (match($result, "\\bforeach\\s+\\$[A-Za-z_]") && !match($result, "\\bforeach\\s+my\\s")) {
        $result = replace($result, "\\bforeach\\s+(\\$)", "foreach my scalar $1");
    }
    # for $var (@list) (no 'my') -> foreach my scalar $var (@list)
    if (match($result, "\\bfor\\s+\\$[A-Za-z_]") && !match($result, "\\bfor\\s+my\\s") && !match($result, "\\bfor\\s+\\$[A-Za-z_].*=") && match($result, "\\(")) {
        $result = replace($result, "\\bfor\\s+(\\$)", "foreach my scalar $1");
    }
    # for ($scalar) { ... } (topicalizer, no semicolons in parens) -> foreach my scalar $_ ($scalar) { ... }
    if (match($result, "\\bfor\\s*\\(\\s*\\$[A-Za-z_][A-Za-z0-9_]*\\s*\\)\\s*\\{") && !match($result, "\\bforeach") && !match($result, "^\\s*#")) {
        $result = replace($result, "\\bfor\\s*\\(", "foreach my scalar $_ (");
    }
    # for/foreach without loop variable (implicit $_): for (@list) { -> foreach my scalar $_ (@list) {
    if (match($result, "\\bfor\\s*\\(") && !match($result, "\\bfor\\s+my\\s") && !match($result, "\\bfor\\s+\\$") && !match($result, "\\bfor\\s*\\(\\s*my\\s") && !match($result, "\\bfor\\s*\\(\\s*\\$") && !match($result, "\\bforeach") && !match($result, "#")) {
        # C-style for loop has semicolons: for (init; cond; incr)
        if (!match($result, ";")) {
            $result = replace($result, "\\bfor\\s*\\(", "foreach my scalar $_ (");
        }
    }
    if (match($result, "\\bforeach\\s*\\(") && !match($result, "\\bforeach\\s+my\\s") && !match($result, "\\bforeach\\s+\\$") && !match($result, "#")) {
        $result = replace($result, "\\bforeach\\s*\\(", "foreach my scalar $_ (");
    }

    # ---- Variable declarations ----

    # my $var -> my scalar $var (but not if already typed)
    if (match($result, "\\bmy\\s+\\$") && !match($result, "\\bmy\\s+(scalar|int|num|str)\\s+\\$")) {
        $result = replace($result, "\\bmy\\s+(\\$)", "my scalar $1");
    }
    # my @arr -> my array @arr
    if (match($result, "\\bmy\\s+@") && !match($result, "\\bmy\\s+array\\s+@")) {
        $result = replace($result, "\\bmy\\s+@", "my array @");
    }
    # my %hash -> my hash %hash
    if (match($result, "\\bmy\\s+%") && !match($result, "\\bmy\\s+hash\\s+%")) {
        $result = replace($result, "\\bmy\\s+%", "my hash %");
    }

    # our ($a, $b, %c, @d); -> split into individual declarations
    if (match($result, "\\bour\\s*\\(") && !match($result, "#")) {
        my array @our_cap = capture(trim_str($result), "^our\\s*\\(([^)]*)\\)\\s*;?");
        if (scalar(@our_cap) > 1) {
            my str $our_vars = $our_cap[1];
            my array @our_parts = split(",", $our_vars);
            my str $our_result = "";
            my int $oi = 0;
            while ($oi < scalar(@our_parts)) {
                my str $ovar = trim_str($our_parts[$oi]);
                if (length($ovar) > 0) {
                    if (length($our_result) > 0) {
                        $our_result = $our_result . "\n";
                    }
                    if ($ovar eq "@ISA") {
                        $our_result = $our_result . $indent . "# " . $ovar . " â€” not needed in Strada (use extends)";
                    } elsif ($ovar eq "@EXPORT" || $ovar eq "@EXPORT_OK" || $ovar eq "@EXPORT_FAIL") {
                        $our_result = $our_result . $indent . "# " . $ovar . " â€” not needed in Strada (callers use Package::func())";
                    } elsif (starts_with($ovar, "@")) {
                        $our_result = $our_result . $indent . "my array " . $ovar . ";";
                    } elsif (starts_with($ovar, "%")) {
                        $our_result = $our_result . $indent . "my hash " . $ovar . ";";
                    } else {
                        $our_result = $our_result . $indent . "our scalar " . $ovar . ";";
                    }
                }
                $oi++;
            }
            if (length($our_result) > 0) {
                return $our_result;
            }
        }
    }

    # our $scalar -> our scalar $ (native Strada our)
    if (match($result, "\\bour\\s+\\$")) {
        $result = replace($result, "\\bour\\s+(\\$)", "our scalar $1");
    }
    # our @ISA / @EXPORT / @EXPORT_OK -> comment out (Exporter patterns not needed in Strada)
    if (match($result, "\\bour\\s+@ISA\\b")) {
        $result = $indent . "# " . $trimmed . "  # Not needed in Strada (use extends)";
    } elsif (match($result, "\\bour\\s+@EXPORT\\b") || match($result, "\\bour\\s+@EXPORT_OK\\b") || match($result, "\\bour\\s+@EXPORT_FAIL\\b")) {
        $result = $indent . "# " . $trimmed . "  # Not needed in Strada (callers use Package::func())";
    } elsif (match($result, "\\bour\\s+@")) {
        # our @array -> my array @ (Strada our doesn't support arrays)
        $result = replace($result, "\\bour\\s+@", "my array @");
    }
    # our %hash -> my hash % (Strada our doesn't support hashes)
    if (match($result, "\\bour\\s+%")) {
        $result = replace($result, "\\bour\\s+%", "my hash %");
    }

    # state $var = val -> our scalar $var (state is per-function persistent, emulated with our)
    # The sub_info hash carries "__current_func" set during convert_file's main loop.
    # We prefix the variable name with __state_funcname_ to avoid collisions.
    if (match($result, "\\bstate\\s+\\$")) {
        my str $st_func = "unknown";
        if (length("" . $sub_info{"__current_func"}) > 0) {
            $st_func = "" . $sub_info{"__current_func"};
        }
        # Extract variable name for renaming
        my array @st_cap = capture($result, "\\bstate\\s+\\$([A-Za-z_][A-Za-z0-9_]*)");
        if (scalar(@st_cap) > 1) {
            my str $st_var = $st_cap[1];
            my str $st_new = "__state_" . $st_func . "_" . $st_var;
            $result = replace($result, "\\bstate\\s+\\$" . $st_var, "our scalar $" . $st_new);
        } else {
            $result = replace($result, "\\bstate\\s+(\\$)", "our scalar $1");
        }
    }
    if (match($result, "\\bstate\\s+@")) {
        my str $st_func2 = "unknown";
        if (length("" . $sub_info{"__current_func"}) > 0) {
            $st_func2 = "" . $sub_info{"__current_func"};
        }
        my array @st_cap2 = capture($result, "\\bstate\\s+@([A-Za-z_][A-Za-z0-9_]*)");
        if (scalar(@st_cap2) > 1) {
            my str $st_var2 = $st_cap2[1];
            my str $st_new2 = "__state_" . $st_func2 . "_" . $st_var2;
            $result = replace($result, "\\bstate\\s+@" . $st_var2, "our array @" . $st_new2);
        } else {
            $result = replace($result, "\\bstate\\s+@", "our array @");
        }
    }
    if (match($result, "\\bstate\\s+%")) {
        my str $st_func3 = "unknown";
        if (length("" . $sub_info{"__current_func"}) > 0) {
            $st_func3 = "" . $sub_info{"__current_func"};
        }
        my array @st_cap3 = capture($result, "\\bstate\\s+%([A-Za-z_][A-Za-z0-9_]*)");
        if (scalar(@st_cap3) > 1) {
            my str $st_var3 = $st_cap3[1];
            my str $st_new3 = "__state_" . $st_func3 . "_" . $st_var3;
            $result = replace($result, "\\bstate\\s+%" . $st_var3, "our hash %" . $st_new3);
        } else {
            $result = replace($result, "\\bstate\\s+%", "our hash %");
        }
    }

    # ---- Package-qualified variable access: $Pkg::var -> core::global_get/set ----
    # Handle $Pkg::var, $Pkg::Sub::var patterns (but not $self->method:: or $_:: or $::var)
    # Write pattern: $Pkg::var = expr -> core::global_set("Pkg::var", expr)
    # Read pattern: $Pkg::var -> core::global_get("Pkg::var")
    if (match($result, "\\$[A-Z][A-Za-z0-9_]*::[A-Za-z_]") && !match($result, "^\\s*#") && !match($result, "->") && !match($result, "\\$self::") && !match($result, "REVIEW.*global") && !match($result, "\\blocal\\s+\\$[A-Z]")) {
        # Check if this is an assignment: $Pkg::var = expr (but not ==, !=, =~)
        if (match($result, "\\$[A-Z][A-Za-z0-9_]*::[A-Za-z_][A-Za-z0-9_:]*\\s*=[^=~>]")) {
            my int $pv_safety = 0;
            while (match($result, "\\$[A-Z][A-Za-z0-9_]*::[A-Za-z_][A-Za-z0-9_:]*\\s*=[^=~>]") && $pv_safety < 10) {
                my array @pv_cap = capture($result, "(\\$([A-Z][A-Za-z0-9_]*::[A-Za-z_][A-Za-z0-9_:]*))\\s*=\\s*([^=~>].*)$");
                if (scalar(@pv_cap) > 3) {
                    my str $pv_full = $pv_cap[1];
                    my str $pv_name = $pv_cap[2];
                    my str $pv_expr = trim_str($pv_cap[3]);
                    $pv_expr =~ s/;\s*$//;
                    $result = replace($result, "\\$" . $pv_name . "\\s*=\\s*[^=~>].*$", "core::global_set(\"" . $pv_name . "\", " . $pv_expr . ");");
                } else {
                    $pv_safety = 10;
                }
                $pv_safety++;
            }
        } else {
            # Read access: $Pkg::var -> core::global_get("Pkg::var")
            my int $pv_safety2 = 0;
            while (match($result, "\\$([A-Z][A-Za-z0-9_]*::[A-Za-z_][A-Za-z0-9_:]*)") && !match($result, "core::global_get") && $pv_safety2 < 10) {
                my array @pvr_cap = capture($result, "\\$([A-Z][A-Za-z0-9_]*::[A-Za-z_][A-Za-z0-9_:]*)");
                if (scalar(@pvr_cap) > 1) {
                    my str $pvr_name = $pvr_cap[1];
                    $result = replace($result, "\\$" . $pvr_name, "core::global_get(\"" . $pvr_name . "\")");
                } else {
                    $pv_safety2 = 10;
                }
                $pv_safety2++;
            }
        }
    }
    # @Pkg::var -> REVIEW (arrays can't use global_get/set directly)
    if (match($result, "@[A-Z][A-Za-z0-9_]*::[A-Za-z_]") && !match($result, "^\\s*#") && !match($result, "REVIEW.*package") && !match($result, "@EXPORT") && !match($result, "@ISA") && !match($result, "@CARP_NOT")) {
        if (!match($result, "REVIEW")) {
            $result = $result . "  # REVIEW: package array variable â€” convert to our array or refactor";
        }
    }

    # ---- Scalar context: my $n = @array -> my int $n = scalar(@array) ----
    # Detect array in scalar context (RHS of scalar assignment)
    # Pattern: $var = @array; (not followed by [ for slice, not inside parens for list assignment)
    if (match($result, "\\$[A-Za-z_][A-Za-z0-9_]*\\s*=\\s*@[A-Za-z_][A-Za-z0-9_]*\\s*;") && !match($result, "#")) {
        # Make sure it's not a list assignment like my ($a, $b) = @arr
        if (!match($result, "\\(.*\\)\\s*=\\s*@")) {
            $result = replace($result, "(\\$[A-Za-z_][A-Za-z0-9_]*\\s*=\\s*)(@[A-Za-z_][A-Za-z0-9_]*)(\\s*;)", "$1scalar($2)$3");
            # If type is "scalar", upgrade to "int" since scalar(@arr) returns an integer
            if (match($result, "my\\s+scalar\\s+\\$") && match($result, "scalar\\(@")) {
                $result = replace($result, "my\\s+scalar\\s+(\\$)", "my int $1");
            }
        }
    }

    # local $/ -> slurp idiom detection (must check BEFORE generic local->my conversion)
    if (match($result, "\\blocal\\s+\\$/")) {
        # Single-line slurp: do { local $/; <$fh> }
        if (match($result, "do\\s*\\{\\s*local\\s+\\$/\\s*;\\s*<\\$")) {
            my array @sl_cap = capture($result, "<\\$([A-Za-z_][A-Za-z0-9_]*)>");
            if (scalar(@sl_cap) > 1) {
                my str $sl_fh = $sl_cap[1];
                # Replace entire do { local $/; <$fh> } with core::slurp() call
                $result = replace($result, "do\\s*\\{\\s*local\\s+\\$/\\s*;\\s*<\\$[A-Za-z_][A-Za-z0-9_]*>\\s*;?\\s*\\}", "core::slurp($" . $sl_fh . ")");
                $result = $result . "  # REVIEW: converted slurp idiom - arg may need to be a filename not fh";
                return $result;
            }
        }
        # Standalone local $/ - differentiate by value
        if (match($result, "=\\s*undef") || !match($result, "=")) {
            # local $/ = undef or just local $/ â†’ slurp mode
            $result = $indent . "# " . $trimmed . "  # $/ = undef (slurp mode) â€” use core::slurp($file) instead of line-by-line reading";
        } elsif (match($result, "=\\s*\"\\\\n\"") || match($result, "=\\s*\"\\n\"")) {
            # local $/ = "\n" â†’ default (no-op)
            $result = $indent . "# " . $trimmed . "  # $/ = newline (default) â€” not needed, Strada reads lines by newline";
        } elsif (match($result, "=\\s*[\"']")) {
            # local $/ = ":" or other custom delimiter
            $result = $indent . "# " . $trimmed . "  # $/ with custom delimiter â€” use split() with the delimiter after core::slurp()";
        } else {
            $result = $indent . "# " . $trimmed . "  # $/ (input record separator) â€” Strada reads lines with newline delimiter; use core::slurp() + split()";
        }
        return $result;
    }

    # local $Pkg::Var = val -> generate save/restore with core::global_get/set
    if (match($result, "\\blocal\\s+\\$[A-Z][A-Za-z0-9_]*::[A-Za-z_]") && !match($result, "^\\s*#")) {
        my array @lpv_cap = capture($result, "\\blocal\\s+\\$([A-Z][A-Za-z0-9_]*::[A-Za-z_][A-Za-z0-9_]*)");
        if (scalar(@lpv_cap) > 1) {
            my str $lpv_name = $lpv_cap[1];
            # Check if there's an assignment
            if (match($result, "\\blocal\\s+\\$[A-Z].*=")) {
                my array @lpv_val = capture($result, "\\blocal\\s+\\$[A-Z][A-Za-z0-9_:]*\\s*=\\s*(.+);");
                if (scalar(@lpv_val) > 1) {
                    my str $lpv_value = trim_str($lpv_val[1]);
                    $result = $indent . "my scalar $__saved_" . replace_all($lpv_name, "::", "_") . " = core::global_get(\"" . $lpv_name . "\");  # save";
                    $result = $result . "\n" . $indent . "core::global_set(\"" . $lpv_name . "\", " . $lpv_value . ");";
                    $result = $result . "  # REVIEW: restore with core::global_set(\"" . $lpv_name . "\", $__saved_" . replace_all($lpv_name, "::", "_") . ") at scope exit";
                } else {
                    $result = $indent . "# " . $trimmed . "  # REVIEW: local $Pkg::Var â€” save/restore with core::global_get/set";
                }
            } else {
                # local $Pkg::Var without assignment (just save current value to restore later)
                $result = $indent . "my scalar $__saved_" . replace_all($lpv_name, "::", "_") . " = core::global_get(\"" . $lpv_name . "\");";
                $result = $result . "  # REVIEW: restore with core::global_set(\"" . $lpv_name . "\", $__saved_" . replace_all($lpv_name, "::", "_") . ") at scope exit";
            }
            return $result;
        }
    }
    # local $special_var -> comment out with specific guidance
    # Also match local($var) form (no space before paren)
    if ((match($result, "\\blocal\\s+\\$[\\\\,\"!;]") || match($result, "\\blocal\\s*\\(\\s*\\$[\\\\,\"!;]")) && !match($result, "^\\s*#")) {
        if (match($result, "local.*\\$,")) {
            $result = $indent . "# " . $trimmed . "  # $, (output field separator) â€” Strada: use join() instead";
            return $result;
        } elsif (match($result, "local.*\\$\\\\")) {
            $result = $indent . "# " . $trimmed . "  # $\\ (output record separator) â€” Strada: append newline explicitly";
            return $result;
        } elsif (match($result, "local.*\\$\"")) {
            $result = $indent . "# " . $trimmed . "  # $\" (list separator) â€” Strada: use join() instead";
            return $result;
        } elsif (match($result, "local.*\\$!")) {
            $result = $indent . "# " . $trimmed . "  # $! (errno) â€” removed (Strada has no errno)";
            return $result;
        } elsif (match($result, "local.*\\$;")) {
            $result = $indent . "# " . $trimmed . "  # $; (multidimensional hash subscript separator) â€” removed";
            return $result;
        } else {
            $result = $indent . "# " . $trimmed . "  # Removed (Strada special variable)";
            return $result;
        }
    }
    if ((match($result, "\\blocal\\s+\\$[.?]") || match($result, "\\blocal\\s*\\(\\s*\\$[.?]")) && !match($result, "^\\s*#") && !match($result, "local\\s+\\$[A-Za-z_]")) {
        $result = $indent . "# " . $trimmed . "  # Removed (Strada special variable)";
        return $result;
    }
    # local $var -> pass through (Strada supports local natively for 'our' variables)
    elsif (match($result, "\\blocal\\s+\\$") && !match($result, "\\blocal\\s+\\$[{/\\\\]") && !match($result, "^\\s*#")) {
        # Pass through - Strada local works with 'our' variables
    }
    # local @array / local %hash -> convert to my (Strada local only supports scalars)
    if (match($result, "\\blocal\\s+@")) {
        $result = replace($result, "\\blocal\\s+@", "my array @");
    }
    # local %ENV = (...) -> comment out with core::setenv suggestion
    if (match($result, "\\blocal\\s+%ENV\\b")) {
        $result = $indent . "# " . $trimmed . "  # Use core::setenv()/core::unsetenv() instead";
    }
    elsif (match($result, "\\blocal\\s+%")) {
        $result = replace($result, "\\blocal\\s+%", "my hash %");
    }

    # ---- print/say conversion ----

    # print { $fh } expr -> print($fh, expr)
    if (match($result, "\\bprint\\s*\\{\\s*\\$") && !match($result, "#")) {
        my array @pfh_cap = capture($result, "\\bprint\\s*\\{\\s*(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*\\}\\s*(.+);");
        if (scalar(@pfh_cap) > 2) {
            my str $pfh_var = $pfh_cap[1];
            my str $pfh_expr = trim_str($pfh_cap[2]);
            $result = $indent . "print(" . $pfh_var . ", " . $pfh_expr . ");";
        }
    }

    # printf $fh "fmt", args -> print($fh, sprintf("fmt", args))
    if (match($result, "\\bprintf\\s+\\$[A-Za-z_][A-Za-z0-9_]*\\s+") && !match($result, "\\bprintf\\s*\\(")) {
        my array @pfhcap = capture($result, "\\bprintf\\s+(\\$[A-Za-z_][A-Za-z0-9_]*)\\s+(.+);");
        if (scalar(@pfhcap) > 2) {
            my str $pfh = $pfhcap[1];
            my str $pfmt = $pfhcap[2];
            $result = $indent . "print(" . $pfh . ", sprintf(" . $pfmt . "));";
        }
    }
    # print $fh "content" -> print($fh, "content")
    # But NOT: print $var . "expr" or print $var; (those are expressions, not filehandle prints)
    elsif (match($result, "\\bprint\\s+\\$[A-Za-z_][A-Za-z0-9_]*\\s+[\"']") && !match($result, "\\bprint\\s*\\(") && !match($result, "\\bprint\\s+\\$[A-Za-z_][A-Za-z0-9_]*\\s*\\.") && !match($result, "\\bprint\\s+\\$[A-Za-z_][A-Za-z0-9_]*\\s*;")) {
        my array @fhcap = capture($result, "\\bprint\\s+(\\$[A-Za-z_][A-Za-z0-9_]*)\\s+(.+);");
        if (scalar(@fhcap) > 2) {
            my str $fhvar = $fhcap[1];
            my str $fhcontent = $fhcap[2];
            $result = $indent . "print(" . $fhvar . ", " . $fhcontent . ");";
        }
    }
    # say $fh "content" -> say($fh, "content")
    elsif (match($result, "\\bsay\\s+\\$[A-Za-z_][A-Za-z0-9_]*\\s+[\"']") && !match($result, "\\bsay\\s*\\(") && !match($result, "\\bsay\\s+\\$[A-Za-z_][A-Za-z0-9_]*\\s*\\.") && !match($result, "\\bsay\\s+\\$[A-Za-z_][A-Za-z0-9_]*\\s*;")) {
        my array @sfhcap = capture($result, "\\bsay\\s+(\\$[A-Za-z_][A-Za-z0-9_]*)\\s+(.+);");
        if (scalar(@sfhcap) > 2) {
            my str $sfhvar = $sfhcap[1];
            my str $sfhcontent = $sfhcap[2];
            $result = $indent . "say(" . $sfhvar . ", " . $sfhcontent . ");";
        }
    }
    # print STDERR "..." -> warn("...")
    elsif (match($result, "\\bprint\\s+STDERR\\s+")) {
        $result = replace($result, "\\bprint\\s+STDERR\\s+", "warn(");
        $result = add_close_paren($result);
    }
    # print STDOUT "..." -> print("...") or say("...")
    elsif (match($result, "\\bprint\\s+STDOUT\\s+")) {
        $result = replace($result, "\\bprint\\s+STDOUT\\s+", "print(");
        $result = add_close_paren($result);
    }
    # say STDERR "..." -> warn("...")
    elsif (match($result, "\\bsay\\s+STDERR\\s+")) {
        $result = replace($result, "\\bsay\\s+STDERR\\s+", "warn(");
        $result = add_close_paren($result);
    }
    # say STDOUT "..." -> say("...")
    elsif (match($result, "\\bsay\\s+STDOUT\\s+")) {
        $result = replace($result, "\\bsay\\s+STDOUT\\s+", "say(");
        $result = add_close_paren($result);
    }
    # print FH "..." (other bareword filehandles) -> print($FH, "...")
    elsif (match($result, "\\bprint\\s+[A-Z][A-Z_0-9]*\\s+") && !match($result, "\\bprint\\s*\\(") && !match($result, "\\bprint\\s+STDERR") && !match($result, "\\bprint\\s+STDOUT")) {
        my array @bfh_cap = capture($result, "\\bprint\\s+([A-Z][A-Z_0-9]*)\\s+(.+);");
        if (scalar(@bfh_cap) > 2) {
            my str $bfh_name = $bfh_cap[1];
            my str $bfh_content = $bfh_cap[2];
            $result = $indent . "print($" . $bfh_name . ", " . $bfh_content . ");  # REVIEW: bareword FH '" . $bfh_name . "' converted to variable $" . $bfh_name;
        }
    }
    # print "..." without parens -> say("...")
    elsif (match($result, "\\bprint\\s+\"") && !match($result, "\\bprint\\s*\\(")) {
        $result = replace($result, "\\bprint\\s+", "say(");
        $result = add_close_paren($result);
    }
    # print $var or print $var . "..." or print func() without parens -> say($var...)
    elsif (match($result, "\\bprint\\s+[\\$a-z_]") && !match($result, "\\bprint\\s*\\(") && !match($result, "\\bprint\\s+STDERR") && !match($result, "\\bprint\\s+STDOUT") && !match($result, "\\bprint\\s+[A-Z][A-Z]") && !match($result, "\\bprint\\s+if\\b") && !match($result, "\\bprint\\s+unless\\b") && !match($result, "\\bprintf")) {
        $result = replace($result, "\\bprint\\s+", "say(");
        $result = add_close_paren($result);
    }
    # say "..." without parens -> say("...")
    if (match($result, "\\bsay\\s+\"") && !match($result, "\\bsay\\s*\\(")) {
        $result = replace($result, "\\bsay\\s+", "say(");
        $result = add_close_paren($result);
    }
    # say $var or say $var . "..." without parens -> say($var...)
    if (match($result, "\\bsay\\s+\\$") && !match($result, "\\bsay\\s*\\(") && !match($result, "\\bsay\\s+if\\b") && !match($result, "\\bsay\\s+unless\\b")) {
        $result = replace($result, "\\bsay\\s+", "say(");
        $result = add_close_paren($result);
    }
    # Bare print; (prints $_) -> say($_);
    if (trim_str($result) eq "print;" || match($result, "^\\s*print\\s*;\\s*$")) {
        $result = $indent . "say($_);  # REVIEW: bare print â€” verify $_ is in scope";
    }
    # Bare say; (prints $_) -> say($_);
    if (trim_str($result) eq "say;" || match($result, "^\\s*say\\s*;\\s*$")) {
        $result = $indent . "say($_);  # REVIEW: bare say â€” verify $_ is in scope";
    }
    # print $_ -> say($_)
    if (match($result, "\\bprint\\s+\\$_\\s*;") && !match($result, "\\bprint\\s*\\(")) {
        $result = replace($result, "\\bprint\\s+\\$_\\s*;", "say($_);");
    }

    # ---- say() trailing \n cleanup ----
    # say() already adds a newline, so say("...\n") produces a double newline.
    # Strip trailing \n from say() arguments; convert say("...\n") -> say("...")
    # Also: if say("text") had no trailing \n, it was originally print without \n â€” use print() instead.
    if (match($result, "\\bsay\\(") && !match($result, "^\\s*#")) {
        # say("...\n") -> say("...")  (strip trailing literal \n before closing quote+paren)
        if (match($result, "\\\\n\"\\)\\s*;")) {
            $result = replace($result, "\\\\n\"\\)\\s*;", "\");");
        }
        # say($fh, "...\n") -> say($fh, "...")
        elsif (match($result, "\\\\n\"\\)\\s*;")) {
            $result = replace($result, "\\\\n\"\\)\\s*;", "\");");
        }
        # say("..." . "\n") -> say("...")
        if (match($result, "\\. \"\\\\n\"\\)\\s*;")) {
            $result = replace($result, " \\. \"\\\\n\"\\)\\s*;", ");");
        }
    }

    # ---- $#array -> (scalar(@array) - 1) ----
    # $#array gives the last index (length - 1)
    if (match($result, "\\$#[A-Za-z_]")) {
        my int $dh_safety = 0;
        while (match($result, "\\$#[A-Za-z_]") && $dh_safety < 10) {
            my array @dhcap = capture($result, "\\$#([A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@dhcap) > 1) {
                my str $arr_name = $dhcap[1];
                # Build replacement - need to use index+substr since $ can't be matched literally
                my int $dh_pos = index($result, "$#" . $arr_name);
                if ($dh_pos >= 0) {
                    my str $before = substr($result, 0, $dh_pos);
                    my str $after = substr($result, $dh_pos + 2 + length($arr_name), length($result) - $dh_pos - 2 - length($arr_name));
                    $result = $before . "(scalar(@" . $arr_name . ") - 1)" . $after;
                } else {
                    $dh_safety = 10;
                }
            } else {
                $dh_safety = 10;
            }
            $dh_safety++;
        }
    }

    # ---- Enforce parens on builtins ----

    # push @arr, val -> push(@arr, val)
    if (match($result, "\\bpush\\s+@") && !match($result, "\\bpush\\s*\\(")) {
        $result = replace($result, "\\bpush\\s+", "push(");
        $result = add_close_paren($result);
    }
    # pop @arr -> pop(@arr)
    if (match($result, "\\bpop\\s+@") && !match($result, "\\bpop\\s*\\(")) {
        $result = replace($result, "\\bpop\\s+", "pop(");
        $result = add_close_paren($result);
    }
    # shift @arr -> shift(@arr)
    if (match($result, "\\bshift\\s+@") && !match($result, "\\bshift\\s*\\(")) {
        $result = replace($result, "\\bshift\\s+", "shift(");
        $result = add_close_paren($result);
    }
    # bare shift (no argument) -> shift(@_)  (Perl's implicit @_)
    if (match($result, "\\bshift\\s*;") && !match($result, "\\bshift\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\bshift\\s*;", "shift(@_);");
    }
    if (match($result, "=\\s*shift\\s*;") && !match($result, "=\\s*shift\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "shift\\s*;", "shift(@_);");
    }
    # unshift @arr, val -> unshift(@arr, val)
    if (match($result, "\\bunshift\\s+@") && !match($result, "\\bunshift\\s*\\(")) {
        $result = replace($result, "\\bunshift\\s+", "unshift(");
        $result = add_close_paren($result);
    }
    # @_ in numeric comparison context -> scalar(@_)
    # @_ == N, @_ != N, @_ > N, @_ >= N, @_ < N, @_ <= N
    if (match($result, "@_\\s*[=!<>]") && !match($result, "scalar\\(@_\\)") && !match($result, "#")) {
        if (match($result, "@_\\s*[=!<>]=?\\s*[0-9]") || match($result, "[0-9]\\s*[=!<>]=?\\s*@_")) {
            $result = replace_all($result, "@_", "scalar(@_)");
        }
    }
    # if (@_) -> if (scalar(@_) > 0) â€” bare @_ in boolean context
    if (match($result, "\\bif\\s*\\(\\s*@_\\s*\\)") && !match($result, "#")) {
        $result = replace($result, "\\bif\\s*\\(\\s*@_\\s*\\)", "if (scalar(@_) > 0)");
    }

    # reverse @arr or reverse $str -> reverse(@arr) or reverse($str)
    if (match($result, "\\breverse\\s+[@\\$]") && !match($result, "\\breverse\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\breverse\\s+", "reverse(");
        $result = add_close_paren($result);
    }
    # chomp $var -> chomp($var)
    if (match($result, "\\bchomp\\s+\\$") && !match($result, "\\bchomp\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\bchomp\\s+", "chomp(");
        $result = add_close_paren($result);
    }
    # chop $var -> chop($var)
    if (match($result, "\\bchop\\s+\\$") && !match($result, "\\bchop\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\bchop\\s+", "chop(");
        $result = add_close_paren($result);
    }
    # defined $var -> defined($var)
    if (match($result, "\\bdefined\\s+\\$") && !match($result, "\\bdefined\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\bdefined\\s+", "defined(");
        $result = add_close_paren($result);
    }
    # exists $hash{key} -> exists($hash{key})
    if (match($result, "\\bexists\\s+\\$") && !match($result, "\\bexists\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\bexists\\s+", "exists(");
        $result = add_close_paren($result);
    }
    # delete $hash{key} -> delete($hash{key})
    if (match($result, "\\bdelete\\s+\\$") && !match($result, "\\bdelete\\s*\\(") && !match($result, "#") && !match($result, "core::")) {
        $result = replace($result, "\\bdelete\\s+", "delete(");
        $result = add_close_paren($result);
    }
    # ref $var -> ref($var)
    if (match($result, "\\bref\\s+\\$") && !match($result, "\\bref\\s*\\(") && !match($result, "#") && !match($result, "deref") && !match($result, "_ref")) {
        $result = replace($result, "\\bref\\s+(\\$)", "ref($1");
        $result = add_close_paren($result);
    }
    # length $var -> length($var)
    if (match($result, "\\blength\\s+\\$") && !match($result, "\\blength\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\blength\\s+", "length(");
        $result = add_close_paren($result);
    }

    # die "msg" -> die("msg")
    if (match($result, "\\bdie\\s+[\"']") && !match($result, "\\bdie\\s*\\(")) {
        $result = replace($result, "\\bdie\\s+", "die(");
        $result = add_close_paren($result);
    }
    # warn "msg" -> warn("msg")  (if not already converted from print STDERR)
    if (match($result, "\\bwarn\\s+[\"']") && !match($result, "\\bwarn\\s*\\(")) {
        $result = replace($result, "\\bwarn\\s+", "warn(");
        $result = add_close_paren($result);
    }
    # warn $variable -> warn($variable)  (die $variable handled later as throw)
    if (match($result, "\\bwarn\\s+\\$[A-Za-z_]") && !match($result, "\\bwarn\\s*\\(") && !match($result, "^\\s*#")) {
        $result = replace($result, "\\bwarn\\s+(\\$)", "warn($1");
        $result = add_close_paren($result);
    }
    # defined $x -> defined($x), defined $x[N] -> defined($x[N])
    if (match($result, "\\bdefined\\s+[\\$@%]") && !match($result, "\\bdefined\\s*\\(")) {
        # Find the variable after defined, including optional subscript [...]
        my array @dcap = capture($result, "\\bdefined\\s+(\\$[A-Za-z_][A-Za-z0-9_]*)");
        if (scalar(@dcap) > 1) {
            my str $dvar = $dcap[1];
            # Check if there's a subscript [N] or [-N] or [$var] immediately after the variable
            my str $dsub = "";
            my str $dvar_esc = "\\" . $dvar;
            my array @dsub_cap = capture($result, "\\bdefined\\s+" . $dvar_esc . "(\\[[^\\]]*\\])");
            if (scalar(@dsub_cap) > 1) {
                $dsub = $dsub_cap[1];
                $result = replace($result, "defined\\s+" . $dvar_esc . "\\[[^\\]]*\\]", "defined(" . $dvar . $dsub . ")");
            } else {
                # Also check for hash subscript {key}
                my array @dhsub_cap = capture($result, "\\bdefined\\s+" . $dvar_esc . "(\\{[^}]*\\})");
                if (scalar(@dhsub_cap) > 1) {
                    $dsub = $dhsub_cap[1];
                    $result = replace($result, "defined\\s+" . $dvar_esc . "\\{[^}]*\\}", "defined(" . $dvar . $dsub . ")");
                } else {
                    $result = replace($result, "defined\\s+" . $dvar_esc, "defined(" . $dvar . ")");
                }
            }
        }
    }

    # delete $h{key} -> delete $h{"key"}  (Strada uses: delete $h{"key"})
    # No paren conversion needed - bare key quoting handles the rest

    # keys %$ref -> keys(%{$ref})  (hashref dereference)
    if (match($result, "\\bkeys\\s+%\\$") && !match($result, "\\bkeys\\s*\\(")) {
        my array @krcap = capture($result, "\\bkeys\\s+%\\$([A-Za-z_][A-Za-z0-9_]*)");
        if (scalar(@krcap) > 1) {
            $result = replace($result, "\\bkeys\\s+%\\$[A-Za-z_][A-Za-z0-9_]*", "keys(%{$" . $krcap[1] . "})");
        }
    }
    # values %$ref -> values(%{$ref})
    elsif (match($result, "\\bvalues\\s+%\\$") && !match($result, "\\bvalues\\s*\\(")) {
        my array @vrcap = capture($result, "\\bvalues\\s+%\\$([A-Za-z_][A-Za-z0-9_]*)");
        if (scalar(@vrcap) > 1) {
            $result = replace($result, "\\bvalues\\s+%\\$[A-Za-z_][A-Za-z0-9_]*", "values(%{$" . $vrcap[1] . "})");
        }
    }
    # keys %h -> keys(%h)  (smart close paren - single-arg builtins)
    if (match($result, "\\bkeys\\s+%") && !match($result, "\\bkeys\\s*\\(")) {
        $result = replace($result, "\\bkeys\\s+", "keys(");
        $result = add_close_paren_after_arg($result, "keys");
    }
    # values %h -> values(%h)
    if (match($result, "\\bvalues\\s+%") && !match($result, "\\bvalues\\s*\\(")) {
        $result = replace($result, "\\bvalues\\s+", "values(");
        $result = add_close_paren_after_arg($result, "values");
    }
    # ref $var -> ref($var)
    if (match($result, "\\bref\\s+\\$") && !match($result, "\\bref\\s*\\(")) {
        $result = replace($result, "\\bref\\s+", "ref(");
        $result = add_close_paren_after_arg($result, "ref");
    }
    # length $var -> length($var)
    if (match($result, "\\blength\\s+\\$") && !match($result, "\\blength\\s*\\(")) {
        $result = replace($result, "\\blength\\s+", "length(");
        $result = add_close_paren_after_arg($result, "length");
    }
    # scalar @arr -> scalar(@arr)
    if (match($result, "\\bscalar\\s+@") && !match($result, "\\bscalar\\s*\\(")) {
        $result = replace($result, "\\bscalar\\s+@", "scalar(@");
        $result = add_close_paren_after_arg($result, "scalar");
    }
    # exists $h{key} -> exists($h{key})  (smart close paren)
    if (match($result, "\\bexists\\s+\\$") && !match($result, "\\bexists\\s*\\(")) {
        $result = replace($result, "\\bexists\\s+", "exists(");
        $result = add_close_paren_after_arg($result, "exists");
    }

    # tie %hash, "Class" -> tie(%hash, "Class")
    if (match($result, "\\btie\\s+[%@]") && !match($result, "\\btie\\s*\\(") && !match($result, "untie")) {
        $result = replace($result, "\\btie\\s+", "tie(");
        $result = add_close_paren($result);
    }
    # untie %hash -> untie(%hash)
    if (match($result, "\\buntie\\s+[%@]") && !match($result, "\\buntie\\s*\\(")) {
        $result = replace($result, "\\buntie\\s+", "untie(");
        $result = add_close_paren_after_arg($result, "untie");
    }
    # tied %hash -> tied(%hash)
    if (match($result, "\\btied\\s+[%@]") && !match($result, "\\btied\\s*\\(")) {
        $result = replace($result, "\\btied\\s+", "tied(");
        $result = add_close_paren_after_arg($result, "tied");
    }

    # ---- int/abs paren enforcement ----
    # int $x -> int($x)
    if (match($result, "\\bint\\s+\\$") && !match($result, "\\bint\\s*\\(") && !match($result, "\\bmy\\s+int\\b") && !match($result, "^\\s*func\\s")) {
        $result = replace($result, "\\bint\\s+(\\$)", "int($1");
        $result = add_close_paren_after_arg($result, "int");
    }
    # abs $x -> abs($x)
    if (match($result, "\\babs\\s+\\$") && !match($result, "\\babs\\s*\\(")) {
        $result = replace($result, "\\babs\\s+(\\$)", "abs($1");
        $result = add_close_paren_after_arg($result, "abs");
    }

    # ---- String case functions (bare form paren enforcement) ----
    # lc $str -> lc($str)
    if (match($result, "\\blc\\s+\\$") && !match($result, "\\blc\\s*\\(")) {
        $result = replace($result, "\\blc\\s+", "lc(");
        $result = add_close_paren_after_arg($result, "lc");
    }
    # uc $str -> uc($str)
    if (match($result, "\\buc\\s+\\$") && !match($result, "\\buc\\s*\\(")) {
        $result = replace($result, "\\buc\\s+", "uc(");
        $result = add_close_paren_after_arg($result, "uc");
    }
    # lcfirst $str -> lcfirst($str)
    if (match($result, "\\blcfirst\\s+\\$") && !match($result, "\\blcfirst\\s*\\(")) {
        $result = replace($result, "\\blcfirst\\s+", "lcfirst(");
        $result = add_close_paren_after_arg($result, "lcfirst");
    }
    # ucfirst $str -> ucfirst($str)
    if (match($result, "\\bucfirst\\s+\\$") && !match($result, "\\bucfirst\\s*\\(")) {
        $result = replace($result, "\\bucfirst\\s+", "ucfirst(");
        $result = add_close_paren_after_arg($result, "ucfirst");
    }

    # fc($str) -> lc($str) (Unicode case fold approximated with lc)
    if (match($result, "\\bfc\\s*\\(") && !match($result, "#") && !match($result, "->fc") && !match($result, "[A-Za-z_]fc\\s*\\(")) {
        $result = replace($result, "\\bfc\\s*\\(", "lc(");
        $result = $result . "  # Note: fc() (Unicode case fold) approximated with lc()";
    }

    # builtin true/false/is_bool (Perl 5.36+)
    if (match($result, "\\btrue\\b") && !match($result, "#") && !match($result, "\".*true.*\"") && !match($result, "'.*true.*'") && !match($result, "\\$true") && !match($result, "_true")) {
        $result = replace_keyword_outside_strings($result, "true", "1");
    }
    if (match($result, "\\bfalse\\b") && !match($result, "#") && !match($result, "\".*false.*\"") && !match($result, "'.*false.*'") && !match($result, "\\$false") && !match($result, "_false")) {
        $result = replace_keyword_outside_strings($result, "false", "0");
    }
    if (match($result, "\\bis_bool\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\bis_bool\\s*\\(", "(ref(");
        # Close: is_bool(X) -> (ref(X) eq "")
        # This is approximate â€” just add a TODO
        $result = $result . "  # REVIEW: is_bool() approximated - Strada has no bool type; check manually";
    }

    # ---- sprintf paren enforcement ----
    # sprintf "fmt", $a, $b -> sprintf("fmt", $a, $b)
    if (match($result, "\\bsprintf\\s+\"") && !match($result, "\\bsprintf\\s*\\(")) {
        $result = replace($result, "\\bsprintf\\s+", "sprintf(");
        $result = add_close_paren($result);
    }

    # sprintf with Perl-specific format specifiers (%v, %b)
    if (match($result, "\\bsprintf\\s*\\(") && !match($result, "#.*TODO")) {
        if (match($result, "%v") || match($result, "%b")) {
            $result = $result . "  # REVIEW: %v/%b are Perl-specific â€” format manually";
        }
    }

    # ---- Ampersand call syntax ----
    # &$ref(args) -> $ref->(args)  (must check before &func to avoid false match)
    if (index($result, "&") >= 0) {
        if (match($result, "&\\$[A-Za-z_][A-Za-z0-9_]*\\s*\\(")) {
            my array @amp_cap = capture($result, "&(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*\\(");
            if (scalar(@amp_cap) > 1) {
                my str $ref_var = $amp_cap[1];
                my int $amp_pos = index($result, "&" . $ref_var);
                if ($amp_pos >= 0) {
                    # Make sure it's not \& (reference taking)
                    if ($amp_pos == 0 || substr($result, $amp_pos - 1, 1) ne "\\") {
                        $result = replace($result, "&\\" . $ref_var . "\\s*\\(", $ref_var . "->(");
                    }
                }
            }
        }
        # &func(args) -> func(args)  (strip leading &, but not \&func which is a reference)
        elsif (match($result, "&[A-Za-z_][A-Za-z0-9_:]*\\s*\\(")) {
            my array @amp_cap2 = capture($result, "&([A-Za-z_][A-Za-z0-9_:]*)\\s*\\(");
            if (scalar(@amp_cap2) > 1) {
                my str $func_name = $amp_cap2[1];
                my int $amp_pos2 = index($result, "&" . $func_name);
                if ($amp_pos2 >= 0) {
                    if ($amp_pos2 == 0 || substr($result, $amp_pos2 - 1, 1) ne "\\") {
                        $result = replace($result, "&" . $func_name . "\\s*\\(", $func_name . "(");
                    }
                }
            }
        }
    }

    # ---- chomp/chop ----
    if (match($result, "\\bchomp\\s*\\(\\$([A-Za-z_][A-Za-z0-9_]*)\\)")) {
        my array @ccap = capture($result, "\\bchomp\\s*\\(\\$([A-Za-z_][A-Za-z0-9_]*)\\)");
        if (scalar(@ccap) > 1) {
            my str $var = $ccap[1];
            $result = replace($result, "chomp\\s*\\(\\$" . $var . "\\)", "$" . $var . " =~ s/\\n$//");
        }
    }
    elsif (match($result, "\\bchomp\\s+\\$([A-Za-z_][A-Za-z0-9_]*)")) {
        my array @ccap2 = capture($result, "\\bchomp\\s+\\$([A-Za-z_][A-Za-z0-9_]*)");
        if (scalar(@ccap2) > 1) {
            my str $var = $ccap2[1];
            $result = replace($result, "chomp\\s+\\$" . $var, "$" . $var . " =~ s/\\n$//");
        }
    }
    # chomp @array or chomp(@array) -> REVIEW: Strada chomp is scalar-only
    if (match($result, "\\bchomp\\s*\\(?\\s*@[A-Za-z_]") && !match($result, "^\\s*#")) {
        $result = $result . "  # REVIEW: chomp on array â€” Strada chomp is scalar-only, use a loop";
    }

    if (match($result, "\\bchop\\s*\\(\\$([A-Za-z_][A-Za-z0-9_]*)\\)")) {
        my array @ccap3 = capture($result, "\\bchop\\s*\\(\\$([A-Za-z_][A-Za-z0-9_]*)\\)");
        if (scalar(@ccap3) > 1) {
            my str $var = $ccap3[1];
            $result = replace($result, "chop\\s*\\(\\$" . $var . "\\)", "$" . $var . " = substr($" . $var . ", 0, length($" . $var . ") - 1)");
        }
    }

    # ---- bless conversion ----
    # bless $ref, $class -> bless($ref, "ClassName")
    # bless \%self, $class -> bless(\%self, $class) - already valid Strada
    # Note: Strada bless works the same way, just ensure parens
    # Add REVIEW suggesting Strada declarative OOP with specific guidance
    if (match($result, "\\breturn\\s+bless\\s+") && !match($result, "\\breturn\\s+bless\\s*\\(")) {
        $result = replace($result, "\\breturn\\s+bless\\s+", "return bless(");
        $result = add_close_paren_smart($result, "bless");
    }
    elsif (match($result, "\\bbless\\s+[\\\\\\$\\{]") && !match($result, "\\bbless\\s*\\(")) {
        $result = replace($result, "\\bbless\\s+", "bless(");
        $result = add_close_paren_smart($result, "bless");
    }
    # Add guidance for bless â€” only add REVIEW for non-trivial patterns
    if (match($result, "\\bbless\\s*\\(")) {
        if (match($result, "bless\\s*\\(\\s*\\\\\\*") || match($result, "bless\\s*\\(\\s*\\$[a-z]*fh")) {
            # bless \*FH, $class â€” filehandle blessing needs attention
            $result = $result . "  # REVIEW: filehandle blessing â€” wrap FH in hash: { fh => $fh }";
        } elsif (match($result, "bless\\s*\\(\\s*\\{") || match($result, "bless\\s*\\(\\s*\\\\%") || match($result, "bless\\s*\\(\\s*\\$self") || match($result, "bless\\s*\\(\\s*\\$class")) {
            # bless {}, $class or bless \%self or bless $self â€” standard, works in Strada
            # No REVIEW needed â€” bless works the same way
        } else {
            $result = $result . "  # consider Strada OOP: 'has ro|rw type $attr;' with auto constructor";
        }
    }

    # ---- printf conversion ----
    # printf "fmt", args -> sprintf("fmt", args) with say
    if (match($result, "\\bprintf\\s+STDERR\\s+")) {
        $result = replace($result, "\\bprintf\\s+STDERR\\s+", "warn(sprintf(");
        $result = add_close_paren($result);
        # Add extra ) for the sprintf wrapper
        my int $sp = index($result, ");");
        if ($sp >= 0) {
            $result = substr($result, 0, $sp) . "))" . substr($result, $sp + 1, length($result) - $sp - 1);
        }
    }
    elsif (match($result, "\\bprintf\\s+STDOUT\\s+")) {
        $result = replace($result, "\\bprintf\\s+STDOUT\\s+", "print(sprintf(");
        $result = add_close_paren($result);
        my int $sp3 = index($result, ");");
        if ($sp3 >= 0) {
            $result = substr($result, 0, $sp3) . "))" . substr($result, $sp3 + 1, length($result) - $sp3 - 1);
        }
    }
    elsif (match($result, "\\bprintf\\s+") && !match($result, "\\bprintf\\s*\\(") && !match($result, "\\bsprintf\\b") && !match($result, "\\bprintf\\s+\\$[A-Za-z_]")) {
        $result = replace($result, "\\bprintf\\s+", "print(sprintf(");
        $result = add_close_paren($result);
        my int $sp2 = index($result, ");");
        if ($sp2 >= 0) {
            $result = substr($result, 0, $sp2) . "))" . substr($result, $sp2 + 1, length($result) - $sp2 - 1);
        }
    }

    # ---- chomp + read decomposition (must be BEFORE <STDIN> replacement) ----
    # chomp(my $input = <STDIN>) -> my scalar $input = core::readline(); $input =~ s/\n$//;
    if (match($result, "\\bchomp\\s*\\(\\s*my\\s+") && match($result, "<STDIN>")) {
        my array @ccomb = capture($result, "chomp\\s*\\(\\s*my\\s+(scalar\\s+)?\\$([A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*<STDIN>\\s*\\)");
        if (scalar(@ccomb) > 2) {
            my str $cvar = "$" . $ccomb[2];
            $result = $indent . "my scalar " . $cvar . " = core::readline();";
            $result = $result . "\n" . $indent . $cvar . " =~ s/\\n$//;";
            return $result;
        }
    }
    # chomp(my $line = <$fh>) -> my scalar $line = <$fh>; $line =~ s/\n$//;
    if (match($result, "\\bchomp\\s*\\(\\s*my\\s+") && match($result, "<\\$")) {
        my array @ccfh = capture($result, "chomp\\s*\\(\\s*my\\s+(scalar\\s+)?\\$([A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*(<\\$[A-Za-z_][A-Za-z0-9_]*>)\\s*\\)");
        if (scalar(@ccfh) > 3) {
            my str $cvar = "$" . $ccfh[2];
            my str $diamond = $ccfh[3];
            $result = $indent . "my scalar " . $cvar . " = " . $diamond . ";";
            $result = $result . "\n" . $indent . $cvar . " =~ s/\\n$//;";
            return $result;
        }
    }

    # ---- Diamond operator <STDIN> / <$fh> ----
    # my $line = <STDIN>; -> my $line = core::readline();
    # Skip if inside while() - that's handled later with defined() wrapper
    if (match($result, "<STDIN>") && !match($result, "while\\s*\\(")) {
        $result = replace_all($result, "<STDIN>", "core::readline()");
    }
    # <> (bare diamond - reads STDIN or ARGV files) -> core::readline()
    # Skip if inside while() - that's handled later with defined() wrapper
    if (match($result, "<>") && !match($result, "<=>") && !match($result, "<<") && !match($result, ">>") && !match($result, "#") && !match($result, "while\\s*\\(")) {
        $result = replace_all($result, "<>", "core::readline()");
        $result = $result . "  # <> converted to core::readline() (reads STDIN; Perl also reads @ARGV files)";
    }
    # <$fh> -> <$fh>  (already valid Strada diamond operator)
    # No conversion needed for <$fh> - Strada supports it natively

    # ---- s{pattern}{replacement}flags -> s/pattern/replacement/flags ----
    if (match($result, "=~\\s*s\\{")) {
        my array @sb_cap = capture($result, "=~\\s*s\\{([^}]*)\\}\\{([^}]*)\\}([a-z]*)");
        if (scalar(@sb_cap) > 2) {
            my str $sb_pat = $sb_cap[1];
            my str $sb_repl = $sb_cap[2];
            my str $sb_flags = "";
            if (scalar(@sb_cap) > 3) {
                $sb_flags = $sb_cap[3];
            }
            $result = replace($result, "=~\\s*s\\{[^}]*\\}\\{[^}]*\\}[a-z]*", "=~ s/" . $sb_pat . "/" . $sb_repl . "/" . $sb_flags);
        }
    }
    if (match($result, "!~\\s*s\\{")) {
        my array @sb_cap2 = capture($result, "!~\\s*s\\{([^}]*)\\}\\{([^}]*)\\}([a-z]*)");
        if (scalar(@sb_cap2) > 2) {
            my str $sb_pat2 = $sb_cap2[1];
            my str $sb_repl2 = $sb_cap2[2];
            my str $sb_flags2 = "";
            if (scalar(@sb_cap2) > 3) {
                $sb_flags2 = $sb_cap2[3];
            }
            $result = replace($result, "!~\\s*s\\{[^}]*\\}\\{[^}]*\\}[a-z]*", "!~ s/" . $sb_pat2 . "/" . $sb_repl2 . "/" . $sb_flags2);
        }
    }

    # ---- Regex m// stripping ----
    # =~ m/pattern/ -> =~ /pattern/  (Strada doesn't use m prefix)
    # =~ m{pattern} -> =~ /pattern/
    if (match($result, "=~\\s*m/")) {
        $result = replace($result, "=~\\s*m/", "=~ /");
    }
    if (match($result, "!~\\s*m/")) {
        $result = replace($result, "!~\\s*m/", "!~ /");
    }
    # m{pattern} with braces -> /pattern/ (escape any / in the pattern)
    if (match($result, "=~\\s*m\\{") || match($result, "!~\\s*m\\{")) {
        my str $m_op = "=~";
        if (match($result, "!~\\s*m\\{")) { $m_op = "!~"; }
        my array @mbcap = capture($result, $m_op . "\\s*m\\{([^}]*)\\}([gimsxe]*)");
        if (scalar(@mbcap) > 1) {
            my str $m_pat = $mbcap[1];
            my str $m_flags = "";
            if (scalar(@mbcap) > 2) { $m_flags = $mbcap[2]; }
            # Escape forward slashes in the pattern
            $m_pat = replace_all($m_pat, "/", "\\/");
            $result = replace($result, $m_op . "\\s*m\\{[^}]*\\}[gimsxe]*", $m_op . " /" . $m_pat . "/" . $m_flags);
        }
    }
    # m|pattern| with pipes -> /pattern/ (escape any / in the pattern)
    if (match($result, "=~\\s*m\\|") || match($result, "!~\\s*m\\|")) {
        my str $m_op2 = "=~";
        if (match($result, "!~\\s*m\\|")) { $m_op2 = "!~"; }
        my array @mpcap = capture($result, $m_op2 . "\\s*m\\|([^|]*)\\|([gimsxe]*)");
        if (scalar(@mpcap) > 1) {
            my str $m_pat2 = $mpcap[1];
            my str $m_flags2 = "";
            if (scalar(@mpcap) > 2) { $m_flags2 = $mpcap[2]; }
            $m_pat2 = replace_all($m_pat2, "/", "\\/");
            $result = replace($result, $m_op2 . "\\s*m\\|[^|]*\\|[gimsxe]*", $m_op2 . " /" . $m_pat2 . "/" . $m_flags2);
        }
    }
    # Standalone m{} / m|| in boolean context: if (m{pattern}) -> if (/pattern/)
    if (match($result, "\\bm\\{") && !match($result, "=~") && !match($result, "!~")) {
        my array @mscap = capture($result, "\\bm\\{([^}]*)\\}([gimsxe]*)");
        if (scalar(@mscap) > 1) {
            my str $ms_pat = $mscap[1];
            my str $ms_flags = "";
            if (scalar(@mscap) > 2) { $ms_flags = $mscap[2]; }
            $ms_pat = replace_all($ms_pat, "/", "\\/");
            $result = replace($result, "\\bm\\{[^}]*\\}[gimsxe]*", "/" . $ms_pat . "/" . $ms_flags);
        }
    }
    if (match($result, "\\bm\\|") && !match($result, "=~") && !match($result, "!~")) {
        my array @ms2cap = capture($result, "\\bm\\|([^|]*)\\|([gimsxe]*)");
        if (scalar(@ms2cap) > 1) {
            my str $ms2_pat = $ms2cap[1];
            my str $ms2_flags = "";
            if (scalar(@ms2cap) > 2) { $ms2_flags = $ms2cap[2]; }
            $ms2_pat = replace_all($ms2_pat, "/", "\\/");
            $result = replace($result, "\\bm\\|[^|]*\\|[gimsxe]*", "/" . $ms2_pat . "/" . $ms2_flags);
        }
    }

    # ---- Compound assignment operators ----
    # //= is valid Strada, pass through
    # .= concatenation: $s .= "x" -> $s = $s . "x"
    # Capture RHS up to semicolon (not trailing comments)
    if (match($result, "\\$[A-Za-z_][A-Za-z0-9_]*\\s*\\.=\\s*") && !match($result, "^\\s*#")) {
        my array @dcap2 = capture($result, "(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*\\.=\\s*(.+;)");
        if (scalar(@dcap2) > 2) {
            my str $lhs = $dcap2[1];
            my str $rhs = $dcap2[2];
            # Strip trailing semicolon from rhs, we'll add it back
            if (substr($rhs, length($rhs) - 1, 1) eq ";") {
                $rhs = substr($rhs, 0, length($rhs) - 1);
            }
            $result = replace($result, "\\" . $lhs . "\\s*\\.=\\s*" . ".*$", $lhs . " = " . $lhs . " . " . $rhs . ";");
        } else {
            # Fallback: no semicolon (e.g. inside blocks)
            my array @dcap2b = capture($result, "(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*\\.=\\s*(.+)$");
            if (scalar(@dcap2b) > 2) {
                my str $lhs2 = $dcap2b[1];
                my str $rhs2 = $dcap2b[2];
                $result = replace($result, "\\" . $lhs2 . "\\s*\\.=\\s*" . ".*$", $lhs2 . " = " . $lhs2 . " . " . $rhs2);
            }
        }
    }

    # ---- ||= compound assignment ----
    # $x ||= "default" -> $x = $x || "default"
    if (match($result, "\\$[A-Za-z_][A-Za-z0-9_]*\\s*\\|\\|=\\s*") && !match($result, "//=") && !match($result, "^\\s*#")) {
        my array @oacap = capture($result, "(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*\\|\\|=\\s*(.+;)");
        if (scalar(@oacap) > 2) {
            my str $olhs = $oacap[1];
            my str $orhs = $oacap[2];
            if (substr($orhs, length($orhs) - 1, 1) eq ";") {
                $orhs = substr($orhs, 0, length($orhs) - 1);
            }
            $result = replace($result, "\\" . $olhs . "\\s*\\|\\|=\\s*.*$", $olhs . " = " . $olhs . " || " . $orhs . ";");
        } else {
            my array @oacapb = capture($result, "(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*\\|\\|=\\s*(.+)$");
            if (scalar(@oacapb) > 2) {
                my str $olhs2 = $oacapb[1];
                my str $orhs2 = $oacapb[2];
                $result = replace($result, "\\" . $olhs2 . "\\s*\\|\\|=\\s*.*$", $olhs2 . " = " . $olhs2 . " || " . $orhs2);
            }
        }
    }
    # &&= compound assignment
    if (match($result, "\\$[A-Za-z_][A-Za-z0-9_]*\\s*&&=\\s*") && !match($result, "^\\s*#")) {
        my array @aacap = capture($result, "(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*&&=\\s*(.+;)");
        if (scalar(@aacap) > 2) {
            my str $aalhs = $aacap[1];
            my str $aarhs = $aacap[2];
            if (substr($aarhs, length($aarhs) - 1, 1) eq ";") {
                $aarhs = substr($aarhs, 0, length($aarhs) - 1);
            }
            $result = replace($result, "\\" . $aalhs . "\\s*&&=\\s*.*$", $aalhs . " = " . $aalhs . " && " . $aarhs . ";");
        } else {
            my array @aacapb = capture($result, "(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*&&=\\s*(.+)$");
            if (scalar(@aacapb) > 2) {
                my str $aalhs2 = $aacapb[1];
                my str $aarhs2 = $aacapb[2];
                $result = replace($result, "\\" . $aalhs2 . "\\s*&&=\\s*.*$", $aalhs2 . " = " . $aalhs2 . " && " . $aarhs2);
            }
        }
    }

    # ---- File I/O conversion ----

    # Add parens to bare open: open my $fh, '<', $file -> open(my $fh, '<', $file)
    if (match($result, "\\bopen\\s+my\\s+") && !match($result, "\\bopen\\s*\\(") && !match($result, "core::open") && !match($result, "#")) {
        # Strip "or do { ... }" / "|| do { ... }" suffix â€” converts to if (!defined) check
        my str $open_do_suffix = "";
        if (match($result, "\\s+(or|\\|\\|)\\s+do\\s*\\{")) {
            # Capture the variable name for the if-check
            my array @odv_cap = capture($result, "\\bopen\\s+my\\s+\\$([A-Za-z_][A-Za-z0-9_]*)");
            my str $open_do_var = "";
            if (scalar(@odv_cap) > 1) {
                $open_do_var = $odv_cap[1];
            }
            # Strip "or do {" and everything after
            $result = replace($result, "\\s+(?:or|\\|\\|)\\s+do\\s*\\{.*$", "");
            if (length($open_do_var) > 0) {
                # $open_ordo_var = $open_do_var;  # DISABLED for debugging
            }
        }
        # Strip "or die ..." or "|| die ..." suffix before adding parens
        my str $open_die_suffix = "";
        if (match($result, "\\s+(or|\\|\\|)\\s+die")) {
            my array @od_cap = capture($result, "\\s+((?:or|\\|\\|)\\s+die.*)$");
            if (scalar(@od_cap) > 1) {
                $open_die_suffix = " " . trim_str($od_cap[1]);
                $result = replace($result, "\\s+(?:or|\\|\\|)\\s+die.*$", "");
            }
        }
        # Strip trailing semicolon before adding parens
        my int $had_semi = 0;
        if (match($result, ";\\s*$")) {
            $result = replace($result, ";\\s*$", "");
            $had_semi = 1;
        }
        # Add parens: "open my $fh, ..." -> "open(my $fh, ...)"
        $result = replace($result, "\\bopen\\s+", "open(");
        $result = $result . ")";
        if (length($open_die_suffix) > 0) {
            $result = $result . " " . $open_die_suffix;
        }
        if ($had_semi == 1) {
            $result = $result . ";";
        }
    }
    # open(my $fh, '<', $file) or open(my $fh, '>', $file) -> core::open($file, "r"/"w")
    # Note: variable may already be typed as "my scalar $fh" by earlier conversion
    if (match($result, "\\bopen\\s*\\(") && !match($result, "core::open")) {
        # open to string ref: open(my $fh, '<', \$string) -> core::open(\$string, "r")
        if (match($result, "open\\s*\\([^,]+,\\s*['\"][<>]+['\"]\\s*,\\s*\\\\\\$")) {
            my array @mio_vcap = capture($result, "open\\s*\\((my\\s+(scalar\\s+)?)?\\$([A-Za-z_][A-Za-z0-9_]*)");
            my array @mio_mcap = capture($result, ",\\s*['\"]([<>]+)['\"]\\s*,\\s*\\\\\\$([A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@mio_vcap) > 3 && scalar(@mio_mcap) > 2) {
                my str $mio_var = $mio_vcap[3];
                my str $mio_mode = $mio_mcap[1];
                my str $mio_src = $mio_mcap[2];
                my str $strada_mode = "r";
                if ($mio_mode eq ">") {
                    $strada_mode = "w";
                } elsif ($mio_mode eq ">>") {
                    $strada_mode = "a";
                }
                $result = $indent . "my scalar $" . $mio_var . " = core::open(\\" . "$" . $mio_src . ", \"" . $strada_mode . "\");";
            }
            return $result;
        }

        # Three-arg open pipe: open(my $fh, '|-', $cmd) -> core::popen($cmd, "w")
        # and open(my $fh, '-|', $cmd) -> core::popen($cmd, "r")
        if (match($result, "open\\s*\\([^,]+,\\s*['\"]\\|\\-['\"]\\s*,\\s*")) {
            my array @pipe_vcap = capture($result, "open\\s*\\((my\\s+(scalar\\s+)?)?\\$([A-Za-z_][A-Za-z0-9_]*)");
            my array @pipe_ccap = capture($result, "['\"]\\|\\-['\"]\\s*,\\s*(.+?)\\s*\\)");
            if (scalar(@pipe_vcap) > 3 && scalar(@pipe_ccap) > 1) {
                my str $pipe_var = $pipe_vcap[3];
                my str $pipe_cmd = trim_str($pipe_ccap[1]);
                $result = $indent . "my scalar $" . $pipe_var . " = core::popen(" . $pipe_cmd . ", \"w\");";
            }
        }
        elsif (match($result, "open\\s*\\([^,]+,\\s*['\"]\\-\\|['\"]\\s*,\\s*")) {
            my array @pipe_vcap2 = capture($result, "open\\s*\\((my\\s+(scalar\\s+)?)?\\$([A-Za-z_][A-Za-z0-9_]*)");
            my array @pipe_ccap2 = capture($result, "['\"]\\-\\|['\"]\\s*,\\s*(.+?)\\s*\\)");
            if (scalar(@pipe_vcap2) > 3 && scalar(@pipe_ccap2) > 1) {
                my str $pipe_var2 = $pipe_vcap2[3];
                my str $pipe_cmd2 = trim_str($pipe_ccap2[1]);
                $result = $indent . "my scalar $" . $pipe_var2 . " = core::popen(" . $pipe_cmd2 . ", \"r\");";
            }
        }
        # Three-arg open with encoding layer: open(my $fh, '<:encoding(UTF-8)', $file)
        # Strip encoding layer and convert mode
        elsif (match($result, "open\\s*\\([^,]+,\\s*['\"][<>]+:")) {
            my array @enc_vcap = capture($result, "open\\s*\\((my\\s+(scalar\\s+)?)?\\$([A-Za-z_][A-Za-z0-9_]*)");
            my array @enc_mcap = capture($result, ",\\s*['\"]([<>]+):([^'\"]*)['\"]\\s*,\\s*([^)]+)\\)");
            if (scalar(@enc_vcap) > 3 && scalar(@enc_mcap) > 3) {
                my str $enc_var = $enc_vcap[3];
                my str $enc_mode = $enc_mcap[1];
                my str $enc_layer = $enc_mcap[2];
                my str $enc_file = trim_str($enc_mcap[3]);
                my str $strada_mode = "r";
                if ($enc_mode eq ">") { $strada_mode = "w"; }
                elsif ($enc_mode eq ">>") { $strada_mode = "a"; }
                elsif ($enc_mode eq "+<") { $strada_mode = "rw"; }
                elsif ($enc_mode eq "+>") { $strada_mode = "w"; }
                $result = $indent . "my scalar $" . $enc_var . " = core::open(" . $enc_file . ", \"" . $strada_mode . "\");  # encoding :" . $enc_layer . " stripped (Strada is UTF-8 native)";
            }
        }
        elsif (match($result, "open\\s*\\([^,]+,\\s*['\"]\\+>>['\"]\\s*,\\s*")) {
            # open(my $fh, '+>>', $file) -> my scalar $fh = core::open($file, "a")  # REVIEW: +>> is read-write append
            my array @rwa_cap = capture($result, "open\\s*\\([^,]+,\\s*['\"]\\+>>['\"]\\s*,\\s*([^)]+)\\)");
            my array @rwa_vcap = capture($result, "open\\s*\\((my\\s+(scalar\\s+)?)?\\$([A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@rwa_cap) > 1 && scalar(@rwa_vcap) > 3) {
                my str $ofile = trim_str($rwa_cap[1]);
                my str $ovar = $rwa_vcap[3];
                $result = $indent . "my scalar $" . $ovar . " = core::open(" . $ofile . ", \"a\");  # REVIEW: +>> is read-write append, core::open only supports append mode";
            }
        }
        elsif (match($result, "open\\s*\\([^,]+,\\s*['\"]\\+>['\"]\\s*,\\s*")) {
            # open(my $fh, '+>', $file) -> my scalar $fh = core::open($file, "rw")  # REVIEW: +> is read-write with truncate
            my array @rwt_cap = capture($result, "open\\s*\\([^,]+,\\s*['\"]\\+>['\"]\\s*,\\s*([^)]+)\\)");
            my array @rwt_vcap = capture($result, "open\\s*\\((my\\s+(scalar\\s+)?)?\\$([A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@rwt_cap) > 1 && scalar(@rwt_vcap) > 3) {
                my str $ofile = trim_str($rwt_cap[1]);
                my str $ovar = $rwt_vcap[3];
                $result = $indent . "my scalar $" . $ovar . " = core::open(" . $ofile . ", \"w\");  # REVIEW: +> is read-write with truncate";
            }
        }
        elsif (match($result, "open\\s*\\([^,]+,\\s*['\"]\\+<['\"]\\s*,\\s*")) {
            # open(my $fh, '+<', $file) -> my scalar $fh = core::open($file, "rw")  # REVIEW: +< is read-write without truncate
            my array @rw_cap = capture($result, "open\\s*\\([^,]+,\\s*['\"]\\+<['\"]\\s*,\\s*([^)]+)\\)");
            my array @rw_vcap = capture($result, "open\\s*\\((my\\s+(scalar\\s+)?)?\\$([A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@rw_cap) > 1 && scalar(@rw_vcap) > 3) {
                my str $ofile = trim_str($rw_cap[1]);
                my str $ovar = $rw_vcap[3];
                $result = $indent . "my scalar $" . $ovar . " = core::open(" . $ofile . ", \"rw\");  # REVIEW: +< is read-write without truncate";
            }
        }
        elsif (match($result, "open\\s*\\([^,]+,\\s*['\"]<['\"]\\s*,\\s*")) {
            # open(my $fh, '<', $file) -> my scalar $fh = core::open($file, "r")
            my array @ocap = capture($result, "open\\s*\\([^,]+,\\s*['\"]<['\"]\\s*,\\s*([^)]+)\\)");
            my array @varcap = capture($result, "open\\s*\\((my\\s+(scalar\\s+)?)?\\$([A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@ocap) > 1 && scalar(@varcap) > 3) {
                my str $ofile = trim_str($ocap[1]);
                my str $ovar = $varcap[3];
                $result = $indent . "my scalar $" . $ovar . " = core::open(" . $ofile . ", \"r\");";
            }
        }
        elsif (match($result, "open\\s*\\([^,]+,\\s*['\"]>>['\"]\\s*,\\s*")) {
            # open(my $fh, '>>', $file) -> my scalar $fh = core::open($file, "a")
            my array @ocap3 = capture($result, "open\\s*\\([^,]+,\\s*['\"]>>['\"]\\s*,\\s*([^)]+)\\)");
            my array @varcap3 = capture($result, "open\\s*\\((my\\s+(scalar\\s+)?)?\\$([A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@ocap3) > 1 && scalar(@varcap3) > 3) {
                my str $ofile = trim_str($ocap3[1]);
                my str $ovar = $varcap3[3];
                $result = $indent . "my scalar $" . $ovar . " = core::open(" . $ofile . ", \"a\");";
            }
        }
        elsif (match($result, "open\\s*\\([^,]+,\\s*['\"]>['\"]\\s*,\\s*")) {
            # open(my $fh, '>', $file) -> my scalar $fh = core::open($file, "w")
            my array @ocap2 = capture($result, "open\\s*\\([^,]+,\\s*['\"]>['\"]\\s*,\\s*([^)]+)\\)");
            my array @varcap2 = capture($result, "open\\s*\\((my\\s+(scalar\\s+)?)?\\$([A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@ocap2) > 1 && scalar(@varcap2) > 3) {
                my str $ofile = trim_str($ocap2[1]);
                my str $ovar = $varcap2[3];
                $result = $indent . "my scalar $" . $ovar . " = core::open(" . $ofile . ", \"w\");";
            }
        }
        elsif (match($result, "open\\s*\\([^,]+,\\s*['\"]\\-\\|['\"]\\s*,\\s*")) {
            # open(my $fh, '-|', "cmd") -> my scalar $fh = core::popen("cmd", "r")
            my array @pcap = capture($result, "open\\s*\\([^,]+,\\s*['\"]\\-\\|['\"]\\s*,\\s*([^)]+)\\)");
            my array @pvcap = capture($result, "open\\s*\\((my\\s+(scalar\\s+)?)?\\$([A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@pcap) > 1 && scalar(@pvcap) > 3) {
                my str $pcmd = trim_str($pcap[1]);
                my str $pvar = $pvcap[3];
                $result = $indent . "my scalar $" . $pvar . " = core::popen(" . $pcmd . ", \"r\");";
            }
        }
        elsif (match($result, "open\\s*\\([^,]+,\\s*['\"]\\|\\-['\"]\\s*,\\s*")) {
            # open(my $fh, '|-', "cmd") -> my scalar $fh = core::popen("cmd", "w")
            my array @pcap2 = capture($result, "open\\s*\\([^,]+,\\s*['\"]\\|\\-['\"]\\s*,\\s*([^)]+)\\)");
            my array @pvcap2 = capture($result, "open\\s*\\((my\\s+(scalar\\s+)?)?\\$([A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@pcap2) > 1 && scalar(@pvcap2) > 3) {
                my str $pcmd2 = trim_str($pcap2[1]);
                my str $pvar2 = $pvcap2[3];
                $result = $indent . "my scalar $" . $pvar2 . " = core::popen(" . $pcmd2 . ", \"w\");";
            }
        }
        elsif (match($result, "open\\s*\\(\\s*[A-Z][A-Z0-9_]*\\s*,")) {
            # Bareword FH: open(FH, ">", "file") or open(FH, ">file")
            my array @bfhx_cap = capture($result, "open\\s*\\(\\s*([A-Z][A-Z0-9_]*)\\s*,");
            if (scalar(@bfhx_cap) > 1) {
                my str $bfhx_name = $bfhx_cap[1];
                my str $bfhx_var = lc($bfhx_name);
                my str $bfhx_key = "bareword_fh:" . $bfhx_name;
                if (length("" . $sub_info{$bfhx_key}) > 0) {
                    $bfhx_var = "" . $sub_info{$bfhx_key};
                }
                # 3-arg: open(FH, ">", "file")
                if (match($result, "open\\s*\\(\\s*[A-Z]+\\s*,\\s*['\"]([<>]+)['\"]\\s*,\\s*")) {
                    my array @bfhx3_cap = capture($result, "open\\s*\\(\\s*[A-Z]+\\s*,\\s*['\"]([<>]+)['\"]\\s*,\\s*(.+?)\\s*\\)");
                    if (scalar(@bfhx3_cap) > 2) {
                        my str $bfhx3_mode = $bfhx3_cap[1];
                        my str $bfhx3_path = $bfhx3_cap[2];
                        my str $bfhx3_smode = "r";
                        if ($bfhx3_mode eq ">") { $bfhx3_smode = "w"; }
                        elsif ($bfhx3_mode eq ">>") { $bfhx3_smode = "a"; }
                        $result = $indent . "my scalar $" . $bfhx_var . " = core::open(" . $bfhx3_path . ", \"" . $bfhx3_smode . "\");";
                    }
                }
                # 2-arg: open(FH, ">file") or open(FH, "<file")
                elsif (match($result, "open\\s*\\(\\s*[A-Z]+\\s*,\\s*['\"]")) {
                    my array @bfhx2_cap = capture($result, "open\\s*\\(\\s*[A-Z]+\\s*,\\s*['\"]([<>]*)([^'\"]+)['\"]\\s*\\)");
                    if (scalar(@bfhx2_cap) > 2) {
                        my str $bfhx2_mode = $bfhx2_cap[1];
                        my str $bfhx2_path = $bfhx2_cap[2];
                        my str $bfhx2_smode = "r";
                        if ($bfhx2_mode eq ">") { $bfhx2_smode = "w"; }
                        elsif ($bfhx2_mode eq ">>") { $bfhx2_smode = "a"; }
                        $result = $indent . "my scalar $" . $bfhx_var . " = core::open(\"" . $bfhx2_path . "\", \"" . $bfhx2_smode . "\");";
                    }
                }
                else {
                    $result = $indent . "# REVIEW: convert open() with bareword filehandle " . $bfhx_name . " to core::open()";
                }
            }
        }
        elsif (match($result, "open\\s*\\([^,]+,\\s*['\"]\\|\\s*[A-Za-z_/]")) {
            # 2-arg pipe-write: open(my $fh, "| cmd") -> core::popen("cmd", "w")
            my array @pw_cap = capture($result, "open\\s*\\([^,]+,\\s*['\"]\\|\\s*([^'\"]+)['\"]\\s*\\)");
            my array @pw_vcap = capture($result, "open\\s*\\((my\\s+(scalar\\s+)?)?\\$([A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@pw_cap) > 1 && scalar(@pw_vcap) > 3) {
                my str $pw_cmd = trim_str($pw_cap[1]);
                my str $pw_var = $pw_vcap[3];
                $result = $indent . "my scalar $" . $pw_var . " = core::popen(\"" . $pw_cmd . "\", \"w\");";
            } else {
                $result = $result . "  # REVIEW: convert open() pipe to core::popen()";
            }
        }
        elsif (match($result, "open\\s*\\([^,]+,\\s*['\"][^|]*\\|\\s*['\"]")) {
            # 2-arg pipe-read: open(my $fh, "cmd |") -> core::popen("cmd", "r")
            my array @pr_cap = capture($result, "open\\s*\\([^,]+,\\s*['\"]([^|]+)\\|\\s*['\"]\\s*\\)");
            my array @pr_vcap = capture($result, "open\\s*\\((my\\s+(scalar\\s+)?)?\\$([A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@pr_cap) > 1 && scalar(@pr_vcap) > 3) {
                my str $pr_cmd = trim_str($pr_cap[1]);
                my str $pr_var = $pr_vcap[3];
                $result = $indent . "my scalar $" . $pr_var . " = core::popen(\"" . $pr_cmd . "\", \"r\");";
            } else {
                $result = $result . "  # REVIEW: convert open() pipe to core::popen()";
            }
        }
        elsif (match($result, "open\\s*\\([^,]+,\\s*['\"]>>")) {
            # 2-arg open: open(my $fh, ">>file") -> core::open("file", "a")
            my array @a2cap = capture($result, "open\\s*\\([^,]+,\\s*['\"]>>([^'\"]+)['\"]\\s*\\)");
            my array @a2vcap = capture($result, "open\\s*\\((my\\s+(scalar\\s+)?)?\\$([A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@a2cap) > 1 && scalar(@a2vcap) > 3) {
                my str $a2file = trim_str($a2cap[1]);
                my str $a2var = $a2vcap[3];
                $result = $indent . "my scalar $" . $a2var . " = core::open(\"" . $a2file . "\", \"a\");";
            } else {
                $result = $result . "  # REVIEW: convert open() to core::open()";
            }
        }
        elsif (match($result, "open\\s*\\([^,]+,\\s*['\"]>")) {
            # 2-arg open: open(my $fh, ">file") -> core::open("file", "w")
            my array @a2cap2 = capture($result, "open\\s*\\([^,]+,\\s*['\"]>([^'\"]+)['\"]\\s*\\)");
            my array @a2vcap2 = capture($result, "open\\s*\\((my\\s+(scalar\\s+)?)?\\$([A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@a2cap2) > 1 && scalar(@a2vcap2) > 3) {
                my str $a2file2 = trim_str($a2cap2[1]);
                my str $a2var2 = $a2vcap2[3];
                $result = $indent . "my scalar $" . $a2var2 . " = core::open(\"" . $a2file2 . "\", \"w\");";
            } else {
                $result = $result . "  # REVIEW: convert open() to core::open()";
            }
        }
        elsif (match($result, "open\\s*\\([^,]+,\\s*['\"]<")) {
            # 2-arg open: open(my $fh, "<file") -> core::open("file", "r")
            my array @a2cap3 = capture($result, "open\\s*\\([^,]+,\\s*['\"]<?([^'\"]+)['\"]\\s*\\)");
            my array @a2vcap3 = capture($result, "open\\s*\\((my\\s+(scalar\\s+)?)?\\$([A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@a2cap3) > 1 && scalar(@a2vcap3) > 3) {
                my str $a2file3 = trim_str($a2cap3[1]);
                my str $a2var3 = $a2vcap3[3];
                $result = $indent . "my scalar $" . $a2var3 . " = core::open(\"" . $a2file3 . "\", \"r\");";
            } else {
                $result = $result . "  # REVIEW: convert open() to core::open()";
            }
        }
        else {
            $result = $result . "  # REVIEW: convert open() to core::open()";
        }
    }
    # If original line had "or die" but conversion already stripped it from $result, check original $line
    if ((match($result, "core::open") || match($result, "core::popen")) && !match($result, " or die") && !match($result, " \\|\\| die") && (match($line, " or die") || match($line, " \\|\\| die"))) {
        # Extract die message from original line
        my str $orig_die_msg = "";
        my array @orig_die_cap = capture($line, "die\\s*\\(([^)]*)\\)");
        if (scalar(@orig_die_cap) > 1) {
            $orig_die_msg = $orig_die_cap[1];
        } else {
            my array @orig_die_cap2 = capture($line, "die\\s+\"([^\"]+)\"");
            if (scalar(@orig_die_cap2) > 1) { $orig_die_msg = "\"" . $orig_die_cap2[1] . "\""; }
            else {
                my array @orig_die_cap3 = capture($line, "die\\s+'([^']+)'");
                if (scalar(@orig_die_cap3) > 1) { $orig_die_msg = "\"" . $orig_die_cap3[1] . "\""; }
            }
        }
        # Extract variable name from converted result
        my array @orig_vcap = capture($result, "\\$([A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*core::");
        if (scalar(@orig_vcap) > 1) {
            my str $orig_var = $orig_vcap[1];
            if (length($orig_die_msg) > 0) {
                $result = $result . "\n" . $indent . "if (!defined($" . $orig_var . ")) { die(" . $orig_die_msg . "); }";
            } else {
                $result = $result . "\n" . $indent . "if (!defined($" . $orig_var . ")) { die(\"open failed\"); }";
            }
        }
    }
    # Convert "or die ..." / "|| die(...)" on open/popen lines to if (!defined) check
    if ((match($result, "core::open") || match($result, "core::popen")) && (match($result, " or die") || match($result, " \\|\\| die"))) {
        # Extract the die message for the error check
        my str $die_msg = "";
        my array @die_cap = capture($result, "(?:or|\\|\\|)\\s+die\\s*\\(([^)]*)\\)");
        if (scalar(@die_cap) > 1) {
            $die_msg = $die_cap[1];
        } else {
            my array @die_cap2 = capture($result, "(?:or|\\|\\|)\\s+die\\s+([^;]+)");
            if (scalar(@die_cap2) > 1) {
                $die_msg = trim_str($die_cap2[1]);
            }
        }
        # Extract variable name being assigned to
        my array @ordie_vcap = capture($result, "\\$([A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*core::");
        my str $ordie_var = "";
        if (scalar(@ordie_vcap) > 1) { $ordie_var = $ordie_vcap[1]; }
        # Strip the or die part
        $result = replace($result, "\\s+(or|\\|\\|)\\s+die\\s*\\([^)]*\\)\\s*", "");
        $result = replace($result, "\\s+(or|\\|\\|)\\s+die\\s+[^;]*", "");
        # Add if (!defined) check after the assignment
        if (length($ordie_var) > 0) {
            if (length($die_msg) > 0) {
                $result = $result . "\n" . $indent . "if (!defined($" . $ordie_var . ")) { die(" . $die_msg . "); }";
            } else {
                $result = $result . "\n" . $indent . "if (!defined($" . $ordie_var . ")) { die(\"open failed\"); }";
            }
        }
    }
    # Strip "or do { ... }" / "|| do { ... }" from core::open lines â€” convert to if (!defined) check
    if (match($result, "core::open") && (match($result, " or do\\s*\\{") || match($result, " \\|\\| do\\s*\\{"))) {
        my array @ordo_vcap = capture($result, "\\$([A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*core::open");
        my str $ordo_var2 = "";
        if (scalar(@ordo_vcap) > 1) { $ordo_var2 = $ordo_vcap[1]; }
        $result = replace($result, "\\s+(?:or|\\|\\|)\\s+do\\s*\\{.*$", ";");
        if (length($ordo_var2) > 0) {
            $result = $result . "\n" . $indent . "if (!defined($" . $ordo_var2 . ")) {";
        }
    }

    # Post-process "or do" from open: append if (!defined) check
    # DISABLED for debugging â€” will be re-enabled after fixing $1 issue

    # sysopen -> TODO with core::open guidance
    if (match($result, "\\bsysopen\\s*\\(") && !match($result, "#")) {
        $result = $result . "  # REVIEW: sysopen() -> use core::open() with mode string: O_RDONLY=\"r\", O_WRONLY|O_CREAT=\"w\", O_RDWR=\"r+\"";
    }

    # close($fh) -> core::close($fh)
    if (match($result, "\\bclose\\s*\\(\\$") && !match($result, "core::close")) {
        $result = replace($result, "\\bclose\\s*\\(", "core::close(");
    }
    elsif (match($result, "\\bclose\\s+\\$") && !match($result, "core::close")) {
        $result = replace($result, "\\bclose\\s+", "core::close(");
        $result = add_close_paren_smart($result, "core::close");
    }

    # ---- seek/tell/eof -> core:: equivalents ----
    if (match($result, "\\bseek\\s*\\(") && !match($result, "core::seek")) {
        $result = replace($result, "\\bseek\\s*\\(", "core::seek(");
    }
    if (match($result, "\\btell\\s*\\(") && !match($result, "core::tell")) {
        $result = replace($result, "\\btell\\s*\\(", "core::tell(");
    }
    if (match($result, "\\beof\\s*\\(") && !match($result, "core::eof")) {
        $result = replace($result, "\\beof\\s*\\(", "core::eof(");
    }
    # bare form: seek $fh, 0, 0 -> core::seek($fh, 0, 0)
    if (match($result, "\\bseek\\s+\\$") && !match($result, "core::seek") && !match($result, "\\bseek\\s*\\(")) {
        $result = replace($result, "\\bseek\\s+", "core::seek(");
        $result = add_close_paren($result);
    }
    if (match($result, "\\btell\\s+\\$") && !match($result, "core::tell") && !match($result, "\\btell\\s*\\(")) {
        $result = replace($result, "\\btell\\s+", "core::tell(");
        $result = add_close_paren($result);
    }
    if (match($result, "\\beof\\s+\\$") && !match($result, "core::eof") && !match($result, "\\beof\\s*\\(")) {
        $result = replace($result, "\\beof\\s+", "core::eof(");
        $result = add_close_paren($result);
    }

    # ---- binmode -> comment out with guidance ----
    if (match($result, "\\bbinmode\\s*\\(") || match($result, "\\bbinmode\\s+")) {
        if (match($result, ":utf8") || match($result, ":encoding")) {
            $result = $indent . "# " . $trimmed . "  # Strada handles UTF-8 natively; for binary data use core::read_fd/write_fd";
        } elsif (match($result, ":raw") || match($result, ":bytes")) {
            $result = $indent . "# " . $trimmed . "  # For binary I/O use \"rb\"/\"wb\" mode with core::open(), or core::read_fd/write_fd";
        } else {
            $result = $indent . "# " . $trimmed . "  # Not needed in Strada â€” files are binary-safe by default";
        }
        return $result;
    }

    # ---- sysread/syswrite -> convert to core::read_fd/write_fd ----
    if (match($result, "\\bsysread\\s*\\(") && !match($result, "#")) {
        # sysread($fh, $buf, $len) â†’ $buf = core::read_fd(core::fileno($fh), $len)
        my array @sr_cap = capture($result, "sysread\\s*\\(\\s*(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*,\\s*(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*,\\s*([^)]+)\\)");
        if (scalar(@sr_cap) > 3) {
            my str $sr_fh = $sr_cap[1];
            my str $sr_buf = $sr_cap[2];
            my str $sr_len = trim_str($sr_cap[3]);
            $result = $indent . $sr_buf . " = core::read_fd(core::fileno(" . $sr_fh . "), " . $sr_len . ");";
        } else {
            $result = replace($result, "\\bsysread\\s*\\(", "core::read(");
        }
        return $result;
    }
    if (match($result, "\\bsyswrite\\s*\\(") && !match($result, "#")) {
        # syswrite($fh, $data) â†’ core::write_fd(core::fileno($fh), $data)
        my array @sw_cap = capture($result, "syswrite\\s*\\(\\s*(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*,\\s*(\\$[A-Za-z_][A-Za-z0-9_]*[^)]*)\\)");
        if (scalar(@sw_cap) > 2) {
            my str $sw_fh = $sw_cap[1];
            my str $sw_data = trim_str($sw_cap[2]);
            # Strip optional length/offset args
            if (match($sw_data, ",")) {
                my array @sw_parts = split(",", $sw_data);
                $sw_data = trim_str($sw_parts[0]);
            }
            $result = $indent . "core::write_fd(core::fileno(" . $sw_fh . "), " . $sw_data . ");";
        } else {
            $result = replace($result, "\\bsyswrite\\s*\\(", "core::write(");
        }
        return $result;
    }

    # ---- File & Directory Operations ----

    # unlink($file) -> core::unlink($file)
    if (match($result, "\\bunlink\\s*\\(") && !match($result, "core::unlink")) {
        $result = replace($result, "\\bunlink\\s*\\(", "core::unlink(");
    }
    # unlink $file -> core::unlink($file) (bare form - capture arg to avoid add_close_paren bug in conditions)
    elsif (match($result, "\\bunlink\\s+[\"\\$]") && !match($result, "core::unlink") && !match($result, "\\bunlink\\s*\\(")) {
        my array @ul_cap = capture($result, "\\bunlink\\s+(\\$[A-Za-z_][A-Za-z0-9_]*)");
        if (scalar(@ul_cap) > 1) {
            $result = replace($result, "\\bunlink\\s+\\" . $ul_cap[1], "core::unlink(" . $ul_cap[1] . ")");
        } else {
            $result = replace($result, "\\bunlink\\s+", "core::unlink(");
            $result = add_close_paren($result);
        }
    }

    # rename($old, $new) -> core::rename($old, $new)
    if (match($result, "\\brename\\s*\\(") && !match($result, "core::rename")) {
        $result = replace($result, "\\brename\\s*\\(", "core::rename(");
    }
    # rename $old, $new -> core::rename($old, $new) (bare form - capture args)
    elsif (match($result, "\\brename\\s+[\"\\$]") && !match($result, "core::rename") && !match($result, "\\brename\\s*\\(")) {
        my array @rn_cap = capture($result, "\\brename\\s+(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*,\\s*(\\$[A-Za-z_][A-Za-z0-9_]*)");
        if (scalar(@rn_cap) > 2) {
            $result = replace($result, "\\brename\\s+\\" . $rn_cap[1] . "\\s*,\\s*\\" . $rn_cap[2], "core::rename(" . $rn_cap[1] . ", " . $rn_cap[2] . ")");
        } else {
            $result = replace($result, "\\brename\\s+", "core::rename(");
            $result = add_close_paren($result);
        }
    }

    # chmod(0755, $file) -> core::chmod(0755, $file)
    if (match($result, "\\bchmod\\s*\\(") && !match($result, "core::chmod")) {
        $result = replace($result, "\\bchmod\\s*\\(", "core::chmod(");
    }
    # chmod 0755, $file or chmod $perm, $file -> core::chmod(perm, $file) (bare form - capture args)
    elsif (match($result, "\\bchmod\\s+[0-9\\$]") && !match($result, "core::chmod") && !match($result, "\\bchmod\\s*\\(")) {
        my array @cm_cap = capture($result, "\\bchmod\\s+([0-9]+|\\$[A-Za-z_][A-Za-z0-9_]*)\\s*,\\s*(\\$[A-Za-z_][A-Za-z0-9_]*)");
        if (scalar(@cm_cap) > 2) {
            my str $cm_perm = $cm_cap[1];
            my str $cm_file = $cm_cap[2];
            $result = replace($result, "\\bchmod\\s+[^;)]+", "core::chmod(" . $cm_perm . ", " . $cm_file . ")");
        } else {
            $result = replace($result, "\\bchmod\\s+", "core::chmod(");
            $result = add_close_paren($result);
        }
    }

    # stat($file) -> core::stat($file)
    if (match($result, "\\bstat\\s*\\(") && !match($result, "core::stat")) {
        $result = replace($result, "\\bstat\\s*\\(", "core::stat(");
    }
    # stat $file -> core::stat($file) (bare form - capture arg)
    elsif (match($result, "\\bstat\\s+[\"\\$]") && !match($result, "core::stat") && !match($result, "\\bstat\\s*\\(") && !match($result, "#")) {
        my array @st_cap = capture($result, "\\bstat\\s+(\\$[A-Za-z_][A-Za-z0-9_]*)");
        if (scalar(@st_cap) > 1) {
            $result = replace($result, "\\bstat\\s+\\" . $st_cap[1], "core::stat(" . $st_cap[1] . ")");
        } else {
            $result = replace($result, "\\bstat\\s+", "core::stat(");
            $result = add_close_paren($result);
        }
    }
    # lstat($file) -> core::lstat($file)
    if (match($result, "\\blstat\\s*\\(") && !match($result, "core::lstat")) {
        $result = replace($result, "\\blstat\\s*\\(", "core::lstat(");
    }

    # mkdir($dir) -> core::mkdir($dir)
    if (match($result, "\\bmkdir\\s*\\(") && !match($result, "core::mkdir")) {
        $result = replace($result, "\\bmkdir\\s*\\(", "core::mkdir(");
    }
    # mkdir "dir" / mkdir $dir -> core::mkdir("dir") / core::mkdir($dir) (bare form)
    elsif (match($result, "\\bmkdir\\s+[\"\\$]") && !match($result, "core::mkdir") && !match($result, "\\bmkdir\\s*\\(")) {
        $result = replace($result, "\\bmkdir\\s+", "core::mkdir(");
        $result = add_close_paren($result);
    }

    # chdir($dir) -> core::chdir($dir)
    if (match($result, "\\bchdir\\s*\\(") && !match($result, "core::chdir")) {
        $result = replace($result, "\\bchdir\\s*\\(", "core::chdir(");
    }
    # chdir "dir" / chdir $dir -> core::chdir($dir) (bare form)
    elsif (match($result, "\\bchdir\\s+[\"\\$]") && !match($result, "core::chdir") && !match($result, "\\bchdir\\s*\\(")) {
        $result = replace($result, "\\bchdir\\s+", "core::chdir(");
        $result = add_close_paren($result);
    }

    # rmdir($dir) -> core::rmdir($dir)
    if (match($result, "\\brmdir\\s*\\(") && !match($result, "core::rmdir")) {
        $result = replace($result, "\\brmdir\\s*\\(", "core::rmdir(");
    }
    # rmdir $dir -> core::rmdir($dir) (bare form)
    elsif (match($result, "\\brmdir\\s+[\"\\$]") && !match($result, "core::rmdir") && !match($result, "\\brmdir\\s*\\(")) {
        $result = replace($result, "\\brmdir\\s+", "core::rmdir(");
        $result = add_close_paren($result);
    }

    # ---- Socket functions -> convert to core:: equivalents ----
    if (match($result, "\\bsocket\\s*\\(") && !match($result, "#") && !match($result, "core::socket") && !match($result, "IO::Socket")) {
        # socket(SOCK, PF_INET, SOCK_STREAM, 0) â†’ my scalar $SOCK = core::socket_create("tcp");
        my array @sck_cap = capture($result, "socket\\s*\\(\\s*([A-Za-z_][A-Za-z0-9_]*)");
        if (scalar(@sck_cap) > 1) {
            my str $sck_name = $sck_cap[1];
            my str $sck_proto = "\"tcp\"";
            if (match($result, "SOCK_DGRAM") || match($result, "IPPROTO_UDP") || match($result, "udp")) {
                $sck_proto = "\"udp\"";
            }
            $result = $indent . "my scalar $" . $sck_name . " = core::socket_create(" . $sck_proto . ");  # REVIEW: was low-level socket()";
        } else {
            $result = $result . "  # REVIEW: socket() -> use core::socket_client() or core::socket_server()";
        }
    }
    if (match($result, "\\bbind\\s*\\(") && !match($result, "#") && !match($result, "core::") && !match($result, "->bind")) {
        # bind(SOCK, $addr) â†’ core::socket_bind($SOCK, $port)
        my array @bnd_cap = capture($result, "bind\\s*\\(\\s*(\\$?[A-Za-z_][A-Za-z0-9_]*)");
        if (scalar(@bnd_cap) > 1) {
            my str $bnd_sock = $bnd_cap[1];
            if (!starts_with($bnd_sock, "$")) { $bnd_sock = "$" . $bnd_sock; }
            $result = $indent . "core::socket_bind(" . $bnd_sock . ", $port);  # REVIEW: extract port from original sockaddr";
        }
    }
    if (match($result, "\\blisten\\s*\\(") && !match($result, "#") && !match($result, "core::") && !match($result, "->listen")) {
        # listen(SOCK, 5) â†’ core::socket_listen($SOCK, 5)
        my array @lst_cap = capture($result, "listen\\s*\\(\\s*(\\$?[A-Za-z_][A-Za-z0-9_]*)\\s*,\\s*([0-9]+)");
        if (scalar(@lst_cap) > 2) {
            my str $lst_sock = $lst_cap[1];
            if (!starts_with($lst_sock, "$")) { $lst_sock = "$" . $lst_sock; }
            $result = $indent . "core::socket_listen(" . $lst_sock . ", " . $lst_cap[2] . ");";
        } else {
            $result = $result . "  # REVIEW: listen() -> core::socket_listen($sock, $backlog)";
        }
    }
    if (match($result, "\\bsetsockopt\\s*\\(") && !match($result, "#")) {
        $result = $indent . "# " . $trimmed . "  # REVIEW: setsockopt() - use __C__ block if needed";
    }
    if (match($result, "\\bgetsockopt\\s*\\(") && !match($result, "#")) {
        $result = $indent . "# " . $trimmed . "  # REVIEW: getsockopt() - use __C__ block if needed";
    }

    # Socket constants and helper functions â€” comment out (not needed with core:: API)
    if (match($result, "\\bAF_INET\\b") && !match($result, "#.*AF_INET") && !match($result, "core::")) {
        # Usually part of a socket() call already converted above; if standalone, comment
        if (!match($result, "core::socket")) {
            $result = $indent . "# " . $trimmed . "  # Not needed - core::socket_client/server handles addressing";
        }
    }
    if (match($result, "\\bSOCK_STREAM\\b") && !match($result, "#.*SOCK_STREAM") && !match($result, "core::")) {
        if (!match($result, "core::socket")) {
            $result = $indent . "# " . $trimmed . "  # Not needed - core::socket_client() uses TCP by default";
        }
    }
    if (match($result, "\\binet_aton\\s*\\(") && !match($result, "#.*inet_aton")) {
        $result = $indent . "# " . $trimmed . "  # Not needed - core::socket_client(host, port) resolves hostnames";
    }
    if (match($result, "\\binet_ntoa\\s*\\(") && !match($result, "#.*inet_ntoa")) {
        $result = $indent . "# " . $trimmed . "  # Not needed with core::socket_client()";
    }
    if (match($result, "\\bsockaddr_in\\s*\\(") && !match($result, "#.*sockaddr_in") && !match($result, "pack_sockaddr")) {
        $result = $indent . "# " . $trimmed . "  # Not needed - core::socket_client(host, port) handles addressing";
    }
    if (match($result, "\\bpack_sockaddr_in\\s*\\(") && !match($result, "#.*pack_sockaddr_in")) {
        $result = $indent . "# " . $trimmed . "  # Not needed - use core::socket_client(host, port)";
    }

    # opendir(...) -> extract dirhandle+path, comment out (core::readdir handles open/read/close)
    if (match($result, "\\bopendir\\s*\\(")) {
        my str $od_dh = "";
        my str $od_dir = "";
        # Try: opendir(my $dh, $dir) or opendir(my scalar $dh, $dir) (after type annotation)
        my array @od_cap1 = capture($result, "opendir\\s*\\(\\s*my\\s+[a-z]*\\s*\\$([A-Za-z_][A-Za-z0-9_]*)\\s*,\\s*([^)]+)\\)");
        if (scalar(@od_cap1) > 2) {
            $od_dh = trim_str($od_cap1[1]);
            $od_dir = trim_str($od_cap1[2]);
        } else {
            # Try: opendir($dh, $dir) or opendir(DIR, $dir)
            my array @od_cap2 = capture($result, "opendir\\s*\\(\\s*\\$?([A-Za-z_][A-Za-z0-9_]*)\\s*,\\s*([^)]+)\\)");
            if (scalar(@od_cap2) > 2) {
                $od_dh = trim_str($od_cap2[1]);
                $od_dir = trim_str($od_cap2[2]);
            }
        }
        if (length($od_dh) > 0 && length($od_dir) > 0) {
            # Store the mapping: dirhandle name -> directory path for readdir/closedir
            $sub_info{"__opendir_path:" . $od_dh} = $od_dir;
            $result = $indent . "# opendir - unnecessary, using core::readdir() below  # was: " . $trimmed;
        } else {
            $result = $indent . "# " . $trimmed . "  # REVIEW: replace opendir/readdir/closedir with core::readdir($path)";
        }
    }
    # readdir($dh) -> core::readdir($dir_path) using stored path from opendir
    if (match($result, "\\breaddir\\s*\\(") && !match($result, "core::readdir") && !match($result, "#")) {
        # Extract the dirhandle name from readdir($dh) or readdir(DIR)
        my array @rd_cap = capture($result, "readdir\\s*\\(\\s*\\$?([A-Za-z_][A-Za-z0-9_]*)\\s*\\)");
        my str $rd_path = "";
        if (scalar(@rd_cap) > 1) {
            my str $rd_dh = $rd_cap[1];
            my str $rd_key = "__opendir_path:" . $rd_dh;
            if (length("" . $sub_info{$rd_key}) > 0) {
                $rd_path = "" . $sub_info{$rd_key};
            }
        }
        if (length($rd_path) > 0) {
            $result = replace($result, "\\breaddir\\s*\\([^)]*\\)", "core::readdir(" . $rd_path . ")");
        } elsif (match($result, "=\\s*readdir")) {
            $result = replace($result, "\\breaddir\\s*\\([^)]*\\)", "core::readdir($dir_path)");
            $result = $result . "  # REVIEW: replace $dir_path with actual directory path string";
        } else {
            $result = replace($result, "\\breaddir\\s*\\(", "core::readdir(");
            $result = $result . "  # REVIEW: readdir() -> core::readdir($dir_path) returns array of filenames";
        }
    }
    # closedir($dh) -> comment out
    if (match($result, "\\bclosedir\\s*\\(")) {
        $result = $indent . "# closedir - unnecessary, core::readdir() is self-contained  # was: " . $trimmed;
    }

    # ---- flock() -> core::flock() ----
    if (match($result, "\\bflock\\s*\\(") && !match($result, "#") && !match($result, "core::flock")) {
        # Convert Perl flock constants to numeric values
        $result = replace($result, "\\bflock\\s*\\(", "core::flock(");
        # Handle Fcntl::LOCK_*() function call form first
        $result = replace_all($result, "Fcntl::LOCK_SH()", "1");
        $result = replace_all($result, "Fcntl::LOCK_EX()", "2");
        $result = replace_all($result, "Fcntl::LOCK_UN()", "8");
        $result = replace_all($result, "Fcntl::LOCK_NB()", "4");
        # Handle bare constant form
        $result = replace_all($result, "LOCK_SH", "1");
        $result = replace_all($result, "LOCK_EX", "2");
        $result = replace_all($result, "LOCK_UN", "8");
        $result = replace_all($result, "LOCK_NB", "4");
    }
    # Also handle Fcntl constants outside of flock context
    if (match($result, "\\bFcntl::LOCK_") && !match($result, "#")) {
        $result = replace_all($result, "Fcntl::LOCK_SH()", "1");
        $result = replace_all($result, "Fcntl::LOCK_EX()", "2");
        $result = replace_all($result, "Fcntl::LOCK_UN()", "8");
        $result = replace_all($result, "Fcntl::LOCK_NB()", "4");
        $result = replace_all($result, "Fcntl::LOCK_SH", "1");
        $result = replace_all($result, "Fcntl::LOCK_EX", "2");
        $result = replace_all($result, "Fcntl::LOCK_UN", "8");
        $result = replace_all($result, "Fcntl::LOCK_NB", "4");
    }

    # ---- System Calls & Process Control ----

    # system("cmd") -> core::system("cmd")
    if (match($result, "\\bsystem\\s*\\(") && !match($result, "core::system")) {
        $result = replace($result, "\\bsystem\\s*\\(", "core::system(");
    }
    # system $cmd -> core::system($cmd) (bare form)
    elsif (match($result, "\\bsystem\\s+[\"\\$]") && !match($result, "core::system") && !match($result, "\\bsystem\\s*\\(")) {
        $result = replace($result, "\\bsystem\\s+", "core::system(");
        $result = add_close_paren($result);
    }

    # exec("cmd") -> core::exec("cmd")
    if (match($result, "\\bexec\\s*\\(") && !match($result, "core::exec")) {
        $result = replace($result, "\\bexec\\s*\\(", "core::exec(");
    }
    # exec $cmd -> core::exec($cmd) (bare form)
    elsif (match($result, "\\bexec\\s+[\"\\$]") && !match($result, "core::exec") && !match($result, "\\bexec\\s*\\(")) {
        $result = replace($result, "\\bexec\\s+", "core::exec(");
        $result = add_close_paren($result);
    }

    # fork() -> core::fork()
    if (match($result, "\\bfork\\s*\\(") && !match($result, "core::fork")) {
        $result = replace($result, "\\bfork\\s*\\(", "core::fork(");
    }

    # waitpid($p, $o) -> core::waitpid($p, $o)
    if (match($result, "\\bwaitpid\\s*\\(") && !match($result, "core::waitpid")) {
        $result = replace($result, "\\bwaitpid\\s*\\(", "core::waitpid(");
    }

    # sleep($n) -> core::sleep($n)
    if (match($result, "\\bsleep\\s*\\(") && !match($result, "core::sleep")) {
        $result = replace($result, "\\bsleep\\s*\\(", "core::sleep(");
    }
    # sleep 5 -> core::sleep(5) (bare form)
    elsif (match($result, "\\bsleep\\s+[0-9\\$]") && !match($result, "core::sleep") && !match($result, "\\bsleep\\s*\\(")) {
        $result = replace($result, "\\bsleep\\s+", "core::sleep(");
        $result = add_close_paren($result);
    }

    # kill($sig, $pid) -> core::kill($sig, $pid)
    if (match($result, "\\bkill\\s*\\(") && !match($result, "core::kill")) {
        $result = replace($result, "\\bkill\\s*\\(", "core::kill(");
    }
    # kill $sig, $pid -> core::kill($sig, $pid) (bare form)
    elsif (match($result, "\\bkill\\s+[0-9\"\\$]") && !match($result, "core::kill") && !match($result, "\\bkill\\s*\\(")) {
        $result = replace($result, "\\bkill\\s+", "core::kill(");
        $result = add_close_paren($result);
    }
    # kill 'SIGNAME', $pid -> core::kill(N, $pid) (signal name to number)
    if (match($result, "\\bkill\\s+['\"]") && !match($result, "core::kill")) {
        $result = replace($result, "\\bkill\\s+", "core::kill(");
        $result = add_close_paren($result);
    }
    # Convert signal name strings inside core::kill() to numbers
    if (match($result, "core::kill\\s*\\(\\s*['\"]")) {
        $result = replace_all($result, "'HUP'", "1");
        $result = replace_all($result, "'INT'", "2");
        $result = replace_all($result, "'QUIT'", "3");
        $result = replace_all($result, "'KILL'", "9");
        $result = replace_all($result, "'TERM'", "15");
        $result = replace_all($result, "'USR1'", "10");
        $result = replace_all($result, "'USR2'", "12");
        $result = replace_all($result, "'ALRM'", "14");
        $result = replace_all($result, "'PIPE'", "13");
        $result = replace_all($result, "'STOP'", "19");
        $result = replace_all($result, "'CONT'", "18");
        $result = replace_all($result, "\"HUP\"", "1");
        $result = replace_all($result, "\"INT\"", "2");
        $result = replace_all($result, "\"QUIT\"", "3");
        $result = replace_all($result, "\"KILL\"", "9");
        $result = replace_all($result, "\"TERM\"", "15");
        $result = replace_all($result, "\"USR1\"", "10");
        $result = replace_all($result, "\"USR2\"", "12");
        $result = replace_all($result, "\"ALRM\"", "14");
        $result = replace_all($result, "\"PIPE\"", "13");
        $result = replace_all($result, "\"STOP\"", "19");
        $result = replace_all($result, "\"CONT\"", "18");
        if (match($result, "core::kill\\s*\\(\\s*['\"]")) {
            $result = $result . "  # REVIEW: unknown signal name - use numeric signal value";
        }
    }

    # alarm($sec) -> core::alarm($sec)
    if (match($result, "\\balarm\\s*\\(") && !match($result, "core::alarm")) {
        $result = replace($result, "\\balarm\\s*\\(", "core::alarm(");
    }
    # alarm $sec -> core::alarm($sec) (bare form)
    elsif (match($result, "\\balarm\\s+[0-9\\$]") && !match($result, "core::alarm") && !match($result, "\\balarm\\s*\\(")) {
        $result = replace($result, "\\balarm\\s+", "core::alarm(");
        $result = add_close_paren($result);
    }

    # wait() -> core::wait()
    if (match($result, "\\bwait\\s*\\(\\s*\\)") && !match($result, "core::wait") && !match($result, "waitpid")) {
        $result = replace($result, "\\bwait\\s*\\(\\s*\\)", "core::wait()");
    }

    # symlink($old, $new) -> core::symlink($old, $new)
    if (match($result, "\\bsymlink\\s*\\(") && !match($result, "core::symlink")) {
        $result = replace($result, "\\bsymlink\\s*\\(", "core::symlink(");
    }
    # link($old, $new) -> core::link($old, $new)
    if (match($result, "\\blink\\s*\\(") && !match($result, "core::link") && !match($result, "symlink") && !match($result, "readlink") && !match($result, "unlink")) {
        $result = replace($result, "\\blink\\s*\\(", "core::link(");
    }
    # umask($mask) -> core::umask($mask)
    if (match($result, "\\bumask\\s*\\(") && !match($result, "core::umask")) {
        $result = replace($result, "\\bumask\\s*\\(", "core::umask(");
    }
    # umask $mask or bare umask -> core::umask(...)
    elsif (match($result, "\\bumask\\s+[0-9\\$]") && !match($result, "core::umask") && !match($result, "\\bumask\\s*\\(")) {
        my array @um_cap = capture($result, "\\bumask\\s+([0-9]+|\\$[A-Za-z_][A-Za-z0-9_]*)");
        if (scalar(@um_cap) > 1) {
            $result = replace($result, "\\bumask\\s+" . $um_cap[1], "core::umask(" . $um_cap[1] . ")");
        } else {
            $result = replace($result, "\\bumask\\s+", "core::umask(");
            $result = add_close_paren($result);
        }
    }
    elsif (match($result, "\\bumask\\b") && !match($result, "core::umask") && !match($result, "#") && !match($result, "umask\\s*\\(") && !match($result, "umask\\s+[0-9\\$]")) {
        # bare umask (no args) -> core::umask()
        $result = replace($result, "\\bumask\\b", "core::umask()");
    }

    # utime($atime, $mtime, @files) -> REVIEW (no direct core::utime)
    if (match($result, "\\butime\\s*\\(") && !match($result, "core::utime") && !match($result, "#")) {
        $result = $result . "  # REVIEW: utime() - use __C__ { utime(atime, mtime, path); } in Strada";
    }
    # bare utime -> also REVIEW
    elsif (match($result, "\\butime\\s+") && !match($result, "#")) {
        $result = $result . "  # REVIEW: utime() - use __C__ { utime(atime, mtime, path); } in Strada";
    }

    # fileno($fh) -> core::fileno($fh)
    if (match($result, "\\bfileno\\s*\\(") && !match($result, "core::fileno")) {
        $result = replace($result, "\\bfileno\\s*\\(", "core::fileno(");
    }
    # recv($sock, $buf, $len, $flags) -> $buf = core::socket_recv($sock, $len)
    if (match($result, "\\brecv\\s*\\(") && !match($result, "core::recv") && !match($result, "core::socket_recv") && !match($result, "->recv")) {
        my array @rv_cap = capture($result, "recv\\s*\\(\\s*(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*,\\s*(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*,\\s*([^,)]+)");
        if (scalar(@rv_cap) > 3) {
            my str $rv_sock = $rv_cap[1];
            my str $rv_buf = $rv_cap[2];
            my str $rv_len = trim_str($rv_cap[3]);
            $result = $indent . $rv_buf . " = core::socket_recv(" . $rv_sock . ", " . $rv_len . ");";
        } else {
            $result = replace($result, "\\brecv\\s*\\(", "core::recv(");
        }
    }
    # send($sock, $data, $flags) -> core::socket_send($sock, $data)
    if (match($result, "\\bsend\\s*\\(") && !match($result, "core::send") && !match($result, "core::socket_send") && !match($result, "->send")) {
        my array @sn_cap = capture($result, "send\\s*\\(\\s*(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*,\\s*([^,)]+)");
        if (scalar(@sn_cap) > 2) {
            my str $sn_sock = $sn_cap[1];
            my str $sn_data = trim_str($sn_cap[2]);
            $result = $indent . "core::socket_send(" . $sn_sock . ", " . $sn_data . ");";
        } else {
            $result = replace($result, "\\bsend\\s*\\(", "core::send(");
        }
    }
    # truncate($fh, $len) -> core::truncate($fh, $len)
    if (match($result, "\\btruncate\\s*\\(") && !match($result, "core::truncate")) {
        $result = replace($result, "\\btruncate\\s*\\(", "core::truncate(");
    }

    # pipe(READ, WRITE) -> core::pipe() returning array of [read_fd, write_fd]
    if (match($result, "\\bpipe\\s*\\(") && !match($result, "#") && !match($result, "core::pipe")) {
        my array @pipe_cap = capture($result, "pipe\\s*\\(\\s*([A-Za-z_][A-Za-z0-9_]*)\\s*,\\s*([A-Za-z_][A-Za-z0-9_]*)\\s*\\)");
        if (scalar(@pipe_cap) > 2) {
            my str $pipe_r = $pipe_cap[1];
            my str $pipe_w = $pipe_cap[2];
            $result = $indent . "my array @_pipe = core::pipe(); my scalar $" . $pipe_r . " = $_pipe[0]; my scalar $" . $pipe_w . " = $_pipe[1];";
        } else {
            $result = replace($result, "\\bpipe\\s*\\(", "core::pipe(");
        }
    }
    # shutdown($sock, $how)  -> core::shutdown($sock, $how)
    if (match($result, "\\bshutdown\\s*\\(") && !match($result, "#") && !match($result, "core::shutdown")) {
        $result = replace($result, "\\bshutdown\\s*\\(", "core::shutdown(");
    }
    # accept(NEW, SOCK) -> my scalar $NEW = core::socket_accept($SOCK)
    if (match($result, "\\baccept\\s*\\(") && !match($result, "#") && !match($result, "core::") && !match($result, "->accept")) {
        my array @acc_cap = capture($result, "accept\\s*\\(\\s*([A-Za-z_][A-Za-z0-9_]*)\\s*,\\s*(\\$?[A-Za-z_][A-Za-z0-9_]*)\\s*\\)");
        if (scalar(@acc_cap) > 2) {
            my str $acc_new = $acc_cap[1];
            my str $acc_sock = $acc_cap[2];
            if (!starts_with($acc_sock, "$")) { $acc_sock = "$" . $acc_sock; }
            $result = $indent . "my scalar $" . $acc_new . " = core::socket_accept(" . $acc_sock . ");";
        } else {
            $result = replace($result, "\\baccept\\s*\\(", "core::socket_accept(");
        }
    }

    # glob("pattern") -> core::glob("pattern")
    if (match($result, "\\bglob\\s*\\(") && !match($result, "#") && !match($result, "core::glob")) {
        $result = replace($result, "\\bglob\\s*\\(", "core::glob(");
        $result = $result . "  # REVIEW: glob() -> core::glob() returns array of matching files";
    }
    # <*.txt> glob syntax -> core::glob("*.txt")
    # Skip regex contexts: =~ s/.../ or bare s/.../ or m/.../ or lines with regex operators
    if (match($result, "<[^>]*\\*[^>]*>") && !match($result, "#") && !match($result, "STDIN") && !match($result, "STDERR") && !match($result, "core::glob") && !match($result, "=~") && !match($result, "^\\s*s/") && !match($result, "^\\s*s\\{") && !match($result, "^\\s*m/") && !match($result, "^\\s*m\\{") && !match($result, "^\\s*tr/") && !match($result, "^\\s*y/")) {
        my array @gl_cap = capture($result, "<([^>]*\\*[^>]*)>");
        if (scalar(@gl_cap) > 1) {
            my str $gl_pat = $gl_cap[1];
            $result = replace($result, "<[^>]*\\*[^>]*>", "core::glob(\"" . $gl_pat . "\")");
        }
    }

    # ---- Backticks & qx ----
    # `cmd arg` -> core::qx("cmd arg")
    # Only convert backticks in expression context (after =, at line start, or after ()
    # Skip backticks inside strings/SQL (e.g. qq|SELECT `col` FROM `table`|)
    if (match($result, "`[^`]+`") && !match($result, "core::qx")) {
        my int $bt_ok = 0;
        if (match($result, "=\\s*`[^`]+`")) { $bt_ok = 1; }
        if (match($result, "^\\s*`[^`]+`")) { $bt_ok = 1; }
        if (match($result, "\\(\\s*`[^`]+`")) { $bt_ok = 1; }
        if ($bt_ok == 1) {
            my array @btcap = capture($result, "`([^`]+)`");
            if (scalar(@btcap) > 1) {
                my str $btcmd = $btcap[1];
                # Check for variable interpolation
                my str $review = "";
                if (match($btcmd, "\\$[A-Za-z_]")) {
                    $review = "  # REVIEW: interpolated variables in backtick";
                }
                $result = replace($result, "`[^`]+`", "core::qx(\"" . $btcmd . "\")");
                $result = $result . $review;
            }
        }
    }
    # qx/cmd/ or qx(cmd) or qx{cmd} -> core::qx("cmd")
    if (match($result, "\\bqx\\s*[/({]") && !match($result, "core::qx")) {
        my array @qxcap = capture($result, "\\bqx\\s*[/({]([^/)})]+)[/)}]");
        if (scalar(@qxcap) > 1) {
            my str $qxcmd = $qxcap[1];
            my str $qxreview = "";
            if (match($qxcmd, "\\$[A-Za-z_]")) {
                $qxreview = "  # REVIEW: interpolated variables in qx";
            }
            $result = replace($result, "\\bqx\\s*[/({][^/)})]+[/)}]", "core::qx(\"" . $qxcmd . "\")");
            $result = $result . $qxreview;
        }
    }

    # ---- Special variables ----
    # $$ -> core::getpid()  (process ID)
    # Note: Can't use regex match for $ patterns (POSIX anchor), use index() instead
    if (index($result, "$$") >= 0 && index($result, "#") < 0 && index($result, "core::getpid") < 0) {
        my int $dd_pos = index($result, "$$");
        while ($dd_pos >= 0) {
            my int $dd_after = $dd_pos + 2;
            my int $dd_ok = 1;
            if ($dd_after < length($result)) {
                my int $dd_nch = char_at($result, $dd_after);
                # If followed by a word char, it's $$ref (deref), not PID
                if (($dd_nch >= 65 && $dd_nch <= 90) || ($dd_nch >= 97 && $dd_nch <= 122) || $dd_nch == 95 || $dd_nch == 123) {
                    $dd_ok = 0;
                }
            }
            if ($dd_ok == 1) {
                $result = substr($result, 0, $dd_pos) . "core::getpid()" . substr($result, $dd_after, length($result) - $dd_after);
                $dd_pos = index($result, "$$", $dd_pos + 13);
            } else {
                $dd_pos = index($result, "$$", $dd_pos + 1);
            }
        }
    }
    # $! as lvalue: $! = expr -> comment out (errno assignment, no Strada equivalent)
    if (index($result, "$!") >= 0 && index($result, "#") < 0 && index($result, "core::errno") < 0) {
        # Check for $! = ... (assignment) or ($!, $var) = ... (list assignment)
        my str $rt = trim_str($result);
        my str $ri = get_indent($result);
        my str $dol_bang = "$" . "!";
        if (starts_with($rt, $dol_bang)) {
            # Check if next non-space char is = (not ==)
            my str $after_bang = trim_str(substr($rt, 2, length($rt) - 2));
            if (starts_with($after_bang, "= ") || (starts_with($after_bang, "=") && !starts_with($after_bang, "=="))) {
                $result = $ri . "# " . $rt . "  # REVIEW: $! assignment (set errno) - use __C__ { errno = value; } in Strada";
                return $result;
            }
        }
        # Also handle: ($!, $^E) = ($sts, $ossts)  or  ($!, expr) = ...
        if (starts_with($rt, "(" . $dol_bang)) {
            $result = $ri . "# " . $rt . "  # REVIEW: $! list assignment - use __C__ { errno = value; } in Strada";
            return $result;
        }
        # Check for $! = anywhere in line (e.g. inside { $! = $status; } from postfix conversion)
        my int $bang_lv = index($result, $dol_bang);
        while ($bang_lv >= 0) {
            # Check if $! is followed by = (not ==)
            my str $after_lv = trim_str(substr($result, $bang_lv + 2, length($result) - $bang_lv - 2));
            if (starts_with($after_lv, "= ") || (starts_with($after_lv, "=") && !starts_with($after_lv, "=="))) {
                # This is a $! lvalue assignment - comment out the whole line
                $result = $ri . "# " . $rt . "  # REVIEW: $! assignment (set errno) - use __C__ { errno = value; } in Strada";
                return $result;
            }
            $bang_lv = index($result, $dol_bang, $bang_lv + 2);
        }
    }
    # $! in expressions (not die $!) -> core::strerror(core::errno())
    if (index($result, "$!") >= 0 && index($result, "#") < 0 && index($result, "core::errno") < 0 && !match($result, "\\bdie\\b") && !match($result, "\\bwarn\\b")) {
        my int $bang_pos = index($result, "$!");
        while ($bang_pos >= 0) {
            my int $bok = 1;
            # Make sure it's not != operator (preceded by ! with no $)
            if ($bang_pos > 0) {
                my int $bpch = char_at($result, $bang_pos - 1);
                if ($bpch == 92) { $bok = 0; }  # \$! in regex
            }
            # Check char after ! is not = (would be $!= which doesn't exist, but be safe)
            if ($bang_pos + 2 < length($result)) {
                my int $bnch = char_at($result, $bang_pos + 2);
                if ($bnch == 61) { $bok = 0; }
            }
            if ($bok == 1) {
                # Check if inside double-quoted string
                my int $bqi = 0;
                my int $bqc = 0;
                while ($bqi < $bang_pos) {
                    if (substr($result, $bqi, 1) eq "\"" && ($bqi == 0 || substr($result, $bqi - 1, 1) ne "\\")) {
                        $bqc++;
                    }
                    $bqi++;
                }
                if ($bqc % 2 == 1) {
                    # Inside string â€” break out with concatenation
                    my str $bang_repl = "\" . core::strerror(core::errno()) . \"";
                    $result = substr($result, 0, $bang_pos) . $bang_repl . substr($result, $bang_pos + 2, length($result) - $bang_pos - 2);
                    $bang_pos = index($result, "$!", $bang_pos + length($bang_repl));
                } else {
                    my str $bang_repl = "core::strerror(core::errno())";
                    $result = substr($result, 0, $bang_pos) . $bang_repl . substr($result, $bang_pos + 2, length($result) - $bang_pos - 2);
                    $bang_pos = index($result, "$!", $bang_pos + length($bang_repl));
                }
            } else {
                $bang_pos = index($result, "$!", $bang_pos + 1);
            }
        }
    }

    # ---- die $! -> die(core::strerror(core::errno())) (BEFORE die $obj -> throw) ----
    if (match($result, "\\bdie\\s+\\$!") || match($result, "\\bdie\\(\\$!\\)")) {
        $result = replace($result, "\\bdie\\s+\\$!\\s*;", "die(core::strerror(core::errno()));");
        $result = replace($result, "\\bdie\\(\\$!\\)", "die(core::strerror(core::errno()))");
    }

    # ---- die $obj â†’ throw (for typed exceptions) ----
    # die $obj -> throw($obj)  (when die has a variable, not a string literal)
    if (match($result, "\\bdie\\s+\\$") && !match($result, "\\bdie\\s*\\(") && !match($result, "\\bdie\\s+\"")) {
        $result = replace($result, "\\bdie\\s+(\\$\\S+)\\s*;", "throw($1);");
        # Handle die $obj without semicolon (mid-expression)
        if (match($result, "\\bdie\\s+\\$")) {
            $result = replace($result, "\\bdie\\s+(\\$\\S+)", "throw($1)");
        }
    }
    # die Something->new(...) -> throw(Something::new(...))
    # The ->new to ::new conversion happens later at Class->method() pass
    if (match($result, "\\bdie\\s+[A-Z][A-Za-z0-9_:]*->new")) {
        $result = replace($result, "\\bdie\\s+([A-Z])", "throw($1");
        # Find the matching close paren of new(...) and add our close paren
        $result = add_close_paren_smart($result, "throw");
    }
    # die Something::new(...) -> throw(Something::new(...))  (already converted)
    if (match($result, "\\bdie\\s+[A-Z][A-Za-z0-9_:]*::new") && !match($result, "\\bthrow")) {
        $result = replace($result, "\\bdie\\s+([A-Z])", "throw($1");
        $result = add_close_paren_smart($result, "throw");
    }
    # die func_call(...) or die func_call @args -> die(func_call(...)) / die(func_call(@args))
    if (match($result, "\\bdie\\s+[a-z_][A-Za-z0-9_]*\\s") && !match($result, "\\bdie\\s*\\(") && !match($result, "\\bdie\\s+\"") && !match($result, "^\\s*#")) {
        $result = replace($result, "\\bdie\\s+([a-z_])", "die($1");
        $result = add_close_paren_smart($result, "die");
    }
    # bare die; -> throw("fatal error");
    if (match($result, "\\bdie\\s*;")) {
        $result = replace($result, "\\bdie\\s*;", "throw(\"fatal error\");");
    }

    # ---- Destructuring assignment (outside @_ context) ----
    # my ($a, $b, $c) = @arr; -> my ($a, $b, $c) = @arr;  (valid Strada!)
    # my ($a, $b) = split(...); -> my ($a, $b) = split(...);  (valid Strada!)
    # Just need to add types: my ($a, $b) -> my (scalar $a, scalar $b)
    if (match($result, "\\bmy\\s*\\([^)]*\\$[^)]*\\)\\s*=") && !match($result, "@_")) {
        # Add scalar type to each variable in the destructuring
        my array @dest_cap = capture($result, "\\bmy\\s*\\(([^)]*)\\)\\s*=");
        if (scalar(@dest_cap) > 1) {
            my str $vars = $dest_cap[1];
            my array @var_list = split(",", $vars);
            my str $new_vars = "";
            my int $vi = 0;
            while ($vi < scalar(@var_list)) {
                if ($vi > 0) { $new_vars = $new_vars . ", "; }
                my str $v = trim_str($var_list[$vi]);
                # Add type if not already typed
                if (starts_with($v, "$") && !match($v, "^(scalar|int|str|num)\\s+")) {
                    $new_vars = $new_vars . "scalar " . $v;
                } elsif (starts_with($v, "@") && !match($v, "^array\\s+")) {
                    $new_vars = $new_vars . "array " . $v;
                } elsif (starts_with($v, "%") && !match($v, "^hash\\s+")) {
                    $new_vars = $new_vars . "hash " . $v;
                } else {
                    $new_vars = $new_vars . $v;
                }
                $vi++;
            }
            $result = replace($result, "my\\s*\\([^)]*\\)\\s*=", "my (" . $new_vars . ") =");
        }
    }

    # ---- qw() conversion ----
    $result = convert_qw($result);

    # ---- qr// direct match: =~ $qr_var -> match($str, $qr_var) REVIEW ----
    # When a qr// variable is used directly: $str =~ $pattern (no /.../)
    if (match($result, "=~\\s*\\$[A-Za-z_]") && !match($result, "=~\\s*[/sm]") && !match($result, "#")) {
        $result = $result . "  # REVIEW: regex variable match - use match($str, $var) in Strada";
    }
    # Interpolating qr// var into regex: $str =~ /$pattern\s+/
    if (match($result, "=~\\s*/") && match($result, "/.*\\$[A-Za-z_].*\\$[A-Za-z_]*/") && !match($result, "#.*REVIEW")) {
        # Heuristic: if there's a variable inside a regex, might be qr interpolation
        # Only flag if not already flagged
    }

    # ---- qr// and qr{} and qr#...# etc -> string pattern (MUST run before q/qq conversion) ----
    # qr/pattern/flags -> "(?flags)pattern" (compiled regex -> string pattern with PCRE2 inline flags)
    if (match($result, "\\bqr/")) {
        my array @qr_cap = capture($result, "\\bqr/([^/]*)/([a-z]*)");
        if (scalar(@qr_cap) > 1) {
            my str $qr_pat = $qr_cap[1];
            my str $qr_flags = "";
            if (scalar(@qr_cap) > 2) {
                $qr_flags = $qr_cap[2];
            }
            if (length($qr_flags) > 0) {
                $result = replace($result, "\\bqr/[^/]*/[a-z]*", "\"(?" . $qr_flags . ")" . $qr_pat . "\"");
            } else {
                $result = replace($result, "\\bqr/[^/]*/", "\"" . $qr_pat . "\"");
            }
        }
    }
    if (match($result, "\\bqr\\{")) {
        my array @qr_cap2 = capture($result, "\\bqr\\{([^}]*)\\}([a-z]*)");
        if (scalar(@qr_cap2) > 1) {
            my str $qr_pat2 = $qr_cap2[1];
            my str $qr_flags2 = "";
            if (scalar(@qr_cap2) > 2) {
                $qr_flags2 = $qr_cap2[2];
            }
            if (length($qr_flags2) > 0) {
                $result = replace($result, "\\bqr\\{[^}]*\\}[a-z]*", "\"(?" . $qr_flags2 . ")" . $qr_pat2 . "\"");
            } else {
                $result = replace($result, "\\bqr\\{[^}]*\\}", "\"" . $qr_pat2 . "\"");
            }
        }
    }
    # qr#pattern#flags -> "(?flags)pattern" (# delimiter)
    if (match($result, "\\bqr#")) {
        my array @qr_cap3 = capture($result, "\\bqr#([^#]*)#([a-z]*)");
        if (scalar(@qr_cap3) > 1) {
            my str $qr_pat3 = $qr_cap3[1];
            my str $qr_flags3 = "";
            if (scalar(@qr_cap3) > 2) {
                $qr_flags3 = $qr_cap3[2];
            }
            if (length($qr_flags3) > 0) {
                $result = replace($result, "\\bqr#[^#]*#[a-z]*", "\"(?" . $qr_flags3 . ")" . $qr_pat3 . "\"");
            } else {
                $result = replace($result, "\\bqr#[^#]*#", "\"" . $qr_pat3 . "\"");
            }
        }
    }
    # qr!pattern!flags -> "(?flags)pattern" (! delimiter)
    if (match($result, "\\bqr!")) {
        my array @qr_cap4 = capture($result, "\\bqr!([^!]*)!([a-z]*)");
        if (scalar(@qr_cap4) > 1) {
            my str $qr_pat4 = $qr_cap4[1];
            my str $qr_flags4 = "";
            if (scalar(@qr_cap4) > 2) {
                $qr_flags4 = $qr_cap4[2];
            }
            if (length($qr_flags4) > 0) {
                $result = replace($result, "\\bqr![^!]*![a-z]*", "\"(?" . $qr_flags4 . ")" . $qr_pat4 . "\"");
            } else {
                $result = replace($result, "\\bqr![^!]*!", "\"" . $qr_pat4 . "\"");
            }
        }
    }
    # qr|pattern|flags -> "(?flags)pattern" (| delimiter)
    if (match($result, "\\bqr\\|")) {
        my array @qr_cap5 = capture($result, "\\bqr\\|([^|]*)\\|([a-z]*)");
        if (scalar(@qr_cap5) > 1) {
            my str $qr_pat5 = $qr_cap5[1];
            my str $qr_flags5 = "";
            if (scalar(@qr_cap5) > 2) {
                $qr_flags5 = $qr_cap5[2];
            }
            if (length($qr_flags5) > 0) {
                $result = replace($result, "\\bqr\\|[^|]*\\|[a-z]*", "\"(?" . $qr_flags5 . ")" . $qr_pat5 . "\"");
            } else {
                $result = replace($result, "\\bqr\\|[^|]*\\|", "\"" . $qr_pat5 . "\"");
            }
        }
    }
    # qr(pattern)flags -> "(?flags)pattern" (paren delimiter)
    if (match($result, "\\bqr\\(")) {
        my array @qr_cap6 = capture($result, "\\bqr\\(([^)]*)\\)([a-z]*)");
        if (scalar(@qr_cap6) > 1) {
            my str $qr_pat6 = $qr_cap6[1];
            my str $qr_flags6 = "";
            if (scalar(@qr_cap6) > 2) {
                $qr_flags6 = $qr_cap6[2];
            }
            if (length($qr_flags6) > 0) {
                $result = replace($result, "\\bqr\\([^)]*\\)[a-z]*", "\"(?" . $qr_flags6 . ")" . $qr_pat6 . "\"");
            } else {
                $result = replace($result, "\\bqr\\([^)]*\\)", "\"" . $qr_pat6 . "\"");
            }
        }
    }
    # qr[pattern]flags -> "(?flags)pattern" (bracket delimiter)
    if (match($result, "\\bqr\\[")) {
        my array @qr_cap7 = capture($result, "\\bqr\\[([^]]*)]([a-z]*)");
        if (scalar(@qr_cap7) > 1) {
            my str $qr_pat7 = $qr_cap7[1];
            my str $qr_flags7 = "";
            if (scalar(@qr_cap7) > 2) {
                $qr_flags7 = $qr_cap7[2];
            }
            if (length($qr_flags7) > 0) {
                $result = replace($result, "\\bqr\\[[^]]*][a-z]*", "\"(?" . $qr_flags7 . ")" . $qr_pat7 . "\"");
            } else {
                $result = replace($result, "\\bqr\\[[^]]*]", "\"" . $qr_pat7 . "\"");
            }
        }
    }

    # ---- q/qq string quoting ----
    # q[] q{} q() q// q|| -> single-quoted string (no interpolation)
    # qq[] qq{} qq() qq// qq|| -> double-quoted string (with interpolation)
    # Note: POSIX regex [^]] means "not ]" - ] must be first in char class
    if (match($result, "\\bq[q]?\\s*[\\[{(/|]")) {
        # qq[...] qq{...} qq(...) qq/.../ qq|...| -> "..."
        # Must escape inner double quotes in the content
        if (match($result, "\\bqq\\s*\\[")) {
            my array @qqcap = capture($result, "\\bqq\\[([^]]*)]");
            if (scalar(@qqcap) > 1) {
                my str $qq_inner = replace_all($qqcap[1], "\"", "\\\"");
                $result = replace($result, "\\bqq\\[[^]]*]", "\"" . $qq_inner . "\"");
            }
        }
        elsif (match($result, "\\bqq\\s*\\{")) {
            my array @qqcap2 = capture($result, "\\bqq\\{([^}]*)\\}");
            if (scalar(@qqcap2) > 1) {
                my str $qq_inner2 = replace_all($qqcap2[1], "\"", "\\\"");
                $result = replace($result, "\\bqq\\{[^}]*\\}", "\"" . $qq_inner2 . "\"");
            }
        }
        elsif (match($result, "\\bqq\\s*\\(")) {
            my array @qqcap3 = capture($result, "\\bqq\\(([^)]*)\\)");
            if (scalar(@qqcap3) > 1) {
                my str $qq_inner3 = replace_all($qqcap3[1], "\"", "\\\"");
                $result = replace($result, "\\bqq\\([^)]*\\)", "\"" . $qq_inner3 . "\"");
            }
        }
        elsif (match($result, "\\bqq\\s*/")) {
            my array @qqcap4 = capture($result, "\\bqq/([^/]*)/");
            if (scalar(@qqcap4) > 1) {
                my str $qq_inner4 = replace_all($qqcap4[1], "\"", "\\\"");
                $result = replace($result, "\\bqq/[^/]*/", "\"" . $qq_inner4 . "\"");
            }
        }
        elsif (match($result, "\\bqq\\s*\\|")) {
            my array @qqcap5 = capture($result, "\\bqq\\|([^|]*)\\|");
            if (scalar(@qqcap5) > 1) {
                my str $qq_inner5 = replace_all($qqcap5[1], "\"", "\\\"");
                $result = replace($result, "\\bqq\\|[^|]*\\|", "\"" . $qq_inner5 . "\"");
            }
        }
        # q[...] q{...} q(...) q/.../ q|...| -> '...' (single-quoted, no interpolation)
        elsif (match($result, "\\bq\\[")) {
            my array @qcap = capture($result, "\\bq\\[([^]]*)]");
            if (scalar(@qcap) > 1) {
                $result = replace($result, "\\bq\\[[^]]*]", "'" . $qcap[1] . "'");
            }
        }
        elsif (match($result, "\\bq\\{")) {
            my array @qcap2 = capture($result, "\\bq\\{([^}]*)\\}");
            if (scalar(@qcap2) > 1) {
                $result = replace($result, "\\bq\\{[^}]*\\}", "'" . $qcap2[1] . "'");
            }
        }
        elsif (match($result, "\\bq\\(")) {
            my array @qcap3 = capture($result, "\\bq\\(([^)]*)\\)");
            if (scalar(@qcap3) > 1) {
                $result = replace($result, "\\bq\\([^)]*\\)", "'" . $qcap3[1] . "'");
            }
        }
        elsif (match($result, "\\bq/") && !match($result, "\\bqq/") && !match($result, "\\bqw/") && !match($result, "\\bqr/") && !match($result, "\\bqx/")) {
            my array @qcap4 = capture($result, "\\bq/([^/]*)/");
            if (scalar(@qcap4) > 1) {
                $result = replace($result, "\\bq/[^/]*/", "'" . $qcap4[1] . "'");
            }
        }
        elsif (match($result, "\\bq\\|") && !match($result, "\\bqq\\|") && !match($result, "\\bqw\\|") && !match($result, "\\bqr\\|") && !match($result, "\\bqx\\|")) {
            my array @qcap5 = capture($result, "\\bq\\|([^|]*)\\|");
            if (scalar(@qcap5) > 1) {
                $result = replace($result, "\\bq\\|[^|]*\\|", "'" . $qcap5[1] . "'");
            }
        }
    }

    # ---- split /regex/ -> split("regex", ...) ----
    # split /pattern/, $str -> split("pattern", $str)
    # split /pattern/, $str, $limit -> split("pattern", $str, $limit)
    if (match($result, "\\bsplit\\s+/") && !match($result, "\\bsplit\\s*\\(")) {
        my array @splitcap = capture($result, "\\bsplit\\s+/([^/]*)/\\s*,\\s*(.+)$");
        if (scalar(@splitcap) > 2) {
            my str $spat = $splitcap[1];
            my str $srest = $splitcap[2];
            # Strip trailing ; since we'll add );
            $srest = replace($srest, ";\\s*$", "");
            $result = replace($result, "\\bsplit\\s+/[^/]*/\\s*,\\s*.+$", "split(\"" . $spat . "\", " . $srest . ");");
        }
    }
    # split(/pattern/, $str) -> split("pattern", $str) (already has parens but regex delimiter)
    if (match($result, "\\bsplit\\s*\\(/") && !match($result, "split\\s*\\(\"")) {
        my array @splitcap2 = capture($result, "\\bsplit\\s*\\(/([^/]*)/\\s*,");
        if (scalar(@splitcap2) > 1) {
            my str $spat2 = $splitcap2[1];
            $result = replace($result, "split\\s*\\(/[^/]*/", "split(\"" . $spat2 . "\"");
        }
    }

    # ---- Perl logical operators ----
    # " and " -> " && ", " or " -> " || ", "not " -> "! "
    # Use space-delimited patterns to avoid matching inside identifiers
    # Special case: "or die" -> "|| die" (handled below for general case)
    $result = replace_keyword_outside_strings($result, " and ", " && ");
    $result = replace_keyword_outside_strings($result, " or ", " || ");
    $result = replace_keyword_outside_strings($result, " not ", " ! ");
    # Handle at start of expression (after paren or start of line)
    if (match($result, "\\(not\\s")) {
        $result = replace($result, "\\(not ", "(! ");
    }

    # ---- String interpolation ----
    $result = convert_interpolation($result);

    # ---- Quote bare hash keys ----
    $result = quote_hash_keys($result);

    # ---- Class->method() -> Class::method() (static/class method calls) ----
    # Matches CapitalName->word( patterns (NOT $var-> which is instance method)
    # e.g. Animal->new(...) -> Animal::new(...)
    #      File::Path->make_path -> File::Path::make_path
    if (match($result, "[A-Z][A-Za-z0-9_:]*->\\s*[a-z_][A-Za-z0-9_]*\\s*\\(")) {
        # Replace all Class->method( with Class::method(
        # Use a loop since there may be multiple on one line
        my int $cm_safety = 0;
        while (match($result, "[A-Z][A-Za-z0-9_:]*->\\s*[a-z_][A-Za-z0-9_]*\\s*\\(") && $cm_safety < 10) {
            my array @cmcap = capture($result, "([A-Z][A-Za-z0-9_:]*)\\->\\s*([a-z_][A-Za-z0-9_]*)\\s*\\(");
            if (scalar(@cmcap) > 2) {
                my str $cls = $cmcap[1];
                my str $meth = $cmcap[2];
                $result = replace($result, $cls . "->\\s*" . $meth . "\\s*\\(", $cls . "::" . $meth . "(");
            } else {
                $cm_safety = 10;
            }
            $cm_safety++;
        }
    }
    # Class->method without parens (bare form): Animal->new -> Animal::new
    if (match($result, "[A-Z][A-Za-z0-9_:]*->\\s*[a-z_][A-Za-z0-9_]*") && !match($result, "->\\s*\\{")) {
        my int $cm2_safety = 0;
        while (match($result, "[A-Z][A-Za-z0-9_:]*->\\s*[a-z_][A-Za-z0-9_]*") && $cm2_safety < 10) {
            my array @cmcap2 = capture($result, "([A-Z][A-Za-z0-9_:]*)\\->\\s*([a-z_][A-Za-z0-9_]*)");
            if (scalar(@cmcap2) > 2) {
                my str $cls2 = $cmcap2[1];
                my str $meth2 = $cmcap2[2];
                $result = replace($result, $cls2 . "->\\s*" . $meth2, $cls2 . "::" . $meth2);
            } else {
                $cm2_safety = 10;
            }
            $cm2_safety++;
        }
    }
    # ---- Fat comma in constructor/function args: name => "val" -> "name", "val" ----
    # In Perl, fat comma auto-quotes the left side. Strada constructors use "key", "value" pairs.
    # Convert bareword => value in function call arguments: foo(name => "Rex") -> foo("name", "Rex")
    # Uses index-based approach to avoid regex matching issues with word boundaries
    if (match($result, "[A-Za-z_][A-Za-z0-9_]*\\s*=>") && !match($result, "^\\s*#") && !match($result, "\\$[A-Za-z_][A-Za-z0-9_]*\\s*=>")) {
        my int $fc_safety = 0;
        my int $fc_pos = 0;
        my str $fc_out = "";
        my int $fc_len = length($result);
        while ($fc_pos < $fc_len && $fc_safety < 500) {
            my str $fc_ch = substr($result, $fc_pos, 1);
            # Skip inside quoted strings
            if ($fc_ch eq "\"") {
                $fc_out = $fc_out . $fc_ch;
                $fc_pos++;
                while ($fc_pos < $fc_len) {
                    my str $fc_qc = substr($result, $fc_pos, 1);
                    $fc_out = $fc_out . $fc_qc;
                    $fc_pos++;
                    if ($fc_qc eq "\"") { last; }
                    if ($fc_qc eq "\\" && $fc_pos < $fc_len) {
                        $fc_out = $fc_out . substr($result, $fc_pos, 1);
                        $fc_pos++;
                    }
                }
                next;
            }
            # Check if we're at a bareword followed by =>
            if (match(substr($result, $fc_pos, 1), "[A-Za-z_]")) {
                # Check character before: must be non-word (or start of line)
                my int $fc_ok = 0;
                if ($fc_pos == 0) { $fc_ok = 1; }
                elsif (!match(substr($result, $fc_pos - 1, 1), "[A-Za-z0-9_]")) { $fc_ok = 1; }
                if ($fc_ok == 1) {
                    # Extract the bareword
                    my int $fc_end = $fc_pos;
                    while ($fc_end < $fc_len && match(substr($result, $fc_end, 1), "[A-Za-z0-9_]")) {
                        $fc_end++;
                    }
                    my str $fc_word = substr($result, $fc_pos, $fc_end - $fc_pos);
                    # Skip whitespace after word
                    my int $fc_sp = $fc_end;
                    while ($fc_sp < $fc_len && substr($result, $fc_sp, 1) eq " ") { $fc_sp++; }
                    # Check for =>
                    if ($fc_sp + 1 < $fc_len && substr($result, $fc_sp, 2) eq "=>") {
                        # Check it's not a $var => or already "quoted" =>
                        if ($fc_pos > 0 && substr($result, $fc_pos - 1, 1) eq "\"") {
                            # Already quoted â€” skip
                            $fc_out = $fc_out . $fc_word;
                            $fc_pos = $fc_end;
                        } else {
                            # Quote the bareword
                            $fc_out = $fc_out . "\"" . $fc_word . "\"";
                            $fc_pos = $fc_end;
                        }
                    } else {
                        $fc_out = $fc_out . substr($result, $fc_pos, 1);
                        $fc_pos++;
                    }
                } else {
                    $fc_out = $fc_out . $fc_ch;
                    $fc_pos++;
                }
            } else {
                $fc_out = $fc_out . $fc_ch;
                $fc_pos++;
            }
            $fc_safety++;
        }
        # Copy any remaining
        if ($fc_pos < $fc_len) {
            $fc_out = $fc_out . substr($result, $fc_pos, $fc_len - $fc_pos);
        }
        $result = $fc_out;
    }

    # Instance method calls without parens: $obj->method; -> $obj->method();
    # Handles: ->method; ->method) ->method-> (chained calls)
    # But NOT: ->method( (already has parens), ->{ (hash deref), ->$var (dynamic dispatch)
    if (match($result, "->\\s*[a-z_][A-Za-z0-9_]*") && !match($result, "->\\s*\\{") && !match($result, "#")) {
        my int $imp_safety = 0;
        # First handle chained: ->method-> (method without parens followed by another arrow)
        while (match($result, "->([a-z_][A-Za-z0-9_]*)->") && $imp_safety < 10) {
            my array @chain_cap = capture($result, "->([a-z_][A-Za-z0-9_]*)->");
            if (scalar(@chain_cap) > 1) {
                my str $chain_meth = $chain_cap[1];
                $result = replace($result, "->" . $chain_meth . "->", "->" . $chain_meth . "()->");
            } else {
                $imp_safety = 10;
            }
            $imp_safety++;
        }
        # Then handle terminal: ->method; or ->method) or ->method, (no parens)
        $imp_safety = 0;
        while (match($result, "->\\s*([a-z_][A-Za-z0-9_]*)\\s*([;),])") && $imp_safety < 10) {
            my array @imp_cap = capture($result, "->\\s*([a-z_][A-Za-z0-9_]*)\\s*([;),])");
            if (scalar(@imp_cap) > 2) {
                my str $imp_meth = $imp_cap[1];
                my str $imp_after = $imp_cap[2];
                # Skip if already has parens (check one more character)
                if (!match($result, "->" . $imp_meth . "\\s*\\(")) {
                    $result = replace($result, "->\\s*" . $imp_meth . "\\s*" . "\\" . $imp_after, "->" . $imp_meth . "()" . $imp_after);
                } else {
                    $imp_safety = 10;
                }
            } else {
                $imp_safety = 10;
            }
            $imp_safety++;
        }
    }

    # ---- chown -> core::chown ----
    if (match($result, "\\bchown\\s*\\(") && !match($result, "core::chown")) {
        $result = replace($result, "\\bchown\\s*\\(", "core::chown(");
    }
    elsif (match($result, "\\bchown\\s+[0-9\\$]") && !match($result, "core::chown") && !match($result, "\\bchown\\s*\\(")) {
        $result = replace($result, "\\bchown\\s+", "core::chown(");
        $result = add_close_paren($result);
    }

    # ---- localtime -> core::localtime ----
    if (match($result, "\\blocaltime\\s*\\(") && !match($result, "core::localtime")) {
        $result = replace($result, "\\blocaltime\\s*\\(", "core::localtime(");
    }
    elsif (match($result, "\\blocaltime\\b") && !match($result, "core::localtime") && !match($result, "#")) {
        $result = replace($result, "\\blocaltime\\b", "core::localtime()");
    }

    # ---- time -> core::time ----
    if (match($result, "\\btime\\s*\\(\\s*\\)") && !match($result, "core::time") && !match($result, "localtime") && !match($result, "Time::")) {
        $result = replace($result, "\\btime\\s*\\(\\s*\\)", "core::time()");
    }
    elsif (match($result, "\\btime\\b") && !match($result, "core::time") && !match($result, "#") && !match($result, "localtime") && !match($result, "\\$time") && !match($result, "Time::") && !match($result, "timeout") && !match($result, "timestamp") && !match($result, "timer") && !match($result, "times") && !match($result, "time_")) {
        # Bare time without parens - only if it looks like a standalone call
        if (match($result, "=\\s*time\\s*;") || match($result, "=\\s*time\\s*$") || match($result, "\\(time\\)") || match($result, ",\\s*time\\s*[,;)]")) {
            $result = replace($result, "\\btime\\b", "core::time()");
        }
    }

    # ---- our $VERSION -> version directive ----
    if (match($result, "our\\s+scalar\\s+\\$VERSION\\s*=\\s*")) {
        my array @vercap = capture($result, "\\$VERSION\\s*=\\s*['\"]?([^'\";\n]+)['\"]?\\s*;");
        if (scalar(@vercap) > 1) {
            my str $ver = trim_str($vercap[1]);
            $result = $indent . "version \"" . $ver . "\";";
        }
    }

    # ---- or die / || die on core:: calls -> if (!defined) check ----
    if (match($result, "core::[a-z_]+\\(") && (match($result, " \\|\\| die") || match($result, " or die"))) {
        # Extract die message
        my str $ordie_msg2 = "";
        my array @ordie2_cap = capture($result, "(?:or|\\|\\|)\\s+die\\s*\\(([^)]*)\\)");
        if (scalar(@ordie2_cap) > 1) {
            $ordie_msg2 = $ordie2_cap[1];
        } else {
            my array @ordie2_cap2 = capture($result, "(?:or|\\|\\|)\\s+die\\s+([^;]+)");
            if (scalar(@ordie2_cap2) > 1) {
                $ordie_msg2 = trim_str($ordie2_cap2[1]);
            }
        }
        # Extract variable being assigned
        my array @ordie2_vcap = capture($result, "\\$([A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*core::");
        my str $ordie_var2 = "";
        if (scalar(@ordie2_vcap) > 1) { $ordie_var2 = $ordie2_vcap[1]; }
        # Strip the or die part
        $result = replace($result, "\\s+\\|\\|\\s+die\\s*\\([^)]*\\)\\s*", "");
        $result = replace($result, "\\s+\\|\\|\\s+die\\s+[^;]*", "");
        $result = replace($result, "\\s+or\\s+die\\s*\\([^)]*\\)\\s*", "");
        $result = replace($result, "\\s+or\\s+die\\s+[^;]*", "");
        # Add if (!defined) check
        if (length($ordie_var2) > 0 && length($ordie_msg2) > 0) {
            $result = $result . "\n" . $indent . "if (!defined($" . $ordie_var2 . ")) { die(" . $ordie_msg2 . "); }";
        } elsif (length($ordie_var2) > 0) {
            $result = $result . "\n" . $indent . "if (!defined($" . $ordie_var2 . ")) { die(\"operation failed\"); }";
        }
    }

    # ---- Scalar::Util function conversions ----
    # blessed($ref) -> ref($ref) (close approximation: returns class name or "")
    if (match($result, "\\bblessed\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\bblessed\\s*\\(", "ref(");
    }
    # reftype($ref) -> ref($ref) with REVIEW
    if (match($result, "\\breftype\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\breftype\\s*\\(", "ref(");
        $result = $result . "  # REVIEW: reftype() replaced with ref() - may differ for blessed refs";
    }
    # weaken($ref) -> core::weaken($ref) (Strada now supports weak references)
    if (match($result, "\\bweaken\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\bweaken\\s*\\(", "core::weaken(");
    }
    # isweak($ref) -> core::isweak($ref)
    if (match($result, "\\bisweak\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\bisweak\\s*\\(", "core::isweak(");
    }
    # looks_like_number($val) -> match($val, "^-?[0-9]")
    if (match($result, "\\blooks_like_number\\s*\\(") && !match($result, "#")) {
        # Extract the argument to looks_like_number()
        my array @lln_cap = capture($result, "\\blooks_like_number\\s*\\(([^)]*)\\)");
        if (scalar(@lln_cap) > 1) {
            my str $lln_arg = trim_str($lln_cap[1]);
            $result = replace($result, "\\blooks_like_number\\s*\\([^)]*\\)", "match(" . $lln_arg . ", \"^-?[0-9]*[.]?[0-9]+\")");
        } else {
            $result = replace($result, "\\blooks_like_number\\s*\\(", "match(");
            $result = $result . "  # REVIEW: add numeric pattern as second arg to match()";
        }
    }
    # openhandle($fh) -> defined($fh)
    if (match($result, "\\bopenhandle\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\bopenhandle\\s*\\(", "defined(");
    }
    # tainted($val) -> 0 (no taint mode in Strada)
    if (match($result, "\\btainted\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\btainted\\s*\\([^)]*\\)", "0");
        $result = $result . "  # REVIEW: no taint mode in Strada";
    }
    # dualvar($num, $str) -> no equivalent
    if (match($result, "\\bdualvar\\s*\\(") && !match($result, "#")) {
        $result = $result . "  # REVIEW: dualvar() has no Strada equivalent â€” value will be either numeric or string, not both";
    }
    # isvstring($val) -> 0 (not applicable in Strada)
    if (match($result, "\\bisvstring\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\bisvstring\\s*\\([^)]*\\)", "0");
        $result = $result . "  # Note: v-strings not applicable in Strada";
    }
    # set_prototype(\&func, $proto) -> no equivalent
    if (match($result, "\\bset_prototype\\s*\\(") && !match($result, "#")) {
        $result = $indent . "# " . $trimmed . "  # REVIEW: set_prototype() has no Strada equivalent â€” Strada uses typed function signatures";
    }
    # readonly($var) -> 0
    if (match($result, "\\breadonly\\s*\\(") && !match($result, "#") && !match($result, "\\bReadonly\\b")) {
        $result = replace($result, "\\breadonly\\s*\\([^)]*\\)", "0");
        $result = $result . "  # REVIEW: readonly() â€” use 'const' for compile-time constants in Strada";
    }

    # ---- List::Util function conversions ----
    # max(@list) / min(@list) / sum(@list) -> List::Util::max/min/sum
    if (match($result, "\\bmax\\s*\\(") && !match($result, "#") && !match($result, "math::") && !match($result, "MAX_") && !match($result, "max_") && !match($result, "List::Util::max")) {
        $result = replace($result, "\\bmax\\s*\\(", "List::Util::max(");
    }
    if (match($result, "\\bmin\\s*\\(") && !match($result, "#") && !match($result, "math::") && !match($result, "MIN_") && !match($result, "min_") && !match($result, "List::Util::min")) {
        $result = replace($result, "\\bmin\\s*\\(", "List::Util::min(");
    }
    if (match($result, "\\bsum\\s*\\(") && !match($result, "#") && !match($result, "SUM_") && !match($result, "sum_") && !match($result, "checksum") && !match($result, "List::Util::sum")) {
        $result = replace($result, "\\bsum\\s*\\(", "List::Util::sum(");
    }
    if (match($result, "\\bsum0\\s*\\(") && !match($result, "#") && !match($result, "List::Util::sum0")) {
        $result = replace($result, "\\bsum0\\s*\\(", "List::Util::sum0(");
    }
    # product(@list) -> List::Util::product(@list)
    if (match($result, "\\bproduct\\s*\\(") && !match($result, "#") && !match($result, "List::Util::product")) {
        $result = replace($result, "\\bproduct\\s*\\(", "List::Util::product(");
    }
    # uniq(@list) / uniqstr(@list) -> List::Util::uniq(@list)
    if (match($result, "\\buniq\\s*\\(") && !match($result, "#") && !match($result, "List::Util::uniq") && !match($result, "uniq_")) {
        $result = replace($result, "\\buniq\\s*\\(", "List::Util::uniq(");
    }
    if (match($result, "\\buniqstr\\s*\\(") && !match($result, "#") && !match($result, "List::Util::")) {
        $result = replace($result, "\\buniqstr\\s*\\(", "List::Util::uniq(");
    }
    # shuffle(@list) -> List::Util::shuffle(@list)
    if (match($result, "\\bshuffle\\s*\\(") && !match($result, "#") && !match($result, "List::Util::shuffle")) {
        $result = replace($result, "\\bshuffle\\s*\\(", "List::Util::shuffle(");
    }
    # pairs(@list) -> List::Util::pairs(@list)
    if (match($result, "\\bpairs\\s*\\(") && !match($result, "#") && !match($result, "List::Util::pairs")) {
        $result = replace($result, "\\bpairs\\s*\\(", "List::Util::pairs(");
    }
    # reduce { BLOCK } @list -> loop-based conversion
    if (match($result, "\\breduce\\s*\\{") && !match($result, "#")) {
        my array @red_cap = capture($result, "\\breduce\\s*\\{\\s*([^}]+)\\s*\\}\\s*(@[A-Za-z_][A-Za-z0-9_]*)");
        if (scalar(@red_cap) > 2) {
            my str $red_body = trim_str($red_cap[1]);
            my str $red_arr = $red_cap[2];
            # Convert $a, $b to $__acc, $__item in the body
            my str $red_strada = replace_all($red_body, "$a", "$__acc");
            $red_strada = replace_all($red_strada, "$b", "$__item");
            my array @red_v = capture($result, "(my\\s+(scalar\\s+|int\\s+|num\\s+)?\\$[A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*reduce");
            if (scalar(@red_v) > 1) {
                my str $red_decl = $red_v[1];
                my array @red_vn = capture($red_decl, "(\\$[A-Za-z_][A-Za-z0-9_]*)");
                my str $red_var = "$__reduce_result";
                if (scalar(@red_vn) > 1) { $red_var = $red_vn[1]; }
                $result = $indent . "# was: reduce { " . $red_body . " } " . $red_arr;
                $result = $result . "\n" . $indent . $red_decl . " = " . $red_arr . "[0];";
                $result = $result . "\n" . $indent . "for (my int $__i = 1; $__i < scalar(" . $red_arr . "); $__i++) { my scalar $__acc = " . $red_var . "; my scalar $__item = " . $red_arr . "[$__i]; " . $red_var . " = " . $red_strada . "; }";
            } else {
                $result = $result . "  # REVIEW: reduce { " . $red_body . " } " . $red_arr . " â€” convert to for loop with accumulator";
            }
        } else {
            $result = $result . "  # REVIEW: reduce { $a OP $b } @list â€” convert to for loop with accumulator";
        }
    }
    # first { BLOCK } @list -> convert to loop
    if (match($result, "\\bfirst\\s*\\{") && !match($result, "#") && !match($result, "first_")) {
        # Try to extract simple condition: first { COND } @arr
        my array @fc = capture($result, "\\bfirst\\s*\\{\\s*([^}]+)\\s*\\}\\s*(@[A-Za-z_][A-Za-z0-9_]*)");
        if (scalar(@fc) > 2) {
            my str $fc_cond = trim_str($fc[1]);
            my str $fc_arr = $fc[2];
            # Replace $_ with $__item in condition
            my str $fc_strada = replace_all($fc_cond, "$_", "$__item");
            # Check if it's an assignment: my $var = first { ... } @arr;
            my array @fv = capture($result, "(my\\s+(scalar\\s+)?\\$[A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*first");
            if (scalar(@fv) > 1) {
                my str $fv_decl = $fv[1];
                # Extract just the variable name (e.g. "$found" from "my scalar $found")
                my array @fv_name_cap = capture($fv_decl, "(\\$[A-Za-z_][A-Za-z0-9_]*)");
                my str $fv_var = "$found";
                if (scalar(@fv_name_cap) > 1) {
                    $fv_var = $fv_name_cap[1];
                }
                $result = $indent . "# was: first { " . $fc_cond . " } " . $fc_arr;
                $result = $result . "\n" . $indent . $fv_decl . " = undef;";
                $result = $result . "\n" . $indent . "for (my int $__i = 0; $__i < scalar(" . $fc_arr . "); $__i++) { my scalar $__item = " . $fc_arr . "[$__i]; if (" . $fc_strada . ") { " . $fv_var . " = $__item; last; } }";
            } else {
                $result = $result . "  # REVIEW: first { " . $fc_cond . " } " . $fc_arr . " â€” convert to for loop finding first match";
            }
        } else {
            $result = $result . "  # REVIEW: first { BLOCK } @list â€” convert to for loop finding first match";
        }
    }
    # any { BLOCK } @list -> loop-based conversion
    if (match($result, "\\bany\\s*\\{") && !match($result, "#") && !match($result, "any_")) {
        my array @any_cap = capture($result, "\\bany\\s*\\{\\s*([^}]+)\\s*\\}\\s*(@[A-Za-z_][A-Za-z0-9_]*)");
        if (scalar(@any_cap) > 2) {
            my str $any_cond = trim_str($any_cap[1]);
            my str $any_arr = $any_cap[2];
            my str $any_strada = replace_all($any_cond, "$_", "$__item");
            # Check if assignment: my $var = any { ... } @arr;
            my array @any_v = capture($result, "(my\\s+(scalar\\s+|int\\s+)?\\$[A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*any");
            if (scalar(@any_v) > 1) {
                my str $any_decl = $any_v[1];
                my array @any_vn = capture($any_decl, "(\\$[A-Za-z_][A-Za-z0-9_]*)");
                my str $any_var = "$__any_result";
                if (scalar(@any_vn) > 1) { $any_var = $any_vn[1]; }
                $result = $indent . "# was: any { " . $any_cond . " } " . $any_arr;
                $result = $result . "\n" . $indent . $any_decl . " = 0;";
                $result = $result . "\n" . $indent . "for (my int $__i = 0; $__i < scalar(" . $any_arr . "); $__i++) { my scalar $__item = " . $any_arr . "[$__i]; if (" . $any_strada . ") { " . $any_var . " = 1; last; } }";
            } else {
                $result = $result . "  # REVIEW: any { " . $any_cond . " } " . $any_arr . " â€” convert to for loop with flag";
            }
        } else {
            $result = $result . "  # REVIEW: any { COND } @list â€” convert to for loop with early return";
        }
    }
    # all { BLOCK } @list -> loop-based conversion
    if (match($result, "\\ball\\s*\\{") && !match($result, "#") && !match($result, "install")) {
        my array @all_cap = capture($result, "\\ball\\s*\\{\\s*([^}]+)\\s*\\}\\s*(@[A-Za-z_][A-Za-z0-9_]*)");
        if (scalar(@all_cap) > 2) {
            my str $all_cond = trim_str($all_cap[1]);
            my str $all_arr = $all_cap[2];
            my str $all_strada = replace_all($all_cond, "$_", "$__item");
            my array @all_v = capture($result, "(my\\s+(scalar\\s+|int\\s+)?\\$[A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*all");
            if (scalar(@all_v) > 1) {
                my str $all_decl = $all_v[1];
                my array @all_vn = capture($all_decl, "(\\$[A-Za-z_][A-Za-z0-9_]*)");
                my str $all_var = "$__all_result";
                if (scalar(@all_vn) > 1) { $all_var = $all_vn[1]; }
                $result = $indent . "# was: all { " . $all_cond . " } " . $all_arr;
                $result = $result . "\n" . $indent . $all_decl . " = 1;";
                $result = $result . "\n" . $indent . "for (my int $__i = 0; $__i < scalar(" . $all_arr . "); $__i++) { my scalar $__item = " . $all_arr . "[$__i]; if (!(" . $all_strada . ")) { " . $all_var . " = 0; last; } }";
            } else {
                $result = $result . "  # REVIEW: all { " . $all_cond . " } " . $all_arr . " â€” convert to for loop with flag";
            }
        } else {
            $result = $result . "  # REVIEW: all { COND } @list â€” convert to for loop with early return";
        }
    }
    # none { BLOCK } @list -> loop-based conversion
    if (match($result, "\\bnone\\s*\\{") && !match($result, "#")) {
        my array @none_cap = capture($result, "\\bnone\\s*\\{\\s*([^}]+)\\s*\\}\\s*(@[A-Za-z_][A-Za-z0-9_]*)");
        if (scalar(@none_cap) > 2) {
            my str $none_cond = trim_str($none_cap[1]);
            my str $none_arr = $none_cap[2];
            my str $none_strada = replace_all($none_cond, "$_", "$__item");
            my array @none_v = capture($result, "(my\\s+(scalar\\s+|int\\s+)?\\$[A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*none");
            if (scalar(@none_v) > 1) {
                my str $none_decl = $none_v[1];
                my array @none_vn = capture($none_decl, "(\\$[A-Za-z_][A-Za-z0-9_]*)");
                my str $none_var = "$__none_result";
                if (scalar(@none_vn) > 1) { $none_var = $none_vn[1]; }
                $result = $indent . "# was: none { " . $none_cond . " } " . $none_arr;
                $result = $result . "\n" . $indent . $none_decl . " = 1;";
                $result = $result . "\n" . $indent . "for (my int $__i = 0; $__i < scalar(" . $none_arr . "); $__i++) { my scalar $__item = " . $none_arr . "[$__i]; if (" . $none_strada . ") { " . $none_var . " = 0; last; } }";
            } else {
                $result = $result . "  # REVIEW: none { " . $none_cond . " } " . $none_arr . " â€” convert to for loop with flag";
            }
        } else {
            $result = $result . "  # REVIEW: none { COND } @list â€” convert to for loop with early return";
        }
    }

    # ---- List::MoreUtils functions -> TODO annotations ----
    if (match($result, "\\b(zip|uniq_by|natatime|each_array|mesh|pairwise|part|first_index|last_index)\\s*[({]") && !match($result, "#.*TODO")) {
        my array @lmu_cap = capture($result, "\\b(zip|uniq_by|natatime|each_array|mesh|pairwise|part|first_index|last_index)\\s*[({]");
        if (scalar(@lmu_cap) > 1) {
            my str $lmu_func = $lmu_cap[1];
            if ($lmu_func eq "zip" || $lmu_func eq "mesh") {
                $result = $result . "  # REVIEW: " . $lmu_func . "() â€” implement as interleave loop";
            } elsif ($lmu_func eq "uniq_by") {
                $result = $result . "  # REVIEW: uniq_by â€” implement with hash-based dedup loop";
            } elsif ($lmu_func eq "natatime") {
                $result = $result . "  # REVIEW: natatime() â€” implement as chunked iteration with index step";
            } elsif ($lmu_func eq "each_array") {
                $result = $result . "  # REVIEW: each_array() â€” implement as parallel index iteration";
            } elsif ($lmu_func eq "pairwise") {
                $result = $result . "  # REVIEW: pairwise â€” implement as parallel map with two arrays";
            } elsif ($lmu_func eq "part") {
                $result = $result . "  # REVIEW: part â€” implement as partition loop into array of arrays";
            } elsif ($lmu_func eq "first_index") {
                $result = $result . "  # REVIEW: first_index â€” implement as for loop returning index on first match";
            } elsif ($lmu_func eq "last_index") {
                $result = $result . "  # REVIEW: last_index â€” implement as reverse for loop returning index";
            }
        }
    }

    # ---- map/grep block: fix bare builtins and bare regex inside blocks ----
    # map { uc } @list -> map { uc($_) } @list
    # grep { /pattern/ } @list -> grep { $_ =~ /pattern/ } @list
    if (match($result, "\\b(map|grep)\\s*\\{") && !match($result, "^\\s*#")) {
        my str $topic = "$" . "_";
        # Fix bare builtins without args inside map/grep blocks
        # map { uc } -> map { uc($_) }
        if (match($result, "\\{\\s*(uc|lc|ucfirst|lcfirst|chomp|chop|length|defined|ref)\\s*\\}")) {
            my array @bb_cap = capture($result, "\\{\\s*(uc|lc|ucfirst|lcfirst|chomp|chop|length|defined|ref)\\s*\\}");
            if (scalar(@bb_cap) > 1) {
                my str $bb_func = $bb_cap[1];
                $result = replace($result, "\\{\\s*(uc|lc|ucfirst|lcfirst|chomp|chop|length|defined|ref)\\s*\\}", "{ " . $bb_func . "(" . $topic . ") }");
            }
        }
        # Fix bare regex inside grep blocks: grep { /pat/ } -> grep { $_ =~ /pat/ }
        if (match($result, "\\bgrep\\s*\\{\\s*/[^/]") && !match($result, "=~")) {
            $result = replace($result, "(grep\\s*\\{\\s*)/", "$1" . $topic . " =~ /");
        }
        # Fix bare negated regex: grep { !/pat/ } -> grep { $_ !~ /pat/ }
        if (match($result, "\\bgrep\\s*\\{\\s*!/[^/]") && !match($result, "!~")) {
            $result = replace($result, "(grep\\s*\\{\\s*)!/", "$1" . $topic . " !~ /");
        }
    }

    # ---- Bare builtins defaulting to $_ (outside map/grep) -> add ($_) ----
    # uc; -> uc($_); lc; -> lc($_); length; -> length($_); defined; -> defined($_); etc.
    if (!match($result, "\\b(map|grep)\\s*\\{") && !match($result, "^\\s*#") && !match($result, "->")) {
        my str $topic2 = chr(36) . "_";
        if (match($result, "\\buc\\s*;") && !match($result, "uc\\(") && !match($result, "ucfirst")) {
            $result = replace($result, "\\buc\\s*;", "uc(" . $topic2 . ");");
        }
        if (match($result, "\\blc\\s*;") && !match($result, "lc\\(") && !match($result, "lcfirst")) {
            $result = replace($result, "\\blc\\s*;", "lc(" . $topic2 . ");");
        }
        if (match($result, "\\bucfirst\\s*;") && !match($result, "ucfirst\\(")) {
            $result = replace($result, "\\bucfirst\\s*;", "ucfirst(" . $topic2 . ");");
        }
        if (match($result, "\\blcfirst\\s*;") && !match($result, "lcfirst\\(")) {
            $result = replace($result, "\\blcfirst\\s*;", "lcfirst(" . $topic2 . ");");
        }
        if (match($result, "\\blength\\s*;") && !match($result, "length\\(")) {
            $result = replace($result, "\\blength\\s*;", "length(" . $topic2 . ");");
        }
        if (match($result, "\\bdefined\\s*;") && !match($result, "defined\\(")) {
            $result = replace($result, "\\bdefined\\s*;", "defined(" . $topic2 . ");");
        }
        if (match($result, "\\bref\\s*;") && !match($result, "ref\\(") && !match($result, "deref") && !match($result, "_ref") && !match($result, "href") && !match($result, "pref") && !match($result, "\\$[A-Za-z_]*ref\\s*;")) {
            $result = replace($result, "\\bref\\s*;", "ref(" . $topic2 . ");");
        }
    }

    # ---- sort with $a/$b comparator -> annotation ----
    if (match($result, "\\bsort\\s*\\{") && !match($result, "^\\s*#")) {
        # Simple sort { $a <=> $b } or sort { $a cmp $b } -> works natively
        if (match($result, "sort\\s*\\{\\s*\\$a\\s*<=>\\s*\\$b\\s*\\}") || match($result, "sort\\s*\\{\\s*\\$a\\s+cmp\\s+\\$b\\s*\\}")) {
            # These work natively in Strada - no annotation needed
        } elsif (match($result, "sort\\s*\\{\\s*\\$b\\s*<=>\\s*\\$a\\s*\\}") || match($result, "sort\\s*\\{\\s*\\$b\\s+cmp\\s+\\$a\\s*\\}")) {
            # Reverse sort - works natively too
        } elsif (match($result, "sort\\s*\\{\\s*\\$a->\\{") || match($result, "sort\\s*\\{\\s*\\$b->\\{")) {
            # Hash key access sort { $a->{"key"} <=> $b->{"key"} } -> works natively
        } elsif (match($result, "sort\\s*\\{.*\\blc\\s*\\(\\$a\\)") || match($result, "sort\\s*\\{.*\\buc\\s*\\(\\$a\\)")) {
            # lc/uc sort { lc($a) cmp lc($b) } -> works natively
        } elsif (match($result, "sort\\s*\\{.*\\blength\\s*\\(\\$a\\)") || match($result, "sort\\s*\\{.*\\blength\\s*\\(\\$b\\)")) {
            # length sort -> works natively
        } elsif (!match($result, "#.*TODO") && !match($result, "#.*REVIEW")) {
            $result = $result . "  # REVIEW: complex sort â€” verify comparator works in Strada";
        }
        # Strada sort blocks require a semicolon before the closing brace
        # sort { expr } -> sort { expr; }
        if (match($result, "\\bsort\\s*\\{[^}]*[^;\\s]\\s*\\}")) {
            $result = replace($result, "([^;\\s])\\s*\\}", "$1; }");
        }
    }

    # ---- Multi-statement grep blocks -> loop expansion ----
    # Strada grep only accepts single-expression bodies, so multi-statement grep
    # needs to be expanded to a for loop
    if (match($result, "\\bgrep\\s*\\{") && !match($result, "^\\s*#") && !match($result, "#.*TODO") && !match($result, "#.*REVIEW")) {
        my array @grep_cap = capture($result, "\\bgrep\\s*\\{([^}]*)\\}\\s*(@[A-Za-z_][A-Za-z0-9_]*)");
        if (scalar(@grep_cap) > 2) {
            my str $grep_body = trim_str($grep_cap[1]);
            my str $grep_arr = $grep_cap[2];
            # Count semicolons to detect multi-statement
            my int $grep_semis = 0;
            my int $grep_si = 0;
            while ($grep_si < length($grep_body)) {
                if (substr($grep_body, $grep_si, 1) eq ";") { $grep_semis++; }
                $grep_si++;
            }
            if ($grep_semis >= 2) {
                # Multi-statement: expand to loop
                # Replace $_ with $__item in body
                my str $grep_body_s = replace_all($grep_body, "$_", "$__item");
                # Check for assignment: my @result = grep { ... } @arr;
                my array @grep_v = capture($result, "(my\\s+(array\\s+)?@[A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*grep");
                if (scalar(@grep_v) > 1) {
                    my str $grep_decl = $grep_v[1];
                    my array @grep_vn = capture($grep_decl, "(@[A-Za-z_][A-Za-z0-9_]*)");
                    my str $grep_var = "@__grep_result";
                    if (scalar(@grep_vn) > 1) { $grep_var = $grep_vn[1]; }
                    $result = $indent . "# was: grep { " . $grep_body . " } " . $grep_arr;
                    $result = $result . "\n" . $indent . $grep_decl . " = ();";
                    $result = $result . "\n" . $indent . "for (my int $__i = 0; $__i < scalar(" . $grep_arr . "); $__i++) { my scalar $__item = " . $grep_arr . "[$__i]; " . $grep_body_s . " push(" . $grep_var . ", $__item); }";
                } else {
                    $result = $result . "  # REVIEW: multi-statement grep block â€” convert to for loop";
                }
            }
        }
    }
    # ---- Multi-statement map blocks -> REVIEW ----
    if (match($result, "\\bmap\\s*\\{") && !match($result, "^\\s*#") && !match($result, "#.*TODO") && !match($result, "#.*REVIEW")) {
        my array @mg_cap = capture($result, "\\bmap\\s*\\{([^}]*)\\}");
        if (scalar(@mg_cap) > 1) {
            my str $mg_body = $mg_cap[1];
            my int $mg_semis = 0;
            my int $mg_si = 0;
            while ($mg_si < length($mg_body)) {
                if (substr($mg_body, $mg_si, 1) eq ";") { $mg_semis++; }
                $mg_si++;
            }
            if ($mg_semis >= 2) {
                $result = $result . "  # REVIEW: multi-statement map block â€” consider converting to for loop";
            }
        }
    }

    # ---- pack/unpack -> core::pack/core::unpack ----
    if (match($result, "\\bpack\\s*\\(") && !match($result, "#") && !match($result, "core::pack") && !match($result, "unpack")) {
        $result = replace($result, "\\bpack\\s*\\(", "core::pack(");
    }
    if (match($result, "\\bunpack\\s*\\(") && !match($result, "#") && !match($result, "core::unpack")) {
        $result = replace($result, "\\bunpack\\s*\\(", "core::unpack(");
    }

    # ---- $? (child process status) ----
    if (index($result, "$?") >= 0 && !match($result, "#")) {
        # $? >> 8 -> $__exit_code (use return value of core::system() to populate)
        if (match($result, "\\$\\?\\s*>>\\s*8")) {
            $result = replace($result, "\\$\\?\\s*>>\\s*8", "$__exit_code");
        }
        elsif (match($result, "\\$\\?\\s*=")) {
            # Assignment to $? â€” comment out
            $result = $indent . "# " . $trimmed . "  # $? not assignable in Strada";
        }
        elsif (match($result, "\\$\\?")) {
            # Bare $? usage â€” replace with $__exit_code
            $result = replace_all($result, "$?", "$__exit_code");
        }
    }

    # ---- $| (autoflush) ----
    if (index($result, "$|") >= 0 && index($result, "#") < 0) {
        if (match($result, "\\$\\|\\s*=\\s*[01]") || match($result, "\\$\\|\\+\\+") || match($result, "local\\s+\\$\\|")) {
            $result = $indent . "# " . $trimmed . "  # Not needed - Strada auto-flushes";
        }
    }

    # ---- $. (input line number) ----
    if (index($result, "$.") >= 0 && index($result, "#") < 0 && index($result, "__line_number") < 0) {
        my int $dot_pos = index($result, "$.");
        my int $dot_is_special = 0;
        while ($dot_pos >= 0 && $dot_is_special == 0) {
            my int $dot_ok = 1;
            # Check it's not $. followed by a word char (would be a variable like $something)
            if ($dot_pos + 2 < length($result)) {
                my int $dot_nch = char_at($result, $dot_pos + 2);
                if (($dot_nch >= 65 && $dot_nch <= 90) || ($dot_nch >= 97 && $dot_nch <= 122) || $dot_nch == 95 || ($dot_nch >= 48 && $dot_nch <= 57)) {
                    $dot_ok = 0;
                }
            }
            # Verify char before $ is not a word char or another $ (like $$.)
            if ($dot_pos > 0) {
                my int $dot_pch = char_at($result, $dot_pos - 1);
                if ($dot_pch == 36) { $dot_ok = 0; }
            }
            if ($dot_ok == 1) {
                $dot_is_special = 1;
            } else {
                $dot_pos = index($result, "$.", $dot_pos + 1);
            }
        }
        if ($dot_is_special == 1) {
            # Comment out lines using $. â€” Perl input line number not available in Strada
            $result = $indent . "# " . $trimmed . "  # $. (Perl input line number) not available in Strada";
        }
    }

    # ---- $^O (OS name) -> core::uname() ----
    if (index($result, "$^O") >= 0 && index($result, "#") < 0) {
        my int $os_pos = index($result, "$^O");
        while ($os_pos >= 0) {
            $result = substr($result, 0, $os_pos) . "core::uname()" . substr($result, $os_pos + 3, length($result) - $os_pos - 3);
            $os_pos = index($result, "$^O", $os_pos + 13);
        }
        # Evaluate core::uname() eq/ne comparisons: on Linux, core::uname() returns "linux"
        my array @os_eq_cap = capture($result, "core::uname\\(\\)\\s+eq\\s+['\"]([^'\"]*)['\"]");
        if (scalar(@os_eq_cap) > 1) {
            my str $os_cmp_val = $os_eq_cap[1];
            if ($os_cmp_val eq "linux") {
                $result = replace($result, "core::uname\\(\\)\\s+eq\\s+['\"][^'\"]*['\"]", "1");
            } else {
                $result = replace($result, "core::uname\\(\\)\\s+eq\\s+['\"][^'\"]*['\"]", "0");
            }
        }
        my array @os_ne_cap = capture($result, "core::uname\\(\\)\\s+ne\\s+['\"]([^'\"]*)['\"]");
        if (scalar(@os_ne_cap) > 1) {
            my str $os_ne_val = $os_ne_cap[1];
            if ($os_ne_val eq "linux") {
                $result = replace($result, "core::uname\\(\\)\\s+ne\\s+['\"][^'\"]*['\"]", "0");
            } else {
                $result = replace($result, "core::uname\\(\\)\\s+ne\\s+['\"][^'\"]*['\"]", "1");
            }
        }
        # Also handle reversed: 'MSWin32' eq core::uname()
        my array @os_req_cap = capture($result, "['\"]([^'\"]*)['\"]\\s+eq\\s+core::uname\\(\\)");
        if (scalar(@os_req_cap) > 1) {
            my str $os_req_val = $os_req_cap[1];
            if ($os_req_val eq "linux") {
                $result = replace($result, "['\"][^'\"]*['\"]\\s+eq\\s+core::uname\\(\\)", "1");
            } else {
                $result = replace($result, "['\"][^'\"]*['\"]\\s+eq\\s+core::uname\\(\\)", "0");
            }
        }
        my array @os_rne_cap = capture($result, "['\"]([^'\"]*)['\"]\\s+ne\\s+core::uname\\(\\)");
        if (scalar(@os_rne_cap) > 1) {
            my str $os_rne_val = $os_rne_cap[1];
            if ($os_rne_val eq "linux") {
                $result = replace($result, "['\"][^'\"]*['\"]\\s+ne\\s+core::uname\\(\\)", "0");
            } else {
                $result = replace($result, "['\"][^'\"]*['\"]\\s+ne\\s+core::uname\\(\\)", "1");
            }
        }
    }

    # ---- $^W (warnings flag) ----
    if (index($result, "$^W") >= 0 && index($result, "#") < 0) {
        $result = $indent . "# " . $trimmed . "  # $^W not needed in Strada";
    }

    # ---- $^E (extended OS error) -> 0 (use core::strerror for error strings) ----
    if (index($result, "$^E") >= 0 && index($result, "#") < 0) {
        my int $ext_pos = index($result, "$^E");
        while ($ext_pos >= 0) {
            $result = substr($result, 0, $ext_pos) . "0" . substr($result, $ext_pos + 3, length($result) - $ext_pos - 3);
            $ext_pos = index($result, "$^E", $ext_pos + 1);
        }
    }

    # ---- $] (Perl version number) ----
    my str $dol_bracket = "$" . "]";
    if (index($result, $dol_bracket) >= 0 && index($result, "#") < 0) {
        # Replace $] with 5.038 (modern Perl) so version checks use the modern branch
        my int $dv_pos = index($result, $dol_bracket);
        while ($dv_pos >= 0) {
            # Make sure it's not inside a string or part of array subscript
            my int $dv_ok = 1;
            if ($dv_pos > 0) {
                my int $dv_prev = char_at($result, $dv_pos - 1);
                # Skip if preceded by [ (array subscript like $arr[$])
                if ($dv_prev == 91) { $dv_ok = 0; }
            }
            if ($dv_ok == 1) {
                $result = substr($result, 0, $dv_pos) . "5.038" . substr($result, $dv_pos + 2, length($result) - $dv_pos - 2);
                $dv_pos = index($result, $dol_bracket, $dv_pos + 5);
            } else {
                $dv_pos = index($result, $dol_bracket, $dv_pos + 2);
            }
        }
    }

    # ---- ${^TAINT} -> 0 (Strada has no taint mode) ----
    my str $taint_var = "$" . "{^TAINT}";
    if (index($result, $taint_var) >= 0 && index($result, "#") < 0) {
        $result = replace_all($result, $taint_var, "0");
    }

    # ---- ${^WARNING_BITS} -> undef (no warning bits in Strada) ----
    my str $warn_bits = "$" . "{^WARNING_BITS}";
    if (index($result, $warn_bits) >= 0 && index($result, "#") < 0) {
        $result = replace_all($result, $warn_bits, "undef");
    }

    # ---- $^V -> "v5.38" (Perl version string) ----
    my str $caret_V = "$" . "^V";
    if (index($result, $caret_V) >= 0 && index($result, "#") < 0) {
        my int $cv_pos = index($result, $caret_V);
        while ($cv_pos >= 0) {
            $result = substr($result, 0, $cv_pos) . "\"v5.38\"" . substr($result, $cv_pos + 3, length($result) - $cv_pos - 3);
            $cv_pos = index($result, $caret_V, $cv_pos + 6);
        }
    }

    # ---- $^F -> 2 (max system file descriptor, standard default) ----
    my str $caret_F = "$" . "^F";
    if (index($result, $caret_F) >= 0 && index($result, "#") < 0) {
        my int $cf_pos = index($result, $caret_F);
        while ($cf_pos >= 0) {
            $result = substr($result, 0, $cf_pos) . "2" . substr($result, $cf_pos + 3, length($result) - $cf_pos - 3);
            $cf_pos = index($result, $caret_F, $cf_pos + 1);
        }
    }

    # ---- $^A -> "" (format accumulator, not applicable) ----
    my str $caret_A = "$" . "^A";
    if (index($result, $caret_A) >= 0 && index($result, "#") < 0 && !match($result, "\\$\\^A[A-Za-z]")) {
        my int $ca_pos = index($result, $caret_A);
        while ($ca_pos >= 0) {
            # Skip if followed by a letter (part of another variable)
            my int $ca_next = $ca_pos + 3;
            if ($ca_next < length($result) && match(substr($result, $ca_next, 1), "[A-Za-z_]")) {
                $ca_pos = index($result, $caret_A, $ca_pos + 3);
                next;
            }
            $result = substr($result, 0, $ca_pos) . "\"\"" . substr($result, $ca_pos + 3, length($result) - $ca_pos - 3);
            $ca_pos = index($result, $caret_A, $ca_pos + 2);
        }
    }

    # ---- $^L -> "\f" (form feed, format page separator) ----
    my str $caret_L = "$" . "^L";
    if (index($result, $caret_L) >= 0 && index($result, "#") < 0 && !match($result, "\\$\\^L[A-Za-z]")) {
        my int $cl_pos = index($result, $caret_L);
        while ($cl_pos >= 0) {
            my int $cl_next = $cl_pos + 3;
            if ($cl_next < length($result) && match(substr($result, $cl_next, 1), "[A-Za-z_]")) {
                $cl_pos = index($result, $caret_L, $cl_pos + 3);
                next;
            }
            $result = substr($result, 0, $cl_pos) . "\"\\f\"" . substr($result, $cl_pos + 3, length($result) - $cl_pos - 3);
            $cl_pos = index($result, $caret_L, $cl_pos + 4);
        }
    }

    # ---- $^O -> core::uname() or "linux" (operating system name) ----
    my str $caret_O = "$" . "^O";
    if (index($result, $caret_O) >= 0 && index($result, "#") < 0 && !match($result, "\\$\\^O[A-Za-z]")) {
        my int $co_pos = index($result, $caret_O);
        while ($co_pos >= 0) {
            my int $co_next = $co_pos + 3;
            if ($co_next < length($result) && match(substr($result, $co_next, 1), "[A-Za-z_]")) {
                $co_pos = index($result, $caret_O, $co_pos + 3);
                next;
            }
            $result = substr($result, 0, $co_pos) . "core::uname()" . substr($result, $co_pos + 3, length($result) - $co_pos - 3);
            $co_pos = index($result, $caret_O, $co_pos + 13);
        }
    }

    # ---- $^W -> 0 (warnings flag â€” not applicable in Strada) ----
    my str $caret_W = "$" . "^W";
    if (index($result, $caret_W) >= 0 && index($result, "#") < 0 && !match($result, "\\$\\^W[A-Za-z]")) {
        my int $cw_pos = index($result, $caret_W);
        while ($cw_pos >= 0) {
            my int $cw_next = $cw_pos + 3;
            if ($cw_next < length($result) && match(substr($result, $cw_next, 1), "[A-Za-z_]")) {
                $cw_pos = index($result, $caret_W, $cw_pos + 3);
                next;
            }
            $result = substr($result, 0, $cw_pos) . "0" . substr($result, $cw_pos + 3, length($result) - $cw_pos - 3);
            $cw_pos = index($result, $caret_W, $cw_pos + 1);
        }
    }

    # ---- $^T -> core::time() (program start time) ----
    my str $caret_T = "$" . "^T";
    if (index($result, $caret_T) >= 0 && index($result, "#") < 0 && !match($result, "\\$\\^T[A-Za-z]")) {
        my int $ct_pos = index($result, $caret_T);
        while ($ct_pos >= 0) {
            my int $ct_next = $ct_pos + 3;
            if ($ct_next < length($result) && match(substr($result, $ct_next, 1), "[A-Za-z_]")) {
                $ct_pos = index($result, $caret_T, $ct_pos + 3);
                next;
            }
            $result = substr($result, 0, $ct_pos) . "core::time()" . substr($result, $ct_pos + 3, length($result) - $ct_pos - 3);
            $ct_pos = index($result, $caret_T, $ct_pos + 12);
        }
        $result = $result . "  # was $" . "^T (program start time)";
    }

    # ---- $^X -> core::argv(0) (Perl executable path â†’ program path) ----
    my str $caret_X = "$" . "^X";
    if (index($result, $caret_X) >= 0 && index($result, "#") < 0 && !match($result, "\\$\\^X[A-Za-z]")) {
        my int $cx_pos = index($result, $caret_X);
        while ($cx_pos >= 0) {
            my int $cx_next = $cx_pos + 3;
            if ($cx_next < length($result) && match(substr($result, $cx_next, 1), "[A-Za-z_]")) {
                $cx_pos = index($result, $caret_X, $cx_pos + 3);
                next;
            }
            $result = substr($result, 0, $cx_pos) . "core::argv(0)" . substr($result, $cx_pos + 3, length($result) - $cx_pos - 3);
            $cx_pos = index($result, $caret_X, $cx_pos + 13);
        }
        $result = $result . "  # was $" . "^X (Perl executable path)";
    }

    # ---- $; -> comment (subscript separator â€” use nested hashes in Strada) ----
    my str $dol_semi = "$" . ";";
    if (index($result, $dol_semi) >= 0 && index($result, "#") < 0) {
        # Only match if $; is not inside a string or followed by more identifier chars
        # $; is rare â€” just add a comment if it appears
        my int $ds_pos = index($result, $dol_semi);
        my int $ds_ok = 1;
        if ($ds_pos + 2 < length($result)) {
            my int $ds_nch = char_at($result, $ds_pos + 2);
            # Skip if followed by a letter/digit/underscore (another variable like $;foo)
            if (($ds_nch >= 65 && $ds_nch <= 90) || ($ds_nch >= 97 && $ds_nch <= 122) || ($ds_nch >= 48 && $ds_nch <= 57) || $ds_nch == 95) { $ds_ok = 0; }
        }
        if ($ds_ok == 1) {
            $result = $result . "  # REVIEW: $" . "; (subscript separator) â€” use nested hashes in Strada";
        }
    }

    # ---- $+ (last successful match bracket) -> $1 ----
    my str $dol_plus = "$" . "+";
    if (index($result, $dol_plus) >= 0 && index($result, "#") < 0) {
        my int $dp_pos = index($result, $dol_plus);
        while ($dp_pos >= 0) {
            # Make sure it's not $+{name} (named captures hash) or $++ or += etc.
            my int $dp_ok = 1;
            if ($dp_pos + 2 < length($result)) {
                my int $dp_nch = char_at($result, $dp_pos + 2);
                # Skip if followed by { (named captures), + (increment), = (assign)
                if ($dp_nch == 123 || $dp_nch == 43 || $dp_nch == 61) { $dp_ok = 0; }
                # Skip if followed by letter/digit (another variable)
                if (($dp_nch >= 65 && $dp_nch <= 90) || ($dp_nch >= 97 && $dp_nch <= 122) || ($dp_nch >= 48 && $dp_nch <= 57) || $dp_nch == 95) { $dp_ok = 0; }
            }
            if ($dp_ok == 1) {
                $result = substr($result, 0, $dp_pos) . "$" . "1" . substr($result, $dp_pos + 2, length($result) - $dp_pos - 2);
                # $1 is the correct Strada equivalent of $+ (last successful match)
            }
            $dp_pos = index($result, $dol_plus, $dp_pos + 2);
        }
    }

    # ---- $> (effective UID) ----
    if (index($result, "$>") >= 0 && index($result, ">>") < 0) {
        # Make sure it's $> not $>> or => or ->
        my int $euid_pos = index($result, "$>");
        my int $euid_ok = 1;
        if ($euid_pos + 2 < length($result)) {
            my int $euid_nch = char_at($result, $euid_pos + 2);
            if ($euid_nch == 62) { $euid_ok = 0; }  # >>
        }
        if ($euid_pos > 0) {
            my int $euid_pch = char_at($result, $euid_pos - 1);
            if ($euid_pch == 45) { $euid_ok = 0; }  # -> (arrow)
            if ($euid_pch == 61) { $euid_ok = 0; }  # =>
        }
        if ($euid_ok == 1) {
            $result = substr($result, 0, $euid_pos) . "core::geteuid()" . substr($result, $euid_pos + 2, length($result) - $euid_pos - 2);
            if (index($result, "REVIEW") < 0) {
                $result = $result . "  # $> -> core::geteuid()";
            }
        }
    }

    # ---- $) (effective GID - space-separated list) ----
    my str $dol_rparen = "$" . ")";
    if (index($result, $dol_rparen) >= 0 && index($result, "#") < 0 && index($result, "core::getegid") < 0) {
        # Be careful: $) could appear in context like "$var)" or "func($x)"
        my int $gid_pos = index($result, $dol_rparen);
        my int $gid_ok = 0;
        # $) is only 2 chars: $ followed by )
        # Check that it's a standalone $) not $var)
        if ($gid_pos > 0) {
            my int $gid_pch = char_at($result, $gid_pos - 1);
            # If preceded by space, tab, comma, or double-quote, it's $)
            # Note: do NOT include 40 (open paren) - that matches sub ($) prototypes
            if ($gid_pch == 32 || $gid_pch == 9 || $gid_pch == 44 || $gid_pch == 34) {
                $gid_ok = 1;
            }
        }
        if ($gid_ok == 1) {
            $result = substr($result, 0, $gid_pos) . "core::getegid()" . substr($result, $gid_pos + 2, length($result) - $gid_pos - 2);
            if (index($result, "REVIEW") < 0) {
                $result = $result . "  # REVIEW: $) -> core::getegid() - Perl $) is space-separated GID list, Strada returns primary GID only";
            }
        }
    }

    # ---- $< (real UID) ----
    if (index($result, "$<") >= 0 && index($result, "<<") < 0 && index($result, "#") < 0 && index($result, "core::getuid") < 0) {
        my int $ruid_pos = index($result, "$<");
        my int $ruid_ok = 1;
        # Make sure it's not $<something> or => or ->
        if ($ruid_pos + 2 < length($result)) {
            my int $ruid_nch = char_at($result, $ruid_pos + 2);
            if ($ruid_nch == 60) { $ruid_ok = 0; }  # << (heredoc)
        }
        if ($ruid_pos > 0) {
            my int $ruid_pch = char_at($result, $ruid_pos - 1);
            if ($ruid_pch == 45) { $ruid_ok = 0; }  # -> (arrow)
            if ($ruid_pch == 61) { $ruid_ok = 0; }  # =>
        }
        # Check it's standalone $< not $<fh> (angle bracket read)
        if ($ruid_ok == 1 && $ruid_pos + 2 < length($result)) {
            my int $ruid_nch2 = char_at($result, $ruid_pos + 2);
            # If followed by a word character, it's <FILEHANDLE> pattern
            if ($ruid_nch2 >= 65 && $ruid_nch2 <= 90) { $ruid_ok = 0; }
            if ($ruid_nch2 >= 97 && $ruid_nch2 <= 122) { $ruid_ok = 0; }
        }
        if ($ruid_ok == 1) {
            $result = substr($result, 0, $ruid_pos) . "core::getuid()" . substr($result, $ruid_pos + 2, length($result) - $ruid_pos - 2);
        }
    }

    # ---- $( (real GID) ----
    my str $dol_lparen = chr(36) . "(";
    if (index($result, $dol_lparen) >= 0 && index($result, "#") < 0 && index($result, "core::getgid") < 0) {
        my int $rgid_pos = index($result, $dol_lparen);
        my int $rgid_ok = 0;
        # $( is standalone only when preceded by space, tab, comma, =, or at line start
        if ($rgid_pos == 0) { $rgid_ok = 1; }
        if ($rgid_pos > 0) {
            my int $rgid_pch = char_at($result, $rgid_pos - 1);
            if ($rgid_pch == 32 || $rgid_pch == 9 || $rgid_pch == 44 || $rgid_pch == 61) {
                $rgid_ok = 1;
            }
        }
        # Make sure it's not $(var) pattern - check if ) follows immediately or after space
        if ($rgid_ok == 1 && $rgid_pos + 2 < length($result)) {
            my int $rgid_nch = char_at($result, $rgid_pos + 2);
            # If followed by a word char, it's $(var) not the $( special var
            if ($rgid_nch >= 65 && $rgid_nch <= 90) { $rgid_ok = 0; }
            if ($rgid_nch >= 97 && $rgid_nch <= 122) { $rgid_ok = 0; }
            if ($rgid_nch == 95) { $rgid_ok = 0; }  # underscore
        }
        if ($rgid_ok == 1) {
            $result = substr($result, 0, $rgid_pos) . "core::getgid()" . substr($result, $rgid_pos + 2, length($result) - $rgid_pos - 2);
            if (index($result, "TODO") < 0) {
                $result = $result . "  # " . $dol_lparen . " -> core::getgid() - Perl " . $dol_lparen . " is space-separated GID list, Strada returns primary GID only";
            }
        }
    }

    # ---- $" (list separator) ----
    my str $dol_dq = chr(36) . chr(34);
    if (index($result, $dol_dq) >= 0 && index($result, "#") < 0) {
        my int $lsep_pos = index($result, $dol_dq);
        my int $lsep_ok = 0;
        # $" must be preceded by space/tab/= or at line start
        if ($lsep_pos == 0) { $lsep_ok = 1; }
        if ($lsep_pos > 0) {
            my int $lsep_pch = char_at($result, $lsep_pos - 1);
            if ($lsep_pch == 32 || $lsep_pch == 9 || $lsep_pch == 61) {
                $lsep_ok = 1;
            }
        }
        if ($lsep_ok == 1) {
            $result = $indent . "# " . $trimmed . "  # REVIEW: " . $dol_dq . " (list separator) - Strada uses join() to control array-to-string separator";
        }
    }

    # ---- xor operator ----
    # Strada does not have ^^ â€” convert to explicit logical XOR expression
    # xor is very low precedence â€” split on it and convert operands
    if (match($result, "\\bxor\\b") && !match($result, "#")) {
        my int $xor_pos = index($result, " xor ");
        if ($xor_pos >= 0) {
            my str $xor_before = substr($result, 0, $xor_pos);
            my str $xor_after = substr($result, $xor_pos + 5, length($result) - $xor_pos - 5);
            # Find the last = sign in xor_before to separate prefix from operand
            my int $xor_eq = -1;
            my int $xor_si = length($xor_before) - 1;
            while ($xor_si >= 0) {
                if (substr($xor_before, $xor_si, 1) eq "=" && ($xor_si == 0 || substr($xor_before, $xor_si - 1, 1) ne "!")) {
                    $xor_eq = $xor_si;
                    last;
                }
                $xor_si--;
            }
            if ($xor_eq >= 0) {
                my str $xor_prefix = substr($xor_before, 0, $xor_eq + 1);
                my str $xor_lhs = trim_str(substr($xor_before, $xor_eq + 1, length($xor_before) - $xor_eq - 1));
                my str $xor_rhs = trim_str($xor_after);
                # Remove trailing semicolon from rhs if present
                if (match($xor_rhs, ";\\s*$")) {
                    $xor_rhs = replace($xor_rhs, ";\\s*$", "");
                    $result = $xor_prefix . " (!" . $xor_lhs . " != !" . $xor_rhs . ");  # REVIEW: was xor â€” verify logical XOR conversion";
                } else {
                    $result = $xor_prefix . " (!" . $xor_lhs . " != !" . $xor_rhs . ")  # REVIEW: was xor â€” verify logical XOR conversion";
                }
            } else {
                # No assignment â€” entire expression is xor
                my str $xor_lhs = trim_str($xor_before);
                my str $xor_rhs = trim_str($xor_after);
                my str $xor_indent = get_indent($result);
                # Check if xor is inside a condition (if/while/unless/elsif/until)
                if (match($xor_lhs, "^(if|unless|while|elsif|until)\\s*\\(")) {
                    my array @xcond_cap = capture($xor_lhs, "^(if|unless|while|elsif|until)\\s*\\(");
                    if (scalar(@xcond_cap) > 1) {
                        my str $xor_kw = $xcond_cap[1];
                        # Strip keyword and opening paren from lhs
                        my str $xor_lhs_inner = replace($xor_lhs, "^(if|unless|while|elsif|until)\\s*\\(\\s*", "");
                        # Find closing ) in rhs that matches the condition paren
                        my int $xor_rp = -1;
                        my int $xor_rd = 0;
                        my int $xor_ri = 0;
                        while ($xor_ri < length($xor_rhs)) {
                            my int $xrc = char_at($xor_rhs, $xor_ri);
                            if ($xrc == 40) { $xor_rd++; }
                            elsif ($xrc == 41) {
                                if ($xor_rd > 0) { $xor_rd--; }
                                else { $xor_rp = $xor_ri; last; }
                            }
                            $xor_ri++;
                        }
                        if ($xor_rp >= 0) {
                            my str $xor_rhs_inner = trim_str(substr($xor_rhs, 0, $xor_rp));
                            my str $xor_rest = substr($xor_rhs, $xor_rp + 1, length($xor_rhs) - $xor_rp - 1);
                            $result = $xor_indent . $xor_kw . " (!" . $xor_lhs_inner . " != !" . $xor_rhs_inner . ")" . $xor_rest . "  # REVIEW: was xor â€” verify logical XOR conversion";
                        } else {
                            $result = $xor_indent . "(!" . $xor_lhs . " != !" . $xor_rhs . ")  # REVIEW: was xor â€” verify logical XOR conversion";
                        }
                    }
                }
                elsif (match($xor_rhs, ";\\s*$")) {
                    $xor_rhs = replace($xor_rhs, ";\\s*$", "");
                    $result = $xor_indent . "(!" . $xor_lhs . " != !" . $xor_rhs . ");  # REVIEW: was xor â€” verify logical XOR conversion";
                } else {
                    $result = $xor_indent . "(!" . $xor_lhs . " != !" . $xor_rhs . ")  # REVIEW: was xor â€” verify logical XOR conversion";
                }
            }
        } else {
            $result = $result . "  # REVIEW: xor operator â€” Strada has no logical XOR; rewrite as: (!a != !b)";
        }
    }

    # ---- Smartmatch ~~ operator ----
    if (index($result, "~~") >= 0 && !match($result, "#") && !match($result, "=~")) {
        # Check it's not inside a string: look for ~~ outside quotes
        my int $sm_pos = index($result, "~~");
        my int $sm_ok = 1;
        # Quick guard: make sure it's not ~~ inside a string literal
        if ($sm_pos > 0) {
            my str $sm_before = substr($result, 0, $sm_pos);
            # Count unescaped quotes - if odd, we're inside a string
            my int $sm_dq = 0;
            my int $sm_sq = 0;
            my int $smi = 0;
            while ($smi < length($sm_before)) {
                my str $smc = substr($sm_before, $smi, 1);
                if ($smc eq "\"" && ($smi == 0 || substr($sm_before, $smi - 1, 1) ne "\\")) { $sm_dq++; }
                if ($smc eq "'" && ($smi == 0 || substr($sm_before, $smi - 1, 1) ne "\\")) { $sm_sq++; }
                $smi++;
            }
            if ($sm_dq % 2 != 0 || $sm_sq % 2 != 0) { $sm_ok = 0; }
        }
        if ($sm_ok == 1) {
            $result = $result . "  # REVIEW: smartmatch ~~ has no Strada equivalent - use explicit comparisons";
        }
    }

    # ---- -p file test (named pipe) ----
    if (match($result, "-p\\s+\\$") && !match($result, "#") && !match($result, "core::")) {
        $result = $result . "  # REVIEW: -p (named pipe test) - use __C__ { S_ISFIFO(stat.st_mode) } in Strada";
    }

    # ---- defined &funcname (function existence check) ----
    if (match($result, "\\bdefined\\s+&") && !match($result, "#")) {
        # defined &{"expr"} â€” truly dynamic, needs REVIEW
        if (match($result, "defined\\s+&\\{")) {
            $result = $result . "  # REVIEW: dynamic function existence check â€” refactor to use can() or explicit flag";
        }
        # defined &func or defined &Module::func â†’ 1 (always defined in compiled Strada)
        elsif (match($result, "defined\\s+&[A-Za-z_]")) {
            # Replace defined &func with 1 â€” use replacement without "defined &" to avoid re-matching
            $result = replace($result, "defined\\s+&[A-Za-z_][A-Za-z0-9_:]*", "1 /* compiled_defined_check */");
        }
    }

    # ---- $! (errno string) ----
    if (index($result, "$!") >= 0 && index($result, "#") < 0 && index($result, "!=") < 0) {
        # $! gives errno string in string context, errno number in numeric context
        # Need to be careful not to match $! inside != or $!~ patterns
        my int $bang_pos = index($result, "$!");
        while ($bang_pos >= 0) {
            my int $bang_ok = 1;
            # Skip if next char is = or ~ (it's != or !~)
            if ($bang_pos + 2 < length($result)) {
                my int $bang_nch = char_at($result, $bang_pos + 2);
                if ($bang_nch == 61 || $bang_nch == 126) { $bang_ok = 0; }
                # Skip if followed by word char (some other variable)
                if (($bang_nch >= 65 && $bang_nch <= 90) || ($bang_nch >= 97 && $bang_nch <= 122) || $bang_nch == 95) { $bang_ok = 0; }
            }
            # Skip if preceded by another $ (like $$!)
            if ($bang_pos > 0) {
                my int $bang_pch = char_at($result, $bang_pos - 1);
                if ($bang_pch == 36) { $bang_ok = 0; }
            }
            if ($bang_ok == 1) {
                # Check if $! is inside a double-quoted string by counting unescaped quotes before it
                my int $bang_qi = 0;
                my int $bang_qcount = 0;
                while ($bang_qi < $bang_pos) {
                    if (substr($result, $bang_qi, 1) eq "\"" && ($bang_qi == 0 || substr($result, $bang_qi - 1, 1) ne "\\")) {
                        $bang_qcount++;
                    }
                    $bang_qi++;
                }
                if ($bang_qcount % 2 == 1) {
                    # Inside a string â€” break it: "prefix $! suffix" -> "prefix " . core::strerror(core::errno()) . " suffix"
                    my str $bang_repl = "\" . core::strerror(core::errno()) . \"";
                    $result = substr($result, 0, $bang_pos) . $bang_repl . substr($result, $bang_pos + 2, length($result) - $bang_pos - 2);
                    $bang_pos = index($result, "$!", $bang_pos + length($bang_repl));
                } else {
                    # Outside string â€” direct replacement
                    $result = substr($result, 0, $bang_pos) . "core::strerror(core::errno())" . substr($result, $bang_pos + 2, length($result) - $bang_pos - 2);
                    $bang_pos = index($result, "$!", $bang_pos + 26);
                }
            } else {
                $bang_pos = index($result, "$!", $bang_pos + 1);
            }
        }
    }

    # ---- $\ (output record separator) ----
    # Can't match $ followed by backslash easily, use index
    if (index($result, "$\\") >= 0 && index($result, "#") < 0) {
        my int $bsl_pos = index($result, "$\\");
        my int $bsl_ok = 1;
        # Make sure it's not inside a regex (preceded by = ~)
        if (match($result, "=~")) { $bsl_ok = 0; }
        if ($bsl_ok == 1) {
            $result = $indent . "# " . $trimmed . "  # $\\ (output record separator) not needed in Strada";
        }
    }

    # ---- $, (output field separator) ----
    if (index($result, "$,") >= 0 && index($result, "#") < 0) {
        my int $comma_pos = index($result, "$,");
        my int $comma_ok = 1;
        # Make sure it's standalone (not $,something)
        if ($comma_pos + 2 < length($result)) {
            my int $comma_nch = char_at($result, $comma_pos + 2);
            if (($comma_nch >= 65 && $comma_nch <= 90) || ($comma_nch >= 97 && $comma_nch <= 122) || $comma_nch == 95) {
                $comma_ok = 0;
            }
        }
        if ($comma_ok == 1) {
            $result = $indent . "# " . $trimmed . "  # $, (output field separator) not supported in Strada";
        }
    }

    # ---- $/ (input record separator) ----
    # Only match $/ when used as a variable (in assignment or after local/my)
    # NOT inside regex where $ is end-of-line anchor before / delimiter
    my str $dollar_slash = chr(36) . "/";
    if (index($result, $dollar_slash) >= 0 && index($result, "#") < 0) {
        my int $irs_pos = index($result, $dollar_slash);
        my int $irs_ok = 0;
        # Check if preceded by whitespace or = or at start of line (variable context)
        if ($irs_pos == 0) {
            $irs_ok = 1;
        }
        if ($irs_pos > 0) {
            my int $irs_pch = char_at($result, $irs_pos - 1);
            # preceded by space, tab, or = means it's a variable
            if ($irs_pch == 32 || $irs_pch == 9 || $irs_pch == 61) {
                $irs_ok = 1;
            }
        }
        # Also check if $/ is followed by = or ; (assignment context)
        if ($irs_pos + 2 < length($result)) {
            my int $irs_nch = char_at($result, $irs_pos + 2);
            if ($irs_nch == 61 || $irs_nch == 59) { $irs_ok = 1; }
        }
        # At end of line (standalone $/)
        if ($irs_pos + 2 >= length($result)) { $irs_ok = 1; }
        # Skip if preceded by $$ or inside regex
        if ($irs_pos > 0 && char_at($result, $irs_pos - 1) == 36) { $irs_ok = 0; }
        # Skip if line has regex operators
        if (match($result, "=~") || match($result, "!/")) { $irs_ok = 0; }
        if ($irs_ok == 1) {
            # Setting $/ = undef means slurp mode, $/ = "\n" is default
            if (match($result, "=\\s*undef")) {
                $result = $indent . "# " . $trimmed . "  # $/ = undef (slurp mode) â€” use core::slurp($file) instead of line-by-line reading";
            } elsif (match($result, "=\\s*\"\\\\n\"") || match($result, "=\\s*\"\\n\"")) {
                $result = $indent . "# " . $trimmed . "  # $/ = newline (default) â€” not needed, Strada reads lines by newline";
            } elsif (match($result, "=\\s*[\"']")) {
                $result = $indent . "# " . $trimmed . "  # $/ with custom delimiter â€” use split() with the delimiter after core::slurp()";
            } else {
                $result = $indent . "# " . $trimmed . "  # $/ (input record separator) â€” Strada reads lines with newline delimiter; use core::slurp() + split()";
            }
        }
    }

    # ---- $; (subscript separator for emulated multidimensional hashes) ----
    my str $dollar_semi = chr(36) . ";";
    if (index($result, $dollar_semi) >= 0 && index($result, "#") < 0) {
        my int $semi_pos = index($result, $dollar_semi);
        my int $semi_ok = 1;
        if ($semi_pos + 2 < length($result)) {
            my int $semi_nch = char_at($result, $semi_pos + 2);
            if (($semi_nch >= 65 && $semi_nch <= 90) || ($semi_nch >= 97 && $semi_nch <= 122) || $semi_nch == 95) {
                $semi_ok = 0;
            }
        }
        if ($semi_pos > 0) {
            my int $semi_pch = char_at($result, $semi_pos - 1);
            if ($semi_pch == 36) { $semi_ok = 0; }
        }
        if ($semi_ok == 1) {
            $result = $indent . "# " . $trimmed . "  # REVIEW: $; (multidimensional hash separator) - use nested hashes instead";
        }
    }

    # ---- Yada-yada operator (...) ----
    if (trim_str($result) eq "..." || trim_str($result) eq "...;") {
        $result = $indent . "die(\"Not implemented\");";
    }

    # ---- __SUB__ keyword ----
    if (match($result, "\\b__SUB__\\b") && !match($result, "#")) {
        $result = $result . "  # REVIEW: __SUB__ (current sub reference) - no Strada equivalent; refactor to named function";
    }

    # ---- defer block (Perl 5.36+) ----
    if (match($result, "\\bdefer\\s*\\{") && !match($result, "#")) {
        $result = $indent . "# " . $trimmed . "  # REVIEW: defer {} - no Strada equivalent; use END {} for file-scope cleanup or refactor to explicit cleanup";
    }

    # ---- /ee flag (double eval) ----
    if (match($result, "=~\\s*s/[^/]*/[^/]*/[a-z]*ee") && !match($result, "#.*REVIEW")) {
        # Convert s/pat/expr/ee to s/pat/expr/e with a REVIEW note
        # The first /e is handled normally (eval replacement); the second /e would re-eval the result
        $result = replace($result, "([a-z]*)ee", "$1e");
        $result = $result . "  # REVIEW: had /ee (double eval) â€” converted to single /e; apply second evaluation manually if needed";
    }

    # ---- (?{code}) and (??{code}) in regex ----
    if (match($result, "\\(\\?\\??\\{") && !match($result, "#.*TODO")) {
        $result = $result . "  # REVIEW: (?{code}) embedded code in regex - not supported in Strada; refactor to match + process loop";
    }

    # ---- push/unshift @INC -> use lib ----
    if (index($result, "@INC") >= 0 && (match($result, "\\bpush") || match($result, "\\bunshift")) && !match($result, "^\\s*#")) {
        # Try all push @INC forms: push(@INC, "path"), push @INC, "path"
        my int $inc_done = 0;
        my array @inc_cap = capture($result, "push\\s*\\(?\\s*@INC\\s*,\\s*[\"']([^\"']+)[\"']");
        if (scalar(@inc_cap) > 1) {
            $result = $indent . "use lib \"" . $inc_cap[1] . "\";  # was: push @INC";
            $inc_done = 1;
        }
        if ($inc_done == 0) {
            my array @usi_cap = capture($result, "unshift\\s*\\(?\\s*@INC\\s*,\\s*[\"']([^\"']+)[\"']");
            if (scalar(@usi_cap) > 1) {
                $result = $indent . "use lib \"" . $usi_cap[1] . "\";  # was: unshift @INC";
                $inc_done = 1;
            }
        }
        if ($inc_done == 0 && !match($result, "#.*TODO") && !match($result, "#.*REVIEW")) {
            # Dynamic @INC: push @INC, sub { ... } or push @INC, $dir
            if (match($result, "sub\\s*\\{") || match($result, "func\\s*\\(")) {
                $result = $indent . "# " . $trimmed . "  # REVIEW: @INC hook (custom module loader) - not applicable in Strada; use import_lib() for dynamic loading";
            } else {
                $result = $result . "  # REVIEW: dynamic @INC modification - use 'use lib' with literal path instead";
            }
        }
    }
    # %INC manipulation: delete $INC{...}, exists $INC{...}, $INC{...}
    if ((index($result, "%INC") >= 0 || index($result, "$INC{") >= 0) && !match($result, "^\\s*#")) {
        if (match($result, "delete\\s+\\$INC\\{")) {
            $result = $indent . "# " . $trimmed . "  # REVIEW: delete from INC (force module reload) - not applicable in Strada";
        } elsif (match($result, "\\$INC\\{") && !match($result, "#.*REVIEW")) {
            $result = $result . "  # REVIEW: INC (loaded module tracking) - not applicable in Strada";
        }
    }

    # ---- for my ($k, $v) (pairs @list) - Perl 5.36+ ----
    if (match($result, "\\bfor\\s+my\\s*\\(\\$[A-Za-z_]+,\\s*\\$[A-Za-z_]+\\)\\s*\\(pairs\\b")) {
        $result = $result . "  # REVIEW: for/pairs destructuring loop - rewrite as: my int $i = 0; while ($i < scalar(@list)) { my $k = @list[$i]; my $v = @list[$i+1]; $i += 2; }";
    }

    # ---- Unsupported features - add TODO notes ----
    # wantarray -> core::wantarray() (but NOT $wantarray which is a variable name)
    if (match($result, "\\bwantarray\\b") && !match($result, "core::wantarray")) {
        # Protect $wantarray variable references from conversion
        $result = replace_all($result, "$wantarray", "STRADA_WANTARRAY_VAR");
        # Replace wantarray() with parens first, then bare wantarray
        if (match($result, "\\bwantarray\\(")) {
            $result = replace($result, "\\bwantarray\\(\\)", "core::wantarray()");
        }
        if (match($result, "\\bwantarray\\b") && !match($result, "core::wantarray")) {
            $result = replace($result, "\\bwantarray\\b", "core::wantarray()");
        }
        # Restore $wantarray variable references
        $result = replace_all($result, "STRADA_WANTARRAY_VAR", "$wantarray");
    }
    if (match($result, "\\bcaller\\b") && !match($result, "#") && !match($result, "core::") && !match($result, "caller_pkg")) {
        # (caller)[0] or (caller())[0] â€” get calling package name â†’ __PACKAGE__
        if (match($result, "\\(caller\\)\\[0\\]") || match($result, "\\(caller\\(\\)\\)\\[0\\]") || match($result, "\\(caller\\(0\\)\\)\\[0\\]")) {
            $result = replace($result, "\\(caller\\(0\\)\\)\\[0\\]", "__PACKAGE__");
            $result = replace($result, "\\(caller\\(\\)\\)\\[0\\]", "__PACKAGE__");
            $result = replace($result, "\\(caller\\)\\[0\\]", "__PACKAGE__");
        }
        # (caller(N))[1] â€” get file name at depth N
        elsif (match($result, "\\(caller\\([0-9]*\\)\\)\\[1\\]") || match($result, "\\(caller\\)\\[1\\]")) {
            $result = replace($result, "\\(caller\\([0-9]*\\)\\)\\[1\\]", "__FILE__");
            $result = replace($result, "\\(caller\\)\\[1\\]", "__FILE__");
        }
        # (caller(N))[2] â€” get line number at depth N
        elsif (match($result, "\\(caller\\([0-9]*\\)\\)\\[2\\]") || match($result, "\\(caller\\)\\[2\\]")) {
            $result = replace($result, "\\(caller\\([0-9]*\\)\\)\\[2\\]", "__LINE__");
            $result = replace($result, "\\(caller\\)\\[2\\]", "__LINE__");
        }
        # (caller(N))[3] â€” get function name at depth N
        elsif (match($result, "\\(caller\\([0-9]*\\)\\)\\[3\\]") || match($result, "\\(caller\\)\\[3\\]")) {
            # (caller(0))[3] or (caller)[3] â†’ __FUNCTION__ (current function name)
            if (match($result, "\\(caller\\(0\\)\\)\\[3\\]") || match($result, "\\(caller\\)\\[3\\]")) {
                $result = replace($result, "\\(caller\\(0\\)\\)\\[3\\]", "__FUNCTION__");
                $result = replace($result, "\\(caller\\)\\[3\\]", "__FUNCTION__");
            }
            # (caller(1))[3] or higher â†’ needs stack trace
            elsif (match($result, "\\(caller\\([1-9][0-9]*\\)\\)\\[3\\]")) {
                $result = replace($result, "\\(caller\\([1-9][0-9]*\\)\\)\\[3\\]", "\"unknown\"");
                $result = $result . "  # REVIEW: caller(N)[3] for N>0 â€” use core::stack_trace() and parse";
            }
        }
        # caller($level) or caller(N) or caller(EXPR) â€” depth stack walk
        elsif (match($result, "\\bcaller\\s*\\([^)]+\\)")) {
            # In list context (my @info = caller($n)), Perl returns 11 fields
            # Strada's caller() only returns the package name, not a full frame
            if (match($result, "@[A-Za-z_].*=.*\\bcaller") || match($result, "my\\s*\\(.*\\)\\s*=\\s*caller")) {
                $result = $result . "  # REVIEW: caller() in list context returns 11 fields in Perl; Strada only returns package name â€” use core::stack_trace() and parse";
            } else {
                $result = $result . "  # REVIEW: caller(N) â€” Strada has core::stack_trace(); caller() returns differ from Perl";
            }
        }
        # Simple caller() â€” just get package name (most common)
        elsif (match($result, "\\bcaller\\s*\\(\\s*\\)")) {
            $result = replace($result, "\\bcaller\\s*\\(\\s*\\)", "__PACKAGE__");
        }
        # Bare caller without parens â€” just get package name
        elsif (match($result, "\\bcaller\\b") && !match($result, "\\bcaller\\s*\\(")) {
            $result = replace($result, "\\bcaller\\b", "__PACKAGE__");
        }
    }
    # eval STRING -> Strada::JIT::eval(STRING) or comment for conditional imports
    # Handles: eval "code", eval $var, eval($expr), eval qq{...}
    # Note: eval { } blocks are converted to try/catch in pass2b
    if (match($result, "\\beval\\s+[\"'\\$q]") || match($result, "\\beval\\s*\\(")) {
        # Don't touch eval { } (already handled by pass2b)
        if (!match($result, "\\beval\\s*\\{")) {
            # Check if eval string contains "use Module" (conditional import pattern)
            # e.g. BEGIN { eval q{ use Time::HiRes qw(stat utime) } };
            if (match($result, "eval\\s+[q'\"].*\\buse\\s+[A-Z]")) {
                # Extract module name from eval q{ use Module ... }
                my array @evu_cap = capture($trimmed, "eval\\s+[q'\"][^A-Za-z]*use\\s+([A-Za-z_][A-Za-z0-9_:]*)");
                if (scalar(@evu_cap) > 1) {
                    my str $evu_mod = $evu_cap[1];
                    my str $evu_flag = replace_all($evu_mod, "::", "_");
                    $evu_flag = "$" . "__has_" . $evu_flag;
                    $result = $indent . "# " . $trimmed . "\n" . $indent . "my int " . $evu_flag . " = 0;\n" . $indent . "try {\n" . $indent . "    use " . $evu_mod . ";\n" . $indent . "    " . $evu_flag . " = 1;\n" . $indent . "} catch ($__e) {\n" . $indent . "    # " . $evu_mod . " not available\n" . $indent . "}";
                } else {
                    $result = $indent . "# " . $trimmed . "  # REVIEW: conditional module import â€” not available in Strada";
                }
            }
            # eval "require Module" / eval { require Module } â€” conditional require
            elsif (match($result, "eval\\s+[\"']require\\s") || match($result, "eval\\s+qq[{(]require\\s")) {
                # Check if it's a dynamic variable require: eval "require $class"
                if (match($trimmed, "require\\s+\\$")) {
                    $result = $indent . "# " . $trimmed . "  # REVIEW: dynamic require with variable â€” module name not known at conversion time; use 'use' at compile time";
                } else {
                    # Static module name: eval "require Some::Module"
                    my array @evr_cap = capture($trimmed, "require\\s+([A-Za-z_][A-Za-z0-9_:]*)");
                    if (scalar(@evr_cap) > 1) {
                        my str $evr_mod = $evr_cap[1];
                        my str $evr_flag = replace_all($evr_mod, "::", "_");
                        $evr_flag = "$" . "__has_" . $evr_flag;
                        # Check for assignment form: my $ok = eval "require Module"
                        if (match($trimmed, "my\\s+\\$[A-Za-z_]") || match($trimmed, "\\$[A-Za-z_][A-Za-z0-9_]*\\s*=\\s*eval")) {
                            my array @evra_cap = capture($trimmed, "\\$([A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*eval");
                            my str $evr_assign = "";
                            if (scalar(@evra_cap) > 1) {
                                $evr_assign = $evra_cap[1];
                            }
                            $result = $indent . "# " . $trimmed . "\n" . $indent . "my int " . $evr_flag . " = 0;\n" . $indent . "try {\n" . $indent . "    use " . $evr_mod . ";\n" . $indent . "    " . $evr_flag . " = 1;\n" . $indent . "} catch ($__e) {\n" . $indent . "    # " . $evr_mod . " not available\n" . $indent . "}";
                            if (length($evr_assign) > 0) {
                                $result = $result . "\n" . $indent . "my int $" . $evr_assign . " = " . $evr_flag . ";";
                            }
                        } else {
                            $result = $indent . "# " . $trimmed . "\n" . $indent . "my int " . $evr_flag . " = 0;\n" . $indent . "try {\n" . $indent . "    use " . $evr_mod . ";\n" . $indent . "    " . $evr_flag . " = 1;\n" . $indent . "} catch ($__e) {\n" . $indent . "    # " . $evr_mod . " not available\n" . $indent . "}";
                        }
                    } else {
                        $result = $indent . "# " . $trimmed . "  # REVIEW: dynamic require â€” load module at compile time with 'use' instead";
                    }
                }
            }
            # eval $variable â€” can't know contents at conversion time
            elsif (match($result, "\\beval\\s+\\$[A-Za-z_]") || match($result, "\\beval\\s*\\(\\s*\\$[A-Za-z_]")) {
                $result = $indent . "# " . $trimmed . "  # REVIEW: string eval of variable â€” manual conversion needed";
            }
            # eval with Perl-specific keywords â†’ comment out (code generation pattern)
            elsif (match($result, "eval.*\\bsub\\s") || match($result, "eval.*\\bmy\\s") || match($result, "eval.*\\bour\\s") || match($result, "eval.*\\bpackage\\s") || match($result, "eval.*\\bbless\\b") || match($result, "eval.*->")) {
                # Provide specific guidance based on what the eval is creating
                if (match($result, "eval.*\\bsub\\s") && match($result, "eval.*\\bpackage\\s")) {
                    $result = $indent . "# " . $trimmed . "\n" . $indent . "# REVIEW: eval creates sub in package â€” define func in the target package directly";
                } elsif (match($result, "eval.*\\bsub\\s")) {
                    $result = $indent . "# " . $trimmed . "\n" . $indent . "# REVIEW: eval creates sub â€” define func statically, or use closure: my scalar $fn = func(...) { ... };";
                } elsif (match($result, "eval.*\\bpackage\\s")) {
                    $result = $indent . "# " . $trimmed . "\n" . $indent . "# REVIEW: eval creates package â€” define package statically in a separate file";
                } elsif (match($result, "eval.*\\bbless\\b")) {
                    $result = $indent . "# " . $trimmed . "\n" . $indent . "# REVIEW: eval creates object â€” use Strada OOP: package + has + new()";
                } else {
                    $result = $indent . "# " . $trimmed . "  # REVIEW: string eval contains Perl code â€” manual conversion needed";
                }
            } else {
                # Simple expressions â€” convert to eval() via chosen backend
                my str $eval_fn = "Strada::Interpreter::eval_string";
                if ($g_eval_backend eq "jit") {
                    $eval_fn = "Strada::JIT::eval";
                }
                $result = replace($result, "\\beval\\s*\\(", $eval_fn . "(");
                $result = replace($result, "\\beval\\s+", $eval_fn . "(");
                # If we added eval( without closing paren, we need to add )
                # before the trailing semicolon.
                my str $eval_fn_esc = replace_all($eval_fn, "::", "::");
                if (match($result, $eval_fn_esc . "\\(") && !match($result, $eval_fn_esc . "\\([^;]*\\)")) {
                    # Find last semicolon and insert ) before it
                    my int $last_semi = -1;
                    my int $si = 0;
                    while ($si < length($result)) {
                        if (substr($result, $si, 1) eq ";") {
                            $last_semi = $si;
                        }
                        $si = $si + 1;
                    }
                    if ($last_semi >= 0) {
                        $result = substr($result, 0, $last_semi) . ")" . substr($result, $last_semi, length($result) - $last_semi);
                    }
                }
                # init() is auto-injected in post-processing when eval is detected
            }
        }
    }
    # eval("$Module::VERSION") used for version checks -> core::global_get()
    if ((match($result, "Strada::JIT::eval\\(") || match($result, "Strada::Interpreter::eval_string\\(")) && match($result, "VERSION")) {
        my array @rev_cap = capture($result, "(?:Strada::JIT::eval|Strada::Interpreter::eval_string)\\([\"']\\$([A-Za-z_][A-Za-z0-9_:]*::VERSION)[\"']\\)");
        if (scalar(@rev_cap) > 1) {
            my str $rev_pkg = $rev_cap[1];
            $result = replace($result, "(?:Strada::JIT::eval|Strada::Interpreter::eval_string)\\([\"']\\$" . replace_all($rev_pkg, "::", "::") . "[\"']\\)", "core::global_get(\"" . $rev_pkg . "\")");
        }
    }
    # BEGIN/END blocks are natively supported in Strada - no conversion needed
    # INIT/CHECK/UNITCHECK blocks -> convert to BEGIN (closest equivalent)
    if (match($result, "^\\s*INIT\\s*\\{") && !match($result, "#")) {
        $result = replace($result, "\\bINIT\\s*\\{", "BEGIN {");
        $result = $result . "  # was INIT (runs after compilation, before main)";
    }
    if (match($result, "^\\s*CHECK\\s*\\{") && !match($result, "#")) {
        $result = replace($result, "\\bCHECK\\s*\\{", "BEGIN {");
        $result = $result . "  # was CHECK (runs after compilation)";
    }
    if (match($result, "^\\s*UNITCHECK\\s*\\{") && !match($result, "#")) {
        $result = replace($result, "\\bUNITCHECK\\s*\\{", "BEGIN {");
        $result = $result . "  # was UNITCHECK (runs after unit compilation)";
    }
    # warnings->unimport(...) inside BEGIN blocks - not needed in Strada
    if (match($result, "warnings->unimport")) {
        $result = $indent . "# " . $trimmed . "  # Not needed in Strada";
    }
    if (match($result, "\\bno\\s+strict") && !match($result, "^\\s*#")) {
        if (match($result, "no\\s+strict\\s+['\"]refs['\"]")) {
            $result = $indent . "# " . $trimmed . "\n" . $indent . "# REVIEW: symbolic refs below â€” Strada alternatives:\n" . $indent . "#   Method dispatch: my scalar $__fn = $obj->can($name); $__fn->($obj, args);\n" . $indent . "#   Func dispatch: my hash %dispatch = (\"name\" => \\&func, ...); $dispatch{$key}->(args);\n" . $indent . "#   Pkg vars: core::global_get(\"Pkg::var\"), core::global_set(\"Pkg::var\", val);";
        } else {
            $result = $indent . "# " . $trimmed . "  # Not needed in Strada";
        }
    }
    if (match($result, "\\bTie::")) {
        $result = $result . "  # REVIEW: Strada has native tie() but Perl Tie:: modules need manual conversion";
    }
    # $obj->$method() and $obj->$method â€” native Strada dynamic dispatch, pass through as-is
    # Strada supports $obj->$method(), $obj->$method($args), and $obj->$method natively
    # $_[0] -> $self, $_[1] -> $__arg1, etc. (OOP method args)
    # fix_arg_signatures() auto-patches func signatures to include $__argN params
    my str $dol_us_bracket = "$" . "_[";
    if (index($result, $dol_us_bracket) >= 0 && index($result, "#") < 0) {
        # $_[-1] -> last argument (special case)
        my str $dol_us_neg1 = "$" . "_[-1]";
        if (index($result, $dol_us_neg1) >= 0) {
            $result = replace_all($result, $dol_us_neg1, "$" . "__last_arg");
            $result = $result . "  # REVIEW: " . chr(36) . "_[-1] is last argument â€” pass explicitly or use variadic";
        }
        # $_[0] -> $self
        my str $dol_us_0 = "$" . "_[0]";
        if (index($result, $dol_us_0) >= 0) {
            $result = replace_all($result, $dol_us_0, "$" . "self");
        }
        # $_[1] through $_[9] -> $__arg1 through $__arg9 (no REVIEW â€” fix_arg_signatures handles it)
        my int $arg_idx = 1;
        while ($arg_idx <= 9) {
            my str $dol_us_n = "$" . "_[" . $arg_idx . "]";
            if (index($result, $dol_us_n) >= 0) {
                $result = replace_all($result, $dol_us_n, "$" . "__arg" . $arg_idx);
            }
            $arg_idx++;
        }
    }
    # scalar(@_) -> argument count hint
    my str $scalar_at_us = "scalar(@" . "_)";
    if (index($result, $scalar_at_us) >= 0 && index($result, "#") < 0) {
        $result = $result . "  # REVIEW: scalar(@_) counts arguments â€” use named params instead";
    }
    # $#_ -> scalar(@_) - 1  (last index of arguments)
    my str $hash_us = "$" . "#_";
    if (index($result, $hash_us) >= 0 && index($result, "#") < 0) {
        $result = replace_all($result, $hash_us, "(scalar(@_) - 1)");
        $result = $result . "  # was " . chr(36) . "#_ (last arg index) â€” use variadic params instead";
    }
    if (match($result, "\\bDumper\\s*\\(") && !match($result, "#")) {
        # Data::Dumper::Dumper(...) -> dumper(...)
        if (match($result, "Data::Dumper::Dumper\\s*\\(")) {
            $result = replace($result, "Data::Dumper::Dumper\\s*\\(", "dumper(");
        } else {
            $result = replace($result, "\\bDumper\\s*\\(", "dumper(");
        }
    }
    # substr() as lvalue: substr($var, pos, len) = val -> $var = substr($var, 0, pos) . val . substr($var, pos + len)
    if (match($result, "\\bsubstr\\s*\\(.*\\)\\s*=\\s*") && !match($result, "#.*TODO")) {
        # 3-arg form: substr($var, $pos, $len) = $val;
        my array @slv3_cap = capture($result, "^(\\s*)substr\\s*\\(\\s*(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*,\\s*([^,]+)\\s*,\\s*([^)]+)\\)\\s*=\\s*(.+);");
        if (scalar(@slv3_cap) > 5) {
            my str $slv_ind = $slv3_cap[1];
            my str $slv_var = $slv3_cap[2];
            my str $slv_pos = trim_str($slv3_cap[3]);
            my str $slv_len = trim_str($slv3_cap[4]);
            my str $slv_val = trim_str($slv3_cap[5]);
            # Remove trailing semicolon from val if present
            if (ends_with($slv_val, ";")) {
                $slv_val = substr($slv_val, 0, length($slv_val) - 1);
            }
            $slv_val = trim_str($slv_val);
            if ($slv_val eq "\"\"" || $slv_val eq "''") {
                # Deletion: substr($var, $pos, $len) = "" -> $var = substr($var, 0, $pos) . substr($var, $pos + $len)
                $result = $slv_ind . $slv_var . " = substr(" . $slv_var . ", 0, " . $slv_pos . ") . substr(" . $slv_var . ", " . $slv_pos . " + " . $slv_len . ");";
            } else {
                $result = $slv_ind . $slv_var . " = substr(" . $slv_var . ", 0, " . $slv_pos . ") . " . $slv_val . " . substr(" . $slv_var . ", " . $slv_pos . " + " . $slv_len . ");";
            }
        } else {
            # 2-arg form with paren-counting: substr($var, COMPLEX_POS) = $val;
            # Use paren counting to handle nested expressions like length($name) == 2 ? -1 : -2
            my int $slvp_start = index($result, "substr");
            my int $slvp_ok = 0;
            if ($slvp_start >= 0) {
                my int $slvp_open = index($result, "(", $slvp_start);
                if ($slvp_open >= 0) {
                    # Find matching close paren using depth counting
                    my int $slvp_ci = $slvp_open + 1;
                    my int $slvp_depth = 1;
                    while ($slvp_ci < length($result) && $slvp_depth > 0) {
                        my int $slvp_ch = char_at($result, $slvp_ci);
                        if ($slvp_ch == 40) { $slvp_depth = $slvp_depth + 1; }
                        if ($slvp_ch == 41) { $slvp_depth = $slvp_depth - 1; }
                        $slvp_ci = $slvp_ci + 1;
                    }
                    if ($slvp_depth == 0) {
                        # $slvp_ci is one past the matching )
                        my str $slvp_inner = substr($result, $slvp_open + 1, $slvp_ci - $slvp_open - 2);
                        # Find first comma at depth 0 to split var from pos
                        my int $slvp_comma1 = -1;
                        my int $slvp_comma2 = -1;
                        my int $slvp_si = 0;
                        my int $slvp_sd = 0;
                        while ($slvp_si < length($slvp_inner)) {
                            my int $slvp_sch = char_at($slvp_inner, $slvp_si);
                            if ($slvp_sch == 40) { $slvp_sd = $slvp_sd + 1; }
                            if ($slvp_sch == 41) { $slvp_sd = $slvp_sd - 1; }
                            if ($slvp_sch == 44 && $slvp_sd == 0) {
                                if ($slvp_comma1 < 0) {
                                    $slvp_comma1 = $slvp_si;
                                } else {
                                    $slvp_comma2 = $slvp_si;
                                }
                            }
                            $slvp_si = $slvp_si + 1;
                        }
                        if ($slvp_comma1 >= 0) {
                            my str $slvp_var = trim_str(substr($slvp_inner, 0, $slvp_comma1));
                            # Check for = val after the closing paren
                            my str $slvp_after = substr($result, $slvp_ci, length($result) - $slvp_ci);
                            my array @slvp_eq = capture($slvp_after, "^\\s*=\\s*(.+)");
                            if (scalar(@slvp_eq) > 1) {
                                my str $slvp_val = trim_str($slvp_eq[1]);
                                if (ends_with($slvp_val, ";")) {
                                    $slvp_val = substr($slvp_val, 0, length($slvp_val) - 1);
                                }
                                $slvp_val = trim_str($slvp_val);
                                if ($slvp_comma2 >= 0) {
                                    # 3-arg: substr($var, $pos, $len) = val
                                    my str $slvp_pos = trim_str(substr($slvp_inner, $slvp_comma1 + 1, $slvp_comma2 - $slvp_comma1 - 1));
                                    my str $slvp_len = trim_str(substr($slvp_inner, $slvp_comma2 + 1, length($slvp_inner) - $slvp_comma2 - 1));
                                    if ($slvp_val eq "\"\"" || $slvp_val eq "''") {
                                        $result = $indent . $slvp_var . " = substr(" . $slvp_var . ", 0, " . $slvp_pos . ") . substr(" . $slvp_var . ", " . $slvp_pos . " + " . $slvp_len . ");";
                                    } else {
                                        $result = $indent . $slvp_var . " = substr(" . $slvp_var . ", 0, " . $slvp_pos . ") . " . $slvp_val . " . substr(" . $slvp_var . ", " . $slvp_pos . " + " . $slvp_len . ");";
                                    }
                                    $slvp_ok = 1;
                                } else {
                                    # 2-arg: substr($var, $pos) = val
                                    my str $slvp_pos = trim_str(substr($slvp_inner, $slvp_comma1 + 1, length($slvp_inner) - $slvp_comma1 - 1));
                                    if ($slvp_val eq "\"\"" || $slvp_val eq "''") {
                                        $result = $indent . $slvp_var . " = substr(" . $slvp_var . ", 0, " . $slvp_pos . ");";
                                    } else {
                                        $result = $indent . $slvp_var . " = substr(" . $slvp_var . ", 0, " . $slvp_pos . ") . " . $slvp_val . ";";
                                    }
                                    $slvp_ok = 1;
                                }
                            }
                        }
                    }
                }
            }
            if ($slvp_ok == 0) {
                # Fallback for truly unparseable forms
                $result = $result . "  # REVIEW: substr() as lvalue â€” rewrite as: $var = substr($var, 0, $pos) . $val . substr($var, $pos + $len)";
            }
        }
    }
    # caller() with levels -> already handled above (near wantarray section)
    # select(FH) for autoflush -> comment out (Strada auto-flushes)
    if (match($result, "\\bselect\\s*\\(\\s*[A-Z]") && !match($result, "#") && !match($result, "IO::Select") && !match($result, "core::select")) {
        $result = $indent . "# " . $trimmed . "  # Not needed in Strada (auto-flush is default)";
    }
    # $| = 1 (autoflush) -> REVIEW (not needed in Strada)
    if (index($result, "$|") >= 0 && match($result, "\\$\\|\\s*=") && !match($result, "#")) {
        $result = $indent . "# " . $trimmed . "  # Not needed in Strada (auto-flush is default)";
    }
    # goto &func (tail call) -> return func(@_)  (but not for Carp:: which is handled below)
    if (match($result, "\\bgoto\\s+&") && !match($result, "#") && !match($result, "goto\\s+&Carp::")) {
        # goto &{expr} -> return expr->(@_)
        if (match($result, "goto\\s+&\\{")) {
            my array @goto_expr_cap = capture($result, "goto\\s+&\\{([^}]+)\\}\\s*;?");
            if (scalar(@goto_expr_cap) > 1) {
                my str $goto_expr = trim_str($goto_expr_cap[1]);
                $result = replace($result, "goto\\s+&\\{[^}]+\\}\\s*;?", "return " . $goto_expr . "->(@_);");
            }
        } elsif (match($result, "goto\\s+&\\$")) {
            # goto &$ref -> return $ref->(@_)
            my array @goto_ref_cap = capture($result, "goto\\s+&(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*;?");
            if (scalar(@goto_ref_cap) > 1) {
                my str $goto_ref = $goto_ref_cap[1];
                $result = replace($result, "goto\\s+&\\$[A-Za-z_][A-Za-z0-9_]*\\s*;?", "return " . $goto_ref . "->(@_);");
            }
        } else {
            # goto &named_func -> return named_func(@_)
            my array @goto_cap = capture($result, "\\bgoto\\s+&([A-Za-z_][A-Za-z0-9_:]*)\\s*;?");
            if (scalar(@goto_cap) > 1) {
                my str $goto_func = $goto_cap[1];
                $result = replace($result, "\\bgoto\\s+&[A-Za-z_][A-Za-z0-9_:]*\\s*;?", "return " . $goto_func . "(@_);");
            }
        }
    }
    # pos() -> convert to tracking variable pattern
    if (match($result, "\\bpos\\s*\\(") && !match($result, "#") && !match($result, "\\$pos\\b") && !match($result, "core::")) {
        # pos($$ref) -> $__pos_ref  (deref'd ref â€” extract the ref name)
        my array @pos_dcap = capture($result, "\\bpos\\s*\\(\\s*\\$\\$(\\$?[A-Za-z_][A-Za-z0-9_]*)\\s*\\)");
        if (scalar(@pos_dcap) > 1) {
            my str $pos_dvar = $pos_dcap[1];
            # Strip leading $ if present (from $$varname)
            if (starts_with($pos_dvar, "$")) {
                $pos_dvar = substr($pos_dvar, 1, length($pos_dvar) - 1);
            }
            my str $pos_dtrack = "$__pos" . $pos_dvar;
            $result = replace($result, "\\bpos\\s*\\(\\s*\\$\\$[A-Za-z_][A-Za-z0-9_]*\\s*\\)", $pos_dtrack);
            $result = $result . "  # declare: my int " . $pos_dtrack . " = 0; â€” update after each /g match";
        } else {
            # pos($str) -> $__posstr  (track position manually)
            my array @pos_cap = capture($result, "\\bpos\\s*\\(\\s*(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*\\)");
            if (scalar(@pos_cap) > 1) {
                my str $pos_var = $pos_cap[1];
                my str $pos_track = "$__pos" . substr($pos_var, 1, length($pos_var) - 1);
                $result = replace($result, "\\bpos\\s*\\(\\s*\\$[A-Za-z_][A-Za-z0-9_]*\\s*\\)", $pos_track);
                $result = $result . "  # declare: my int " . $pos_track . " = 0; â€” update after each /g match";
            } else {
                # pos() with no arg (operates on $_)
                $result = replace($result, "\\bpos\\s*\\(\\s*\\)", "$__pos");
                $result = $result . "  # declare: my int $__pos = 0; â€” update after each /g match";
            }
        }
    }
    # Path::Tiny method chaining: path(...)->slurp/spew/etc.
    if (match($result, "\\bpath\\s*\\(") && !match($result, "#") && !match($result, "core::")) {
        if (match($result, "->slurp")) {
            $result = replace($result, "path\\s*\\(([^)]+)\\)->slurp[^(]*", "core::slurp($1)");
        }
        if (match($result, "->spew")) {
            $result = replace($result, "path\\s*\\(([^)]+)\\)->spew\\s*\\(([^)]+)\\)", "core::spew($1, $2)");
        }
        if (match($result, "->lines")) {
            my array @pl_cap = capture($result, "path\\s*\\(([^)]+)\\)->lines");
            if (scalar(@pl_cap) > 1) {
                $result = replace($result, "path\\s*\\(([^)]+)\\)->lines[^(]*", "split(\"\\n\", core::slurp($1))");
            }
        }
        if (match($result, "->children")) {
            my array @pc_cap = capture($result, "path\\s*\\(([^)]+)\\)->children");
            if (scalar(@pc_cap) > 1) {
                $result = replace($result, "path\\s*\\(([^)]+)\\)->children[^(]*", "core::readdir($1)");
            }
        }
        if (match($result, "->basename")) {
            $result = replace($result, "path\\s*\\(([^)]+)\\)->basename", "core::basename($1)");
        }
        if (match($result, "->dirname")) {
            $result = replace($result, "path\\s*\\(([^)]+)\\)->dirname", "core::dirname($1)");
        }
        if (match($result, "->parent")) {
            $result = replace($result, "path\\s*\\(([^)]+)\\)->parent", "core::dirname($1)");
        }
        if (match($result, "->realpath")) {
            $result = replace($result, "path\\s*\\(([^)]+)\\)->realpath", "core::realpath($1)");
        }
        if (match($result, "->absolute")) {
            $result = replace($result, "path\\s*\\(([^)]+)\\)->absolute", "core::realpath($1)");
        }
        if (match($result, "->exists")) {
            $result = replace($result, "path\\s*\\(([^)]+)\\)->exists", "core::file_exists($1)");
        }
        if (match($result, "->is_file")) {
            $result = replace($result, "path\\s*\\(([^)]+)\\)->is_file", "core::is_file($1)");
        }
        if (match($result, "->is_dir")) {
            $result = replace($result, "path\\s*\\(([^)]+)\\)->is_dir", "core::is_dir($1)");
        }
        if (match($result, "->remove")) {
            $result = replace($result, "path\\s*\\(([^)]+)\\)->remove", "core::unlink($1)");
        }
        if (match($result, "->mkpath")) {
            $result = replace($result, "path\\s*\\(([^)]+)\\)->mkpath", "core::mkdir($1)");
            $result = $result . "  # REVIEW: mkpath creates parents; core::mkdir may need recursive calls";
        }
        if (match($result, "->touch")) {
            $result = $result . "  # REVIEW: Path::Tiny->touch() â€” use core::spew($f, \"\") or core::open()+core::close()";
        }
        if (match($result, "->stat")) {
            my array @ps_cap = capture($result, "path\\s*\\(([^)]+)\\)->stat");
            if (scalar(@ps_cap) > 1) {
                $result = replace($result, "path\\s*\\(([^)]+)\\)->stat", "core::stat($1)");
            }
        }
    }
    # goto &Carp::croak / goto &Carp::carp -> return die(@_) / return warn(@_)
    if (match($result, "\\bgoto\\s+&Carp::croak")) {
        $result = replace($result, "\\bgoto\\s+&Carp::croak\\s*;", "return die(@_);");
    }
    if (match($result, "\\bgoto\\s+&Carp::carp")) {
        $result = replace($result, "\\bgoto\\s+&Carp::carp\\s*;", "return warn(@_);");
    }
    # Carp::croak -> die(), Carp::carp -> warn()
    if (match($result, "\\bCarp::croak\\b")) {
        $result = replace_all($result, "Carp::croak", "die");
    }
    if (match($result, "\\bCarp::carp\\b")) {
        $result = replace_all($result, "Carp::carp", "warn");
    }
    if (match($result, "\\bCarp::confess\\b")) {
        $result = replace_all($result, "Carp::confess", "die");
    }
    if (match($result, "\\bCarp::cluck\\b")) {
        $result = replace_all($result, "Carp::cluck", "warn");
        $result = $result . "  # REVIEW: cluck prints stack trace - Strada warn() does not; use core::stack_trace() if needed";
    }
    # bare croak/confess (without Carp:: prefix) -> die()
    # Don't rename in function definitions (func croak -> func die is wrong)
    if (match($result, "\\bcroak\\b") && !match($result, "#") && !match($result, "Carp::") && !match($result, "\\bdie\\b") && !match($result, "\\bfunc\\s+croak")) {
        $result = replace_all($result, "croak", "die");
    }
    if (match($result, "\\bconfess\\b") && !match($result, "#") && !match($result, "Carp::") && !match($result, "\\bdie\\b") && !match($result, "\\bfunc\\s+confess")) {
        $result = replace_all($result, "confess", "die");
    }
    # bare carp (without Carp:: prefix) -> warn()
    if (match($result, "\\bcarp\\b") && !match($result, "#") && !match($result, "Carp::") && !match($result, "\\bwarn\\b") && !match($result, "CarpLevel") && !match($result, "\\bfunc\\s+carp")) {
        $result = replace_all($result, "carp", "warn");
    }
    # bare cluck (without Carp:: prefix) -> warn() with REVIEW
    if (match($result, "\\bcluck\\b") && !match($result, "#") && !match($result, "Carp::") && !match($result, "\\bwarn\\b") && !match($result, "\\bfunc\\s+cluck")) {
        $result = replace_all($result, "cluck", "warn");
        $result = $result . "  # REVIEW: cluck prints stack trace - use core::stack_trace() if needed";
    }
    # die { hashref } -> throw({ ... })  (hash ref exception object)
    if (match($result, "\\bdie\\s+\\{") && !match($result, "\\bdie\\s*\\(") && !match($result, "#")) {
        # Check this looks like a hashref (has => inside)
        if (match($result, "=>")) {
            $result = replace($result, "\\bdie\\s+\\{", "throw({");
            # Find the matching close brace and add )
            my int $die_br = index($result, "throw({");
            if ($die_br >= 0) {
                my int $die_i = $die_br + 7;
                my int $die_d = 1;
                my int $die_len = length($result);
                while ($die_i < $die_len && $die_d > 0) {
                    my str $die_c = substr($result, $die_i, 1);
                    if ($die_c eq "{") { $die_d++; }
                    if ($die_c eq "}") { $die_d--; }
                    $die_i++;
                }
                if ($die_d == 0) {
                    # Insert ) after the closing }
                    $result = substr($result, 0, $die_i) . ")" . substr($result, $die_i, $die_len - $die_i);
                }
            }
        }
    }
    # After croak/confess -> die conversion, ensure die has parens: die "msg" -> die("msg")
    if (match($result, "\\bdie\\s+[\"']") && !match($result, "\\bdie\\s*\\(")) {
        $result = replace($result, "\\bdie\\s+", "die(");
        $result = add_close_paren($result);
    }
    # Remove Carp-specific variable settings (e.g. local $Carp::CarpLevel = 1)
    if (match($result, "\\bCarp::CarpLevel\\b")) {
        $result = $indent . "# " . $trimmed . "  # Not needed in Strada (using die() instead of Carp)";
    }
    # UNIVERSAL::isa($obj, 'Class') -> $obj->isa("Class")
    if (match($result, "\\bUNIVERSAL::isa\\b") && !match($result, "#")) {
        my array @uisa_cap = capture($result, "UNIVERSAL::isa\\(\\s*([^,]+)\\s*,\\s*([^)]+)\\s*\\)");
        if (scalar(@uisa_cap) > 2) {
            my str $uisa_obj = trim_str($uisa_cap[1]);
            my str $uisa_cls = trim_str($uisa_cap[2]);
            $result = replace($result, "UNIVERSAL::isa\\([^)]*\\)", $uisa_obj . "->isa(" . $uisa_cls . ")");
        }
    }
    # UNIVERSAL::can($obj, 'method') -> $obj->can("method")
    if (match($result, "\\bUNIVERSAL::can\\b") && !match($result, "#")) {
        my array @ucan_cap = capture($result, "UNIVERSAL::can\\(\\s*([^,]+)\\s*,\\s*([^)]+)\\s*\\)");
        if (scalar(@ucan_cap) > 2) {
            my str $ucan_obj = trim_str($ucan_cap[1]);
            my str $ucan_mth = trim_str($ucan_cap[2]);
            $result = replace($result, "UNIVERSAL::can\\([^)]*\\)", $ucan_obj . "->can(" . $ucan_mth . ")");
        }
    }
    # @ISA = qw(Parent1 Parent2) -> extends Parent1; extends Parent2;
    if (match($result, "@ISA[^A-Za-z0-9_]") && !match($result, "@EXPORT")) {
        # Extract parent classes from qw() or quoted list ("A", "B")
        my str $isa_out = "";
        if (match($result, "qw")) {
            my array @isa_cap = capture($result, "qw[\\(\\[]\\s*([^)\\]]+)\\s*[)\\]]");
            if (scalar(@isa_cap) > 1) {
                my array @isa_parents = split("\\s+", trim_str($isa_cap[1]));
                my int $isai = 0;
                while ($isai < scalar(@isa_parents)) {
                    my str $isa_p = trim_str($isa_parents[$isai]);
                    if (length($isa_p) > 0) {
                        if (length($isa_out) > 0) { $isa_out = $isa_out . "\n"; }
                        $isa_out = $isa_out . $indent . "extends " . $isa_p . ";";
                    }
                    $isai++;
                }
            }
        }
        # Also handle already-converted qw â†’ ("Name1", "Name2") form
        if (length($isa_out) == 0 && match($result, "['\"]([A-Za-z_:][A-Za-z0-9_:]*)['\"]")) {
            my str $isa_scan = $result;
            my int $isa_safety = 0;
            while (match($isa_scan, "['\"]([A-Za-z_:][A-Za-z0-9_:]*)['\"]") && $isa_safety < 20) {
                my array @isa3_cap = capture($isa_scan, "['\"]([A-Za-z_:][A-Za-z0-9_:]*)['\"]");
                if (scalar(@isa3_cap) > 1) {
                    my str $isa_parent = $isa3_cap[1];
                    if ($isa_parent ne "Exporter" && $isa_parent ne "our") {
                        if (length($isa_out) > 0) { $isa_out = $isa_out . "\n"; }
                        $isa_out = $isa_out . $indent . "extends " . $isa_parent . ";";
                    }
                    # Remove matched portion from scan to find next
                    my int $q_pos = index($isa_scan, $isa_parent);
                    if ($q_pos >= 0) {
                        $isa_scan = substr($isa_scan, $q_pos + length($isa_parent), length($isa_scan) - $q_pos - length($isa_parent));
                    } else {
                        $isa_safety = 20;
                    }
                } else {
                    $isa_safety = 20;
                }
                $isa_safety++;
            }
        }
        if (length($isa_out) > 0) {
            $result = $isa_out;
        } else {
            $result = $indent . "# " . $trimmed . "  # Not needed in Strada (use extends)";
        }
    }
    # @EXPORT / @EXPORT_OK / %EXPORT_TAGS - export declarations
    if (match($result, "@EXPORT_OK")) {
        # Try to extract function names from qw()
        my array @eo_cap = capture($result, "qw[\\(\\[]\\s*([^)\\]]+)\\s*[)\\]]");
        if (scalar(@eo_cap) > 1) {
            $result = $indent . "# " . $trimmed . "  # Exported (optional): " . trim_str($eo_cap[1]) . " - callers use Package::func() in Strada";
        } else {
            $result = $indent . "# " . $trimmed . "  # Not needed in Strada (callers use Package::func())";
        }
    } elsif (match($result, "@EXPORT\\b")) {
        my array @ex_cap = capture($result, "qw[\\(\\[]\\s*([^)\\]]+)\\s*[)\\]]");
        if (scalar(@ex_cap) > 1) {
            $result = $indent . "# " . $trimmed . "  # Exported: " . trim_str($ex_cap[1]) . " - callers use Package::func() in Strada";
        } else {
            $result = $indent . "# " . $trimmed . "  # Not needed in Strada (callers use Package::func())";
        }
    }
    if (match($result, "%EXPORT_TAGS")) {
        # Try to extract tag names: %EXPORT_TAGS = (all => [...], default => [...])
        my array @etag_cap = capture($trimmed, "([a-z_]+)\\s*=>");
        if (scalar(@etag_cap) > 1) {
            $result = $indent . "# " . $trimmed . "  # Export tags available: " . $etag_cap[1] . " - callers use Package::func() in Strada";
        } else {
            $result = $indent . "# " . $trimmed . "  # Not needed in Strada (callers use Package::func())";
        }
    }

    # x repetition operator: natively supported in Strada, no conversion needed

    # .. range operator works natively in Strada - no conversion needed

    # Hash slices @hash{@keys} and array slices @arr[1,3,5] are natively supported in Strada

    # return wantarray pattern - already converted above, no extra TODO needed

    # ---- Imported function resolution ----
    # Map imported bare function calls to Strada equivalents based on Pass 1 import tracking
    # Skip function definitions (func name(...)) - only rename calls, not definitions
    if (!match($result, "#") && !match($result, "^\\s*func\\s+")) {
        # Known function -> Strada mappings (applied when function is imported or used bare)
        if (match($result, "\\bbasename\\s*\\(") && !match($result, "core::basename")) {
            $result = replace($result, "\\bbasename\\s*\\(", "core::basename(");
        }
        if (match($result, "\\bdirname\\s*\\(") && !match($result, "core::dirname")) {
            $result = replace($result, "\\bdirname\\s*\\(", "core::dirname(");
        }
        if (match($result, "\\bfileparse\\s*\\(") && !match($result, "#")) {
            # Check if it's a destructuring assignment: ($name, $dir, $sfx) = fileparse(...)
            if (match($result, "\\(.*,.*\\)\\s*=\\s*fileparse")) {
                $result = $result . "  # REVIEW: fileparse($path) returns (name, dir, suffix) â€” use core::basename($path) and core::dirname($path) separately";
            } else {
                # Simple call: fileparse($path) â†’ core::basename($path)
                my array @fp_cap = capture($result, "fileparse\\s*\\(([^,)]+)");
                if (scalar(@fp_cap) > 1) {
                    $result = replace($result, "fileparse\\s*\\([^)]+\\)", "core::basename(" . trim_str($fp_cap[1]) . ")");
                    $result = $result . "  # REVIEW: fileparse() replaced with core::basename() â€” add core::dirname() if dir component needed";
                }
            }
        }
        if (match($result, "\\bgetcwd\\s*\\(") && !match($result, "core::getcwd")) {
            $result = replace($result, "\\bgetcwd\\s*\\(", "core::getcwd(");
        }
        if (match($result, "\\babs_path\\s*\\(") && !match($result, "core::realpath")) {
            $result = replace($result, "\\babs_path\\s*\\(", "core::realpath(");
        }
        if (match($result, "\\brealpath\\s*\\(") && !match($result, "core::realpath")) {
            $result = replace($result, "\\brealpath\\s*\\(", "core::realpath(");
        }
        if (match($result, "\\bfloor\\s*\\(") && !match($result, "math::floor") && !match($result, "->floor") && !match($result, "POSIX::floor")) {
            $result = replace($result, "\\bfloor\\s*\\(", "math::floor(");
        }
        if (match($result, "\\bceil\\s*\\(") && !match($result, "math::ceil") && !match($result, "->ceil") && !match($result, "POSIX::ceil")) {
            $result = replace($result, "\\bceil\\s*\\(", "math::ceil(");
        }
        if (match($result, "\\bencode_base64\\s*\\(") && !match($result, "core::base64_encode")) {
            $result = replace($result, "\\bencode_base64\\s*\\(", "core::base64_encode(");
        }
        if (match($result, "\\bdecode_base64\\s*\\(") && !match($result, "core::base64_decode")) {
            $result = replace($result, "\\bdecode_base64\\s*\\(", "core::base64_decode(");
        }
        if (match($result, "\\bstrftime\\s*\\(") && !match($result, "core::strftime") && !match($result, "->strftime")) {
            $result = replace($result, "\\bstrftime\\s*\\(", "core::strftime(");
        }
        # POSIX::_exit -> core::_exit
        if (match($result, "\\bPOSIX::_exit\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::_exit\\s*\\(", "core::_exit(");
        }
        # POSIX::getcwd -> core::getcwd
        if (match($result, "\\bPOSIX::getcwd\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::getcwd\\s*\\(", "core::getcwd(");
        }
        # POSIX::mktime -> core::mktime
        if (match($result, "\\bPOSIX::mktime\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::mktime\\s*\\(", "core::mktime(");
        }
        # POSIX::strftime -> core::strftime
        if (match($result, "\\bPOSIX::strftime\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::strftime\\s*\\(", "core::strftime(");
        }
        # POSIX::floor -> math::floor
        if (match($result, "\\bPOSIX::floor\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::floor\\s*\\(", "math::floor(");
        }
        # POSIX::ceil -> math::ceil
        if (match($result, "\\bPOSIX::ceil\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::ceil\\s*\\(", "math::ceil(");
        }
        # POSIX::fmod -> math::fmod
        if (match($result, "\\bPOSIX::fmod\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::fmod\\s*\\(", "math::fmod(");
        }
        # POSIX::pow -> math::pow
        if (match($result, "\\bPOSIX::pow\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::pow\\s*\\(", "math::pow(");
        }
        # POSIX::round -> math::round (if available) or int() + 0.5
        if (match($result, "\\bPOSIX::round\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::round\\s*\\(", "math::round(");
        }
        # POSIX::fabs -> math::abs
        if (match($result, "\\bPOSIX::fabs\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::fabs\\s*\\(", "math::abs(");
        }
        # POSIX::log -> math::log
        if (match($result, "\\bPOSIX::log\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::log\\s*\\(", "math::log(");
        }
        # POSIX::exp -> math::exp
        if (match($result, "\\bPOSIX::exp\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::exp\\s*\\(", "math::exp(");
        }
        # POSIX::sqrt -> math::sqrt
        if (match($result, "\\bPOSIX::sqrt\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::sqrt\\s*\\(", "math::sqrt(");
        }
        # POSIX::strerror -> core::strerror
        if (match($result, "\\bPOSIX::strerror\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::strerror\\s*\\(", "core::strerror(");
        }
        # POSIX::getpid -> core::getpid
        if (match($result, "\\bPOSIX::getpid\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::getpid\\s*\\(", "core::getpid(");
        }
        # POSIX::getuid -> core::getuid
        if (match($result, "\\bPOSIX::getuid\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::getuid\\s*\\(", "core::getuid(");
        }
        # POSIX::getgid -> core::getgid
        if (match($result, "\\bPOSIX::getgid\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::getgid\\s*\\(", "core::getgid(");
        }
        # POSIX::uname -> core::uname
        if (match($result, "\\bPOSIX::uname\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::uname\\s*\\(", "core::uname(");
        }
        # POSIX::setlocale -> TODO
        if (match($result, "\\bPOSIX::setlocale\\s*\\(") && !match($result, "#.*TODO")) {
            $result = $result . "  # REVIEW: POSIX::setlocale - no direct Strada equivalent; use __C__ block";
        }
        # POSIX::setsid -> core::setsid
        if (match($result, "\\bPOSIX::setsid\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::setsid\\s*\\(", "core::setsid(");
        }
        # POSIX::isatty -> core::isatty
        if (match($result, "\\bPOSIX::isatty\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::isatty\\s*\\(", "core::isatty(");
        }
        # POSIX::nice -> core::nice
        if (match($result, "\\bPOSIX::nice\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::nice\\s*\\(", "core::nice(");
        }
        # POSIX::access -> core::access
        if (match($result, "\\bPOSIX::access\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::access\\s*\\(", "core::access(");
        }
        # POSIX::getpgrp -> core::getpgrp
        if (match($result, "\\bPOSIX::getpgrp\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::getpgrp\\s*\\(", "core::getpgrp(");
        }
        # POSIX::setpgid -> core::setpgid
        if (match($result, "\\bPOSIX::setpgid\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::setpgid\\s*\\(", "core::setpgid(");
        }
        # POSIX::dup -> core::dup
        if (match($result, "\\bPOSIX::dup\\s*\\(") && !match($result, "POSIX::dup2")) {
            $result = replace($result, "\\bPOSIX::dup\\s*\\(", "core::dup(");
        }
        # POSIX::dup2 -> core::dup2
        if (match($result, "\\bPOSIX::dup2\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::dup2\\s*\\(", "core::dup2(");
        }
        # POSIX::pipe -> core::pipe
        if (match($result, "\\bPOSIX::pipe\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::pipe\\s*\\(", "core::pipe(");
        }
        # POSIX::close -> core::close_fd
        if (match($result, "\\bPOSIX::close\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::close\\s*\\(", "core::close_fd(");
        }
        # POSIX::read -> core::read_fd
        if (match($result, "\\bPOSIX::read\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::read\\s*\\(", "core::read_fd(");
        }
        # POSIX::write -> core::write_fd
        if (match($result, "\\bPOSIX::write\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::write\\s*\\(", "core::write_fd(");
        }
        # POSIX::lseek -> core::seek
        if (match($result, "\\bPOSIX::lseek\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::lseek\\s*\\(", "core::seek(");
        }
        # POSIX::umask -> core::umask
        if (match($result, "\\bPOSIX::umask\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::umask\\s*\\(", "core::umask(");
        }
        # POSIX::getppid -> core::getppid
        if (match($result, "\\bPOSIX::getppid\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::getppid\\s*\\(", "core::getppid(");
        }
        # POSIX::tcgetattr -> core::tcgetattr
        if (match($result, "\\bPOSIX::tcgetattr\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::tcgetattr\\s*\\(", "core::tcgetattr(");
        }
        # POSIX::tcsetattr -> core::tcsetattr
        if (match($result, "\\bPOSIX::tcsetattr\\s*\\(")) {
            $result = replace($result, "\\bPOSIX::tcsetattr\\s*\\(", "core::tcsetattr(");
        }
        # POSIX::WNOHANG constant -> 1
        if (match($result, "\\bPOSIX::WNOHANG\\b") && !match($result, "#")) {
            $result = replace_all($result, "POSIX::WNOHANG", "1");
        }
        # POSIX::WUNTRACED constant -> 2
        if (match($result, "\\bPOSIX::WUNTRACED\\b") && !match($result, "#")) {
            $result = replace_all($result, "POSIX::WUNTRACED", "2");
        }
        # Catch-all for remaining POSIX:: calls
        if (match($result, "\\bPOSIX::[A-Za-z_]+\\s*\\(") && !match($result, "#.*REVIEW") && !match($result, "core::") && !match($result, "math::")) {
            $result = $result . "  # REVIEW: POSIX:: function â€” check if Strada has a core:: or math:: equivalent, or use __C__ block";
        }
        if (match($result, "\\bencode_json\\s*\\(")) {
            $result = replace($result, "\\bencode_json\\s*\\(", "JSON::encode(");
            $result = $result . "  # needs: use JSON;";
        }
        if (match($result, "\\bdecode_json\\s*\\(")) {
            $result = replace($result, "\\bdecode_json\\s*\\(", "JSON::decode(");
            $result = $result . "  # needs: use JSON;";
        }
        # mkpath/make_path -> core::mkdir with REVIEW
        if (match($result, "\\bmkpath\\s*\\(") && !match($result, "core::mkdir") && !match($result, "::mkpath")) {
            $result = replace($result, "\\bmkpath\\s*\\(", "core::system(\"mkdir -p \" . ");
            $result = $result . "  # REVIEW: mkpath() was recursive mkdir â€” uses system mkdir -p";
        }
        if (match($result, "\\bmake_path\\s*\\(") && !match($result, "core::mkdir") && !match($result, "::make_path")) {
            $result = replace($result, "\\bmake_path\\s*\\(", "core::system(\"mkdir -p \" . ");
            $result = $result . "  # REVIEW: make_path() was recursive mkdir â€” uses system mkdir -p";
        }
        # rmtree/remove_tree -> core::system("rm -rf " . ...)
        if (match($result, "\\brmtree\\s*\\(") && !match($result, "#") && !match($result, "::rmtree")) {
            $result = replace($result, "\\brmtree\\s*\\(", "core::system(\"rm -rf \" . ");
        }
        if (match($result, "\\bremove_tree\\s*\\(") && !match($result, "#") && !match($result, "::remove_tree")) {
            $result = replace($result, "\\bremove_tree\\s*\\(", "core::system(\"rm -rf \" . ");
        }
        # File::Spec methods -> direct equivalents
        if (match($result, "File::Spec::catfile\\s*\\(") && !match($result, "#")) {
            # catfile($a, $b) â†’ $a . "/" . $b
            my array @cf_cap = capture($result, "File::Spec::catfile\\s*\\(([^,]+),\\s*([^)]+)\\)");
            if (scalar(@cf_cap) > 2) {
                my str $cf_a = trim_str($cf_cap[1]);
                my str $cf_b = trim_str($cf_cap[2]);
                $result = replace($result, "File::Spec::catfile\\s*\\([^)]+\\)", $cf_a . " . \"/\" . " . $cf_b);
            }
        }
        if (match($result, "File::Spec::catdir\\s*\\(") && !match($result, "#")) {
            my array @cd_cap2 = capture($result, "File::Spec::catdir\\s*\\(([^,]+),\\s*([^)]+)\\)");
            if (scalar(@cd_cap2) > 2) {
                my str $cd_a = trim_str($cd_cap2[1]);
                my str $cd_b = trim_str($cd_cap2[2]);
                $result = replace($result, "File::Spec::catdir\\s*\\([^)]+\\)", $cd_a . " . \"/\" . " . $cd_b);
            }
        }
        if (match($result, "File::Spec::catpath\\s*\\(") && !match($result, "#")) {
            # catpath($vol, $dir, $file) â€” on Unix, volume is empty so just $dir . "/" . $file
            my array @cp_cap = capture($result, "File::Spec::catpath\\s*\\(([^,]+),\\s*([^,]+),\\s*([^)]+)\\)");
            if (scalar(@cp_cap) > 3) {
                my str $cp_dir = trim_str($cp_cap[2]);
                my str $cp_file = trim_str($cp_cap[3]);
                if ($cp_file eq "''" || $cp_file eq "\"\"") {
                    $result = replace($result, "File::Spec::catpath\\s*\\([^)]+\\)", $cp_dir);
                } else {
                    $result = replace($result, "File::Spec::catpath\\s*\\([^)]+\\)", $cp_dir . " . \"/\" . " . $cp_file);
                }
            }
        }
        if (match($result, "File::Spec::curdir") && !match($result, "#")) {
            $result = replace_all($result, "File::Spec::curdir", "\".\"");
        }
        if (match($result, "File::Spec::rootdir") && !match($result, "#")) {
            $result = replace_all($result, "File::Spec::rootdir", "\"/\"");
        }
        if (match($result, "File::Spec::file_name_is_absolute\\s*\\(") && !match($result, "#")) {
            my array @abs_cap = capture($result, "File::Spec::file_name_is_absolute\\s*\\(([^)]+)\\)");
            if (scalar(@abs_cap) > 1) {
                my str $abs_path = trim_str($abs_cap[1]);
                $result = replace($result, "File::Spec::file_name_is_absolute\\s*\\([^)]+\\)", "(substr(" . $abs_path . ", 0, 1) eq \"/\")");
            }
        }
        if (match($result, "File::Spec::rel2abs\\s*\\(") && !match($result, "#")) {
            my array @r2a_cap = capture($result, "File::Spec::rel2abs\\s*\\(([^)]+)\\)");
            if (scalar(@r2a_cap) > 1) {
                $result = replace($result, "File::Spec::rel2abs\\s*\\([^)]+\\)", "core::realpath(" . trim_str($r2a_cap[1]) . ")");
            }
        }
        if (match($result, "File::Spec::splitdir\\s*\\(") && !match($result, "#")) {
            my array @spd_cap = capture($result, "File::Spec::splitdir\\s*\\(([^)]+)\\)");
            if (scalar(@spd_cap) > 1) {
                $result = replace($result, "File::Spec::splitdir\\s*\\([^)]+\\)", "split(\"/\", " . trim_str($spd_cap[1]) . ")");
            }
        }
        if (match($result, "File::Spec::splitpath\\s*\\(") && !match($result, "#")) {
            $result = $result . "  # REVIEW: File::Spec::splitpath â€” use core::dirname() + core::basename() or parse manually";
        }
        # Bare catfile/catdir (without File::Spec:: prefix)
        if (match($result, "\\bcatfile\\s*\\(") && !match($result, "#") && !match($result, "File::Spec")) {
            $result = $result . "  # REVIEW: catfile() -> use string concatenation with \"/\" separator";
        }
        if (match($result, "\\bcatdir\\s*\\(") && !match($result, "#") && !match($result, "File::Spec")) {
            $result = $result . "  # REVIEW: catdir() -> use string concatenation with \"/\" separator";
        }
        # copy($src, $dst) -> core::spew($dst, core::slurp($src))
        if (match($result, "\\bcopy\\s*\\(") && !match($result, "#") && !match($result, "core::") && !match($result, "File::Copy")) {
            my array @bcopy_cap = capture($result, "\\bcopy\\s*\\(\\s*([^,]+)\\s*,\\s*([^)]+)\\)");
            if (scalar(@bcopy_cap) > 2) {
                my str $bcopy_src = trim_str($bcopy_cap[1]);
                my str $bcopy_dst = trim_str($bcopy_cap[2]);
                $result = replace($result, "\\bcopy\\s*\\([^)]+\\)", "core::spew(" . $bcopy_dst . ", core::slurp(" . $bcopy_src . "))");
            } else {
                $result = $result . "  # REVIEW: copy() â€” use core::spew($dst, core::slurp($src)) in Strada";
            }
        }
        # tempfile() -> core::mkstemp("/tmp/strada_XXXXXX")
        if (match($result, "\\btempfile\\s*\\(") && !match($result, "#") && !match($result, "File::Temp") && !match($result, "core::mkstemp")) {
            $result = replace($result, "\\btempfile\\s*\\([^)]*\\)", "core::mkstemp(\"/tmp/strada_XXXXXX\")");
        }
        # File::Temp::tempfile() -> core::mkstemp
        if (match($result, "\\bFile::Temp::tempfile\\s*\\(") && !match($result, "#")) {
            $result = replace($result, "\\bFile::Temp::tempfile\\s*\\([^)]*\\)", "core::mkstemp(\"/tmp/strada_XXXXXX\")");
        }
        # DBI->connect -> DBI::connect
        if (match($result, "\\bDBI->connect\\s*\\(")) {
            $result = replace($result, "\\bDBI->connect\\s*\\(", "DBI::connect(");
        }
        # URI::Escape: uri_escape -> core::url_encode, uri_unescape -> core::url_decode
        if (match($result, "\\buri_escape\\s*\\(") && !match($result, "core::url_encode")) {
            $result = replace($result, "\\buri_escape\\s*\\(", "core::url_encode(");
        }
        if (match($result, "\\buri_unescape\\s*\\(") && !match($result, "core::url_decode")) {
            $result = replace($result, "\\buri_unescape\\s*\\(", "core::url_decode(");
        }
        if (match($result, "\\bURI::Escape::uri_escape\\s*\\(")) {
            $result = replace($result, "\\bURI::Escape::uri_escape\\s*\\(", "core::url_encode(");
        }
        if (match($result, "\\bURI::Escape::uri_unescape\\s*\\(")) {
            $result = replace($result, "\\bURI::Escape::uri_unescape\\s*\\(", "core::url_decode(");
        }
        # HTML::Entities: encode_entities/decode_entities -> REVIEW
        if (match($result, "\\bencode_entities\\s*\\(") && !match($result, "#.*REVIEW")) {
            $result = $result . "  # REVIEW: encode_entities() â€” use chained replace_all() for &, <, >, \" in Strada";
        }
        if (match($result, "\\bdecode_entities\\s*\\(") && !match($result, "#.*REVIEW")) {
            $result = $result . "  # REVIEW: decode_entities() â€” use chained replace_all() for &amp;, &lt;, &gt;, &quot; in Strada";
        }
        # DateTime->now -> core::time(), ->strftime -> core::strftime
        if (match($result, "\\bDateTime->now") && !match($result, "#")) {
            $result = replace($result, "\\bDateTime->now\\s*\\([^)]*\\)", "core::time()");
            $result = $result . "  # was DateTime->now";
        }
        if (match($result, "\\bDateTime->today") && !match($result, "#")) {
            $result = replace($result, "\\bDateTime->today\\s*\\([^)]*\\)", "core::time()");
            $result = $result . "  # was DateTime->today â€” use core::strftime for date formatting";
        }
        # YAML functions: Load/Dump/LoadFile/DumpFile -> REVIEW
        if (match($result, "\\bYAML::Load\\s*\\(") && !match($result, "#.*REVIEW")) {
            $result = $result . "  # REVIEW: YAML::Load() â€” consider using JSON::decode() as alternative";
        }
        if (match($result, "\\bYAML::Dump\\s*\\(") && !match($result, "#.*REVIEW")) {
            $result = $result . "  # REVIEW: YAML::Dump() â€” consider using JSON::encode() as alternative";
        }
        if (match($result, "\\bYAML::LoadFile\\s*\\(") && !match($result, "#.*REVIEW")) {
            $result = $result . "  # REVIEW: YAML::LoadFile() â€” consider JSON::decode(core::slurp(file)) as alternative";
        }
        if (match($result, "\\bYAML::DumpFile\\s*\\(") && !match($result, "#.*REVIEW")) {
            $result = $result . "  # REVIEW: YAML::DumpFile() â€” consider core::spew(file, JSON::encode(data)) as alternative";
        }
        # Bare YAML Load/Dump (imported without prefix)
        if (match($result, "\\bLoadFile\\s*\\(") && !match($result, "#.*REVIEW") && !match($result, "YAML::") && !match($result, "::LoadFile")) {
            $result = $result . "  # REVIEW: LoadFile() (YAML) â€” consider JSON::decode(core::slurp(file)) as alternative";
        }
        if (match($result, "\\bDumpFile\\s*\\(") && !match($result, "#.*REVIEW") && !match($result, "YAML::") && !match($result, "::DumpFile")) {
            $result = $result . "  # REVIEW: DumpFile() (YAML) â€” consider core::spew(file, JSON::encode(data)) as alternative";
        }
        # List::MoreUtils: any/all/none -> loop expansion guidance
        if (match($result, "\\bList::MoreUtils::any\\s*\\{") && !match($result, "#.*REVIEW")) {
            $result = $result . "  # REVIEW: any{} â€” replace with foreach loop: my int $found = 0; foreach ... { if (COND) { $found = 1; last; } }";
        }
        if (match($result, "\\bList::MoreUtils::all\\s*\\{") && !match($result, "#.*REVIEW")) {
            $result = $result . "  # REVIEW: all{} â€” replace with foreach loop: my int $all = 1; foreach ... { unless (COND) { $all = 0; last; } }";
        }
        if (match($result, "\\bList::MoreUtils::none\\s*\\{") && !match($result, "#.*REVIEW")) {
            $result = $result . "  # REVIEW: none{} â€” replace with foreach loop: my int $found = 0; foreach ... { if (COND) { $found = 1; last; } } result is !$found";
        }
        if (match($result, "\\bList::MoreUtils::uniq\\s*\\(") && !match($result, "#.*REVIEW")) {
            $result = $result . "  # REVIEW: uniq() â€” use hash to deduplicate: my hash %seen; foreach ... { push if !exists($seen{$_}); $seen{$_} = 1; }";
        }
        # Bare any/all/none (imported from List::MoreUtils)
        if (match($result, "\\bany\\s*\\{") && !match($result, "#.*REVIEW") && !match($result, "::any") && !match($result, "async::any")) {
            $result = $result . "  # REVIEW: any{} (List::MoreUtils) â€” replace with foreach loop with early exit";
        }
        if (match($result, "\\ball\\s*\\{") && !match($result, "#.*REVIEW") && !match($result, "::all") && !match($result, "async::all")) {
            $result = $result . "  # REVIEW: all{} (List::MoreUtils) â€” replace with foreach loop checking all elements";
        }
        if (match($result, "\\bnone\\s*\\{") && !match($result, "#.*REVIEW") && !match($result, "::none")) {
            $result = $result . "  # REVIEW: none{} (List::MoreUtils) â€” replace with foreach loop with early exit";
        }
        # Text::Wrap: wrap() -> REVIEW
        if (match($result, "\\bText::Wrap::wrap\\s*\\(") && !match($result, "#.*REVIEW")) {
            $result = $result . "  # REVIEW: wrap() â€” implement manual line-breaking with substr()/index() in Strada";
        }
        if (match($result, "\\bwrap\\s*\\(") && !match($result, "#.*REVIEW") && !match($result, "::wrap") && !match($result, "Text::Wrap")) {
            # Only annotate if we know it was imported from Text::Wrap (check sub_info)
            if (exists($sub_info{"import:wrap"})) {
                $result = $result . "  # REVIEW: wrap() (Text::Wrap) â€” implement manual line-breaking in Strada";
            }
        }
        # Module::Load: load() / Module::Runtime: use_module() -> REVIEW
        if (match($result, "\\bModule::Load::load\\s*\\(") && !match($result, "#.*REVIEW")) {
            $result = $result . "  # REVIEW: Module::Load::load() â€” use 'use' at compile time in Strada";
        }
        if (match($result, "\\bModule::Runtime::use_module\\s*\\(") && !match($result, "#.*REVIEW")) {
            $result = $result . "  # REVIEW: use_module() â€” use 'use' at compile time in Strada";
        }
        # UNIVERSAL::can -> $obj->can()
        if (match($result, "\\bUNIVERSAL::can\\s*\\(") && !match($result, "#")) {
            my array @ucan_cap = capture($result, "UNIVERSAL::can\\s*\\(\\s*([^,]+)\\s*,\\s*([^)]+)\\)");
            if (scalar(@ucan_cap) > 2) {
                my str $ucan_obj = trim_str($ucan_cap[1]);
                my str $ucan_meth = trim_str($ucan_cap[2]);
                $result = replace($result, "UNIVERSAL::can\\s*\\([^)]+\\)", $ucan_obj . "->can(" . $ucan_meth . ")");
            }
        }
        # UNIVERSAL::isa -> $obj->isa()
        if (match($result, "\\bUNIVERSAL::isa\\s*\\(") && !match($result, "#")) {
            my array @uisa_cap = capture($result, "UNIVERSAL::isa\\s*\\(\\s*([^,]+)\\s*,\\s*([^)]+)\\)");
            if (scalar(@uisa_cap) > 2) {
                my str $uisa_obj = trim_str($uisa_cap[1]);
                my str $uisa_cls = trim_str($uisa_cap[2]);
                $result = replace($result, "UNIVERSAL::isa\\s*\\([^)]+\\)", $uisa_obj . "->isa(" . $uisa_cls . ")");
            }
        }
        # Import-aware fallback: prefix unqualified calls with module name
        # For functions imported via `use Module qw(func)` that aren't in the known mapping table
        if (match($result, "\\b[a-z_][a-z0-9_]*\\s*\\(") && !match($result, "#.*REVIEW")) {
            # Extract function call names and check against import registry
            my str $imp_scan = $result;
            my int $imp_changed = 0;
            # Try to find a bare function call that matches an import
            my array @imp_keys = keys(%sub_info);
            my int $iki = 0;
            while ($iki < scalar(@imp_keys)) {
                my str $ik_name = $imp_keys[$iki];
                if (starts_with($ik_name, "import:")) {
                    my str $imp_func = substr($ik_name, 7, length($ik_name) - 7);
                    my str $imp_module = "" . $sub_info{$ik_name};
                    # Skip functions that are in our known mapping table (already handled above)
                    if ($imp_func ne "basename" && $imp_func ne "dirname" && $imp_func ne "fileparse"
                        && $imp_func ne "getcwd" && $imp_func ne "abs_path" && $imp_func ne "realpath"
                        && $imp_func ne "floor" && $imp_func ne "ceil"
                        && $imp_func ne "encode_base64" && $imp_func ne "decode_base64"
                        && $imp_func ne "strftime" && $imp_func ne "encode_json" && $imp_func ne "decode_json"
                        && $imp_func ne "mkpath" && $imp_func ne "make_path"
                        && $imp_func ne "rmtree" && $imp_func ne "remove_tree"
                        && $imp_func ne "catfile" && $imp_func ne "catdir"
                        && $imp_func ne "copy" && $imp_func ne "tempfile" && $imp_func ne "tempdir"
                        && $imp_func ne "move" && $imp_func ne "gettimeofday" && $imp_func ne "usleep"
                        && $imp_func ne "md5_hex" && $imp_func ne "sha256_hex"
                        && $imp_func ne "freeze" && $imp_func ne "thaw" && $imp_func ne "nstore" && $imp_func ne "retrieve"
                        && $imp_func ne "encode" && $imp_func ne "decode" && $imp_func ne "is_utf8"
                        && $imp_func ne "croak" && $imp_func ne "carp" && $imp_func ne "confess" && $imp_func ne "cluck"
                        && $imp_func ne "blessed" && $imp_func ne "reftype" && $imp_func ne "weaken"
                        && $imp_func ne "looks_like_number" && $imp_func ne "isvstring"
                        && $imp_func ne "hostname"
                        && $imp_func ne "read_file" && $imp_func ne "write_file"
                        && $imp_func ne "read_text" && $imp_func ne "write_text" && $imp_func ne "read_dir"
                        && $imp_func ne "sha1_hex" && $imp_func ne "sha512_hex"
                        && $imp_func ne "cwd" && $imp_func ne "bsd_glob"
                        && $imp_func ne "openlog" && $imp_func ne "syslog" && $imp_func ne "closelog"
                        && $imp_func ne "uri_escape" && $imp_func ne "uri_unescape"
                        && $imp_func ne "encode_entities" && $imp_func ne "decode_entities"
                        && $imp_func ne "any" && $imp_func ne "all" && $imp_func ne "none" && $imp_func ne "uniq"
                        && $imp_func ne "wrap" && $imp_func ne "fill"
                        && $imp_func ne "load" && $imp_func ne "use_module"
                        && $imp_func ne "Load" && $imp_func ne "Dump" && $imp_func ne "LoadFile" && $imp_func ne "DumpFile") {
                        # Check if this function is called in the line without module prefix
                        if (match($result, "\\b" . $imp_func . "\\s*\\(") && !match($result, $imp_module . "::" . $imp_func) && !match($result, "::" . $imp_func . "\\s*\\(")) {
                            # Prefix with module name
                            my str $imp_repl = $imp_module . "::" . $imp_func . "(";
                            $result = replace($result, "\\b" . $imp_func . "\\s*\\(", $imp_repl);
                            $result = $result . "  # REVIEW: " . $imp_func . "() imported from " . $imp_module . " - verify Strada equivalent";
                            $imp_changed = 1;
                        }
                    }
                }
                $iki++;
            }
        }
    }

    # ---- POSIX macros (WEXITSTATUS, WIFEXITED) ----
    if (match($result, "\\bWEXITSTATUS\\s*\\(") && !match($result, "#")) {
        my array @wex_cap = capture($result, "WEXITSTATUS\\s*\\(([^)]+)\\)");
        if (scalar(@wex_cap) > 1) {
            my str $wex_arg = trim_str($wex_cap[1]);
            $result = replace($result, "WEXITSTATUS\\s*\\([^)]+\\)", "((" . $wex_arg . " >> 8) & 255)");
        }
    }
    if (match($result, "\\bWIFEXITED\\s*\\(") && !match($result, "#")) {
        my array @wif_cap = capture($result, "WIFEXITED\\s*\\(([^)]+)\\)");
        if (scalar(@wif_cap) > 1) {
            my str $wif_arg = trim_str($wif_cap[1]);
            $result = replace($result, "WIFEXITED\\s*\\([^)]+\\)", "((" . $wif_arg . " & 127) == 0)");
        }
    }
    # Standalone POSIX::_exit (when not inside the POSIX conditional block)
    if (match($result, "\\bPOSIX::_exit\\s*\\(") && !match($result, "core::_exit")) {
        $result = replace($result, "\\bPOSIX::_exit\\s*\\(", "core::_exit(");
    }

    # ---- CPAN Module Function Conversions ----

    # File::Copy functions
    if (match($result, "\\bFile::Copy::copy\\s*\\(") && !match($result, "#")) {
        # File::Copy::copy($src, $dst) -> core::spew($dst, core::slurp($src))
        my array @fcc_cap = capture($result, "File::Copy::copy\\s*\\(\\s*([^,]+)\\s*,\\s*([^)]+)\\)");
        if (scalar(@fcc_cap) > 2) {
            my str $fcc_src = trim_str($fcc_cap[1]);
            my str $fcc_dst = trim_str($fcc_cap[2]);
            $result = replace($result, "File::Copy::copy\\s*\\([^)]+\\)", "core::spew(" . $fcc_dst . ", core::slurp(" . $fcc_src . "))");
        } else {
            $result = replace($result, "\\bFile::Copy::copy\\s*\\(", "core::system(\"cp \" . ");
            $result = $result . "  # REVIEW: File::Copy::copy â€” approximated with system cp";
        }
    }
    if (match($result, "\\bFile::Copy::move\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\bFile::Copy::move\\s*\\(", "core::rename(");
    }
    if (match($result, "\\bmove\\s*\\(") && !match($result, "#") && !match($result, "core::") && !match($result, "File::") && !match($result, "->move")) {
        $result = replace($result, "\\bmove\\s*\\(", "core::rename(");
        $result = $result . "  # REVIEW: move() (File::Copy) â€” core::rename() may fail across filesystems";
    }

    # File::Path qualified calls
    if (match($result, "\\bFile::Path::mkpath\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\bFile::Path::mkpath\\s*\\(", "core::system(\"mkdir -p \" . ");
        $result = $result . "  # REVIEW: mkpath() was recursive mkdir â€” uses system mkdir -p";
    }
    if (match($result, "\\bFile::Path::make_path\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\bFile::Path::make_path\\s*\\(", "core::system(\"mkdir -p \" . ");
        $result = $result . "  # REVIEW: make_path() was recursive mkdir â€” uses system mkdir -p";
    }

    # File::Find
    if (match($result, "\\bfind\\s*\\(\\\\&") && !match($result, "#.*TODO") && !match($result, "core::")) {
        $result = $result . "  # REVIEW: File::Find::find - use core::readdir() with recursive helper function";
    }
    if (match($result, "\\bfind\\s*\\(\\{") && !match($result, "#.*REVIEW") && !match($result, "core::")) {
        $result = $result . "  # REVIEW: File::Find::find - use core::readdir() with recursive helper function";
    }

    # File::Temp
    if (match($result, "\\btempdir\\s*\\(") && !match($result, "#") && !match($result, "core::mkdtemp")) {
        $result = replace($result, "\\btempdir\\s*\\(", "core::mkdtemp(\"/tmp/strada_XXXXXX\"");
        # Fix double args: if there were args after tempdir(, they're now extra
        $result = $result . "  # REVIEW: tempdir() -> core::mkdtemp() - review arguments";
    }
    if (match($result, "\\bFile::Temp::tempdir\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\bFile::Temp::tempdir\\s*\\(", "core::mkdtemp(\"/tmp/strada_XXXXXX\"");
        $result = $result . "  # REVIEW: File::Temp::tempdir() -> core::mkdtemp()";
    }

    # Time::HiRes functions
    if (match($result, "\\bgettimeofday\\s*\\(") && !match($result, "#") && !match($result, "core::gettimeofday")) {
        $result = replace($result, "\\bgettimeofday\\s*\\(", "core::gettimeofday(");
    }
    if (match($result, "\\busleep\\s*\\(") && !match($result, "#") && !match($result, "core::usleep")) {
        $result = replace($result, "\\busleep\\s*\\(", "core::usleep(");
    }

    # IO::Socket::INET constructor â†’ core::socket_client() or core::socket_server()
    if ((match($result, "IO::Socket::INET->new\\s*\\(") || match($result, "IO::Socket::INET::new\\s*\\(")) && !match($result, "#")) {
        if (match($result, "PeerAddr") || match($result, "PeerHost")) {
            # Client socket: extract host and port
            # Note: fat comma quoting may have added quotes around key names ("PeerHost" =>)
            my str $sock_host = "\"localhost\"";
            my str $sock_port = "0";
            my array @sh_cap = capture($result, "\"?Peer(?:Addr|Host)\"?\\s*=>\\s*['\"]?([^'\">,)]+)['\"]?");
            if (scalar(@sh_cap) > 1) {
                $sock_host = "\"" . trim_str($sh_cap[1]) . "\"";
            }
            my array @sp_cap = capture($result, "\"?PeerPort\"?\\s*=>\\s*['\"]?([^'\">,)]+)['\"]?");
            if (scalar(@sp_cap) > 1) {
                $sock_port = trim_str($sp_cap[1]);
                # If port is numeric, keep as number; if variable, keep as-is
                if (!match($sock_port, "^[0-9]+$") && !match($sock_port, "^\\$")) {
                    $sock_port = "\"" . $sock_port . "\"";
                }
            }
            # Check if there's a variable assignment: my $sock = IO::Socket::...
            my array @sv_cap = capture($result, "((?:my\\s+(?:scalar\\s+)?)?\\$[A-Za-z_][A-Za-z0-9_]*)\\s*=");
            if (scalar(@sv_cap) > 1) {
                $result = $indent . $sv_cap[1] . " = core::socket_client(" . $sock_host . ", " . $sock_port . ");";
            } else {
                $result = $indent . "core::socket_client(" . $sock_host . ", " . $sock_port . ");";
            }
        } elsif (match($result, "LocalPort") || match($result, "Listen")) {
            # Server socket: extract port
            # Note: fat comma quoting may have added quotes around key names ("LocalPort" =>)
            my str $srv_port = "0";
            my array @lp_cap = capture($result, "\"?LocalPort\"?\\s*=>\\s*['\"]?([^'\">,)]+)['\"]?");
            if (scalar(@lp_cap) > 1) {
                $srv_port = trim_str($lp_cap[1]);
            }
            my array @sv2_cap = capture($result, "((?:my\\s+(?:scalar\\s+)?)?\\$[A-Za-z_][A-Za-z0-9_]*)\\s*=");
            if (scalar(@sv2_cap) > 1) {
                $result = $indent . $sv2_cap[1] . " = core::socket_server(" . $srv_port . ");";
            } else {
                $result = $indent . "core::socket_server(" . $srv_port . ");";
            }
        } else {
            $result = $result . "  # REVIEW: IO::Socket::INET->new() -> use core::socket_client() or core::socket_server()";
        }
    }
    # Socket method calls: $sock->send() / $sock->recv()
    if (match($result, "->send\\s*\\(") && !match($result, "#.*TODO") && !match($result, "core::")) {
        # $sock->send($data) â†’ core::socket_send($sock, $data)
        my array @ssend_cap = capture($result, "(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*->send\\s*\\(([^)]+)\\)");
        if (scalar(@ssend_cap) > 2) {
            my str $ssend_var = $ssend_cap[1];
            my str $ssend_args = trim_str($ssend_cap[2]);
            # Strip flags argument (usually 0)
            $ssend_args =~ s/,\s*0\s*$//;
            $result = replace($result, "\\$" . substr($ssend_var, 1, length($ssend_var) - 1) . "\\s*->send\\s*\\([^)]+\\)", "core::socket_send(" . $ssend_var . ", " . $ssend_args . ")");
        }
    }
    if (match($result, "->recv\\s*\\(") && !match($result, "#.*TODO") && !match($result, "core::")) {
        # $sock->recv($buf, $len) â†’ $buf = core::socket_recv($sock, $len)
        my array @srecv_cap = capture($result, "(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*->recv\\s*\\((\\$[A-Za-z_][A-Za-z0-9_]*)\\s*,\\s*([^),]+)");
        if (scalar(@srecv_cap) > 3) {
            my str $srecv_sock = $srecv_cap[1];
            my str $srecv_buf = $srecv_cap[2];
            my str $srecv_len = trim_str($srecv_cap[3]);
            $result = $indent . $srecv_buf . " = core::socket_recv(" . $srecv_sock . ", " . $srecv_len . ");";
        } else {
            $result = $result . "  # REVIEW: ->recv() -> core::socket_recv($sock, $len)";
        }
    }

    # Encode module
    if (match($result, "\\bEncode::encode\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\bEncode::encode\\s*\\([^,]+,\\s*", "");
        $result = $result . "  # Note: Strada strings are UTF-8 by default; encode() removed";
    }
    if (match($result, "\\bEncode::decode\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\bEncode::decode\\s*\\([^,]+,\\s*", "");
        $result = $result . "  # Note: Strada strings are UTF-8 by default; decode() removed";
    }
    if (match($result, "\\bencode\\s*\\(\"UTF") && !match($result, "#") && !match($result, "Encode::") && !match($result, "base64") && !match($result, "json")) {
        $result = $result . "  # Note: Strada strings are UTF-8 by default; encode(\"UTF-8\", ...) is a no-op";
    }
    if (match($result, "\\bdecode\\s*\\(\"UTF") && !match($result, "#") && !match($result, "Encode::") && !match($result, "base64") && !match($result, "json")) {
        $result = $result . "  # Note: Strada strings are UTF-8 by default; decode(\"UTF-8\", ...) is a no-op";
    }
    # is_utf8() -> 1 (Strada strings are always UTF-8)
    if (match($result, "\\bis_utf8\\s*\\(") && !match($result, "#") && !match($result, "utf8::is_utf8")) {
        $result = replace($result, "\\bis_utf8\\s*\\([^)]*\\)", "1");
        $result = $result . "  # Note: Strada strings are always UTF-8";
    }

    # Digest functions
    if (match($result, "\\bmd5_hex\\s*\\(") && !match($result, "#") && !match($result, "core::md5")) {
        if (match($result, "Digest::MD5::md5_hex")) {
            $result = replace($result, "\\bDigest::MD5::md5_hex\\s*\\(", "core::md5(");
        } else {
            $result = replace($result, "\\bmd5_hex\\s*\\(", "core::md5(");
        }
        $result = $result . "  # REVIEW: needs import_lib \"crypt.so\"";
    }
    if (match($result, "\\bsha256_hex\\s*\\(") && !match($result, "#") && !match($result, "core::sha256")) {
        if (match($result, "Digest::SHA::sha256_hex")) {
            $result = replace($result, "\\bDigest::SHA::sha256_hex\\s*\\(", "core::sha256(");
        } else {
            $result = replace($result, "\\bsha256_hex\\s*\\(", "core::sha256(");
        }
        $result = $result . "  # REVIEW: needs import_lib \"crypt.so\"";
    }
    # sha1_hex -> core::sha1
    if (match($result, "\\bsha1_hex\\s*\\(") && !match($result, "#") && !match($result, "core::sha1")) {
        if (match($result, "Digest::SHA::sha1_hex")) {
            $result = replace($result, "\\bDigest::SHA::sha1_hex\\s*\\(", "core::sha1(");
        } else {
            $result = replace($result, "\\bsha1_hex\\s*\\(", "core::sha1(");
        }
        $result = $result . "  # REVIEW: needs import_lib \"crypt.so\"";
    }
    # sha512_hex -> core::sha512
    if (match($result, "\\bsha512_hex\\s*\\(") && !match($result, "#") && !match($result, "core::sha512")) {
        if (match($result, "Digest::SHA::sha512_hex")) {
            $result = replace($result, "\\bDigest::SHA::sha512_hex\\s*\\(", "core::sha512(");
        } else {
            $result = replace($result, "\\bsha512_hex\\s*\\(", "core::sha512(");
        }
        $result = $result . "  # REVIEW: needs import_lib \"crypt.so\"";
    }
    # Digest::MD5::md5 -> core::md5
    if (match($result, "\\bDigest::MD5::md5\\s*\\(") && !match($result, "#") && !match($result, "core::md5") && !match($result, "md5_hex")) {
        $result = replace($result, "\\bDigest::MD5::md5\\s*\\(", "core::md5(");
        $result = $result . "  # REVIEW: needs import_lib \"crypt.so\"";
    }
    # md5() bare -> core::md5 (only when not md5_hex)
    if (match($result, "\\bmd5\\s*\\(") && !match($result, "#") && !match($result, "core::md5") && !match($result, "md5_hex") && !match($result, "Digest::")) {
        $result = replace($result, "\\bmd5\\s*\\(", "core::md5(");
        $result = $result . "  # REVIEW: needs import_lib \"crypt.so\"";
    }
    # Digest::SHA::sha1 -> core::sha1
    if (match($result, "\\bDigest::SHA::sha1\\s*\\(") && !match($result, "#") && !match($result, "core::sha1") && !match($result, "sha1_hex")) {
        $result = replace($result, "\\bDigest::SHA::sha1\\s*\\(", "core::sha1(");
        $result = $result . "  # REVIEW: needs import_lib \"crypt.so\"";
    }
    # Digest::SHA::sha512 -> core::sha512
    if (match($result, "\\bDigest::SHA::sha512\\s*\\(") && !match($result, "#") && !match($result, "core::sha512") && !match($result, "sha512_hex")) {
        $result = replace($result, "\\bDigest::SHA::sha512\\s*\\(", "core::sha512(");
        $result = $result . "  # REVIEW: needs import_lib \"crypt.so\"";
    }

    # HTTP::Tiny
    if (match($result, "HTTP::Tiny->new") && !match($result, "#")) {
        $result = $result . "  # REVIEW: HTTP::Tiny - use Cannoli::HTTP or core::socket_client for raw HTTP";
    }
    if (match($result, "->get\\s*\\(") && match($result, "http") && !match($result, "#.*REVIEW")) {
        $result = $result . "  # REVIEW: HTTP::Tiny->get() - use Cannoli::HTTP::get() or core::socket_client()";
    }
    if (match($result, "->post\\s*\\(") && match($result, "http") && !match($result, "#.*REVIEW")) {
        $result = $result . "  # REVIEW: HTTP::Tiny->post() - use Cannoli::HTTP::post() or core::socket_client()";
    }

    # Storable functions
    if (match($result, "\\bfreeze\\s*\\(") && !match($result, "#") && !match($result, "JSON::encode") && !match($result, "->freeze")) {
        $result = replace($result, "\\bfreeze\\s*\\(", "JSON::encode(");
        $result = $result . "  # REVIEW: was Storable::freeze - JSON is approximate equivalent; needs import_lib \"JSON.so\"";
    }
    if (match($result, "\\bthaw\\s*\\(") && !match($result, "#") && !match($result, "JSON::decode") && !match($result, "->thaw")) {
        $result = replace($result, "\\bthaw\\s*\\(", "JSON::decode(");
        $result = $result . "  # REVIEW: was Storable::thaw - JSON is approximate equivalent; needs import_lib \"JSON.so\"";
    }
    if (match($result, "\\bnstore\\s*\\(") && !match($result, "#.*REVIEW")) {
        $result = $result . "  # REVIEW: Storable::nstore - use core::spew() + JSON::encode() in Strada";
    }
    if (match($result, "\\bretrieve\\s*\\(") && !match($result, "#.*REVIEW") && !match($result, "->retrieve")) {
        $result = $result . "  # REVIEW: Storable::retrieve - use core::slurp() + JSON::decode() in Strada";
    }

    # ---- Test::More function conversions ----
    # ok($test) / ok($test, $name) -> if (!($test)) { die("Test failed"); }
    if (match($result, "\\bok\\s*\\(") && !match($result, "#") && !match($result, "->ok") && !match($result, "\\$ok") && !match($result, "\"ok")) {
        # Distinguish ok() from other uses: must be at start of statement or after ; or in condition
        if (match($trimmed, "^ok\\s*\\(") || match($result, ";\\s*ok\\s*\\(")) {
            my array @ok_cap = capture($result, "\\bok\\s*\\(([^,)]+)");
            if (scalar(@ok_cap) > 1) {
                my str $ok_test = trim_str($ok_cap[1]);
                $result = $indent . "if (!(" . $ok_test . ")) { die(\"Test failed: " . $ok_test . "\"); }";
            }
        }
    }
    # is($got, $expected) / is($got, $expected, $name) -> assertion
    if (match($trimmed, "^is\\s*\\(") && !match($result, "#") && !match($result, "->is")) {
        my array @is_cap = capture($result, "\\bis\\s*\\(([^,]+),\\s*([^,)]+)");
        if (scalar(@is_cap) > 2) {
            my str $is_got = trim_str($is_cap[1]);
            my str $is_exp = trim_str($is_cap[2]);
            $result = $indent . "if (" . $is_got . " ne " . $is_exp . ") { die(\"Expected \" . " . $is_exp . " . \" got \" . " . $is_got . "); }";
        }
    }
    # isnt($got, $expected) -> assertion
    if (match($trimmed, "^isnt\\s*\\(") && !match($result, "#")) {
        my array @isnt_cap = capture($result, "\\bisnt\\s*\\(([^,]+),\\s*([^,)]+)");
        if (scalar(@isnt_cap) > 2) {
            my str $isnt_got = trim_str($isnt_cap[1]);
            my str $isnt_exp = trim_str($isnt_cap[2]);
            $result = $indent . "if (" . $isnt_got . " eq " . $isnt_exp . ") { die(\"Expected not \" . " . $isnt_exp . "); }";
        }
    }
    # like($got, qr/pattern/) -> assertion
    if (match($trimmed, "^like\\s*\\(") && !match($result, "#")) {
        my array @like_cap = capture($result, "\\blike\\s*\\(([^,]+),\\s*([^,)]+)");
        if (scalar(@like_cap) > 2) {
            my str $like_got = trim_str($like_cap[1]);
            my str $like_pat = trim_str($like_cap[2]);
            $result = $indent . "if (!match(" . $like_got . ", " . $like_pat . ")) { die(\"No match for \" . " . $like_pat . "); }";
        }
    }
    # unlike($got, qr/pattern/) -> assertion
    if (match($trimmed, "^unlike\\s*\\(") && !match($result, "#")) {
        my array @unlike_cap = capture($result, "\\bunlike\\s*\\(([^,]+),\\s*([^,)]+)");
        if (scalar(@unlike_cap) > 2) {
            my str $unlike_got = trim_str($unlike_cap[1]);
            my str $unlike_pat = trim_str($unlike_cap[2]);
            $result = $indent . "if (match(" . $unlike_got . ", " . $unlike_pat . ")) { die(\"Unexpected match for \" . " . $unlike_pat . "); }";
        }
    }
    # is_deeply() -> REVIEW
    if (match($trimmed, "^is_deeply\\s*\\(") && !match($result, "#")) {
        $result = $result . "  # REVIEW: is_deeply() â€” deep comparison not available; compare key fields manually";
    }
    # plan tests => N -> comment out
    if (match($trimmed, "^plan\\s+tests") && !match($result, "#")) {
        $result = $indent . "# " . $trimmed . "  # test plan not needed in Strada";
    }
    # plan skip_all -> comment out
    if (match($trimmed, "^plan\\s+skip_all") && !match($result, "#")) {
        $result = $indent . "# " . $trimmed . "  # test plan not needed in Strada";
    }
    # done_testing() -> comment out
    if (match($trimmed, "^done_testing") && !match($result, "#")) {
        $result = $indent . "# " . $trimmed . "  # not needed in Strada";
    }
    # diag($msg) -> warn($msg)
    if (match($trimmed, "^diag\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\bdiag\\s*\\(", "warn(");
    }
    # note($msg) -> say($msg)  (informational output)
    if (match($trimmed, "^note\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\bnote\\s*\\(", "say(");
    }
    # cmp_ok($got, $op, $expected) -> REVIEW
    if (match($trimmed, "^cmp_ok\\s*\\(") && !match($result, "#")) {
        $result = $result . "  # REVIEW: cmp_ok() â€” convert to direct comparison";
    }
    # can_ok($obj, @methods) -> REVIEW
    if (match($trimmed, "^can_ok\\s*\\(") && !match($result, "#")) {
        $result = $result . "  # REVIEW: can_ok() â€” use $obj->can(\"method\") in Strada";
    }
    # isa_ok($obj, $class) -> REVIEW
    if (match($trimmed, "^isa_ok\\s*\\(") && !match($result, "#")) {
        $result = $result . "  # REVIEW: isa_ok() â€” use $obj->isa(\"Class\") in Strada";
    }

    # ---- Time::HiRes qualified calls ----
    if (match($result, "\\bTime::HiRes::time\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\bTime::HiRes::time\\s*\\(", "core::hires_time(");
    }
    if (match($result, "\\bTime::HiRes::gettimeofday\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\bTime::HiRes::gettimeofday\\s*\\(", "core::gettimeofday(");
    }
    if (match($result, "\\bTime::HiRes::usleep\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\bTime::HiRes::usleep\\s*\\(", "core::usleep(");
    }
    if (match($result, "\\bTime::HiRes::sleep\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\bTime::HiRes::sleep\\s*\\(", "core::sleep(");
    }
    if (match($result, "\\bTime::HiRes::tv_interval\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\bTime::HiRes::tv_interval\\s*\\(", "core::tv_interval(");
    }

    # ---- IO::File constructor ----
    # Handle both IO::File->new (before generic conversion) and IO::File::new (after)
    if ((match($result, "\\bIO::File->new\\s*\\(") || match($result, "\\bIO::File::new\\s*\\(")) && !match($result, "#")) {
        my str $iof_result = $result;
        $iof_result = replace_all($iof_result, "IO::File->new", "core::open");
        $iof_result = replace_all($iof_result, "IO::File::new", "core::open");
        # Convert common Perl open modes to Strada modes
        $iof_result = replace_all($iof_result, "\"<\"", "\"r\"");
        $iof_result = replace_all($iof_result, "\">\"", "\"w\"");
        $iof_result = replace_all($iof_result, "\">>\"", "\"a\"");
        $iof_result = replace_all($iof_result, "\"+<\"", "\"rw\"");
        $result = $iof_result;
    }

    # ---- File::Spec arrow-syntax methods ----
    if (match($result, "File::Spec->catfile\\s*\\(") && !match($result, "#")) {
        my array @fsc_cap = capture($result, "File::Spec->catfile\\s*\\(([^,]+),\\s*([^)]+)\\)");
        if (scalar(@fsc_cap) > 2) {
            my str $fsc_a = trim_str($fsc_cap[1]);
            my str $fsc_b = trim_str($fsc_cap[2]);
            $result = replace($result, "File::Spec->catfile\\s*\\([^)]+\\)", $fsc_a . " . \"/\" . " . $fsc_b);
        }
    }
    if (match($result, "File::Spec->catdir\\s*\\(") && !match($result, "#")) {
        my array @fscd_cap = capture($result, "File::Spec->catdir\\s*\\(([^,]+),\\s*([^)]+)\\)");
        if (scalar(@fscd_cap) > 2) {
            my str $fscd_a = trim_str($fscd_cap[1]);
            my str $fscd_b = trim_str($fscd_cap[2]);
            $result = replace($result, "File::Spec->catdir\\s*\\([^)]+\\)", $fscd_a . " . \"/\" . " . $fscd_b);
        }
    }
    if (match($result, "File::Spec->tmpdir") && !match($result, "#")) {
        $result = replace_all($result, "File::Spec->tmpdir()", "\"/tmp\"");
        $result = replace_all($result, "File::Spec->tmpdir", "\"/tmp\"");
    }
    if (match($result, "File::Spec->devnull") && !match($result, "#")) {
        $result = replace_all($result, "File::Spec->devnull()", "\"/dev/null\"");
        $result = replace_all($result, "File::Spec->devnull", "\"/dev/null\"");
    }
    # Handle File::Spec:: forms (after Class->method to Class::method conversion)
    if (match($result, "File::Spec::tmpdir") && !match($result, "#") && !match($result, "\"/tmp\"")) {
        $result = replace_all($result, "File::Spec::tmpdir()", "\"/tmp\"");
        $result = replace_all($result, "File::Spec::tmpdir", "\"/tmp\"");
    }
    if (match($result, "File::Spec::devnull") && !match($result, "#") && !match($result, "\"/dev/null\"")) {
        $result = replace_all($result, "File::Spec::devnull()", "\"/dev/null\"");
        $result = replace_all($result, "File::Spec::devnull", "\"/dev/null\"");
    }
    if (match($result, "File::Spec->abs2rel\\s*\\(") && !match($result, "#")) {
        $result = $result . "  # REVIEW: File::Spec->abs2rel â€” no direct Strada equivalent; use string manipulation";
    }

    # ---- File::Slurp / File::Slurper function conversions ----
    if (match($result, "\\bread_file\\s*\\(") && !match($result, "#") && !match($result, "core::slurp")) {
        $result = replace($result, "\\bread_file\\s*\\(", "core::slurp(");
    }
    if (match($result, "\\bwrite_file\\s*\\(") && !match($result, "#") && !match($result, "core::spew")) {
        $result = replace($result, "\\bwrite_file\\s*\\(", "core::spew(");
    }
    if (match($result, "\\bread_text\\s*\\(") && !match($result, "#") && !match($result, "core::slurp")) {
        $result = replace($result, "\\bread_text\\s*\\(", "core::slurp(");
    }
    if (match($result, "\\bwrite_text\\s*\\(") && !match($result, "#") && !match($result, "core::spew")) {
        $result = replace($result, "\\bwrite_text\\s*\\(", "core::spew(");
    }
    if (match($result, "\\bappend_file\\s*\\(") && !match($result, "#")) {
        $result = $result . "  # REVIEW: append_file() â€” use core::open($path, \"a\") + say($fh, $data) + core::close($fh)";
    }
    if (match($result, "\\bread_dir\\s*\\(") && !match($result, "#") && !match($result, "core::readdir")) {
        $result = replace($result, "\\bread_dir\\s*\\(", "core::readdir(");
    }

    # ---- Cwd bare cwd() ----
    if (match($result, "\\bcwd\\s*\\(") && !match($result, "#") && !match($result, "core::getcwd") && !match($result, "getcwd")) {
        $result = replace($result, "\\bcwd\\s*\\(", "core::getcwd(");
    }

    # ---- File::Glob / bsd_glob ----
    if (match($result, "\\bbsd_glob\\s*\\(") && !match($result, "#") && !match($result, "core::glob")) {
        $result = replace($result, "\\bbsd_glob\\s*\\(", "core::glob(");
    }

    # ---- Sys::Syslog functions ----
    if (match($result, "\\bopenlog\\s*\\(") && !match($result, "#") && !match($result, "core::openlog")) {
        $result = replace($result, "\\bopenlog\\s*\\(", "core::openlog(");
    }
    if (match($result, "\\bsyslog\\s*\\(") && !match($result, "#") && !match($result, "core::syslog")) {
        $result = replace($result, "\\bsyslog\\s*\\(", "core::syslog(");
    }
    if (match($result, "\\bcloselog\\s*\\(") && !match($result, "#") && !match($result, "core::closelog")) {
        $result = replace($result, "\\bcloselog\\s*\\(", "core::closelog(");
    }

    # ---- Sys::Hostname::hostname qualified ----
    if (match($result, "\\bSys::Hostname::hostname\\s*\\(") && !match($result, "#")) {
        $result = replace($result, "\\bSys::Hostname::hostname\\s*\\(", "core::gethostname(");
    }

    # DBI handle method annotations - pass through WITHOUT unnecessary TODOs
    # Since Strada DBI uses the same API, these method calls are valid Strada code
    if (match($result, "->prepare\\s*\\(") && !match($result, "#.*TODO")) {
        # DBI prepare() - Strada DBI uses same API, no annotation needed
    }
    if (match($result, "->execute\\s*\\(") && !match($result, "#.*TODO") && !match($result, "->execute_")) {
        # DBI execute() - Strada DBI uses same API, no annotation needed
    }
    if (match($result, "->fetchrow_hashref") && !match($result, "#.*TODO")) {
        # DBI fetchrow_hashref() - Strada DBI uses same API, no annotation needed
    }
    # Getopt::Long - GetOptions() -> argv parsing loop
    if (match($result, "\\bGetOptions\\s*\\(") && !match($result, "#")) {
        # Extract the contents of GetOptions(...)
        my int $go_paren = index($result, "GetOptions(");
        if ($go_paren >= 0) {
            my int $go_start = $go_paren + 11;
            # Find matching close paren
            my int $go_depth = 1;
            my int $go_pos = $go_start;
            my int $go_len = length($result);
            while ($go_pos < $go_len && $go_depth > 0) {
                my str $go_ch = substr($result, $go_pos, 1);
                if ($go_ch eq "(") { $go_depth++; }
                if ($go_ch eq ")") { $go_depth--; }
                $go_pos++;
            }
            my str $go_args = "";
            if ($go_depth == 0) {
                $go_args = substr($result, $go_start, $go_pos - $go_start - 1);
            }
            if (length($go_args) > 0) {
                # Parse option specs: 'opt_spec' => \$var or 'opt_spec' => \@arr or 'opt_spec' => \&func
                # Supported specs: 'name', 'name!', 'name=s', 'name=i', 'name=f', 'name|alias=s'
                my str $go_loop = "";
                my str $go_items = $go_args;
                my int $go_ok = 1;
                my int $go_count = 0;
                # Split on => and process pairs
                # Pattern: 'spec' => \$var,  or  "spec" => \$var
                while (length($go_items) > 0 && $go_ok == 1) {
                    $go_items = trim_str($go_items);
                    if (length($go_items) == 0) { last; }
                    # Skip leading comma
                    if (starts_with($go_items, ",")) {
                        $go_items = trim_str(substr($go_items, 1, length($go_items) - 1));
                    }
                    if (length($go_items) == 0) { last; }
                    # Extract quoted spec
                    my str $go_spec = "";
                    my str $go_quote = substr($go_items, 0, 1);
                    if ($go_quote eq "'" || $go_quote eq "\"") {
                        # Find closing quote after position 1
                        my int $go_end = index(substr($go_items, 1, length($go_items) - 1), $go_quote);
                        if ($go_end >= 0) {
                            $go_end = $go_end + 1;
                            $go_spec = substr($go_items, 1, $go_end - 1);
                            $go_items = trim_str(substr($go_items, $go_end + 1, length($go_items) - $go_end - 1));
                        } else {
                            $go_ok = 0;
                        }
                    } else {
                        $go_ok = 0;
                    }
                    if ($go_ok == 0) { last; }
                    # Skip =>
                    if (starts_with($go_items, "=>")) {
                        $go_items = trim_str(substr($go_items, 2, length($go_items) - 2));
                    } else {
                        $go_ok = 0;
                        last;
                    }
                    # Extract variable reference: \$var, \@var, or \&func
                    my str $go_var = "";
                    if (starts_with($go_items, "\\")) {
                        # Find end of variable name
                        my int $go_vi = 1;
                        # Skip sigil ($, @, &, %)
                        if ($go_vi < length($go_items)) {
                            $go_vi++;
                        }
                        while ($go_vi < length($go_items)) {
                            my str $go_vc = substr($go_items, $go_vi, 1);
                            if (match($go_vc, "[A-Za-z0-9_]")) {
                                $go_vi++;
                            } else {
                                last;
                            }
                        }
                        $go_var = substr($go_items, 1, $go_vi - 1);
                        $go_items = trim_str(substr($go_items, $go_vi, length($go_items) - $go_vi));
                    } else {
                        $go_ok = 0;
                        last;
                    }
                    # Parse the option spec: name, name|alias, name=s, name=i, name=f, name!
                    my str $go_name = $go_spec;
                    my str $go_type = "bool";
                    my str $go_alias = "";
                    # Check for type suffix
                    if (match($go_spec, "=s$")) {
                        $go_name = substr($go_spec, 0, length($go_spec) - 2);
                        $go_type = "str";
                    }
                    if (match($go_spec, "=i$")) {
                        $go_name = substr($go_spec, 0, length($go_spec) - 2);
                        $go_type = "int";
                    }
                    if (match($go_spec, "=f$")) {
                        $go_name = substr($go_spec, 0, length($go_spec) - 2);
                        $go_type = "num";
                    }
                    if (match($go_spec, "!$")) {
                        $go_name = substr($go_spec, 0, length($go_spec) - 1);
                        $go_type = "neg";
                    }
                    # Check for alias: name|alias
                    my int $go_pipe = index($go_name, "|");
                    if ($go_pipe >= 0) {
                        $go_alias = substr($go_name, $go_pipe + 1, length($go_name) - $go_pipe - 1);
                        $go_name = substr($go_name, 0, $go_pipe);
                    }
                    # Generate the if/elsif clause
                    my str $go_flag = "--" . $go_name;
                    my str $go_short = "";
                    if (length($go_alias) > 0) {
                        if (length($go_alias) == 1) {
                            $go_short = "-" . $go_alias;
                        } else {
                            $go_short = "--" . $go_alias;
                        }
                    }
                    my str $go_cond = "";
                    if ($go_type eq "bool") {
                        $go_cond = "if ($__arg eq \"" . $go_flag . "\"";
                        if (length($go_short) > 0) {
                            $go_cond = $go_cond . " || $__arg eq \"" . $go_short . "\"";
                        }
                        $go_cond = $go_cond . ") { " . $go_var . " = 1; }";
                    }
                    if ($go_type eq "neg") {
                        $go_cond = "if ($__arg eq \"" . $go_flag . "\"";
                        if (length($go_short) > 0) {
                            $go_cond = $go_cond . " || $__arg eq \"" . $go_short . "\"";
                        }
                        $go_cond = $go_cond . ") { " . $go_var . " = 1; }";
                        $go_cond = $go_cond . " elsif ($__arg eq \"--no-" . $go_name . "\" || $__arg eq \"--no" . $go_name . "\") { " . $go_var . " = 0; }";
                    }
                    if ($go_type eq "str" || $go_type eq "int" || $go_type eq "num") {
                        $go_cond = "if ($__arg eq \"" . $go_flag . "\"";
                        if (length($go_short) > 0) {
                            $go_cond = $go_cond . " || $__arg eq \"" . $go_short . "\"";
                        }
                        $go_cond = $go_cond . ") { $__argi++; " . $go_var . " = core::argv($__argi); }";
                    }
                    if (length($go_cond) > 0) {
                        if ($go_count > 0) {
                            $go_loop = $go_loop . "\n" . $indent . "    els" . $go_cond;
                        } else {
                            $go_loop = $go_loop . "\n" . $indent . "    " . $go_cond;
                        }
                        $go_count++;
                    }
                }
                if ($go_ok == 1 && $go_count > 0) {
                    $result = $indent . "# REVIEW: auto-converted from GetOptions - verify flag parsing";
                    $result = $result . "\n" . $indent . "my int $__argi = 1;";
                    $result = $result . "\n" . $indent . "while ($__argi < core::argc()) {";
                    $result = $result . "\n" . $indent . "    my str $__arg = core::argv($__argi);";
                    $result = $result . $go_loop;
                    $result = $result . "\n" . $indent . "    $__argi++;";
                    $result = $result . "\n" . $indent . "}";
                } else {
                    $result = $result . "  # REVIEW: GetOptions() - convert to core::argv() loop manually";
                }
            } else {
                $result = $result . "  # REVIEW: GetOptions() - convert to core::argv() loop manually";
            }
        }
    }

    # ---- /r flag (non-destructive substitution) ----
    # my $new = $old =~ s/foo/bar/r;  -> copy then modify
    # $var = $src =~ s/pat/rep/[gi]r -> $var = $src; $var =~ s/pat/rep/[gi];
    if (match($result, "=~\\s*s/[^/]*/[^/]*/[a-z]*r") && !match($result, "#")) {
        # Check if this is an assignment: $dest = $src =~ s/pat/rep/flags_r
        my array @r_cap = capture($result, "(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*=~\\s*(s/[^/]*/[^/]*/[a-z]*)r");
        if (scalar(@r_cap) > 3) {
            my str $r_dest = $r_cap[1];
            my str $r_src = $r_cap[2];
            my str $r_subst = $r_cap[3];
            $result = $indent . $r_dest . " = " . $r_src . "; " . $r_dest . " =~ " . $r_subst . ";  # was s///r (non-destructive)";
        }
        # Check if my $dest = $src =~ s/pat/rep/flags_r
        elsif (match($result, "\\bmy\\s+")) {
            my array @r_cap2 = capture($result, "my\\s+(scalar\\s+|str\\s+)?\\$([A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*=~\\s*(s/[^/]*/[^/]*/[a-z]*)r");
            if (scalar(@r_cap2) > 4) {
                my str $r_type = trim_str($r_cap2[1]);
                my str $r_name = $r_cap2[2];
                my str $r_src2 = $r_cap2[3];
                my str $r_subst2 = $r_cap2[4];
                if (length($r_type) == 0) { $r_type = "scalar"; }
                $result = $indent . "my " . $r_type . " $" . $r_name . " = " . $r_src2 . "; $" . $r_name . " =~ " . $r_subst2 . ";  # was s///r (non-destructive)";
            } else {
                # Fallback: just strip the /r flag and add REVIEW
                $result = replace($result, "(s/[^/]*/[^/]*/[a-z]*)r", "$1");
                $result = $result . "  # REVIEW: had /r flag (non-destructive) - assign copy first, then modify";
            }
        } else {
            # Fallback: strip /r flag and add REVIEW
            $result = replace($result, "(s/[^/]*/[^/]*/[a-z]*)r", "$1");
            $result = $result . "  # REVIEW: had /r flag (non-destructive) - assign copy first, then modify";
        }
    }

    # ---- Global match in list context ----
    # my @matches = ($str =~ /pattern/g); -> while loop collecting captures
    # my @matches = $str =~ /pattern/g; -> while loop collecting captures
    if (match($result, "@[A-Za-z_].*=\\s*.*=~\\s*/[^/]*/[a-z]*g") && !match($result, "#") && !match($result, "=~\\s*s/")) {
        my int $gm_converted = 0;
        # Try: my @arr = ($var =~ /pattern/g); or my @arr = $var =~ /pattern/g;
        my array @gm_cap = capture($result, "my\\s+(array\\s+)?@([A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*\\(?\\s*(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*=~\\s*/([^/]*)/([a-z]*)g\\)?");
        if (scalar(@gm_cap) > 4) {
            my str $gm_arrname = $gm_cap[2];
            my str $gm_var = $gm_cap[3];
            my str $gm_pat = $gm_cap[4];
            my str $gm_flags = $gm_cap[5];
            # Check if pattern has a capture group
            if (index($gm_pat, "(") >= 0 && index($gm_pat, ")") >= 0) {
                $result = $indent . "my array @" . $gm_arrname . "; while (" . $gm_var . " =~ /" . $gm_pat . "/" . $gm_flags . "g) { push(@" . $gm_arrname . ", " . chr(36) . "1); }";
                $gm_converted = 1;
            }
        }
        if ($gm_converted == 0) {
            # Also try without my: @arr = ($var =~ /pattern/g);
            my array @gm_cap2 = capture($result, "@([A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*\\(?\\s*(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*=~\\s*/([^/]*)/([a-z]*)g\\)?");
            if (scalar(@gm_cap2) > 3) {
                my str $gm_arr2 = $gm_cap2[1];
                my str $gm_var2 = $gm_cap2[2];
                my str $gm_pat2 = $gm_cap2[3];
                my str $gm_flags2 = $gm_cap2[4];
                if (index($gm_pat2, "(") >= 0 && index($gm_pat2, ")") >= 0) {
                    $result = $indent . "@" . $gm_arr2 . " = (); while (" . $gm_var2 . " =~ /" . $gm_pat2 . "/" . $gm_flags2 . "g) { push(@" . $gm_arr2 . ", " . chr(36) . "1); }";
                    $gm_converted = 1;
                }
            }
        }
        if ($gm_converted == 0 && !match($result, "#.*REVIEW")) {
            $result = $result . "  # REVIEW: global match in list context - use a while loop with match() to collect captures";
        }
    }

    # ---- Regex flags detection ----
    # s/pattern/replace/e and s/pattern/replace/eg -> natively supported in Strada with PCRE2
    # $1-$9 backreferences are natively supported in Strada
    # /i, /s, /x flags are supported with PCRE2 (may need review for POSIX fallback)
    if (match($result, "=~\\s*s/[^/]*/[^/]*/[a-z]*e") && !match($result, "#.*REVIEW")) {
        $result = $result . "  # REVIEW: /e flag (eval replacement) - Strada supports s///e with PCRE2; ensure replacement is valid Strada expression";
    }
    # /i, /s, /x flags are standard with PCRE2 in Strada â€” no REVIEW needed

    # ---- Regex backreferences ($1-$9) ----
    # Strada natively supports $1-$9 as capture variables, so pass them through.
    # String interpolation of $1 in "...$1..." is handled by convert_interpolation() above.

    # ---- Named captures: $+{name} -> named_captures(){"name"} ----
    if (match($result, "\\$\\+\\{") && !match($result, "#")) {
        my int $nc_safety = 0;
        while (match($result, "\\$\\+\\{[A-Za-z_]") && $nc_safety < 20) {
            my array @nc_cap = capture($result, "\\$\\+\\{([A-Za-z_][A-Za-z0-9_]*)\\}");
            if (scalar(@nc_cap) > 1) {
                my str $nc_name = $nc_cap[1];
                $result = replace($result, "\\$\\+\\{" . $nc_name . "\\}", "named_captures(){\"" . $nc_name . "\"}");
            } else {
                $nc_safety = 20;
            }
            $nc_safety++;
        }
    }

    # ---- Named capture groups: (?P<name>...) -> (?P<name>...) (pass through - PCRE2 native) ----
    # Strada's PCRE2 backend supports (?P<name>...) natively, so pass them through.

    # ---- Try::Tiny catch { $_ } -> catch ($e) { $e } ----
    # Try::Tiny uses: catch { ... $_  ... }; where $_ is the exception
    # Strada uses: catch ($e) { ... $e ... }
    if (match($result, "\\}\\s*catch\\s*\\{") || match($result, "^\\s*catch\\s*\\{")) {
        # catch { -> catch ($e) {
        $result = replace($result, "\\bcatch\\s*\\{", "catch ($e) {");
        # Replace $_ inside catch block with $e (only for single-line catch blocks)
        # This is approximate but handles the common case
    }

    # ---- Try::Tiny finally { ... } -> strip finally wrapper, keep body ----
    if (match($result, "\\bfinally\\s*\\{") && !match($result, "#")) {
        $result = replace($result, "\\}?;?\\s*finally\\s*\\{", "# finally block (runs after try/catch):");
    }
    # Closing };  after a finally block (orphaned) -> remove
    if (match($result, "^\\s*\\};\\s*$") && !match($result, "#")) {
        # Only remove if it looks like a straggler closure
    }

    # ---- Anonymous sub fallback (should be handled earlier, but catch stragglers) ----
    # Note: skip "sub name" (named subs) which are handled by pass 2
    if (match($result, "\\bsub\\s*\\{") && !match($result, "\\bsub\\s+[A-Za-z_]")) {
        my int $sub_safety = 0;
        while (match($result, "\\bsub\\s*\\{") && $sub_safety < 10) {
            $result = replace($result, "\\bsub\\s*\\{", "func (scalar ...@_) scalar {");
            $sub_safety++;
        }
    }

    # ---- Deref syntax ----
    # @$ref -> @{$ref}  (normalize to brace form)
    if (match($result, "@\\$[A-Za-z_]") && !match($result, "@\\{\\$")) {
        my int $ad_safety = 0;
        while (match($result, "@\\$[A-Za-z_]") && !match($result, "@\\{\\$") && $ad_safety < 10) {
            my array @adcap = capture($result, "@\\$([A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@adcap) > 1) {
                my str $ad_name = $adcap[1];
                $result = replace($result, "@\\$" . $ad_name, "@{$" . $ad_name . "}");
            } else {
                $ad_safety = 10;
            }
            $ad_safety++;
        }
    }
    # %$ref -> %{$ref}  (normalize to brace form)
    if (match($result, "%\\$[A-Za-z_]") && !match($result, "%\\{\\$")) {
        my int $hd_safety = 0;
        while (match($result, "%\\$[A-Za-z_]") && !match($result, "%\\{\\$") && $hd_safety < 10) {
            my array @hdcap = capture($result, "%\\$([A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@hdcap) > 1) {
                my str $hd_name = $hdcap[1];
                $result = replace($result, "%\\$" . $hd_name, "%{$" . $hd_name . "}");
            } else {
                $hd_safety = 10;
            }
            $hd_safety++;
        }
    }
    # ---- Postfix dereference (Perl 5.20+): $ref->@* -> @{$ref}, $ref->%* -> %{$ref} ----
    if (match($result, "->@\\*") && !match($result, "#")) {
        # $ref->@* -> @{$ref}
        my int $pd_safety = 0;
        while (match($result, "(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*->@\\*") && $pd_safety < 10) {
            my array @pd_cap = capture($result, "(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*->@\\*");
            if (scalar(@pd_cap) > 1) {
                my str $pd_var = $pd_cap[1];
                $result = replace($result, "\\$" . substr($pd_var, 1, length($pd_var) - 1) . "\\s*->@\\*", "@{" . $pd_var . "}");
            } else {
                $pd_safety = 10;
            }
            $pd_safety++;
        }
    }
    if (match($result, "->%\\*") && !match($result, "#")) {
        # $ref->%* -> %{$ref}
        my int $pd_safety2 = 0;
        while (match($result, "(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*->%\\*") && $pd_safety2 < 10) {
            my array @pd_cap2 = capture($result, "(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*->%\\*");
            if (scalar(@pd_cap2) > 1) {
                my str $pd_var2 = $pd_cap2[1];
                $result = replace($result, "\\$" . substr($pd_var2, 1, length($pd_var2) - 1) . "\\s*->%\\*", "%{" . $pd_var2 . "}");
            } else {
                $pd_safety2 = 10;
            }
            $pd_safety2++;
        }
    }
    # $ref->$* -> ${$ref}  (scalar deref) - use index/replace_all since $ can't be matched in POSIX regex
    my str $pd_arrow_dollar = "->" . "$" . "*";
    if (index($result, $pd_arrow_dollar) >= 0 && !match($result, "#")) {
        my str $dol_brace = "$" . "{";
        # Find $varname immediately before ->$*
        my int $pd_pos = index($result, $pd_arrow_dollar);
        if ($pd_pos > 0) {
            # Scan backwards from pd_pos to find start of $varname
            my int $pd_start = $pd_pos - 1;
            while ($pd_start > 0 && match(substr($result, $pd_start, 1), "[A-Za-z0-9_]")) {
                $pd_start--;
            }
            # Check for $ at pd_start
            if (substr($result, $pd_start, 1) eq "$") {
                my str $pd_varname = substr($result, $pd_start, $pd_pos - $pd_start);
                my str $pd_before = substr($result, 0, $pd_start);
                my str $pd_after = substr($result, $pd_pos + length($pd_arrow_dollar), length($result) - $pd_pos - length($pd_arrow_dollar));
                $result = $pd_before . $dol_brace . $pd_varname . "}" . $pd_after;
            }
        }
    }
    # Postfix slice: $ref->@[...] -> @{$ref}[...]
    if (match($result, "->@\\[") && !match($result, "#")) {
        # $ref->@[0,1,2] -> @{$ref}[0,1,2]
        my array @pas_cap = capture($result, "(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*->@\\[");
        if (scalar(@pas_cap) > 1) {
            my str $pas_ref = $pas_cap[1];
            $result = replace($result, "\\$[A-Za-z_][A-Za-z0-9_]*\\s*->@\\[", "@{" . $pas_ref . "}[");
        }
    }
    # Postfix hash slice: $ref->%{...} -> @{$ref}{...}
    if (match($result, "->%\\{") && !match($result, "->%\\*") && !match($result, "#")) {
        my array @phs_cap = capture($result, "(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*->%\\{");
        if (scalar(@phs_cap) > 1) {
            my str $phs_ref = $phs_cap[1];
            $result = replace($result, "\\$[A-Za-z_][A-Za-z0-9_]*\\s*->%\\{", "@{" . $phs_ref . "}{");
        }
    }

    # All dereference syntax ($$ref, ${$expr}, @{$ref}, %{$ref}) works natively.
    # Slices (@hash{list}, @array[list]) are natively supported in Strada.

    # ---- Control flow & misc TODOs ----
    # while (<>) / while (<STDIN>) -> core::readline() loop
    if (match($result, "while\\s*\\(.*<")) {
        # while (my $line = <STDIN>) -> while (defined(my scalar $line = core::readline()))
        if (match($result, "while\\s*\\(\\s*my\\s+[^=]+=\\s*<STDIN>\\s*\\)")) {
            my array @wlcap = capture($result, "while\\s*\\(\\s*my\\s+\\S*\\s*\\$([A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*<STDIN>\\s*\\)");
            if (scalar(@wlcap) > 1) {
                my str $wl_var = $wlcap[1];
                $result = replace($result, "while\\s*\\(\\s*my\\s+\\S*\\s*\\$[A-Za-z_][A-Za-z0-9_]*\\s*=\\s*<STDIN>\\s*\\)", "while (defined(my str $" . $wl_var . " = core::readline()))");
            }
        }
        # while (my $line = <$fh>) -> while (defined(my str $line = <$fh>))
        elsif (match($result, "while\\s*\\(\\s*my\\s+[^=]+=\\s*<\\$[A-Za-z_]")) {
            my array @wfcap = capture($result, "while\\s*\\(\\s*my\\s+\\S*\\s*\\$([A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*(<\\$[A-Za-z_][A-Za-z0-9_]*>)\\s*\\)");
            if (scalar(@wfcap) > 2) {
                my str $wf_var = $wfcap[1];
                my str $wf_fh = $wfcap[2];
                $result = replace($result, "while\\s*\\(\\s*my\\s+\\S*\\s*\\$[A-Za-z_][A-Za-z0-9_]*\\s*=\\s*<\\$[A-Za-z_][A-Za-z0-9_]*>\\s*\\)", "while (defined(my str $" . $wf_var . " = " . $wf_fh . "))");
            }
        }
        # while (<STDIN>) -> while (defined(my str $_ = core::readline()))
        elsif (match($result, "while\\s*\\(\\s*<STDIN>\\s*\\)")) {
            $result = replace($result, "while\\s*\\(\\s*<STDIN>\\s*\\)", "while (defined(my str $__line = core::readline()))  # REVIEW: was while (<STDIN>), $_ is now $__line");
        }
        # while (<>) -> while (defined(my str $_ = core::readline()))
        elsif (match($result, "while\\s*\\(\\s*<>\\s*\\)")) {
            $result = replace($result, "while\\s*\\(\\s*<>\\s*\\)", "while (defined(my str $__line = core::readline()))  # was while (<>), reads STDIN only (Perl also reads @ARGV files)");
        }
    }
    # tr/a-z/A-Z/ and y/a-z/A-Z/ -> natively supported in Strada, no conversion needed
    # tr///r (non-destructive) -> copy-then-modify: my $upper = $text =~ tr/a-z/A-Z/r -> my scalar $upper = $text; $upper =~ tr/a-z/A-Z/;
    if (match($result, "=~\\s*(tr|y)/[^/]*/[^/]*/r") && !match($result, "#")) {
        # Check for my $dest = $src =~ tr/from/to/r FIRST (before non-my, to avoid losing 'my')
        if (match($result, "\\bmy\\s+")) {
            my array @tr_cap2 = capture($result, "my\\s+(scalar\\s+|str\\s+)?\\$([A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*=~\\s*((tr|y)/[^/]*/[^/]*/)r");
            if (scalar(@tr_cap2) > 4) {
                my str $tr_type = trim_str($tr_cap2[1]);
                my str $tr_name = $tr_cap2[2];
                my str $tr_src2 = $tr_cap2[3];
                my str $tr_subst2 = $tr_cap2[4];
                if (length($tr_type) == 0) { $tr_type = "scalar"; }
                $result = $indent . "my " . $tr_type . " $" . $tr_name . " = " . $tr_src2 . "; $" . $tr_name . " =~ " . $tr_subst2 . ";  # was tr///r (non-destructive)";
            } else {
                $result = replace($result, "((tr|y)/[^/]*/[^/]*/)r", "$1");
                $result = $result . "  # REVIEW: had tr///r flag (non-destructive) - assign copy first, then modify";
            }
        } else {
            # $dest = $src =~ tr/from/to/r (no my)
            my array @tr_cap = capture($result, "(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*=\\s*(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*=~\\s*((tr|y)/[^/]*/[^/]*/)r");
            if (scalar(@tr_cap) > 3) {
                my str $tr_dest = $tr_cap[1];
                my str $tr_src = $tr_cap[2];
                my str $tr_subst = $tr_cap[3];
                $result = $indent . $tr_dest . " = " . $tr_src . "; " . $tr_dest . " =~ " . $tr_subst . ";  # was tr///r (non-destructive)";
            } else {
                $result = replace($result, "((tr|y)/[^/]*/[^/]*/)r", "$1");
                $result = $result . "  # REVIEW: had tr///r flag (non-destructive) - assign copy first, then modify";
            }
        }
    }
    # study($var) / study $var -> comment out (no-op in modern Perl, not needed in Strada)
    if (match($result, "\\bstudy\\s*[\\(\\$]") && !match($result, "#")) {
        $result = $indent . "# " . $trimmed . "  # study() is a no-op in modern Perl; not needed in Strada";
    }
    # qr// and qr{} are handled earlier (before q/qq conversion)
    # given ($x) { -> { my scalar $__given = $x;  (convert to scoped variable for when->if)
    if (match($result, "\\bgiven\\s*\\(") && !match($result, "#")) {
        my array @gv_cap = capture($result, "\\bgiven\\s*\\(([^)]*)\\)\\s*\\{");
        if (scalar(@gv_cap) > 1) {
            my str $gv_expr = $gv_cap[1];
            $result = $indent . "{ my scalar $__given = " . $gv_expr . ";  # was: given(" . $gv_expr . ")";
            # Reset the when-chain state for this given block
            $sub_info{"__given_when_active"} = "";
        } else {
            $result = $result . "  # REVIEW: convert given/when to if/elsif manually";
        }
    }
    # when ($x) { -> if/elsif ($__given == $x) {  (or eq for strings, =~ for regex)
    if (match($result, "\\bwhen\\s*\\(") && !match($result, "#")) {
        my array @wh_cap = capture($result, "\\bwhen\\s*\\(([^)]*)\\)");
        if (scalar(@wh_cap) > 1) {
            my str $wh_val = $wh_cap[1];
            # Determine if this is the first when (use "if") or subsequent (use "elsif")
            my str $wh_keyword = "if";
            if (length("" . $sub_info{"__given_when_active"}) > 0) {
                $wh_keyword = "} elsif";
            }
            $sub_info{"__given_when_active"} = "1";
            # Auto-detect: regex pattern, number, string, or variable
            if (match($wh_val, "^\\s*/")) {
                # Regex pattern: when (/pattern/) -> if ($__given =~ /pattern/)
                $result = replace($result, "\\bwhen\\s*\\([^)]*\\)", $wh_keyword . " ($__given =~ " . trim_str($wh_val) . ")");
            } elsif (match($wh_val, "^\\s*[0-9]") || match($wh_val, "^\\s*-[0-9]")) {
                $result = replace($result, "\\bwhen\\s*\\([^)]*\\)", $wh_keyword . " ($__given == " . $wh_val . ")");
            } elsif (match($wh_val, "^\\s*[\"']")) {
                $result = replace($result, "\\bwhen\\s*\\([^)]*\\)", $wh_keyword . " ($__given eq " . $wh_val . ")");
            } else {
                # Variable - default to eq, add REVIEW
                $result = replace($result, "\\bwhen\\s*\\([^)]*\\)", $wh_keyword . " ($__given eq " . $wh_val . ")");
                $result = $result . "  # REVIEW: was when() - check == vs eq";
            }
        }
    }
    # default { -> else {
    if (match($result, "\\bdefault\\s*\\{") && !match($result, "#")) {
        if (length("" . $sub_info{"__given_when_active"}) > 0) {
            $result = replace($result, "\\bdefault\\s*\\{", "} else {");
        } else {
            $result = replace($result, "\\bdefault\\s*\\{", "else {");
        }
        $sub_info{"__given_when_active"} = "";
        $result = $result . "  # was: default";
    }
    # redo -> natively supported in Strada, no conversion needed
    # __FILE__ and __LINE__ work natively in Strada - no conversion needed
    # require "file" -> use import_lib
    if (match($result, "\\brequire\\s+[\"']") && !match($result, "#")) {
        my array @rqf_cap = capture($result, "\\brequire\\s+[\"']([^\"']+)[\"']");
        if (scalar(@rqf_cap) > 1) {
            my str $rqf_file = $rqf_cap[1];
            # Convert Perl module path to import_lib
            if (match($rqf_file, "\\.pm$")) {
                my str $rqf_mod = replace_all($rqf_file, "/", "::");
                $rqf_mod = replace($rqf_mod, "\\.pm$", "");
                $result = $indent . "use " . $rqf_mod . ";  # was: require \"" . $rqf_file . "\"";
            } else {
                $result = $indent . "# " . $trimmed . "  # REVIEW: use import_lib(\"" . $rqf_file . "\") in Strada";
            }
        } else {
            $result = $indent . "# " . $trimmed . "  # REVIEW: use import_lib in Strada";
        }
    }
    # require Module -> use Module
    if (match($result, "\\brequire\\s+[A-Z]") && !match($result, "#")) {
        my array @rqm_cap = capture($result, "\\brequire\\s+([A-Z][A-Za-z0-9_:]*)");
        if (scalar(@rqm_cap) > 1) {
            $result = replace($result, "\\brequire\\s+[A-Z][A-Za-z0-9_:]*", "use " . $rqm_cap[1]);
        }
    }
    # require $var -> dynamic module loading
    if (match($result, "\\brequire\\s+\\$[A-Za-z_]") && !match($result, "#")) {
        my array @rqv_cap = capture($result, "\\brequire\\s+(\\$[A-Za-z_][A-Za-z0-9_]*)");
        if (scalar(@rqv_cap) > 1) {
            $result = $indent . "# " . $trimmed . "  # REVIEW: dynamic require â€” use import_lib(" . $rqv_cap[1] . ") or load at compile time with 'use'";
        }
    }
    # do "file.pl" -> use Module or import_lib
    if (match($result, "\\bdo\\s+[\"']") && !match($result, "#")) {
        my array @do_cap = capture($result, "\\bdo\\s+[\"']([^\"']+)[\"']");
        if (scalar(@do_cap) > 1) {
            my str $do_file = $do_cap[1];
            # Convert path/to/file.pm to Module::Name
            my str $do_mod = replace_all($do_file, "/", "::");
            $do_mod = replace_all($do_mod, ".pm", "");
            $do_mod = replace_all($do_mod, ".pl", "");
            $result = replace($result, "\\bdo\\s+[\"'][^\"']+[\"']", "use " . $do_mod);
            $result = $result . "  # REVIEW: was do \"" . $do_file . "\" â€” converted to use";
        } else {
            $result = $result . "  # REVIEW: do \"file\" â€” use import_lib() in Strada";
        }
    }
    # splice(@arr, ...) -> natively supported in Strada, no conversion needed
    # hex("ff") -> core::hex("ff")
    if (match($result, "\\bhex\\s*\\(") && !match($result, "#") && !match($result, "core::hex")) {
        $result = replace_all($result, "hex(", "core::hex(");
    }
    # hex $var or hex shift -> core::hex($var)
    if (match($result, "\\bhex\\s+[A-Za-z_]") && !match($result, "#") && !match($result, "core::hex")) {
        $result = replace_all($result, "hex ", "core::hex(");
        $result = add_close_paren($result);
    }
    # oct("77") -> core::oct()
    if (match($result, "\\boct\\s*\\(") && !match($result, "#") && !match($result, "core::oct")) {
        $result = replace($result, "\\boct\\s*\\(", "core::oct(");
    }
    # quotemeta($str) -> core::quotemeta($str)
    if (match($result, "\\bquotemeta\\s*\\(") && !match($result, "#") && !match($result, "core::quotemeta")) {
        $result = replace($result, "\\bquotemeta\\s*\\(", "core::quotemeta(");
    }
    # \Q...\E inside strings/regex -> REVIEW (PCRE2 supports \Q\E natively in regex)
    if (match($result, "\\\\Q") && match($result, "\\\\E") && !match($result, "#.*REVIEW")) {
        $result = $result . "  # REVIEW: \\Q...\\E - in regex this works with PCRE2; in strings, use core::quotemeta() instead";
    }

    # ---- getpwnam/getgrnam/getpwuid/getgrgid -> core:: calls ----
    if (match($result, "\\bgetpwnam\\s*\\(") && !match($result, "#") && !match($result, "->") && !match($result, "core::getpwnam")) {
        $result = replace($result, "\\bgetpwnam\\s*\\(", "core::getpwnam(");
        $result = $result . "  # returns hash: name, uid, gid, dir, shell";
    }
    if (match($result, "\\bgetgrnam\\s*\\(") && !match($result, "#") && !match($result, "->") && !match($result, "core::getgrnam")) {
        $result = replace($result, "\\bgetgrnam\\s*\\(", "core::getgrnam(");
        $result = $result . "  # returns hash: name, gid, members";
    }
    if (match($result, "\\bgetpwuid\\s*\\(") && !match($result, "#") && !match($result, "->") && !match($result, "core::getpwuid")) {
        $result = replace($result, "\\bgetpwuid\\s*\\(", "core::getpwuid(");
        $result = $result . "  # returns hash: name, uid, gid, dir, shell";
    }
    if (match($result, "\\bgetgrgid\\s*\\(") && !match($result, "#") && !match($result, "->") && !match($result, "core::getgrgid")) {
        $result = replace($result, "\\bgetgrgid\\s*\\(", "core::getgrgid(");
        $result = $result . "  # returns hash: name, gid, members";
    }

    # ---- System builtins -> core:: calls ----
    if (match($result, "\\bfcntl\\s*\\(") && !match($result, "#") && !match($result, "->") && !match($result, "core::fcntl")) {
        $result = replace($result, "\\bfcntl\\s*\\(", "core::fcntl(");
    }
    if (match($result, "\\bioctl\\s*\\(") && !match($result, "#") && !match($result, "->") && !match($result, "core::ioctl")) {
        $result = replace($result, "\\bioctl\\s*\\(", "core::ioctl(");
    }
    if (match($result, "\\bchroot\\s*\\(") && !match($result, "#") && !match($result, "->") && !match($result, "core::chroot")) {
        $result = replace($result, "\\bchroot\\s*\\(", "core::chroot(");
    }

    # ---- Rare builtins batch -> TODO annotations ----
    if (match($result, "\\bvec\\s*\\(") && !match($result, "#.*TODO") && !match($result, "->") && !match($result, "\\$vec") && !match($result, "_vec")) {
        $result = $result . "  # REVIEW: vec() - use core::pack/core::unpack for bit manipulation";
    }
    if (match($result, "\\bformline\\s*\\(") && !match($result, "#") && !match($result, "->")) {
        $result = $indent . "# " . $trimmed . "  # REVIEW: formline() â€” use sprintf() for formatted output in Strada";
    }
    if (match($result, "\\bdbmopen\\s*\\(") && !match($result, "#") && !match($result, "->")) {
        # dbmopen(%hash, "file", 0644) -> use DBI with SQLite
        my array @dbm_cap = capture($result, "dbmopen\\s*\\(\\s*%([A-Za-z_][A-Za-z0-9_]*)\\s*,\\s*([^,]+)\\s*,");
        if (scalar(@dbm_cap) > 2) {
            my str $dbm_hash = $dbm_cap[1];
            my str $dbm_file = trim_str($dbm_cap[2]);
            $result = $indent . "# " . $trimmed . "  # REVIEW: use DBI with SQLite: my scalar $__dbh = DBI::connect(\"dbi:SQLite:dbname=\" . " . $dbm_file . "); â€” then use SQL for key-value access";
        } else {
            $result = $indent . "# " . $trimmed . "  # REVIEW: dbmopen â€” use DBI with SQLite for key-value storage";
        }
    }
    if (match($result, "\\bdbmclose\\s*\\(") && !match($result, "#") && !match($result, "->")) {
        $result = $indent . "# " . $trimmed . "  # REVIEW: dbmclose â€” use DBI::disconnect() if using SQLite";
    }
    # ---- IPC primitives (System V IPC) ----
    if (match($result, "\\bmsgget\\s*\\(") && !match($result, "#") && !match($result, "->")) {
        $result = $indent . "# " . $trimmed . "  # REVIEW: msgget() â€” use core::socket_create(\"unix\") or async::channel() for IPC in Strada";
    }
    if (match($result, "\\bmsgsnd\\s*\\(") && !match($result, "#") && !match($result, "->")) {
        $result = $indent . "# " . $trimmed . "  # REVIEW: msgsnd() â€” use core::socket_send() or async::send() in Strada";
    }
    if (match($result, "\\bmsgrcv\\s*\\(") && !match($result, "#") && !match($result, "->")) {
        $result = $indent . "# " . $trimmed . "  # REVIEW: msgrcv() â€” use core::socket_recv() or async::recv() in Strada";
    }
    if (match($result, "\\bsemget\\s*\\(") && !match($result, "#") && !match($result, "->")) {
        $result = $indent . "# " . $trimmed . "  # REVIEW: semget() â€” use async::mutex() for synchronization in Strada";
    }
    if (match($result, "\\bsemop\\s*\\(") && !match($result, "#") && !match($result, "->")) {
        $result = $indent . "# " . $trimmed . "  # REVIEW: semop() â€” use async::lock()/async::unlock() in Strada";
    }
    if (match($result, "\\bshmget\\s*\\(") && !match($result, "#") && !match($result, "->")) {
        $result = $indent . "# " . $trimmed . "  # REVIEW: shmget() â€” use async::channel() or core::global_set/get for shared data in Strada";
    }
    if (match($result, "\\bshmread\\s*\\(") && !match($result, "#") && !match($result, "->")) {
        $result = $indent . "# " . $trimmed . "  # REVIEW: shmread() â€” use async::recv() in Strada";
    }
    if (match($result, "\\bshmwrite\\s*\\(") && !match($result, "#") && !match($result, "->")) {
        $result = $indent . "# " . $trimmed . "  # REVIEW: shmwrite() â€” use async::send() in Strada";
    }
    if (match($result, "\\bshmctl\\s*\\(") && !match($result, "#") && !match($result, "->")) {
        $result = $indent . "# " . $trimmed . "  # REVIEW: shmctl() â€” not needed with Strada async primitives";
    }
    if (match($result, "\\bmsgctl\\s*\\(") && !match($result, "#") && !match($result, "->")) {
        $result = $indent . "# " . $trimmed . "  # REVIEW: msgctl() â€” not needed with Strada async primitives";
    }
    if (match($result, "\\bsemctl\\s*\\(") && !match($result, "#") && !match($result, "->")) {
        $result = $indent . "# " . $trimmed . "  # REVIEW: semctl() â€” not needed with Strada async primitives";
    }
    if (match($result, "\\bprototype\\s*\\(") && !match($result, "#.*TODO") && !match($result, "->")) {
        $result = $result . "  # REVIEW: prototype() - Perl prototypes don't exist in Strada; remove or refactor";
    }

    # ---- Additional misc patterns ----

    # Bare chomp (no argument, operates on $_)
    if (match($result, "\\bchomp\\s*;") && !match($result, "#")) {
        $result = replace($result, "\\bchomp\\s*;", "$_ =~ s/\\n$//;");
    }
    # Bare print (no argument, prints $_)
    if (match($trimmed, "^print\\s*;") && !match($result, "#")) {
        $result = $indent . "print($_);";
    }
    # Bare say (no argument, prints $_ with newline)
    if (match($trimmed, "^say\\s*;") && !match($result, "#")) {
        $result = $indent . "say($_);";
    }
    # Bare chomp with just a variable: chomp $line; -> $line =~ s/\n$//;
    # (already handled earlier)
    # Bare chop; -> chop $_
    if (match($result, "\\bchop\\s*;") && !match($result, "#")) {
        $result = replace($result, "\\bchop\\s*;", "$_ = substr($_, 0, length($_) - 1);");
    }
    # Bare defined (rare but possible)
    # Bare length -> length($_)
    if (match($trimmed, "^length\\s*;") && !match($result, "#")) {
        $result = $indent . "length($_);";
    }

    # read($fh, $buf, $len) -> core::read($fh, $len) with REVIEW
    if (match($result, "\\bread\\s*\\(\\$") && !match($result, "core::read") && !match($result, "sysread") && !match($result, "#")) {
        $result = replace($result, "\\bread\\s*\\(", "core::read(");
        $result = $result . "  # REVIEW: read() -> core::read() - returns string instead of writing to buffer; adjust variable assignment";
    }

    # @lines = <$fh> - works natively in Strada, no conversion needed
    # The my -> my array type annotation is already handled earlier

    # (my $copy = $orig) =~ s/pattern/replace/ -> split into assignment + regex
    if (match($result, "\\(my\\s+") && match($result, "\\)\\s*=~")) {
        # Extract: (my [$type] $var = $src) =~ s/pat/rep/[g];
        my array @cmc = capture($result, "\\(my\\s+([^)]+)\\)\\s*=~\\s*(.+)$");
        if (scalar(@cmc) > 2) {
            my str $assign_part = $cmc[1];
            my str $regex_part = $cmc[2];
            # Strip trailing ;
            $regex_part = replace($regex_part, ";\\s*$", "");
            # Split assignment on =
            my int $eq_pos = index($assign_part, "=");
            if ($eq_pos > 0) {
                my str $var_part = substr($assign_part, 0, $eq_pos);
                my str $src_part = substr($assign_part, $eq_pos + 1, length($assign_part) - $eq_pos - 1);
                $var_part = replace($var_part, "\\s+$", "");
                $src_part = replace($src_part, "^\\s+", "");
                # Extract variable name
                my array @varcap = capture($var_part, "(\\$[A-Za-z_][A-Za-z0-9_]*)");
                if (scalar(@varcap) > 1) {
                    my str $varname = $varcap[1];
                    my str $indent = "";
                    my array @indcap = capture($result, "^(\\s*)");
                    if (scalar(@indcap) > 1) {
                        $indent = $indcap[1];
                    }
                    $result = $indent . "my scalar " . $varname . " = " . $src_part . ";\n" . $indent . $varname . " =~ " . $regex_part . ";";
                }
            }
        }
    }

    # if (my $var = expr) - split into declaration before if
    # e.g. if (my $match = $hash{"key"}) -> my scalar $match = $hash{"key"};\nif ($match) {
    # Uses balanced paren scanning to handle nested function calls
    if (match($result, "\\bif\\s*\\(\\s*my\\s+") && !match($result, "#.*assignment")) {
        # Find the opening paren of if(
        my int $if_pos = index($result, "if");
        my int $open_pos = index(substr($result, $if_pos, length($result) - $if_pos), "(");
        if ($open_pos >= 0) {
            $open_pos = $open_pos + $if_pos;
            # Scan for matching close paren with depth tracking
            my int $depth = 1;
            my int $scan = $open_pos + 1;
            my int $rlen = length($result);
            while ($scan < $rlen && $depth > 0) {
                my int $ch = char_at($result, $scan);
                if ($ch == 40) {
                    $depth = $depth + 1;
                }
                if ($ch == 41) {
                    $depth = $depth - 1;
                }
                if ($ch == 34) {
                    # Skip double-quoted string
                    $scan = $scan + 1;
                    while ($scan < $rlen && char_at($result, $scan) != 34) {
                        if (char_at($result, $scan) == 92) {
                            $scan = $scan + 1;
                        }
                        $scan = $scan + 1;
                    }
                }
                $scan = $scan + 1;
            }
            my int $close_pos = $scan - 1;
            # Extract content between if( and matching )
            my str $inner = substr($result, $open_pos + 1, $close_pos - $open_pos - 1);
            # Remove leading "my " or "my type "
            my str $after_my = replace($inner, "^\\s*my\\s+", "");
            # Split on first = to get var part and expr part
            my int $eq_pos = index($after_my, "=");
            if ($eq_pos > 0) {
                my str $var_part = substr($after_my, 0, $eq_pos);
                my str $expr_part = substr($after_my, $eq_pos + 1, length($after_my) - $eq_pos - 1);
                $var_part = replace($var_part, "\\s+$", "");
                $expr_part = replace($expr_part, "^\\s+", "");
                # Extract variable name
                my array @varcap = capture($var_part, "(\\$[A-Za-z_][A-Za-z0-9_]*)");
                if (scalar(@varcap) > 1) {
                    my str $varname = $varcap[1];
                    my str $indent = "";
                    my array @indcap = capture($result, "^(\\s*)");
                    if (scalar(@indcap) > 1) {
                        $indent = $indcap[1];
                    }
                    my str $decl = $indent . "my scalar " . $varname . " = " . $expr_part . ";";
                    # Get everything after the closing paren
                    my str $after = substr($result, $close_pos + 1, $rlen - $close_pos - 1);
                    $after = replace($after, "^\\s*", "");
                    if (length($after) == 0) {
                        $after = "{";
                    }
                    $result = $decl . "\n" . $indent . "if (" . $varname . ") " . $after;
                }
            }
        }
    }

    # Bare shift is now handled above (converted to shift(@_))

    # return undef -> return   (Strada implicitly returns undef from void funcs)
    if (match($result, "\\breturn\\s+undef\\s*;")) {
        $result = replace($result, "return\\s+undef\\s*;", "return;  # Strada returns undef implicitly");
    }

    # ---- study() -> comment out (no-op in modern Perl) ----
    if (match($result, "\\bstudy\\s*[\\(;]") && !match($result, "#")) {
        $result = $indent . "# " . $trimmed . "  # study() is a no-op - removed";
        return $result;
    }

    # ---- pos() -> already handled above in main section ----

    # format blocks are handled in Pass 2c (multi-line processing)
    # Perl write (format output) -> comment out with sprintf suggestion
    if (match($trimmed, "^write\\s*[;(]") && !match($result, "#") && !match($result, "core::") && !match($result, "syswrite")) {
        # write; or write(HANDLE);
        if (match($trimmed, "^write\\s*\\(\\s*([A-Z_]+)\\s*\\)")) {
            my array @wfh_cap = capture($trimmed, "^write\\s*\\(\\s*([A-Z_]+)\\s*\\)");
            if (scalar(@wfh_cap) > 1) {
                $result = $indent . "# " . $trimmed . "  # Perl write(" . $wfh_cap[1] . ") â€” use say(sprintf(...)) instead";
            } else {
                $result = $indent . "# " . $trimmed . "  # Perl write â€” use say(sprintf(...)) instead";
            }
        } else {
            $result = $indent . "# " . $trimmed . "  # Perl write â€” use say(sprintf(...)) instead";
        }
        return $result;
    }

    # ---- do { expr } expression blocks ----
    # Single-line: my $x = do { expr }; -> my scalar $x = expr;
    # Multi-line: my $x = do { -> note
    if (match($result, "\\bdo\\s*\\{") && !match($result, "#") && !match($result, "do\\s*\\{\\s*\\}\\s*while") && !match($result, "do\\s+\"")) {
        # Single-line do { ... }
        if (match($result, "=\\s*do\\s*\\{[^}]+\\}")) {
            my array @do_cap = capture($result, "=\\s*do\\s*\\{\\s*(.+?)\\s*\\}\\s*;?");
            if (scalar(@do_cap) > 1) {
                my str $do_body = trim_str($do_cap[1]);
                # Remove trailing semicolon from body if present
                $do_body =~ s/;\s*$//;
                # If body has inner semicolons, use last expression
                if (index($do_body, ";") >= 0) {
                    my array @do_parts = split(";", $do_body);
                    my int $do_last_idx = scalar(@do_parts) - 1;
                    my str $do_last = trim_str($do_parts[$do_last_idx]);
                    if (length($do_last) > 0) {
                        $do_body = $do_last;
                    }
                }
                $result = replace($result, "do\\s*\\{\\s*[^}]+\\}\\s*;?", $do_body . ";");
            }
        } elsif (match($result, "=\\s*do\\s*\\{\\s*$")) {
            # Multi-line do { block â€” assign last statement
            $result = $result . "  # do {} block â€” assign last expression to variable";
        }
    }

    # ---- inline eval { } not caught by pass2b ----
    # e.g. eval { expr } ? a : b, if (eval { ... }), return eval { ... }
    if (match($result, "\\beval\\s*\\{") && !match($result, "^\\s*#") && !match($result, "REVIEW") && !match($result, "^\\s*try\\s*\\{") && !match($result, "^\\s*eval\\s*\\{")) {
        # Pattern: eval { CODE } ? TRUE : FALSE -> try/catch with success flag
        my array @eval_tern = capture($result, "^(\\s*)(.*)eval\\s*\\{(.+)\\}\\s*\\?\\s*(.+)\\s*:\\s*(.+)$");
        if (scalar(@eval_tern) > 5) {
            my str $et_ind = $eval_tern[1];
            my str $et_pre = trim_str($eval_tern[2]);
            my str $et_body = trim_str($eval_tern[3]);
            my str $et_true = trim_str($eval_tern[4]);
            my str $et_false = trim_str($eval_tern[5]);
            $result = $et_ind . "my int $_eval_ok = 0; try { " . $et_body . "; $_eval_ok = 1; } catch ($e) { }";
            if (length($et_pre) > 0) {
                $result = $result . "\n" . $et_ind . $et_pre . "($_eval_ok) ? " . $et_true . " : " . $et_false;
            } else {
                $result = $result . "\n" . $et_ind . "if ($_eval_ok) { " . $et_true . " } else { " . $et_false . " }";
            }
        }
        # Pattern: EXPR if eval { CODE; 1 }
        elsif (match($result, "\\bif\\s+eval\\s*\\{")) {
            my array @eval_if = capture($result, "^(\\s*)(.+)\\bif\\s+eval\\s*\\{(.+)\\}\\s*;?$");
            if (scalar(@eval_if) > 3) {
                my str $ei_ind = $eval_if[1];
                my str $ei_expr = trim_str($eval_if[2]);
                my str $ei_body = trim_str($eval_if[3]);
                $result = $ei_ind . "my int $_eval_ok = 0; try { " . $ei_body . "; $_eval_ok = 1; } catch ($e) { }";
                $result = $result . "\n" . $ei_ind . "if ($_eval_ok) { " . $ei_expr . " }";
            } else {
                $result = $result . "  # REVIEW: inline eval {} â€” convert to try/catch";
            }
        }
        # Pattern: return eval { EXPR; }
        elsif (match($result, "\\breturn\\s+eval\\s*\\{")) {
            my array @eval_ret = capture($result, "^(\\s*)return\\s+eval\\s*\\{(.+)\\}\\s*;?$");
            if (scalar(@eval_ret) > 2) {
                my str $er_ind = $eval_ret[1];
                my str $er_body = trim_str($eval_ret[2]);
                $result = $er_ind . "my scalar $_eval_result; try { $_eval_result = " . $er_body . "; } catch ($e) { }";
                $result = $result . "\n" . $er_ind . "return $_eval_result;";
            } else {
                $result = $result . "  # REVIEW: inline eval {} â€” convert to try/catch";
            }
        }
        # Pattern: if (eval { CODE }) { ... }
        elsif (match($result, "\\bif\\s*\\(\\s*eval\\s*\\{")) {
            my array @eval_cond = capture($result, "^(\\s*)if\\s*\\(\\s*eval\\s*\\{(.+)\\}\\s*\\)\\s*(.*)$");
            if (scalar(@eval_cond) > 3) {
                my str $ec_ind = $eval_cond[1];
                my str $ec_body = trim_str($eval_cond[2]);
                my str $ec_rest = $eval_cond[3];
                $result = $ec_ind . "my int $_eval_ok = 0; try { " . $ec_body . "; $_eval_ok = 1; } catch ($e) { }";
                $result = $result . "\n" . $ec_ind . "if ($_eval_ok) " . $ec_rest;
            } else {
                $result = $result . "  # REVIEW: inline eval {} â€” convert to try/catch";
            }
        }
        # Remaining inline eval â€” add REVIEW
        else {
            $result = $result . "  # REVIEW: inline eval {} â€” convert to try/catch";
        }
    }

    # ---- goto LABEL -> natively supported in Strada ----
    # goto label; works in Strada - pass through unchanged

    # Conditional use (use if) is handled in the pragma section above

    # /g in scalar context (while loop iterator) â€” supported natively in Strada with PCRE2

    # ---- Perl math builtins -> math:: namespace ----
    if (match($result, "\\bsin\\s*\\(") && !match($result, "#") && !match($result, "math::sin") && !match($result, "single") && !match($result, "->sin")) {
        $result = replace($result, "\\bsin\\s*\\(", "math::sin(");
    }
    if (match($result, "\\bcos\\s*\\(") && !match($result, "#") && !match($result, "math::cos") && !match($result, "cosm") && !match($result, "cosp") && !match($result, "->cos")) {
        $result = replace($result, "\\bcos\\s*\\(", "math::cos(");
    }
    if (match($result, "\\batan2\\s*\\(") && !match($result, "#") && !match($result, "math::atan2") && !match($result, "->atan2")) {
        $result = replace($result, "\\batan2\\s*\\(", "math::atan2(");
    }
    if (match($result, "\\bsqrt\\s*\\(") && !match($result, "#") && !match($result, "math::sqrt") && !match($result, "->sqrt") && !match($result, "POSIX::sqrt")) {
        $result = replace($result, "\\bsqrt\\s*\\(", "math::sqrt(");
    }
    if (match($result, "\\blog\\s*\\(") && !match($result, "#") && !match($result, "math::log") && !match($result, "\\$log") && !match($result, "log_") && !match($result, "syslog") && !match($result, "_log") && !match($result, "\"log") && !match($result, "->log") && !match($result, "POSIX::log")) {
        $result = replace($result, "\\blog\\s*\\(", "math::log(");
    }
    if (match($result, "\\bexp\\s*\\(") && !match($result, "#") && !match($result, "math::exp") && !match($result, "\\$exp") && !match($result, "exp_") && !match($result, "_exp") && !match($result, "expect") && !match($result, "export") && !match($result, "->exp") && !match($result, "POSIX::exp")) {
        $result = replace($result, "\\bexp\\s*\\(", "math::exp(");
    }
    if (match($result, "\\babs\\s*\\(") && !match($result, "#") && !match($result, "math::abs") && !match($result, "abs_") && !match($result, "_abs") && !match($result, "abstract") && !match($result, "->abs")) {
        $result = replace($result, "\\babs\\s*\\(", "math::abs(");
    }
    # int() -> pass through (Strada's native int() truncates toward zero, same as Perl)
    # Do NOT convert to math::floor() â€” floor rounds toward -inf which differs for negatives
    # rand/srand -> core::rand/core::srand
    if (match($result, "\\brand\\s*\\(") && !match($result, "#") && !match($result, "core::rand") && !match($result, "rand_") && !match($result, "_rand")) {
        $result = replace($result, "\\brand\\s*\\(", "core::rand(");
    }
    if (match($result, "\\bsrand\\s*\\(") && !match($result, "#") && !match($result, "core::srand")) {
        $result = replace($result, "\\bsrand\\s*\\(", "core::srand(");
    }
    # hex/oct -> core::hex/core::oct
    if (match($result, "\\bhex\\s*\\(") && !match($result, "#") && !match($result, "core::hex") && !match($result, "hex_") && !match($result, "_hex") && !match($result, "hexdig")) {
        $result = replace($result, "\\bhex\\s*\\(", "core::hex(");
    }
    if (match($result, "\\boct\\s*\\(") && !match($result, "#") && !match($result, "core::oct")) {
        $result = replace($result, "\\boct\\s*\\(", "core::oct(");
    }
    # chr/ord -> chr/ord (native in Strada, pass through)
    # hostname() -> core::gethostname()
    if (match($result, "\\bhostname\\s*\\(") && !match($result, "#") && !match($result, "core::gethostname") && !match($result, "->hostname") && !match($result, "_hostname") && !match($result, "hostname_")) {
        $result = replace($result, "\\bhostname\\s*\\(", "core::gethostname(");
    }
    # readlink -> core::readlink
    if (match($result, "\\breadlink\\s*\\(") && !match($result, "#") && !match($result, "core::readlink")) {
        $result = replace($result, "\\breadlink\\s*\\(", "core::readlink(");
    }
    # gmtime/localtime -> core:: with REVIEW
    if (match($result, "\\bgmtime\\s*\\(") && !match($result, "#") && !match($result, "core::gmtime")) {
        $result = replace($result, "\\bgmtime\\s*\\(", "core::gmtime(");
        $result = $result . "  # REVIEW: gmtime() returns hash in Strada â€” access fields via $t->{\"year\"}, $t->{\"mon\"}, etc.";
    }
    if (match($result, "\\blocaltime\\s*\\(") && !match($result, "#") && !match($result, "core::localtime")) {
        $result = replace($result, "\\blocaltime\\s*\\(", "core::localtime(");
        $result = $result . "  # REVIEW: localtime() returns hash in Strada â€” access fields via $t->{\"year\"}, $t->{\"mon\"}, etc.";
    }
    # time() -> core::time()
    if (match($result, "\\btime\\s*\\(\\s*\\)") && !match($result, "#") && !match($result, "core::time") && !match($result, "str.*time") && !match($result, "time_") && !match($result, "_time") && !match($result, "timeout") && !match($result, "datetime")) {
        $result = replace($result, "\\btime\\s*\\(\\s*\\)", "core::time()");
    }
    # sleep -> core::sleep
    if (match($result, "\\bsleep\\s*\\(") && !match($result, "#") && !match($result, "core::sleep") && !match($result, "usleep")) {
        $result = replace($result, "\\bsleep\\s*\\(", "core::sleep(");
    }
    # each(%hash) -> each(%hash)  (native in Strada, pass through)
    # wantarray -> core::wantarray (Strada supports this)
    if (match($result, "\\bwantarray\\s*\\(") && !match($result, "#") && !match($result, "core::wantarray")) {
        # Protect $wantarray variable refs
        $result = replace_all($result, "$wantarray", "STRADA_WANTARRAY_VAR2");
        if (match($result, "\\bwantarray\\s*\\(")) {
            $result = replace($result, "\\bwantarray\\s*\\(", "core::wantarray(");
        }
        $result = replace_all($result, "STRADA_WANTARRAY_VAR2", "$wantarray");
    }
    # caller -> already handled in main caller section above
    # ref() -> ref() (native in Strada, pass through)
    # ref($x) eq "ClassName" -> $x->isa("ClassName") when ClassName is a package name
    if (match($result, "ref\\s*\\(\\s*\\$[A-Za-z_]") && match($result, "\\beq\\s+[\"'][A-Z]")) {
        my array @ref_eq_cap = capture($result, "ref\\s*\\(\\s*(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*\\)\\s+eq\\s+[\"']([A-Z][A-Za-z0-9_:]*)[\"']");
        if (scalar(@ref_eq_cap) > 2) {
            my str $ref_var = $ref_eq_cap[1];
            my str $ref_class = $ref_eq_cap[2];
            # Don't convert HASH/ARRAY/SCALAR/CODE/REF â€” those are type names not classes
            if ($ref_class ne "HASH" && $ref_class ne "ARRAY" && $ref_class ne "SCALAR" && $ref_class ne "CODE" && $ref_class ne "REF" && $ref_class ne "GLOB") {
                $result = replace($result, "ref\\s*\\(\\s*\\" . $ref_var . "\\s*\\)\\s+eq\\s+[\"']" . $ref_class . "[\"']", $ref_var . "->isa(\"" . $ref_class . "\")");
            }
        }
    }
    # ref($x) ne "ClassName" -> !$x->isa("ClassName")
    if (match($result, "ref\\s*\\(\\s*\\$[A-Za-z_]") && match($result, "\\bne\\s+[\"'][A-Z]")) {
        my array @ref_ne_cap = capture($result, "ref\\s*\\(\\s*(\\$[A-Za-z_][A-Za-z0-9_]*)\\s*\\)\\s+ne\\s+[\"']([A-Z][A-Za-z0-9_:]*)[\"']");
        if (scalar(@ref_ne_cap) > 2) {
            my str $rn_var = $ref_ne_cap[1];
            my str $rn_class = $ref_ne_cap[2];
            if ($rn_class ne "HASH" && $rn_class ne "ARRAY" && $rn_class ne "SCALAR" && $rn_class ne "CODE" && $rn_class ne "REF" && $rn_class ne "GLOB") {
                $result = replace($result, "ref\\s*\\(\\s*\\" . $rn_var . "\\s*\\)\\s+ne\\s+[\"']" . $rn_class . "[\"']", "!" . $rn_var . "->isa(\"" . $rn_class . "\")");
            }
        }
    }
    # defined() -> defined() (native in Strada, pass through)

    # ---- Match variables: $& $` $' -> convert/REVIEW ----
    my str $dol_amp = "$" . "&";
    if (match($result, "\\" . $dol_amp) && !match($result, "#.*REVIEW") && !match($result, "&&")) {
        # Replace $& with captures()[0] (the full match)
        $result = replace_all($result, $dol_amp, "captures()[0]");
        $result = $result . "  # was " . $dol_amp . " (match result)";
    }
    my str $dol_backtick = "$" . "`";
    if (match($result, "\\" . $dol_backtick) && !match($result, "#.*REVIEW")) {
        $result = $result . "  # REVIEW: " . $dol_backtick . " (prematch) has no Strada equivalent - use substr() with match position";
    }
    my str $dol_tick = "$" . "'";
    if (match($result, "\\" . $dol_tick) && !match($result, "#.*REVIEW") && !match($result, "\\$'[A-Za-z]") && !match($result, "'\\$'") && !match($result, "Strada::JIT::eval") && !match($result, "Strada::Interpreter::eval_string")) {
        $result = $result . "  # REVIEW: " . $dol_tick . " (postmatch) has no Strada equivalent - use substr() with match position";
    }

    # ---- local $@, local $!, local $? â€” comment out (error variable save/restore) ----
    # Also handle parenthesized forms: local($@), local($!), local($?)
    my str $local_dol_at = "local $" . "@";
    my str $local_paren_dol_at = "local($" . "@";
    if ((index($result, $local_dol_at) >= 0 || index($result, $local_paren_dol_at) >= 0) && !match($result, "^\\s*#")) {
        $result = $indent . "# " . $trimmed . "  # Not needed in Strada (exceptions use try/catch)";
    }
    if ((match($result, "\\blocal\\s+\\$\\!") || match($result, "\\blocal\\s*\\(\\s*\\$\\!")) && !match($result, "^\\s*#") && !match($result, "!=")) {
        $result = $indent . "# " . $trimmed . "  # Not needed in Strada (no $! error variable)";
    }
    if ((match($result, "\\blocal\\s+\\$\\?") || match($result, "\\blocal\\s*\\(\\s*\\$\\?")) && !match($result, "^\\s*#")) {
        $result = $indent . "# " . $trimmed . "  # Not needed in Strada (use return value of core::system())";
    }

    # ---- B4: Reference dereferencing â€” simplify braces or annotate ----
    # @{$var} â†’ @$var (simple variable deref â€” braces are optional)
    # @{$hash->{key}} â†’ @{$hash->{"key"}} (complex deref â€” valid Strada, no REVIEW needed)
    # @{$expr} â€” array deref (simple â†’ simplify, hash/arr value â†’ pass through, symbolic â†’ global_get)
    if (match($result, "@\\{\\$") && !match($result, "#.*TODO") && !match($result, "^\\s*#")) {
        my int $deref_safety = 0;
        while (match($result, "@\\{\\$") && $deref_safety < 10) {
            # Check if content is a simple variable: @{$var} or @{$var_name}
            if (match($result, "@\\{\\$[A-Za-z_][A-Za-z0-9_]*\\}")) {
                my array @ad_cap = capture($result, "@\\{(\\$[A-Za-z_][A-Za-z0-9_]*)\\}");
                if (scalar(@ad_cap) > 1) {
                    my str $ad_var = $ad_cap[1];
                    my int $ad_pos = index($result, "@{" . $ad_var . "}");
                    if ($ad_pos >= 0) {
                        $result = substr($result, 0, $ad_pos) . "@" . $ad_var . substr($result, $ad_pos + length("@{" . $ad_var . "}"));
                    } else {
                        $deref_safety = 10;
                    }
                } else {
                    $deref_safety = 10;
                }
            } elsif (match($result, "@\\{\\$[A-Za-z_][A-Za-z0-9_]*->")) {
                # @{$ref->{key}} â€” complex but valid deref, just remove REVIEW
                $deref_safety = 10;
            } elsif (match($result, "@\\{\\$[A-Za-z_][A-Za-z0-9_]*\\{") || match($result, "@\\{\\$[A-Za-z_][A-Za-z0-9_]*\\[")) {
                # @{$hash{key}} or @{$arr[$i]} â€” valid Strada array deref, pass through
                $deref_safety = 10;
            } elsif (match($result, "@\\{\\$[A-Za-z_][A-Za-z0-9_]*\\s*\\.")) {
                # @{$pkg . "::EXPORT"} â€” truly symbolic, wrap with core::global_get()
                # Find the @{ position
                my int $sag_pos = index($result, "@{");
                if ($sag_pos >= 0) {
                    # Use brace counting to find matching }
                    my int $sag_ci = $sag_pos + 2;
                    my int $sag_d = 1;
                    while ($sag_ci < length($result) && $sag_d > 0) {
                        my int $sag_ch = char_at($result, $sag_ci);
                        if ($sag_ch == 123) { $sag_d = $sag_d + 1; }
                        if ($sag_ch == 125) { $sag_d = $sag_d - 1; }
                        $sag_ci = $sag_ci + 1;
                    }
                    if ($sag_d == 0) {
                        my str $sag_expr = substr($result, $sag_pos + 2, $sag_ci - $sag_pos - 3);
                        $result = substr($result, 0, $sag_pos) . "@{core::global_get(" . $sag_expr . ")}" . substr($result, $sag_ci, length($result) - $sag_ci);
                    }
                }
                $deref_safety = 10;
            } else {
                # Other complex pattern â€” pass through (valid Strada deref syntax)
                $deref_safety = 10;
            }
            $deref_safety++;
        }
    }
    # ${$var} â†’ $$var (simple scalar deref)
    # But skip ${ followed by ^ (like ${^TAINT}) which is a special var
    if (match($result, "\\$\\{\\$") && !match($result, "#.*REVIEW") && !match($result, "^\\s*#") && !match($result, "\\$\\{\\^")) {
        my int $sd_safety = 0;
        while (match($result, "\\$\\{\\$[A-Za-z_]") && $sd_safety < 10) {
            if (match($result, "\\$\\{\\$[A-Za-z_][A-Za-z0-9_]*\\}")) {
                my array @sd_cap = capture($result, "\\$\\{(\\$[A-Za-z_][A-Za-z0-9_]*)\\}");
                if (scalar(@sd_cap) > 1) {
                    my str $sd_var = $sd_cap[1];
                    my str $sd_search = chr(36) . "{" . $sd_var . "}";
                    my int $sd_pos = index($result, $sd_search);
                    if ($sd_pos >= 0) {
                        $result = substr($result, 0, $sd_pos) . chr(36) . $sd_var . substr($result, $sd_pos + length($sd_search));
                    } else {
                        $sd_safety = 10;
                    }
                } else {
                    $sd_safety = 10;
                }
            } elsif (match($result, "\\$\\{\\$[A-Za-z_][A-Za-z0-9_]*\\{")) {
                # ${$hash{$key}} â€” scalar deref of hash value â†’ $hash{$key}
                my array @shd_cap = capture($result, "\\$\\{(\\$[A-Za-z_][A-Za-z0-9_]*\\{[^}]+\\})\\}");
                if (scalar(@shd_cap) > 1) {
                    my str $shd_expr = $shd_cap[1];
                    my str $shd_search = chr(36) . "{" . $shd_expr . "}";
                    my int $shd_pos = index($result, $shd_search);
                    if ($shd_pos >= 0) {
                        $result = substr($result, 0, $shd_pos) . $shd_expr . substr($result, $shd_pos + length($shd_search));
                    } else {
                        $sd_safety = 10;
                    }
                } else {
                    $sd_safety = 10;
                }
            } elsif (match($result, "\\$\\{\\$[A-Za-z_][A-Za-z0-9_]*->")) {
                # ${$ref->{key}} â€” valid, no annotation
                $sd_safety = 10;
            } elsif (match($result, "\\$\\{\\$[A-Za-z_][A-Za-z0-9_]*\\s*\\.")) {
                # ${$pkg . "::"} â€” symbolic scalar deref, wrap with core::global_get()
                my int $ssd_pos = index($result, chr(36) . "{" . chr(36));
                if ($ssd_pos >= 0) {
                    my int $ssd_ci = $ssd_pos + 2;
                    my int $ssd_d = 1;
                    while ($ssd_ci < length($result) && $ssd_d > 0) {
                        my int $ssd_ch = char_at($result, $ssd_ci);
                        if ($ssd_ch == 123) { $ssd_d = $ssd_d + 1; }
                        if ($ssd_ch == 125) { $ssd_d = $ssd_d - 1; }
                        $ssd_ci = $ssd_ci + 1;
                    }
                    if ($ssd_d == 0) {
                        my str $ssd_expr = substr($result, $ssd_pos + 2, $ssd_ci - $ssd_pos - 3);
                        $result = substr($result, 0, $ssd_pos) . "core::global_get(" . $ssd_expr . ")" . substr($result, $ssd_ci, length($result) - $ssd_ci);
                    }
                }
                $sd_safety = 10;
            } else {
                $result = $result . "  # REVIEW: symbolic scalar deref â€” use hash/variable access in Strada";
                $sd_safety = 10;
            }
            $sd_safety++;
        }
    }
    # %{$var} â†’ %$var (simple hash deref)
    if (match($result, "%\\{\\$") && !match($result, "#.*REVIEW") && !match($result, "^\\s*#")) {
        if (match($result, "%\\{\\$[A-Za-z_][A-Za-z0-9_]*\\}")) {
            my array @hd_cap = capture($result, "%\\{(\\$[A-Za-z_][A-Za-z0-9_]*)\\}");
            if (scalar(@hd_cap) > 1) {
                my str $hd_var = $hd_cap[1];
                my int $hd_pos = index($result, "%{" . $hd_var . "}");
                if ($hd_pos >= 0) {
                    $result = substr($result, 0, $hd_pos) . "%" . $hd_var . substr($result, $hd_pos + length("%{" . $hd_var . "}"));
                }
            }
        } elsif (match($result, "%\\{\\$[A-Za-z_][A-Za-z0-9_]*\\s*\\.")) {
            # %{$class . "::"} â€” symbolic hash deref (package symbol table)
            $result = $indent . "# " . $trimmed . "\n" . $indent . "# REVIEW: package symbol table access â€” Strada alternatives:\n" . $indent . "#   List functions: core::global_keys() filtered by package prefix\n" . $indent . "#   Check existence: core::global_exists(\"Pkg::name\")\n" . $indent . "#   Get/set vars: core::global_get(\"Pkg::var\"), core::global_set(\"Pkg::var\", val)";
        } elsif (match($result, "%\\{\\$[A-Za-z_][A-Za-z0-9_]*\\{") || match($result, "%\\{\\$[A-Za-z_][A-Za-z0-9_]*\\[")) {
            # %{$hash{key}} or %{$arr[$i]} â€” valid Strada, no annotation
        } elsif (!match($result, "%\\{\\$[A-Za-z_][A-Za-z0-9_]*->")) {
            $result = $result . "  # REVIEW: symbolic hash deref â€” may need refactoring";
        }
    }
    # &{$var}(args) â†’ $var->(args) (code ref call)
    if (match($result, "&\\{\\$") && !match($result, "#.*TODO") && !match($result, "^\\s*#")) {
        if (match($result, "&\\{\\$[A-Za-z_][A-Za-z0-9_]*\\}")) {
            my array @cd_cap = capture($result, "&\\{(\\$[A-Za-z_][A-Za-z0-9_]*)\\}");
            if (scalar(@cd_cap) > 1) {
                my str $cd_var = $cd_cap[1];
                my int $cd_pos = index($result, "&{" . $cd_var . "}");
                if ($cd_pos >= 0) {
                    my str $cd_rest = substr($result, $cd_pos + length("&{" . $cd_var . "}"));
                    if (!match($cd_rest, "^\\s*\\(")) {
                        $result = substr($result, 0, $cd_pos) . $cd_var . "->()" . $cd_rest;
                    } else {
                        $result = substr($result, 0, $cd_pos) . $cd_var . "->" . $cd_rest;
                    }
                }
            }
        } elsif (match($result, "&\\{\\$[A-Za-z_][A-Za-z0-9_]*->")) {
            # &{$ref->{key}}(args) â†’ $ref->{key}->(args)
            # Use brace counting since nested {"key"} contains }
            my int $cd2_amp = index($result, "&{$");
            if ($cd2_amp >= 0) {
                my int $cd2_start = $cd2_amp + 2;
                my int $cd2_depth = 1;
                my int $cd2_ci = $cd2_start;
                my int $cd2_len = length($result);
                while ($cd2_ci < $cd2_len && $cd2_depth > 0) {
                    my str $cd2_ch = substr($result, $cd2_ci, 1);
                    if ($cd2_ch eq "{") { $cd2_depth++; }
                    if ($cd2_ch eq "}") { $cd2_depth--; }
                    $cd2_ci++;
                }
                # cd2_ci now points past the matching }
                my str $cd2_expr = substr($result, $cd2_start, $cd2_ci - $cd2_start - 1);
                $result = substr($result, 0, $cd2_amp) . $cd2_expr . "->" . substr($result, $cd2_ci);
            }
        } elsif (match($result, "&\\{\\$[A-Za-z_][A-Za-z0-9_]*\\{")) {
            # &{$hash{key}} â€” hash value is a code ref, rewrite to $hash{key}->()
            my int $cd3_amp = index($result, "&{$");
            if ($cd3_amp >= 0) {
                my int $cd3_start = $cd3_amp + 2;
                my int $cd3_depth = 1;
                my int $cd3_ci = $cd3_start;
                my int $cd3_len = length($result);
                while ($cd3_ci < $cd3_len && $cd3_depth > 0) {
                    my int $cd3_ch = char_at($result, $cd3_ci);
                    if ($cd3_ch == 123) { $cd3_depth = $cd3_depth + 1; }
                    if ($cd3_ch == 125) { $cd3_depth = $cd3_depth - 1; }
                    $cd3_ci = $cd3_ci + 1;
                }
                my str $cd3_expr = substr($result, $cd3_start, $cd3_ci - $cd3_start - 1);
                my str $cd3_rest = substr($result, $cd3_ci, length($result) - $cd3_ci);
                # If not followed by ( for args, add ()
                if (!match($cd3_rest, "^\\s*\\(")) {
                    $result = substr($result, 0, $cd3_amp) . $cd3_expr . "->()" . $cd3_rest;
                } else {
                    $result = substr($result, 0, $cd3_amp) . $cd3_expr . "->" . $cd3_rest;
                }
            }
        } elsif (match($result, "&\\{\\$[A-Za-z_][A-Za-z0-9_]*\\s*\\.")) {
            # &{$pkg . "::func"} â€” symbolic function call, comment out
            $result = $indent . "# " . $trimmed . "  # REVIEW: symbolic function call â€” refactor to use Package::func() directly";
        } else {
            $result = $result . "  # REVIEW: symbolic code deref â€” use function reference call in Strada";
        }
    }
    # *{$expr} â€” typeglob manipulation â€” comment out with specific guidance
    if (match($result, "\\*\\{\\$") && !match($result, "#.*TODO") && !match($result, "^\\s*#")) {
        if (match($result, "\\*\\{.*import") && match($result, "=\\s*\\\\&")) {
            # *{$pkg."::import"} = \&import â€” function installation
            $result = $indent . "# " . $trimmed . "  # Not needed in Strada (callers use Package::func() directly)";
        } elsif (match($result, "=\\s*\\\\&") || match($result, "=\\s*sub\\s")) {
            # *{$pkg."::func"} = \&func or = sub { } â€” function installation
            $result = $indent . "# " . $trimmed . "\n" . $indent . "# REVIEW: function installation via typeglob â€” define func in the target package directly";
        } elsif (match($result, "\\*\\{.*\\}\\{\"?CODE")) {
            # *{$name}{CODE} â€” code slot access
            $result = $indent . "# " . $trimmed . "\n" . $indent . "# REVIEW: CODE slot access â€” use $obj->can(\"method\") to check if method exists";
        } elsif (match($result, "\\*\\{.*\\}\\{\"?HASH")) {
            # *{$name}{HASH} â€” hash slot access
            $result = $indent . "# " . $trimmed . "\n" . $indent . "# REVIEW: HASH slot access â€” use core::global_get(\"Pkg::var\") for package variables";
        } elsif (match($result, "\\*\\{.*\\}\\{\"?ARRAY")) {
            # *{$name}{ARRAY} â€” array slot access
            $result = $indent . "# " . $trimmed . "\n" . $indent . "# REVIEW: ARRAY slot access â€” use core::global_get(\"Pkg::var\") for package variables";
        } elsif (match($result, "\\*\\{.*\\}\\{\"?SCALAR")) {
            # *{$name}{SCALAR} â€” scalar slot access
            $result = $indent . "# " . $trimmed . "\n" . $indent . "# REVIEW: SCALAR slot access â€” use core::global_get(\"Pkg::var\") for package variables";
        } else {
            $result = $indent . "# " . $trimmed . "  # REVIEW: typeglob manipulation â€” refactor to use direct function/variable references";
        }
    }

    # ---- B5: local() with special variables -> comment out ----
    if (match($result, "\\blocal\\s*\\(") && !match($result, "^\\s*#")) {
        # local($., $@, $!, $^E, $?) â€” all special variables â†’ comment out
        if (match($result, "\\blocal\\s*\\(\\s*[\\$@%][\\\\|.?!@^]")) {
            $result = $indent . "# " . $trimmed . "  # Not needed in Strada (special variables)";
        }
    }
    # local $hash{"key"} = val â€” hash slot localization (not supported in Strada)
    if (match($result, "\\blocal\\s+\\$[A-Za-z_][A-Za-z0-9_]*\\{") && !match($result, "^\\s*#") && !match($result, "#.*REVIEW")) {
        $result = $result . "  # REVIEW: local $hash{key} â€” Strada has no hash-slot localization; use a temporary variable instead";
    }
    # local $_ = expr â€” topic variable localization
    if (match($result, "\\blocal\\s+\\$_\\s*=") && !match($result, "^\\s*#") && !match($result, "#.*REVIEW") && !match($result, "local\\s+\\*_")) {
        # Convert to: my scalar $_ = expr; (best approximation)
        my array @lt_cap = capture($result, "\\blocal\\s+\\$_\\s*=\\s*(.+)");
        if (scalar(@lt_cap) > 1) {
            my str $lt_val = $lt_cap[1];
            $result = $indent . "my scalar " . chr(36) . "_ = " . $lt_val . "  # REVIEW: was local $_ â€” dynamic scoping not available; using lexical scope";
        }
    }
    # local $_ without assignment
    if (match($result, "\\blocal\\s+\\$_\\s*;") && !match($result, "^\\s*#") && !match($result, "#.*REVIEW") && !match($result, "local\\s+\\*_")) {
        $result = $indent . "my scalar " . chr(36) . "_ = undef;  # REVIEW: was local $_ â€” dynamic scoping not available; using lexical scope";
    }

    # ---- B10: substr as lvalue fallback (should be rare after paren-counting handler) ----
    if (match($result, "\\bsubstr\\s*\\(") && match($result, "\\)\\s*=\\s*") && !match($result, "#.*REVIEW") && !match($result, "^\\s*#") && !match($result, "==")) {
        $result = $result . "  # REVIEW: substr lvalue â€” rewrite as: $str = substr($str, 0, $pos) . $val . substr($str, $pos + $len)";
    }

    # ---- B11: local *_ â†’ my scalar $_ = EXPR ----
    if (match($result, "\\blocal\\s+\\*_") && !match($result, "#.*TODO") && !match($result, "^\\s*#")) {
        if (match($result, "local\\s+\\*_\\s*=\\s*\\\\my\\s")) {
            # local *_ = \my $a; â†’ declare new $_
            $result = $indent . "my scalar " . chr(36) . "_ = undef;";
        } elsif (match($result, "local\\s+\\*_\\s*=\\s*\\\\")) {
            # local *_ = \EXPR; â†’ strip the backslash ref
            my int $ls_bs = index($result, "\\");
            if ($ls_bs >= 0) {
                my str $ls_rest = substr($result, $ls_bs + 1, length($result) - $ls_bs - 1);
                # Strip trailing semicolon for the expression
                $ls_rest = trim_str($ls_rest);
                if (substr($ls_rest, length($ls_rest) - 1, 1) eq ";") {
                    $ls_rest = substr($ls_rest, 0, length($ls_rest) - 1);
                }
                $result = $indent . "my scalar " . chr(36) . "_ = " . $ls_rest . ";";
            } else {
                $result = $indent . "my scalar " . chr(36) . "_ = undef;  # was: local *_";
            }
        } else {
            $result = $indent . "my scalar " . chr(36) . "_ = undef;  # was: local *_";
        }
    }

    # ---- Final pass: annotate remaining @_ usage in active code ----
    # @_ should only appear in variadic declarations (scalar ...@_)
    # Any other occurrence needs review since Strada uses named params
    if (match($result, "@_") && !match($result, "^\\s*#") && !match($result, "#.*REVIEW") && !match($result, "\\.\\.\\.@_") && !match($result, "scalar\\s*\\.\\.\\. *@_") && !match($result, "func ")) {
        # @_[N,M] â€” array slice of args
        if (match($result, "@_\\[")) {
            $result = $result . "  # REVIEW: @_ slice â€” Strada uses named parameters; pass values explicitly";
        }
        # $_[N] â€” indexed arg access
        elsif (match($result, "\\$_\\[") && !match($result, "\\$_\\[\\$")) {
            $result = $result . "  # REVIEW: $_[N] argument access â€” Strada uses named parameters; use the parameter variable instead";
        }
        # scalar(@_) â€” argument count
        elsif (match($result, "scalar\\s*\\(\\s*@_\\s*\\)") || match($result, "\\$#_")) {
            $result = $result . "  # REVIEW: argument count check â€” Strada uses typed parameters; consider variadic func(type ...@args)";
        }
        # shift(@_) or shift @_ â€” extracting arguments
        elsif (match($result, "shift\\s*\\(@_\\)") || match($result, "shift\\(@_\\)") || match($result, "shift\\s+@_") || (match($result, "\\bshift\\b") && !match($result, "shift\\s*\\("))) {
            $result = $result . "  # REVIEW: shift(@_) â€” add this parameter to the function signature instead";
        }
        # splice(@_, ...) â€” extracting multiple arguments
        elsif (match($result, "splice\\s*\\(@_") || match($result, "splice\\(@_")) {
            $result = $result . "  # REVIEW: splice(@_) â€” add these parameters to the function signature instead";
        }
        # my (...) = @_ â€” destructuring args
        elsif (match($result, "=\\s*@_")) {
            # If it's a simple self-unpacking like my ($self) = @_; or my ($self, $args) = @_;
            # these are redundant in Strada since func signatures already include params
            if (match($result, "^\\s*my\\s+\\(.*\\$self.*\\)\\s*=\\s*@_\\s*;\\s*$")) {
                $result = $indent . "# " . $trimmed . "  # handled by func signature";
            } else {
                $result = $result . "  # REVIEW: @_ destructuring â€” add these parameters to the function signature instead";
            }
        }
    }

    # ---- Final pass: convert $@ outside try/catch ----
    # $@ as the Perl error variable (not inside catch blocks)
    if (match($result, "\\$@") && !match($result, "^\\s*#") && !match($result, "#.*REVIEW") && !match($result, "catch") && !match($result, "\\$@_") && !match($result, "\\$@[A-Za-z]") && !match($result, "@\\$") && !match($result, "\\$@{")) {
        # Common patterns: if ($@), warn $@, die $@, $@ =~ /pat/
        # Replace $@ with $__err (a synthetic variable that should come from catch)
        if (match($result, "\\bif\\s*\\(\\$@\\)")) {
            $result = replace_dollar_at($result);
            $result = $result . "  # REVIEW: $@ replaced with $e â€” move into catch block";
        } elsif (match($result, "\\bwarn\\s*\\$@") || match($result, "\\bwarn\\s*\\(\\$@\\)")) {
            $result = replace_dollar_at($result);
            $result = $result . "  # REVIEW: $@ replaced with $e â€” move into catch block";
        } elsif (match($result, "\\bdie\\s+\\$@") || match($result, "\\bdie\\s*\\(\\$@\\)")) {
            $result = replace_dollar_at($result);
            $result = $result . "  # REVIEW: $@ replaced with $e â€” use throw($e) in catch block";
        } elsif (match($result, "=\\s*\\$@\\s*;") || match($result, "=\\s*\\$@$")) {
            $result = replace_dollar_at($result);
            $result = $result . "  # REVIEW: $@ replaced with $e â€” move assignment into catch block";
        } else {
            $result = replace_dollar_at($result);
            $result = $result . "  # REVIEW: $@ replaced with $e â€” ensure this is inside a catch block";
        }
    }

    # ---- Final pass: 4-arg substr ----
    # substr($str, $pos, $len, $replacement) â€” in-place replacement
    if (match($result, "\\bsubstr\\s*\\(") && !match($result, "^\\s*#") && !match($result, "#.*REVIEW")) {
        # Count commas inside substr() to detect 4-arg form
        my int $sb_pos = index($result, "substr(");
        if ($sb_pos < 0) { $sb_pos = index($result, "substr ("); }
        if ($sb_pos >= 0) {
            my int $sb_start = index($result, "(", $sb_pos);
            if ($sb_start >= 0) {
                my int $sb_depth = 1;
                my int $sb_commas = 0;
                my int $sb_ci = $sb_start + 1;
                while ($sb_ci < length($result) && $sb_depth > 0) {
                    my str $sb_ch = substr($result, $sb_ci, 1);
                    if ($sb_ch eq "(") { $sb_depth++; }
                    if ($sb_ch eq ")") { $sb_depth--; }
                    if ($sb_ch eq "," && $sb_depth == 1) { $sb_commas++; }
                    $sb_ci++;
                }
                if ($sb_commas >= 3) {
                    $result = $result . "  # REVIEW: 4-arg substr() â€” rewrite as: $str = substr($str, 0, $pos) . $replacement . substr($str, $pos + $len)";
                }
            }
        }
    }

    # ---- Final pass: 4-arg select (I/O multiplexing) ----
    if (match($result, "\\bselect\\s*\\(") && !match($result, "^\\s*#") && !match($result, "#.*REVIEW")) {
        # 4-arg select: select(RBITS, WBITS, EBITS, TIMEOUT)
        my int $sel_pos = index($result, "select(");
        if ($sel_pos < 0) { $sel_pos = index($result, "select ("); }
        if ($sel_pos >= 0) {
            my int $sel_start = index($result, "(", $sel_pos);
            if ($sel_start >= 0) {
                my int $sel_depth = 1;
                my int $sel_commas = 0;
                my int $sel_ci = $sel_start + 1;
                while ($sel_ci < length($result) && $sel_depth > 0) {
                    my str $sel_ch = substr($result, $sel_ci, 1);
                    if ($sel_ch eq "(") { $sel_depth++; }
                    if ($sel_ch eq ")") { $sel_depth--; }
                    if ($sel_ch eq "," && $sel_depth == 1) { $sel_commas++; }
                    $sel_ci++;
                }
                if ($sel_commas >= 3) {
                    $result = $result . "  # REVIEW: 4-arg select() (I/O multiplexing) â€” use core::poll() or __C__ block with select()";
                }
            }
        }
    }

    # ---- Final pass: \G anchor in regex ----
    if (match($result, "\\\\G") && !match($result, "^\\s*#") && !match($result, "#.*REVIEW")) {
        if (match($result, "=~") || match($result, "/.*\\\\G")) {
            $result = $result . "  # REVIEW: \\G anchor â€” Strada/PCRE2 supports \\G but has no per-string pos() tracking; refactor stateful regex scanning";
        }
    }

    # ---- Final pass: @{$ref} array dereference annotation ----
    if (match($result, "@\\{\\s*\\$") && !match($result, "^\\s*#") && !match($result, "#.*REVIEW") && !match($result, "core::global")) {
        $result = $result . "  # REVIEW: @{$ref} array dereference â€” use @$ref or @{$ref} (same syntax in Strada)";
    }

    # ---- Final pass: %{$ref} hash dereference annotation ----
    if (match($result, "%\\{\\s*\\$") && !match($result, "^\\s*#") && !match($result, "#.*REVIEW") && !match($result, "core::global") && !match($result, "%\\{\\$self")) {
        $result = $result . "  # REVIEW: %{$ref} hash dereference â€” use %$ref or %{$ref} (same syntax in Strada)";
    }

    # ---- Final pass: $$ref scalar dereference annotation ----
    # $$var (not $${, $$_, $$1, or inside comments)
    my str $dol2 = "$" . "$";
    if (match($result, "\\$\\$[A-Za-z]") && !match($result, "^\\s*#") && !match($result, "#.*REVIEW") && !match($result, "\\$\\$self") && !match($result, "\\$\\$class")) {
        $result = $result . "  # REVIEW: " . $dol2 . "ref scalar dereference â€” use " . "$" . "{" . "$" . "ref} in Strada";
    }

    # ---- Final pass: &$coderef() -> $coderef->() ----
    if (match($result, "&\\$[A-Za-z_]") && !match($result, "^\\s*#") && !match($result, "#.*REVIEW") && !match($result, "defined\\s+&")) {
        # Convert &$var(...) to $var->(...) using index-based replacement
        my int $amp_pos = index($result, "&$");
        if ($amp_pos >= 0) {
            # Find the variable name after &$
            my int $amp_end = $amp_pos + 2;
            while ($amp_end < length($result) && (match(substr($result, $amp_end, 1), "[A-Za-z0-9_]"))) {
                $amp_end++;
            }
            my str $amp_var = substr($result, $amp_pos + 1, $amp_end - $amp_pos - 1);
            # Check if followed by (
            if ($amp_end < length($result) && substr($result, $amp_end, 1) eq "(") {
                # &$var(...) -> $var->(...)
                $result = substr($result, 0, $amp_pos) . $amp_var . "->" . substr($result, $amp_end, length($result) - $amp_end);
            } else {
                # bare &$var -> $var->()
                $result = substr($result, 0, $amp_pos) . $amp_var . "->()" . substr($result, $amp_end, length($result) - $amp_end);
            }
        }
        $result = $result . "  # REVIEW: coderef call â€” converted from &" . "$" . "ref to " . "$" . "ref->()";
    }
    # &{$expr}(...) -> ${expr}->(...)
    if (match($result, "&\\{\\$") && !match($result, "^\\s*#") && !match($result, "#.*REVIEW")) {
        $result = $result . "  # REVIEW: &{expr}() coderef call â€” rewrite as " . "$" . "ref->() in Strada";
    }

    # ---- Final pass: caller() -> annotate ----
    if (match($result, "\\bcaller\\s*\\(") && !match($result, "^\\s*#") && !match($result, "#.*REVIEW") && !match($result, "core::caller")) {
        $result = $result . "  # REVIEW: caller() â€” Strada has core::stack_trace(); caller() returns differ from Perl";
    }

    # ---- Final pass: for (;;) -> while (1) ----
    if (match($result, "\\bfor\\s*\\(\\s*;\\s*;\\s*\\)") && !match($result, "^\\s*#")) {
        $result = replace($result, "\\bfor\\s*\\(\\s*;\\s*;\\s*\\)", "while (1)");
    }

    # ---- Final pass: no warnings / no strict inside blocks ----
    if (match($result, "\\bno\\s+warnings\\b") && !match($result, "^\\s*#")) {
        $result = replace($result, "no\\s+warnings\\s*['\"][^'\"]*['\"]\\s*;", "# no warnings;  # Not needed in Strada");
        if (match($result, "\\bno\\s+warnings\\s*;")) {
            $result = replace($result, "no\\s+warnings\\s*;", "# no warnings;  # Not needed in Strada");
        }
    }
    if (match($result, "\\bno\\s+strict\\b") && !match($result, "^\\s*#")) {
        $result = replace($result, "no\\s+strict\\s*['\"][^'\"]*['\"]\\s*;", "# no strict;  # Not needed in Strada");
        if (match($result, "\\bno\\s+strict\\s*;")) {
            $result = replace($result, "no\\s+strict\\s*;", "# no strict;  # Not needed in Strada");
        }
    }

    # ---- Final pass: -f _ / -d _ stat cache ----
    if (match($result, "-[fdlrwxoeszpSbctugkTBAMC]\\s+_\\b") && !match($result, "^\\s*#") && !match($result, "#.*REVIEW")) {
        $result = $result . "  # REVIEW: -X _ (Perl stat cache) â€” Strada has no stat cache; re-specify the path with core::is_file/is_dir/stat";
    }

    # ---- Final pass: $] (Perl version) ----
    my str $dol_rbracket = "$" . "]";
    if (index($result, $dol_rbracket) >= 0 && !match($result, "^\\s*#") && !match($result, "#.*REVIEW")) {
        # Make sure it's actually $] and not $array]
        my int $pv_pos = index($result, $dol_rbracket);
        if ($pv_pos >= 0 && ($pv_pos == 0 || substr($result, $pv_pos - 1, 1) ne "[")) {
            $result = $result . "  # REVIEW: " . $dol_rbracket . " (Perl version) â€” not applicable in Strada; remove or replace with version constant";
        }
    }

    # ---- Final pass: sysread/syswrite annotation ----
    if (match($result, "\\bsysread\\s*\\(") && !match($result, "^\\s*#") && !match($result, "#.*REVIEW")) {
        $result = $result . "  # REVIEW: sysread() â€” use core::read() or __C__ { read(fd, buf, count); } in Strada";
    }
    if (match($result, "\\bsyswrite\\s*\\(") && !match($result, "^\\s*#") && !match($result, "#.*REVIEW")) {
        $result = $result . "  # REVIEW: syswrite() â€” use core::write() or __C__ { write(fd, buf, count); } in Strada";
    }

    # ---- Final pass: open with PerlIO layers ----
    if (match($result, "\\bopen\\s*\\(.*<:.*encoding") && !match($result, "^\\s*#") && !match($result, "#.*REVIEW") && !match($result, "core::open")) {
        $result = $result . "  # REVIEW: PerlIO encoding layer â€” Strada has no PerlIO layers; use core::open() for basic I/O";
    }

    # ---- Final pass: open BAREWORD ----
    if (match($result, "\\bopen\\s+[A-Z][A-Z_]*\\s*,") && !match($result, "^\\s*#") && !match($result, "#.*REVIEW")) {
        $result = $result . "  # REVIEW: bareword filehandle â€” use my scalar $fh = core::open(path, mode) instead";
    }

    # ---- Final pass: local $hash{key} = val â€” save/restore pattern ----
    if (match($result, "\\blocal\\s+\\$[A-Za-z_][A-Za-z0-9_]*\\{") && !match($result, "^\\s*#") && !match($result, "#.*REVIEW") && !match($result, "local\\s+\\$SIG")) {
        # local $hash{key} = val â†’ manual save/restore
        my array @lhk_cap = capture($result, "\\blocal\\s+(\\$[A-Za-z_][A-Za-z0-9_]*\\{[^}]+\\})\\s*=\\s*(.+);");
        if (scalar(@lhk_cap) > 2) {
            my str $lhk_target = $lhk_cap[1];
            my str $lhk_val = $lhk_cap[2];
            $result = $indent . "my scalar $__saved_local = " . $lhk_target . ";  # save for restore\n" . $indent . $lhk_target . " = " . $lhk_val . ";\n" . $indent . "# REVIEW: add '" . $lhk_target . " = $__saved_local;' at end of scope to restore (was local)";
        } else {
            $result = replace($result, "\\blocal\\s+", "");
            $result = $result . "  # REVIEW: was local $hash{key} â€” value not restored on scope exit; add manual save/restore";
        }
    }

    # ---- Final pass: local $var on non-special variables (not $SIG, $ENV, $!, $@, $_, Pkg::) ----
    if (match($result, "\\blocal\\s+\\$[a-zA-Z]") && !match($result, "^\\s*#") && !match($result, "#.*REVIEW") && !match($result, "local\\s+\\$SIG") && !match($result, "local\\s+\\$ENV") && !match($result, "local\\s+\\$_") && !match($result, "local\\s+\\$[A-Z][a-z].*::")) {
        $result = $result . "  # REVIEW: local() dynamic scoping â€” Strada supports local for 'our' variables; for lexicals use my $var";
    }

    return $result;
}


# ============================================================
# Main conversion pipeline
# ============================================================

func add_header(str $source_file) str {
    my str $header = "# Converted from Perl: " . $source_file . "\n";
    $header = $header . "# Generated by perl2strada (multi-pass converter)\n";
    $header = $header . "# NOTE: Lines marked REVIEW: may need manual verification\n";
    $header = $header . "\n";
    return $header;
}

# Check if the file has top-level code outside subs that needs a main() wrapper
func has_toplevel_code(array @lines) int {
    my int $brace_depth = 0;
    my int $i = 0;
    my int $num_lines = scalar(@lines);

    while ($i < $num_lines) {
        my str $trimmed = trim_str($lines[$i]);

        # Skip blank lines, comments, pragmas, package declarations
        if ($trimmed eq "" || starts_with($trimmed, "#")) {
            $i++;
            next;
        }
        if (match($trimmed, "^use\\s+") || match($trimmed, "^package\\s+") || $trimmed eq "1;") {
            $i++;
            next;
        }
        if (match($trimmed, "^(sub|func)\\s+")) {
            # Skip the entire function body
            my int $ci = 0;
            my int $clen = length($trimmed);
            while ($ci < $clen) {
                my str $ch = substr($trimmed, $ci, 1);
                if ($ch eq "{") { $brace_depth++; }
                if ($ch eq "}") { $brace_depth--; }
                $ci++;
            }
            $i++;
            while ($i < $num_lines && $brace_depth > 0) {
                my str $bl = $lines[$i];
                my int $bi = 0;
                my int $blen = length($bl);
                while ($bi < $blen) {
                    my str $bch = substr($bl, $bi, 1);
                    if ($bch eq "{") { $brace_depth++; }
                    if ($bch eq "}") { $brace_depth--; }
                    $bi++;
                }
                $i++;
            }
            next;
        }

        # If we get here, this is top-level executable code
        return 1;
    }

    return 0;
}


func convert_file(str $input_path, str $output_path) int {
    my str $content = core::slurp($input_path);
    if (length($content) == 0) {
        say("Error: Cannot read or empty file: " . $input_path);
        return 1;
    }

    my array @lines = split("\n", $content);
    my int $num_lines = scalar(@lines);
    say("Read " . $num_lines . " lines from " . $input_path);

    # Pass 1: Pre-scan for sub signatures
    say("Pass 1: Scanning for function signatures...");
    my hash %sub_info = pass1_prescan(@lines);

    # Count subs found
    my array @info_keys = keys(%sub_info);
    my int $sub_count = 0;
    my int $ki = 0;
    while ($ki < scalar(@info_keys)) {
        if (starts_with($info_keys[$ki], "sig:")) {
            $sub_count++;
        }
        $ki++;
    }
    say("  Found " . $sub_count . " subroutine(s)");

    # Pass 2: Convert function signatures
    say("Pass 2: Converting function signatures...");
    my array @pass2 = pass2_signatures(@lines, %sub_info);

    # Pass 2b: Multi-line block conversions (eval -> try/catch)
    say("Pass 2b: Converting eval blocks to try/catch...");
    my array @pass2b = pass2b_eval_to_try(@pass2);

    # Pass 2c: POD blocks, DESTROY/AUTOLOAD, SUPER::
    say("Pass 2c: Processing POD blocks and special subs...");
    my array @pass2c = pass2c_pod_and_special(@pass2b);

    # Pass 2d: Join continuation lines (multiline postfix if/unless, etc.)
    say("Pass 2d: Joining continuation lines...");
    my array @pass2d = pass2d_join_continuations(@pass2c);

    # Pass 2e: Expand typeglob method-generation loops
    say("Pass 2e: Expanding typeglob methods...");
    my array @pass2e = pass2e_typeglob_methods(@pass2d);

    # Pass 3: Line-by-line conversion
    say("Pass 3: Converting syntax...");
    my str $output = add_header($input_path);

    my int $needs_main = has_toplevel_code(@pass2e);

    # Perl modules (.pm) are libraries - never generate a main() block
    if (match($input_path, "\\.pm$")) {
        $needs_main = 0;
    }

    my int $brace_depth = 0;
    my int $in_func = 0;
    my int $main_emitted = 0;
    my int $has_package_main = 0;

    # Check if there's a "package main;" that marks where top-level code starts
    my int $pkg_main_line = -1;
    my int $pi = 0;
    while ($pi < scalar(@pass2e)) {
        my str $pt = trim_str($pass2e[$pi]);
        if ($pt eq "package main;" || match($pt, "^package\\s+main\\s*;")) {
            $has_package_main = 1;
            $pkg_main_line = $pi;
        }
        $pi++;
    }

    my int $i = 0;
    my int $p2_lines = scalar(@pass2e);
    # Track which lines are inside func/sub bodies (to exclude from main wrapper)
    # Pre-scan to mark func body ranges
    my array @is_func_line = ();
    my int $pf = 0;
    while ($pf < $p2_lines) {
        push(@is_func_line, 0);
        $pf++;
    }
    $pf = 0;
    my int $pf_depth = 0;
    my int $pf_in = 0;
    while ($pf < $p2_lines) {
        my str $pft = trim_str($pass2e[$pf]);
        if ($pf_in == 0 && (match($pft, "^func\\s+") || match($pft, "^sub\\s+"))) {
            $pf_in = 1;
        }
        if ($pf_in == 1) {
            $is_func_line[$pf] = 1;
            my int $pfc = 0;
            my int $pflen = length($pft);
            while ($pfc < $pflen) {
                my str $pfch = substr($pft, $pfc, 1);
                if ($pfch eq "{") { $pf_depth++; }
                if ($pfch eq "}") { $pf_depth--; }
                $pfc++;
            }
            if ($pf_depth <= 0) {
                $pf_in = 0;
                $pf_depth = 0;
            }
        }
        $pf++;
    }

    # Check if there's a sub/func named "main" already
    my int $has_sub_main = 0;
    my int $hm = 0;
    while ($hm < $p2_lines) {
        my str $hmt = trim_str($pass2e[$hm]);
        if (match($hmt, "^(func|sub)\\s+main\\s*[({]") || match($hmt, "^(func|sub)\\s+main\\s*$")) {
            $has_sub_main = 1;
        }
        $hm++;
    }
    # Don't generate a main() wrapper if there's already a sub main
    if ($has_sub_main == 1) {
        $needs_main = 0;
    }

    # Two-bucket approach: collect func bodies and main body separately
    my str $preamble = "";   # Headers, pragmas, package decls, use statements
    my str $func_code = "";  # All func/sub definitions
    my str $main_body = "";  # Top-level executable code (goes in main())
    my int $in_data_section = 0;
    my str $cf_current_func = "";  # Track current function name for state var renaming

    while ($i < $p2_lines) {
        my str $line = $pass2e[$i];
        my str $trimmed = trim_str($line);
        my int $is_in_func = $is_func_line[$i];

        # Track current function name (for state variable renaming)
        if (match($trimmed, "^(func|sub)\\s+([A-Za-z_][A-Za-z0-9_]*)")) {
            my array @cf_cap = capture($trimmed, "^(?:func|sub)\\s+([A-Za-z_][A-Za-z0-9_]*)");
            if (scalar(@cf_cap) > 1) {
                $cf_current_func = $cf_cap[1];
            }
        }
        if ($is_in_func == 0) {
            $cf_current_func = "";
        }
        $sub_info{"__current_func"} = $cf_current_func;

        # __DATA__/__END__ section: preserve remaining lines as comments without converting
        if ($in_data_section == 1) {
            my str $data_line = "# __DATA__: " . $line;
            if ($needs_main == 1) {
                $preamble = $preamble . $data_line . "\n";
            } else {
                $output = $output . $data_line . "\n";
            }
            $i++;
            next;
        }
        if ($trimmed eq "__END__" || $trimmed eq "__DATA__") {
            $in_data_section = 1;
            my str $marker_line = "# " . $trimmed;
            if ($needs_main == 1) {
                $preamble = $preamble . $marker_line . "\n";
            } else {
                $output = $output . $marker_line . "\n";
            }
            $i++;
            next;
        }

        my str $converted = convert_line($line, %sub_info);
        my str $conv_trimmed = trim_str($converted);

        if ($is_in_func == 1) {
            # This line is part of a func/sub body
            if ($needs_main == 1) {
                $func_code = $func_code . $converted . "\n";
            } else {
                $output = $output . $converted . "\n";
            }
        } else {
            if ($needs_main == 1) {
                # When hitting a new package decl, flush accumulated func_code
                # so functions stay associated with their package
                if (match($conv_trimmed, "^package\\s+") && length($func_code) > 0) {
                    $preamble = $preamble . $func_code;
                    $func_code = "";
                }

                # Classify: preamble (stays outside main) vs executable (goes in main)
                my int $is_preamble = 0;
                if ($conv_trimmed eq "" || starts_with($conv_trimmed, "#") || starts_with($conv_trimmed, "#!/")) {
                    $is_preamble = 1;
                }
                if (match($conv_trimmed, "^package\\s+") || match($conv_trimmed, "^use\\s+") || match($conv_trimmed, "^import_lib\\s+") || match($conv_trimmed, "^import_object\\s+") || match($conv_trimmed, "^const\\s+") || match($conv_trimmed, "^our\\s+")) {
                    $is_preamble = 1;
                }
                # OOP declarations should stay at package level, not inside main()
                if (match($conv_trimmed, "^has\\s+(ro|rw)\\s+") || match($conv_trimmed, "^extends\\s+") || match($conv_trimmed, "^with\\s+")) {
                    $is_preamble = 1;
                }
                # "# use strict" style comments are preamble
                if (starts_with($conv_trimmed, "# use ") || starts_with($conv_trimmed, "# no ") || starts_with($conv_trimmed, "# 1;") || starts_with($conv_trimmed, "# __")) {
                    $is_preamble = 1;
                }

                if ($is_preamble == 1) {
                    # If we haven't started emitting main body yet, put in preamble
                    if (length($main_body) == 0) {
                        $preamble = $preamble . $converted . "\n";
                    } else {
                        # Comments/blanks interspersed with code go in main
                        if ($conv_trimmed eq "") {
                            $main_body = $main_body . "\n";
                        } else {
                            # Handle multi-line converted results (e.g. multiple extends/with)
                            my array @ml_lines = split("\n", $conv_trimmed);
                            my int $mli = 0;
                            while ($mli < scalar(@ml_lines)) {
                                $main_body = $main_body . "    " . trim_str($ml_lines[$mli]) . "\n";
                                $mli++;
                            }
                        }
                    }
                } else {
                    # Handle multi-line converted results
                    my array @ml_lines2 = split("\n", $conv_trimmed);
                    my int $mli2 = 0;
                    while ($mli2 < scalar(@ml_lines2)) {
                        $main_body = $main_body . "    " . trim_str($ml_lines2[$mli2]) . "\n";
                        $mli2++;
                    }
                    $main_emitted = 1;
                }
            } else {
                $output = $output . $converted . "\n";
            }
        }
        $i++;
    }

    # Assemble output: preamble, then funcs, then main()
    if ($needs_main == 1) {
        $output = $output . $preamble;
        if (length($func_code) > 0) {
            $output = $output . "\n" . $func_code;
        }
        if ($main_emitted == 1) {
            $output = $output . "\nfunc main() int {\n";
            $output = $output . $main_body;
            $output = $output . "    return 0;\n";
            $output = $output . "}\n";
        }
    }

    # Post-process: inject eval library imports if eval string was used
    my int $has_jit_eval = index($output, "Strada::JIT::eval(") >= 0;
    my int $has_interp_eval = index($output, "Strada::Interpreter::eval_string(") >= 0;
    if ($has_jit_eval == 1 || $has_interp_eval == 1) {
        # Determine import statement based on backend
        my str $eval_import = "";
        my str $init_call = "";
        if ($has_jit_eval == 1) {
            $eval_import = "use lib \"lib\";\nuse Strada::JIT;\n\n";
            $init_call = "Strada::JIT::init();";
        } else {
            $eval_import = "use lib \"lib\";\nuse Strada::Interpreter;\n\n";
            $init_call = "Strada::Interpreter::init();";
        }
        # Add import after the header comment block
        my int $insert_pos = 0;
        my int $search_pos = 0;
        while ($search_pos < length($output)) {
            my int $nl = index($output, "\n", $search_pos);
            if ($nl < 0) { last; }
            my str $check_line = substr($output, $search_pos, $nl - $search_pos);
            # Skip comment lines and blank lines at the top
            if (length($check_line) == 0 || substr($check_line, 0, 1) eq "#") {
                $search_pos = $nl + 1;
                $insert_pos = $search_pos;
            } else {
                last;
            }
        }
        $output = substr($output, 0, $insert_pos) . $eval_import . substr($output, $insert_pos, length($output) - $insert_pos);

        # Add init() at the start of main() if present
        my int $main_pos = index($output, "func main()");
        if ($main_pos >= 0) {
            my int $brace_pos = index($output, "{", $main_pos);
            if ($brace_pos >= 0) {
                my int $after_brace = $brace_pos + 1;
                $output = substr($output, 0, $after_brace) . "\n    " . $init_call . "\n" . substr($output, $after_brace, length($output) - $after_brace);
            }
        }
    }

    # Post-process: generate func import() for modules that used Exporter
    # Only for .pm files (library modules) that don't already have a func import
    if (match($input_path, "\\.pm$") && index($output, "func import(") < 0) {
        # Check all packages for export info
        my array @si_keys = keys(%sub_info);
        my int $sik = 0;
        while ($sik < scalar(@si_keys)) {
            my str $si_key = $si_keys[$sik];
            if (starts_with($si_key, "uses_exporter:")) {
                my str $exp_pkg = substr($si_key, 14, length($si_key) - 14);
                my str $exp_list = "";
                my str $exp_ok_list = "";
                if (length("" . $sub_info{"export:" . $exp_pkg}) > 0) {
                    $exp_list = "" . $sub_info{"export:" . $exp_pkg};
                }
                if (length("" . $sub_info{"export_ok:" . $exp_pkg}) > 0) {
                    $exp_ok_list = "" . $sub_info{"export_ok:" . $exp_pkg};
                }
                if (length($exp_list) > 0 || length($exp_ok_list) > 0) {
                    my str $imp_func = "\nfunc import(str $pkg, array @list) void {\n";
                    if (length($exp_list) > 0) {
                        $imp_func = $imp_func . "    # Exports: " . $exp_list . "\n";
                    }
                    if (length($exp_ok_list) > 0) {
                        $imp_func = $imp_func . "    # Optional exports: " . $exp_ok_list . "\n";
                    }
                    $imp_func = $imp_func . "}\n";
                    # Insert before end of file
                    $output = $output . $imp_func;
                }
            }
            $sik++;
        }
    }

    # Post-pass: Fix $__argN signature mismatches
    $output = fix_arg_signatures($output);

    # Post-pass: Clean up double semicolons (from eval->try conversion)
    while (match($output, ";;")) {
        $output = replace_all($output, ";;", ";");
    }

    # Post-pass: Fix orphaned else/} blocks from commented-out if/unless conditions
    $output = fix_orphaned_blocks($output);

    core::spew($output_path, $output);
    say("Converted: " . $input_path . " -> " . $output_path);
    return 0;
}

# Post-pass: Fix orphaned else/} blocks from commented-out if/unless conditions
# When convert_line() comments out a block-opening conditional (if/unless/while/for)
# with # REVIEW:, the corresponding } else {, } elsif (...) {, and closing } are left
# orphaned. This function detects those and comments them out too.
func fix_orphaned_blocks(str $text) str {
    my array @lines = split("\n", $text);
    my int $num = scalar(@lines);
    my array @out = ();
    my int $i = 0;
    while ($i < $num) {
        my str $line = $lines[$i];
        my str $trimmed = trim_str($line);
        my str $indent = get_indent($line);
        # Check if this is a commented-out block opener with # REVIEW:
        my int $is_commented_opener = 0;
        if (starts_with($trimmed, "# ") && match($trimmed, "# REVIEW:")) {
            # Extract the original code between "# " and "  # REVIEW:"
            my int $review_pos = index($trimmed, "  # REVIEW:");
            if ($review_pos > 2) {
                my str $orig = substr($trimmed, 2, $review_pos - 2);
                my str $orig_trimmed = trim_str($orig);
                # Check if original code starts with if/unless/while/for
                if (match($orig_trimmed, "^(if|unless|while|for)\\s*\\(")) {
                    # Check for net positive brace imbalance (opened a block)
                    my int $ob = 0;
                    my int $cb = 0;
                    my int $oi = 0;
                    while ($oi < length($orig)) {
                        my str $oc = substr($orig, $oi, 1);
                        if ($oc eq "{") { $ob++; }
                        if ($oc eq "}") { $cb++; }
                        $oi++;
                    }
                    if ($ob > $cb) {
                        $is_commented_opener = 1;
                    }
                }
            }
        }
        if ($is_commented_opener) {
            # Emit the commented-out line as-is
            push(@out, $line);
            $i++;
            # Track brace depth â€” the commented-out line opened a block
            my int $depth = 1;
            while ($depth > 0 && $i < $num) {
                my str $nline = $lines[$i];
                my str $ntrimmed = trim_str($nline);
                my str $nindent = get_indent($nline);
                # If already a comment, emit as-is
                if (starts_with($ntrimmed, "#") || length($ntrimmed) == 0) {
                    push(@out, $nline);
                    $i++;
                } elsif ($depth == 1 && (starts_with($ntrimmed, "} else {") || starts_with($ntrimmed, "} else{") || match($ntrimmed, "^\\}\\s*else\\s*\\{"))) {
                    # } else { at depth 1 â€” comment it out (} closes, { re-opens â†’ depth stays 1)
                    push(@out, $nindent . "# " . $ntrimmed . "  # orphaned â€” if/unless condition was commented out");
                    $i++;
                } elsif ($depth == 1 && (starts_with($ntrimmed, "} elsif") || match($ntrimmed, "^\\}\\s*elsif\\s*\\("))) {
                    # } elsif (...) { at depth 1 â€” comment it out (} closes, { re-opens â†’ depth stays 1)
                    push(@out, $nindent . "# " . $ntrimmed . "  # orphaned â€” if/unless condition was commented out");
                    $i++;
                } else {
                    # Count braces on this line
                    my int $nb = 0;
                    my int $ni = 0;
                    my int $nlen = length($ntrimmed);
                    while ($ni < $nlen) {
                        my str $nc = substr($ntrimmed, $ni, 1);
                        if ($nc eq "{") { $nb++; }
                        if ($nc eq "}") { $nb--; }
                        $ni++;
                    }
                    $depth = $depth + $nb;
                    if ($depth <= 0 && ($ntrimmed eq "}" || $ntrimmed eq "};")) {
                        # Standalone closing } that ends the orphaned block
                        push(@out, $nindent . "# " . $ntrimmed . "  # orphaned â€” if/unless condition was commented out");
                    } else {
                        push(@out, $nline);
                    }
                    $i++;
                }
            }
        } else {
            push(@out, $line);
            $i++;
        }
    }
    return join("\n", @out);
}

# Fix func signatures to include $__argN parameters used in the body
func fix_arg_signatures(str $text) str {
    my array @lines = split("\n", $text);
    my int $num = scalar(@lines);
    my int $i = 0;
    while ($i < $num) {
        my str $line = $lines[$i];
        my str $trimmed = trim_str($line);
        # Look for func declarations
        if (match($trimmed, "^func\\s+[A-Za-z_]") && match($trimmed, "\\(") && match($trimmed, "\\)")) {
            # Find the body of this function (collect lines until brace depth returns to 0)
            my str $body = "";
            my int $fd = 0;
            my int $j = $i;
            while ($j < $num) {
                my str $bl = $lines[$j];
                my str $bt = trim_str($bl);
                my int $bk = 0;
                my int $blen = length($bt);
                while ($bk < $blen) {
                    my str $bch = substr($bt, $bk, 1);
                    if ($bch eq "{") { $fd++; }
                    if ($bch eq "}") { $fd--; }
                    $bk++;
                }
                $body = $body . $bt . " ";
                if ($fd <= 0 && $j > $i) { last; }
                $j++;
            }
            # Find max $__argN used in body
            my int $max_arg = 0;
            my str $arg_check = "$" . "__arg";
            if (index($body, $arg_check) >= 0) {
                my int $ak = 1;
                while ($ak <= 9) {
                    my str $aname = "$" . "__arg" . "" . $ak;
                    if (index($body, $aname) >= 0 && $ak > $max_arg) {
                        $max_arg = $ak;
                    }
                    $ak++;
                }
            }
            if ($max_arg > 0) {
                # Check which $__argN are already in the signature
                my array @sig_cap = capture($trimmed, "^func\\s+[A-Za-z_][A-Za-z0-9_]*\\s*\\(([^)]*)\\)");
                if (scalar(@sig_cap) > 1) {
                    my str $sig = $sig_cap[1];
                    my str $new_params = "";
                    my int $ak2 = 1;
                    while ($ak2 <= $max_arg) {
                        my str $pname = "__arg" . "" . $ak2;
                        if (index($sig, $pname) < 0) {
                            $new_params = $new_params . ", scalar $" . $pname;
                        }
                        $ak2++;
                    }
                    if (length($new_params) > 0) {
                        # Add missing params before the closing paren
                        my str $old_sig_pat = "\\(" . $sig . "\\)";
                        my str $new_sig = "(" . $sig . $new_params . ")";
                        # Direct string replacement on the signature line
                        my str $old_line = $lines[$i];
                        my int $paren_close = index($old_line, ") ");
                        if ($paren_close < 0) { $paren_close = index($old_line, "){"); }
                        if ($paren_close >= 0) {
                            $lines[$i] = substr($old_line, 0, $paren_close) . $new_params . substr($old_line, $paren_close, length($old_line) - $paren_close);
                        }
                    }
                }
            }
        }
        $i++;
    }
    return join("\n", @lines);
}

func main(int $argc, array @argv) int {
    if ($argc < 2) {
        say("Usage: perl2strada [OPTIONS] input.pl [output.strada]");
        say("");
        say("Multi-pass Perl to Strada converter.");
        say("  Pass 1: Scans for sub signatures and parameter unpacking");
        say("  Pass 2: Converts sub -> func with typed parameters");
        say("  Pass 3: Line-by-line syntax conversion");
        say("");
        say("Options:");
        say("  --jit    Use Strada::JIT backend for eval() (default: Strada::Interpreter)");
        say("");
        say("If output file is not specified, uses input.strada");
        return 1;
    }

    # Parse options
    my int $arg_start = 1;
    while ($arg_start < $argc) {
        my str $a = $argv[$arg_start];
        if ($a eq "--jit") {
            $g_eval_backend = "jit";
            $arg_start = $arg_start + 1;
        } else {
            last;
        }
    }

    if ($arg_start >= $argc) {
        say("Error: no input file specified");
        return 1;
    }

    my str $input = $argv[$arg_start];
    my str $output = "";

    if ($arg_start + 1 < $argc) {
        $output = $argv[$arg_start + 1];
    } else {
        $output = $input;
        $output = replace($output, "\\.pl$", ".strada");
        $output = replace($output, "\\.pm$", ".strada");
        $output = replace($output, "\\.xs$", ".strada");
        if ($output eq $input) {
            $output = $input . ".strada";
        }
    }

    # Dispatch based on file extension
    if (match($input, "\\.xs$")) {
        my int $xs_status = convert_xs_file($input, $output);
        exit($xs_status);
        return 0;
    }

    my int $status = convert_file($input, $output);
    exit($status);
    return 0;
}
