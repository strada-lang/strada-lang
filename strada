#!/bin/bash
#
# strada - Compile Strada programs to native executables or shared libraries
#
# Usage: strada [options] input.strada [extra.c ...] [extra.o ...]
#
# Options:
#   -c          Keep the generated C file
#   -r, --run   Run the program after compiling
#   -o FILE     Specify output file name
#   -O LEVEL    Optimization level (0, 1, 2, 3, s, fast)
#   -g          Debug with Strada source (#line directives + DWARF)
#   --c-debug   Debug with C source only (DWARF, no #line)
#   --shared      Compile as shared library (.so)
#   --static      Compile as fully static binary (no dynamic linking)
#   --static-lib  Compile as static library (.a)
#   --object      Compile to object file only (.o)
#   -l LIB        Link with library (e.g., -l ssl -l crypto)
#   -I PATH       Add include path for C headers
#   -v            Verbose output
#   -h, --help    Show this help
#
# Extra Files:
#   You can include additional .c and .o files after the .strada file.
#   These are linked into the final executable, useful for extern "C" libraries.
#
# Examples:
#   strada hello.strada              # Creates ./hello
#   strada hello.strada myapp        # Creates ./myapp
#   strada -r hello.strada           # Compile and run
#   strada -c -g hello.strada        # Keep .c file, debug at Strada level
#   strada -c --c-debug hello.strada # Keep .c file, debug at C level
#   strada --shared mylib.strada     # Creates ./mylib.so
#   strada --static-lib mylib.strada # Creates ./mylib.a (static library)
#   strada --object mylib.strada     # Creates ./mylib.o (object file)
#   strada --static hello.strada     # Creates static binary (no libc dependency)
#
#   # Extern "C" examples:
#   strada app.strada lib/ssl/strada_ssl.c -l ssl -l crypto
#   strada app.strada lib/crypt/strada_crypt.c -l crypt
#   strada app.strada mylib.o -l z
#

set -e
#set -x

# Portable mktemp with suffix (works on Linux and macOS)
mktemp_suffix() {
    local suffix="$1"
    local tmp="$(mktemp)"
    local newfile="${tmp}${suffix}"
    mv "$tmp" "$newfile"
    echo "$newfile"
}

# Find the directory where this script lives
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source config.sh if it exists (generated by ./configure)
if [ -f "$SCRIPT_DIR/config.sh" ]; then
    . "$SCRIPT_DIR/config.sh"
fi

# When using bundled PCRE2, resolve paths relative to SCRIPT_DIR
# (config.sh stores absolute paths from the build machine, which may differ
# from the installed location)
if [ "${STRADA_PCRE2_BUNDLED:-0}" = "1" ]; then
    STRADA_PCRE2_CFLAGS="-DPCRE2_STATIC -I$SCRIPT_DIR/vendor/pcre2/src"
    STRADA_PCRE2_LIBS="$SCRIPT_DIR/vendor/pcre2/libpcre2-8.a"
fi

# Paths relative to script directory
STRADAC="$SCRIPT_DIR/stradac"
RUNTIME_SRC="$SCRIPT_DIR/runtime/strada_runtime.c"
RUNTIME_OBJ="$SCRIPT_DIR/runtime/strada_runtime.o"
RUNTIME_DIR="$SCRIPT_DIR/runtime"
REPL_DIR="$SCRIPT_DIR/tools"

# Default options
KEEP_C=0
RUN_AFTER=0
VERBOSE=0
OPT_LEVEL="2"
DEBUG_SYMBOLS=0
C_DEBUG_SYMBOLS=0
OUTPUT_FILE=""
SHARED_LIB=0
STATIC_LIB=0
OBJECT_ONLY=0
STATIC_LINK=0
SHOW_WARNINGS=0
ENABLE_PROFILING=0
NO_STACK_TRACE=0
REPL_MODE=0
SCRIPT_FILE=""
DOC_MODE=0
DOC_TOPIC=""
LIB_PATHS=()
LIB_PATHS_LOW=()
EXTRA_C_FILES=()
EXTRA_O_FILES=()
LINK_LIBS=()
INCLUDE_PATHS=()
PP_DEFINES=()
PP_INCLUDE_PATHS=()

# Colors (if terminal supports them)
if [ -t 1 ]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[0;33m'
    CYAN='\033[0;36m'
    BOLD='\033[1m'
    NC='\033[0m' # No Color
else
    RED=''
    GREEN=''
    YELLOW=''
    CYAN=''
    BOLD=''
    NC=''
fi

usage() {
    cat << EOF
Usage: strada [options] input.strada [extra.c ...] [extra.o ...]

Compile Strada programs to native executables or shared libraries.

Options:
  -c          Keep the generated C file
  -r, --run   Run the program after compiling
  -o FILE     Specify output file name
  -O LEVEL    Optimization level (0, 1, 2, 3, s, fast) [default: 2]
  -D NAME     Define preprocessor macro NAME as 1
  -D NAME=VAL Define preprocessor macro NAME as VAL
  -L PATH     Add library search path (high priority, searched first)
  -LL PATH    Add library search path (low priority, searched last)
  -l LIB      Link with library (e.g., -l ssl -l crypto)
  -I PATH     Add include path for C headers
  -g          Debug with Strada source (emits #line directives + DWARF symbols)
  -p, --profile  Enable function profiling (timing and call counts)
  --no-stack-trace  Disable stack traces for better performance
  --c-debug   Debug with C source only (DWARF symbols, no #line directives)
  --shared      Compile as shared library (.so)
  --static      Compile as fully static binary (no dynamic linking)
  --static-lib  Compile as static library (.a)
  --object      Compile to object file only (.o)
  --repl        Start interactive REPL
  --script FILE Run a REPL script file
  --doc TOPIC   Show documentation (module POD or guide)
  -w            Show compiler warnings (unused variables, etc.)
  -v          Verbose output
  -h, --help  Show this help

Extra Files:
  You can include additional .c and .o files after the .strada file.
  These are compiled/linked into the final executable, useful for extern "C".

Examples:
  strada hello.strada              # Creates ./hello
  strada hello.strada myapp        # Creates ./myapp
  strada -r hello.strada           # Compile and run
  strada -DDEBUG hello.strada      # Compile with DEBUG defined
  strada -DDEBUG -DVERSION=2 app.strada  # Multiple defines
  strada -L /opt/strada/lib -r app.strada  # Use custom lib path
  strada -c -g hello.strada        # Keep .c file, debug at Strada level
  strada -c --c-debug hello.strada # Keep .c file, debug at C level
  strada -O0 -g test.strada        # No optimization, debug build
  strada --shared mylib.strada     # Creates ./mylib.so
  strada --shared -o libfoo.so foo.strada  # Custom output name
  strada --static-lib mylib.strada # Creates ./mylib.a (static library)
  strada --object mylib.strada     # Creates ./mylib.o (object file)
  strada --static hello.strada     # Creates portable static binary

  # Extern "C" examples:
  strada app.strada lib/ssl/strada_ssl.c -l ssl -l crypto
  strada app.strada lib/crypt/strada_crypt.c -l crypt
  strada app.strada lib/compress/strada_compress.c -l z

EOF
    exit 0
}

error() {
    echo -e "${RED}error:${NC} $1" >&2
    exit 1
}

info() {
    if [ "$VERBOSE" -eq 1 ]; then
        echo -e "${GREEN}info:${NC} $1"
    fi
}

warn() {
    echo -e "${YELLOW}warning:${NC} $1" >&2
}

# Run a command, showing it first if verbose
run_cmd() {
    if [ "$VERBOSE" -eq 1 ]; then
        echo -e "${CYAN}\$${NC} $*"
    fi
    "$@"
}

# Show a command without running it (for display purposes)
show_cmd() {
    if [ "$VERBOSE" -eq 1 ]; then
        echo -e "${CYAN}\$${NC} $*"
    fi
}

# Parse command line arguments
POSITIONAL=()
while [[ $# -gt 0 ]]; do
    case $1 in
        -c)
            KEEP_C=1
            shift
            ;;
        -r|--run)
            RUN_AFTER=1
            shift
            ;;
        -o)
            OUTPUT_FILE="$2"
            shift 2
            ;;
        -O)
            OPT_LEVEL="$2"
            shift 2
            ;;
        -O*)
            OPT_LEVEL="${1#-O}"
            shift
            ;;
        -g)
            DEBUG_SYMBOLS=1
            shift
            ;;
        --c-debug)
            C_DEBUG_SYMBOLS=1
            shift
            ;;
        --shared)
            SHARED_LIB=1
            shift
            ;;
        --static)
            STATIC_LINK=1
            shift
            ;;
        --static-lib)
            STATIC_LIB=1
            shift
            ;;
        --object)
            OBJECT_ONLY=1
            shift
            ;;
        -w|--warnings)
            SHOW_WARNINGS=1
            shift
            ;;
        -p|--profile)
            ENABLE_PROFILING=1
            shift
            ;;
        --no-stack-trace)
            NO_STACK_TRACE=1
            shift
            ;;
        -LL)
            LIB_PATHS_LOW+=("$2")
            shift 2
            ;;
        -LL*)
            LIB_PATHS_LOW+=("${1#-LL}")
            shift
            ;;
        -L)
            LIB_PATHS+=("$2")
            shift 2
            ;;
        -L*)
            LIB_PATHS+=("${1#-L}")
            shift
            ;;
        -l)
            LINK_LIBS+=("$2")
            shift 2
            ;;
        -l*)
            LINK_LIBS+=("${1#-l}")
            shift
            ;;
        -I)
            INCLUDE_PATHS+=("$2")
            shift 2
            ;;
        -I*)
            INCLUDE_PATHS+=("${1#-I}")
            shift
            ;;
        -D)
            PP_DEFINES+=("$2")
            shift 2
            ;;
        -D*)
            PP_DEFINES+=("${1#-D}")
            shift
            ;;
        -v|--verbose)
            VERBOSE=1
            shift
            ;;
        -h|--help)
            usage
            ;;
        --repl)
            REPL_MODE=1
            shift
            ;;
        --script)
            SCRIPT_FILE="$2"
            shift 2
            ;;
        --doc)
            DOC_MODE=1
            DOC_TOPIC="$2"
            shift 2
            ;;
        -*)
            error "Unknown option: $1"
            ;;
        *)
            POSITIONAL+=("$1")
            shift
            ;;
    esac
done

# Restore positional parameters
set -- "${POSITIONAL[@]}"

# Handle REPL mode
if [ "$REPL_MODE" -eq 1 ]; then
    # Try strada-interp (interpreter), fall back to strada-jit (JIT REPL)
    INTERP_BIN="$SCRIPT_DIR/interpreter/strada-interp"
    if [ -x "$INTERP_BIN" ]; then
        exec "$INTERP_BIN" "$@"
    fi
    # Check installed location
    INTERP_BIN="$(dirname "$SCRIPT_DIR")/bin/strada-interp"
    if [ -x "$INTERP_BIN" ]; then
        exec "$INTERP_BIN" "$@"
    fi
    # Fall back to strada-jit
    REPL_BIN="$REPL_DIR/strada-jit"
    if [ -x "$REPL_BIN" ]; then
        exec "$REPL_BIN" "$@"
    fi
    error "Interpreter not found. Run 'make interpreter' to build it."
fi

# Handle script mode
if [ -n "$SCRIPT_FILE" ]; then
    if [ ! -f "$SCRIPT_FILE" ]; then
        error "Script file not found: $SCRIPT_FILE"
    fi
    # Try strada-interp first
    INTERP_BIN="$SCRIPT_DIR/interpreter/strada-interp"
    if [ -x "$INTERP_BIN" ]; then
        exec "$INTERP_BIN" "$SCRIPT_FILE" "$@"
    fi
    INTERP_BIN="$(dirname "$SCRIPT_DIR")/bin/strada-interp"
    if [ -x "$INTERP_BIN" ]; then
        exec "$INTERP_BIN" "$SCRIPT_FILE" "$@"
    fi
    # Fall back to strada-jit
    REPL_BIN="$REPL_DIR/strada-jit"
    if [ -x "$REPL_BIN" ]; then
        exec "$REPL_BIN" "$SCRIPT_FILE" "$@"
    fi
    error "Interpreter not found. Run 'make interpreter' to build it."
fi

# Handle doc mode
if [ "$DOC_MODE" -eq 1 ]; then
    # Look for stradadoc in same directory as this script (for installed version)
    # or in tools/ subdirectory (for development version)
    if [ -x "$SCRIPT_DIR/stradadoc" ]; then
        DOC_BIN="$SCRIPT_DIR/stradadoc"
    else
        DOC_BIN="$SCRIPT_DIR/tools/stradadoc"
    fi
    if [ ! -x "$DOC_BIN" ]; then
        error "stradadoc not found.\nRun './strada tools/stradadoc.strada' to build it, or 'make install' to install."
    fi
    exec "$DOC_BIN" "$DOC_TOPIC" "$@"
fi

# Check for input file
if [ $# -lt 1 ]; then
    echo "Usage: strada [options] input.strada [extra.c ...] [extra.o ...]"
    echo "Try 'strada --help' for more information."
    exit 1
fi

INPUT_FILE="$1"
shift

# Check input file exists
if [ ! -f "$INPUT_FILE" ]; then
    error "Input file not found: $INPUT_FILE"
fi

# Check input file has .strada extension
if [[ "$INPUT_FILE" != *.strada ]]; then
    warn "Input file does not have .strada extension"
fi

# Process remaining positional arguments - could be extra .c/.o files or output name
for arg in "$@"; do
    if [[ "$arg" == *.c ]]; then
        if [ ! -f "$arg" ]; then
            error "C file not found: $arg"
        fi
        EXTRA_C_FILES+=("$arg")
    elif [[ "$arg" == *.o ]]; then
        if [ ! -f "$arg" ]; then
            error "Object file not found: $arg"
        fi
        EXTRA_O_FILES+=("$arg")
    elif [ -z "$OUTPUT_FILE" ]; then
        # First non-.c/.o argument becomes output file name
        OUTPUT_FILE="$arg"
    else
        warn "Ignoring extra argument: $arg"
    fi
done

# Determine output file name
if [ -n "$OUTPUT_FILE" ]; then
    OUTPUT="$OUTPUT_FILE"
else
    # Remove .strada extension and path
    OUTPUT="$(basename "$INPUT_FILE" .strada)"
    # Add appropriate extension for libraries
    if [ "$SHARED_LIB" -eq 1 ]; then
        OUTPUT="${OUTPUT}.so"
    elif [ "$STATIC_LIB" -eq 1 ]; then
        OUTPUT="${OUTPUT}.a"
    elif [ "$OBJECT_ONLY" -eq 1 ]; then
        OUTPUT="${OUTPUT}.o"
    fi
fi

# Determine C file name
if [ "$KEEP_C" -eq 1 ]; then
    C_FILE="${OUTPUT}.c"
else
    C_FILE="$(mktemp_suffix .c)"
    trap "rm -f '$C_FILE'" EXIT
fi

# Check for stradac
if [ ! -x "$STRADAC" ]; then
    error "Strada compiler not found at $STRADAC\nRun 'make' in $SCRIPT_DIR to build it."
fi

# Check for runtime
if [ ! -f "$RUNTIME_SRC" ]; then
    error "Runtime not found at $RUNTIME_SRC"
fi

# Build pre-compiled runtime if needed (much faster compilation)
build_runtime() {
    info "Building pre-compiled runtime..."
    local PCRE2_DEF=""
    if [ "${STRADA_HAVE_PCRE2:-0}" = "1" ]; then
        PCRE2_DEF="-DHAVE_PCRE2 $STRADA_PCRE2_CFLAGS"
    fi
    if ! run_cmd gcc -O2 -std=c99 -ffunction-sections -fdata-sections $PCRE2_DEF -c "$RUNTIME_SRC" -I"$RUNTIME_DIR" -o "$RUNTIME_OBJ"; then
        error "Failed to compile runtime"
    fi
}

if [ ! -f "$RUNTIME_OBJ" ]; then
    build_runtime
elif [ "$RUNTIME_SRC" -nt "$RUNTIME_OBJ" ]; then
    info "Runtime source changed, rebuilding..."
    build_runtime
fi

# Build gcc flags (portable flags only - GCC-specific flags added conditionally)
GCC_FLAGS="-Wall -Wextra -Wno-unused-variable -Wno-unused-function -Wno-return-type -Wno-unused-result -Wno-comment -std=c99 -ffunction-sections -fdata-sections"
# Add GCC-specific flags if not using clang
if ! $CC --version 2>&1 | grep -q clang; then
    GCC_FLAGS="$GCC_FLAGS -Wno-unused-but-set-variable -Wno-clobbered"
fi
GCC_FLAGS="$GCC_FLAGS -O$OPT_LEVEL"
if [ "$DEBUG_SYMBOLS" -eq 1 ] || [ "$C_DEBUG_SYMBOLS" -eq 1 ]; then
    GCC_FLAGS="$GCC_FLAGS -g"
fi

# Pass -D defines to C compiler as well (for #ifdef in embedded C code)
for def in "${PP_DEFINES[@]}"; do
    GCC_FLAGS="$GCC_FLAGS -D$def"
done

# Build extra include paths
INCLUDE_FLAGS=""
for path in "${INCLUDE_PATHS[@]}"; do
    INCLUDE_FLAGS="$INCLUDE_FLAGS -I$path"
done

# Build extra link libraries
LINK_FLAGS=""
for lib in "${LINK_LIBS[@]}"; do
    LINK_FLAGS="$LINK_FLAGS -l$lib"
done

# Add PCRE2 libraries if available
if [ "${STRADA_HAVE_PCRE2:-0}" = "1" ]; then
    LINK_FLAGS="$LINK_FLAGS $STRADA_PCRE2_LIBS"
fi

# Build extra source/object file lists
EXTRA_FILES=""
for f in "${EXTRA_C_FILES[@]}"; do
    EXTRA_FILES="$EXTRA_FILES $f"
done
for f in "${EXTRA_O_FILES[@]}"; do
    EXTRA_FILES="$EXTRA_FILES $f"
done

# Show info about extra files
if [ ${#EXTRA_C_FILES[@]} -gt 0 ] || [ ${#EXTRA_O_FILES[@]} -gt 0 ]; then
    info "Extra files: ${EXTRA_C_FILES[*]} ${EXTRA_O_FILES[*]}"
fi
if [ ${#LINK_LIBS[@]} -gt 0 ]; then
    info "Extra libraries: ${LINK_LIBS[*]}"
fi

# Step 0: Run preprocessor if -D flags were given
# Look for stradapp in same directory as this script (for installed version)
# or in tools/ subdirectory (for development version)
if [ -x "$SCRIPT_DIR/stradapp" ]; then
    PREPROCESSOR="$SCRIPT_DIR/stradapp"
else
    PREPROCESSOR="$SCRIPT_DIR/tools/stradapp"
fi
ACTUAL_INPUT="$INPUT_FILE"

if [ ${#PP_DEFINES[@]} -gt 0 ]; then
    # Check for preprocessor
    if [ ! -x "$PREPROCESSOR" ]; then
        error "Preprocessor not found.\nRun './strada tools/stradapp.strada' to build it, or 'make install' to install."
    fi

    # Build preprocessor flags
    PP_FLAGS=""
    for def in "${PP_DEFINES[@]}"; do
        PP_FLAGS="$PP_FLAGS -D$def"
    done

    # Create temp file for preprocessed output
    PP_OUTPUT="$(mktemp_suffix .strada)"
    trap "rm -f '$PP_OUTPUT' '$C_FILE'" EXIT

    info "Preprocessing $INPUT_FILE (defines: ${PP_DEFINES[*]})"
    if ! run_cmd "$PREPROCESSOR" $PP_FLAGS "$INPUT_FILE" -o "$PP_OUTPUT"; then
        error "Preprocessing failed"
    fi

    # Use preprocessed file as input
    ACTUAL_INPUT="$PP_OUTPUT"
fi

# Step 1: Compile Strada to C
# Export STRADA_DIR so stradac knows where the runtime is
export STRADA_DIR="$SCRIPT_DIR"
# Build stradac flags
STRADAC_FLAGS=""
if [ "$DEBUG_SYMBOLS" -eq 1 ]; then
    STRADAC_FLAGS="$STRADAC_FLAGS -g"
fi
if [ "$SHOW_WARNINGS" -eq 1 ]; then
    STRADAC_FLAGS="$STRADAC_FLAGS -w"
fi
if [ "$ENABLE_PROFILING" -eq 1 ]; then
    STRADAC_FLAGS="$STRADAC_FLAGS -p"
fi
if [ "$NO_STACK_TRACE" -eq 1 ]; then
    STRADAC_FLAGS="$STRADAC_FLAGS --no-stack-trace"
fi
# Add library paths (high priority)
for path in "${LIB_PATHS[@]}"; do
    STRADAC_FLAGS="$STRADAC_FLAGS -L $path"
done
# Add library paths (low priority)
for path in "${LIB_PATHS_LOW[@]}"; do
    STRADAC_FLAGS="$STRADAC_FLAGS -LL $path"
done

info "Compiling $ACTUAL_INPUT -> $C_FILE"
if [ -n "$STRADAC_FLAGS" ]; then
    if ! run_cmd "$STRADAC" $STRADAC_FLAGS "$ACTUAL_INPUT" "$C_FILE"; then
        error "Strada compilation failed"
    fi
else
    if ! run_cmd "$STRADAC" "$ACTUAL_INPUT" "$C_FILE"; then
        error "Strada compilation failed"
    fi
fi

# Extract import_object files from generated C (static linking)
IMPORT_OBJECT_FILES=""
if grep -q '__STRADA_OBJECT_FILES__:' "$C_FILE" 2>/dev/null; then
    # Extract object files from the comment: __STRADA_OBJECT_FILES__: path1.o path2.o ...
    IMPORT_OBJECT_FILES=$(grep '__STRADA_OBJECT_FILES__:' "$C_FILE" | sed 's/.*__STRADA_OBJECT_FILES__: *//' | sed 's/ *\*\///')
    if [ -n "$IMPORT_OBJECT_FILES" ]; then
        info "import_object files: $IMPORT_OBJECT_FILES"
        # Verify each object file exists
        for obj in $IMPORT_OBJECT_FILES; do
            if [ ! -f "$obj" ]; then
                error "import_object: object file not found: $obj"
            fi
        done
        # Add to extra files for linking
        EXTRA_FILES="$EXTRA_FILES $IMPORT_OBJECT_FILES"
    fi
fi

# Extract import_archive files from generated C (static linking)
IMPORT_ARCHIVE_FILES=""
SKIP_RUNTIME=0
if grep -q '__STRADA_ARCHIVE_FILES__:' "$C_FILE" 2>/dev/null; then
    # Extract archive files from the comment: __STRADA_ARCHIVE_FILES__: path1.a path2.a ...
    IMPORT_ARCHIVE_FILES=$(grep '__STRADA_ARCHIVE_FILES__:' "$C_FILE" | sed 's/.*__STRADA_ARCHIVE_FILES__: *//' | sed 's/ *\*\///')
    if [ -n "$IMPORT_ARCHIVE_FILES" ]; then
        info "import_archive files: $IMPORT_ARCHIVE_FILES"
        # Verify each archive file exists
        for arch in $IMPORT_ARCHIVE_FILES; do
            if [ ! -f "$arch" ]; then
                error "import_archive: archive file not found: $arch"
            fi
        done
        # Add to extra files for linking
        EXTRA_FILES="$EXTRA_FILES $IMPORT_ARCHIVE_FILES"
    fi
    # Check if we should skip runtime (archives include it)
    if grep -q '__STRADA_SKIP_RUNTIME__' "$C_FILE" 2>/dev/null; then
        SKIP_RUNTIME=1
        info "Skipping runtime (included in archive)"
    fi
fi

# Step 2: Compile C to executable or library
if [ "$SHARED_LIB" -eq 1 ]; then
    # Shared library: -shared -fPIC, link against runtime source (not object)
    if [ "$STATIC_LINK" -eq 1 ]; then
        error "Cannot use --shared and --static together"
    fi
    if [ "$STATIC_LIB" -eq 1 ]; then
        error "Cannot use --shared and --static-lib together"
    fi
    if [ "$OBJECT_ONLY" -eq 1 ]; then
        error "Cannot use --shared and --object together"
    fi
    info "Compiling $C_FILE -> $OUTPUT (shared library)"
    # Note: We do NOT link the runtime into shared libraries.
    # The runtime symbols are provided by the main program (compiled with -rdynamic).
    # This avoids duplicate globals when the .so is loaded.
    if ! run_cmd gcc -shared -fPIC $GCC_FLAGS -o "$OUTPUT" "$C_FILE" $EXTRA_FILES -I"$RUNTIME_DIR" $INCLUDE_FLAGS -ldl -lm -lpthread $LINK_FLAGS; then
        error "C compilation failed"
    fi
elif [ "$OBJECT_ONLY" -eq 1 ]; then
    # Object file only: compile to .o without linking
    if [ "$STATIC_LIB" -eq 1 ]; then
        error "Cannot use --object and --static-lib together"
    fi
    if [ "$STATIC_LINK" -eq 1 ]; then
        error "Cannot use --object and --static together"
    fi
    info "Compiling $C_FILE -> $OUTPUT (object file)"
    if ! run_cmd gcc -c $GCC_FLAGS -o "$OUTPUT" "$C_FILE" -I"$RUNTIME_DIR" $INCLUDE_FLAGS; then
        error "C compilation failed"
    fi
elif [ "$STATIC_LIB" -eq 1 ]; then
    # Static library: compile to .o then archive with ar
    if [ "$STATIC_LINK" -eq 1 ]; then
        error "Cannot use --static-lib and --static together"
    fi
    OBJ_FILE="${OUTPUT%.a}.o"
    RUNTIME_OBJ_STATIC="${OUTPUT%.a}_runtime.o"
    # Compile extra C files to objects
    EXTRA_OBJ_FILES=()
    for cf in "${EXTRA_C_FILES[@]}"; do
        obj_name="$(basename "$cf" .c).o"
        info "Compiling $cf -> $obj_name"
        if ! run_cmd gcc -c $GCC_FLAGS -o "$obj_name" "$cf" -I"$RUNTIME_DIR" $INCLUDE_FLAGS; then
            error "Compilation of $cf failed"
        fi
        EXTRA_OBJ_FILES+=("$obj_name")
    done
    info "Compiling $C_FILE -> $OBJ_FILE"
    if ! run_cmd gcc -c $GCC_FLAGS -o "$OBJ_FILE" "$C_FILE" -I"$RUNTIME_DIR" $INCLUDE_FLAGS; then
        error "C compilation failed"
    fi
    info "Compiling runtime -> $RUNTIME_OBJ_STATIC"
    if ! run_cmd gcc -c $GCC_FLAGS -o "$RUNTIME_OBJ_STATIC" "$RUNTIME_SRC" -I"$RUNTIME_DIR"; then
        error "Runtime compilation failed"
    fi
    info "Creating archive $OUTPUT"
    if ! run_cmd ar rcs "$OUTPUT" "$OBJ_FILE" "$RUNTIME_OBJ_STATIC" "${EXTRA_OBJ_FILES[@]}" "${EXTRA_O_FILES[@]}"; then
        error "ar failed"
    fi
    # Clean up object files
    rm -f "$OBJ_FILE" "$RUNTIME_OBJ_STATIC" "${EXTRA_OBJ_FILES[@]}"
elif [ "$STATIC_LINK" -eq 1 ]; then
    # Static binary: no dynamic linking, fully portable
    # Note: -ldl removed (no dynamic loading), -lpthread needs special handling
    info "Compiling $C_FILE -> $OUTPUT (static binary)"
    warn "Static binaries cannot use FFI/dynamic library loading (sys::dl_open, import_lib)"
    if ! run_cmd gcc -static $GCC_FLAGS -Wl,--gc-sections -o "$OUTPUT" "$C_FILE" $EXTRA_FILES "$RUNTIME_SRC" -I"$RUNTIME_DIR" $INCLUDE_FLAGS -lm -lpthread $LINK_FLAGS; then
        error "C compilation failed"
    fi
else
    # Executable linking
    # Only use -rdynamic when the program needs FFI/import_lib (uses dlopen).
    # Without -rdynamic, -Wl,--gc-sections can strip unused runtime functions,
    # producing much smaller binaries.
    RDYNAMIC_FLAG=""
    if grep -qE 'dlopen|strada_dl_open|strada_tie_hash' "$C_FILE" 2>/dev/null; then
        RDYNAMIC_FLAG="-rdynamic"
        info "FFI/import_lib detected, using -rdynamic"
    fi
    info "Compiling $C_FILE -> $OUTPUT"
    if [ "$SKIP_RUNTIME" -eq 1 ]; then
        # Skip runtime when import_archive is used (archive includes runtime)
        if ! run_cmd gcc $RDYNAMIC_FLAG $GCC_FLAGS -Wl,--gc-sections -o "$OUTPUT" "$C_FILE" $EXTRA_FILES -I"$RUNTIME_DIR" $INCLUDE_FLAGS -ldl -lm -lpthread $LINK_FLAGS; then
            error "C compilation failed"
        fi
    else
        if ! run_cmd gcc $RDYNAMIC_FLAG $GCC_FLAGS -Wl,--gc-sections -o "$OUTPUT" "$C_FILE" $EXTRA_FILES "$RUNTIME_OBJ" -I"$RUNTIME_DIR" $INCLUDE_FLAGS -ldl -lm -lpthread $LINK_FLAGS; then
            error "C compilation failed"
        fi
    fi
fi

echo -e "${GREEN}Created:${NC} $OUTPUT"

# Step 3: Run if requested
if [ "$RUN_AFTER" -eq 1 ]; then
    if [ "$SHARED_LIB" -eq 1 ]; then
        warn "Cannot run a shared library directly. Use --shared without --run."
    elif [ "$STATIC_LIB" -eq 1 ]; then
        warn "Cannot run a static library directly. Use --static-lib without --run."
    elif [ "$OBJECT_ONLY" -eq 1 ]; then
        warn "Cannot run an object file directly. Use --object without --run."
    else
        echo ""
        show_cmd "./$OUTPUT"
        echo "---"
        exec "./$OUTPUT"
    fi
fi
