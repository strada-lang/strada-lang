package Markdown;

# Markdown.strada - Markdown to HTML conversion library
# Usage: use lib "lib"; use Markdown; my str $html = Markdown::to_html($markdown);

# HTML escape special characters
func html_escape(str $s) str {
    my str $result = $s;
    $result =~ s/&/&amp;/g;
    $result =~ s/</&lt;/g;
    $result =~ s/>/&gt;/g;
    return $result;
}

# Process inline formatting (bold, italic, code, links)
private func process_inline(str $line) str {
    my str $result = $line;

    # Inline code - handle separately using index/substr since backticks are tricky in regex
    my int $done = 0;
    while ($done == 0) {
        my int $start = index($result, "`");
        if ($start < 0) {
            $done = 1;
        } else {
            my int $end = index($result, "`", $start + 1);
            if ($end < 0) {
                $done = 1;
            } else {
                my str $before = substr($result, 0, $start);
                my str $code = substr($result, $start + 1, $end - $start - 1);
                my str $after = substr($result, $end + 1, length($result) - $end - 1);
                my str $escaped = ::html_escape($code);
                $result = $before . "<code>" . $escaped . "</code>" . $after;
            }
        }
    }

    # Bold: **text** - use string operations
    $done = 0;
    while ($done == 0) {
        my int $start = index($result, "**");
        if ($start < 0) {
            $done = 1;
        } else {
            my int $end = index($result, "**", $start + 2);
            if ($end < 0) {
                $done = 1;
            } else {
                my str $before = substr($result, 0, $start);
                my str $bold = substr($result, $start + 2, $end - $start - 2);
                my str $after = substr($result, $end + 2, length($result) - $end - 2);
                $result = $before . "<strong>" . $bold . "</strong>" . $after;
            }
        }
    }

    # Bold: __text__
    $done = 0;
    while ($done == 0) {
        my int $start = index($result, "__");
        if ($start < 0) {
            $done = 1;
        } else {
            my int $end = index($result, "__", $start + 2);
            if ($end < 0) {
                $done = 1;
            } else {
                my str $before = substr($result, 0, $start);
                my str $bold = substr($result, $start + 2, $end - $start - 2);
                my str $after = substr($result, $end + 2, length($result) - $end - 2);
                $result = $before . "<strong>" . $bold . "</strong>" . $after;
            }
        }
    }

    # Italic: *text* - use string operations (single asterisk)
    $done = 0;
    while ($done == 0) {
        my int $start = index($result, "*");
        if ($start < 0) {
            $done = 1;
        } else {
            my int $end = index($result, "*", $start + 1);
            if ($end < 0) {
                $done = 1;
            } else {
                my str $before = substr($result, 0, $start);
                my str $italic = substr($result, $start + 1, $end - $start - 1);
                my str $after = substr($result, $end + 1, length($result) - $end - 1);
                $result = $before . "<em>" . $italic . "</em>" . $after;
            }
        }
    }

    # Italic: _text_
    $done = 0;
    while ($done == 0) {
        my int $start = index($result, "_");
        if ($start < 0) {
            $done = 1;
        } else {
            my int $end = index($result, "_", $start + 1);
            if ($end < 0) {
                $done = 1;
            } else {
                my str $before = substr($result, 0, $start);
                my str $italic = substr($result, $start + 1, $end - $start - 1);
                my str $after = substr($result, $end + 1, length($result) - $end - 1);
                $result = $before . "<em>" . $italic . "</em>" . $after;
            }
        }
    }

    # Images: ![alt](url) - process before links
    $done = 0;
    while ($done == 0) {
        my int $bang = index($result, "![");
        if ($bang < 0) {
            $done = 1;
        } else {
            my int $close_bracket = index($result, "]", $bang + 2);
            if ($close_bracket < 0) {
                $done = 1;
            } else {
                my int $open_paren = index($result, "(", $close_bracket);
                if ($open_paren != $close_bracket + 1) {
                    $done = 1;
                } else {
                    my int $close_paren = index($result, ")", $open_paren);
                    if ($close_paren < 0) {
                        $done = 1;
                    } else {
                        my str $before = substr($result, 0, $bang);
                        my str $alt = substr($result, $bang + 2, $close_bracket - $bang - 2);
                        my str $url = substr($result, $open_paren + 1, $close_paren - $open_paren - 1);
                        my str $after = substr($result, $close_paren + 1, length($result) - $close_paren - 1);
                        $result = $before . "<img src=\"" . $url . "\" alt=\"" . $alt . "\">" . $after;
                    }
                }
            }
        }
    }

    # Links: [text](url)
    $done = 0;
    while ($done == 0) {
        my int $open_bracket = index($result, "[");
        if ($open_bracket < 0) {
            $done = 1;
        } else {
            my int $close_bracket = index($result, "]", $open_bracket + 1);
            if ($close_bracket < 0) {
                $done = 1;
            } else {
                my int $open_paren = index($result, "(", $close_bracket);
                if ($open_paren != $close_bracket + 1) {
                    $done = 1;
                } else {
                    my int $close_paren = index($result, ")", $open_paren);
                    if ($close_paren < 0) {
                        $done = 1;
                    } else {
                        my str $before = substr($result, 0, $open_bracket);
                        my str $text = substr($result, $open_bracket + 1, $close_bracket - $open_bracket - 1);
                        my str $url = substr($result, $open_paren + 1, $close_paren - $open_paren - 1);
                        my str $after = substr($result, $close_paren + 1, length($result) - $close_paren - 1);
                        $result = $before . "<a href=\"" . $url . "\">" . $text . "</a>" . $after;
                    }
                }
            }
        }
    }

    return $result;
}

# Count leading characters
private func count_leading(str $s, str $ch) int {
    my int $count = 0;
    my int $len = length($s);
    while ($count < $len && substr($s, $count, 1) eq $ch) {
        $count = $count + 1;
    }
    return $count;
}

# Check if string contains only one char type
private func is_all_char(str $s, str $ch) int {
    my int $len = length($s);
    my int $i = 0;
    while ($i < $len) {
        if (substr($s, $i, 1) ne $ch) {
            return 0;
        }
        $i = $i + 1;
    }
    return 1;
}

# Check if line is a horizontal rule
private func is_hr(str $line) int {
    my str $trimmed = $line;
    $trimmed =~ s/[ ]//g;
    my int $len = length($trimmed);
    if ($len < 3) {
        return 0;
    }
    if (::is_all_char($trimmed, "-") == 1) {
        return 1;
    }
    if (::is_all_char($trimmed, "*") == 1) {
        return 1;
    }
    if (::is_all_char($trimmed, "_") == 1) {
        return 1;
    }
    return 0;
}

# Skip leading spaces and return remaining string
private func skip_spaces(str $s) str {
    my int $i = 0;
    my int $len = length($s);
    while ($i < $len && substr($s, $i, 1) eq " ") {
        $i = $i + 1;
    }
    return substr($s, $i, $len - $i);
}

# Check if line starts an unordered list item
private func is_ul_item(str $line) int {
    my str $trimmed = ::skip_spaces($line);
    if (length($trimmed) < 2) {
        return 0;
    }
    my str $first = substr($trimmed, 0, 1);
    my str $second = substr($trimmed, 1, 1);
    if (($first eq "-" || $first eq "*" || $first eq "+") && $second eq " ") {
        return 1;
    }
    return 0;
}

# Check if char is a digit
private func is_digit(str $c) int {
    if ($c eq "0" || $c eq "1" || $c eq "2" || $c eq "3" || $c eq "4" ||
        $c eq "5" || $c eq "6" || $c eq "7" || $c eq "8" || $c eq "9") {
        return 1;
    }
    return 0;
}

# Check if line starts an ordered list item
private func is_ol_item(str $line) int {
    my str $trimmed = ::skip_spaces($line);
    my int $len = length($trimmed);
    if ($len < 3) {
        return 0;
    }
    # Look for digits followed by ". "
    my int $i = 0;
    while ($i < $len && ::is_digit(substr($trimmed, $i, 1)) == 1) {
        $i = $i + 1;
    }
    if ($i == 0) {
        return 0;
    }
    if ($i + 1 < $len && substr($trimmed, $i, 2) eq ". ") {
        return 1;
    }
    return 0;
}

# Get list item content (strip marker)
private func get_list_content(str $line) str {
    my str $trimmed = ::skip_spaces($line);
    my int $len = length($trimmed);

    # Check for unordered list: - or * or + followed by space
    if ($len >= 2) {
        my str $first = substr($trimmed, 0, 1);
        if ($first eq "-" || $first eq "*" || $first eq "+") {
            if (substr($trimmed, 1, 1) eq " ") {
                return substr($trimmed, 2, $len - 2);
            }
        }
    }

    # Check for ordered list: digits followed by ". "
    my int $i = 0;
    while ($i < $len && ::is_digit(substr($trimmed, $i, 1)) == 1) {
        $i = $i + 1;
    }
    if ($i > 0 && $i + 1 < $len && substr($trimmed, $i, 2) eq ". ") {
        return substr($trimmed, $i + 2, $len - $i - 2);
    }

    return $trimmed;
}

# Check if line is a blockquote
private func is_blockquote(str $line) int {
    if (length($line) > 0 && substr($line, 0, 1) eq ">") {
        return 1;
    }
    return 0;
}

# Get blockquote content
private func get_blockquote_content(str $line) str {
    if (length($line) == 0) {
        return "";
    }
    # Skip the ">"
    my str $content = substr($line, 1, length($line) - 1);
    # Skip optional space
    if (length($content) > 0 && substr($content, 0, 1) eq " ") {
        $content = substr($content, 1, length($content) - 1);
    }
    return $content;
}

# Check if line starts a code block (```)
private func is_code_fence(str $line) int {
    if (length($line) >= 3 && substr($line, 0, 3) eq "~~~") {
        return 1;
    }
    # Check for triple backtick using index
    my int $pos = index($line, "`");
    if ($pos == 0) {
        if (length($line) >= 3) {
            my str $first3 = substr($line, 0, 3);
            if (index($first3, "`") == 0 && index($first3, "`", 1) == 1 && index($first3, "`", 2) == 2) {
                return 1;
            }
        }
    }
    return 0;
}

# Get code fence language
private func get_fence_lang(str $line) str {
    my str $lang = "";
    if (length($line) > 3) {
        $lang = substr($line, 3, length($line) - 3);
        $lang =~ s/[ \t\r\n]//g;
    }
    return $lang;
}

# Convert markdown to HTML (main function)
func to_html(str $markdown) str {
    my array @lines = split("\n", $markdown);
    my str $html = "";
    my int $i = 0;
    my int $num_lines = size(@lines);
    my int $in_paragraph = 0;
    my str $paragraph = "";

    while ($i < $num_lines) {
        my str $line = $lines[$i];
        my str $trimmed = $line;
        $trimmed =~ s/^[ \t]+//;
        $trimmed =~ s/[ \t]+$//;

        # Code block
        if (::is_code_fence($line) == 1) {
            # Close any open paragraph
            if ($in_paragraph == 1) {
                $html = $html . "<p>" . ::process_inline($paragraph) . "</p>\n";
                $in_paragraph = 0;
                $paragraph = "";
            }

            my str $lang = ::get_fence_lang($line);
            $i = $i + 1;
            my str $code = "";
            while ($i < $num_lines && ::is_code_fence($lines[$i]) == 0) {
                if (length($code) > 0) {
                    $code = $code . "\n";
                }
                $code = $code . ::html_escape($lines[$i]);
                $i = $i + 1;
            }
            if (length($lang) > 0) {
                $html = $html . "<pre><code class=\"language-" . $lang . "\">" . $code . "</code></pre>\n";
            } else {
                $html = $html . "<pre><code>" . $code . "</code></pre>\n";
            }
            $i = $i + 1;
            next;
        }

        # Empty line
        if (length($trimmed) == 0) {
            if ($in_paragraph == 1) {
                $html = $html . "<p>" . ::process_inline($paragraph) . "</p>\n";
                $in_paragraph = 0;
                $paragraph = "";
            }
            $i = $i + 1;
            next;
        }

        # Horizontal rule
        if (::is_hr($trimmed) == 1) {
            if ($in_paragraph == 1) {
                $html = $html . "<p>" . ::process_inline($paragraph) . "</p>\n";
                $in_paragraph = 0;
                $paragraph = "";
            }
            $html = $html . "<hr>\n";
            $i = $i + 1;
            next;
        }

        # Headers
        if (substr($line, 0, 1) eq "#") {
            if ($in_paragraph == 1) {
                $html = $html . "<p>" . ::process_inline($paragraph) . "</p>\n";
                $in_paragraph = 0;
                $paragraph = "";
            }
            my int $level = ::count_leading($line, "#");
            if ($level > 6) {
                $level = 6;
            }
            my str $header_text = substr($line, $level, length($line) - $level);
            $header_text =~ s/^[ ]+//;
            $header_text =~ s/[ ]+$//;
            # Remove trailing #s
            $header_text =~ s/[ ]*#+$//;
            $html = $html . "<h" . $level . ">" . ::process_inline($header_text) . "</h" . $level . ">\n";
            $i = $i + 1;
            next;
        }

        # Blockquote
        if (::is_blockquote($line) == 1) {
            if ($in_paragraph == 1) {
                $html = $html . "<p>" . ::process_inline($paragraph) . "</p>\n";
                $in_paragraph = 0;
                $paragraph = "";
            }
            my str $quote_content = "";
            while ($i < $num_lines && ::is_blockquote($lines[$i]) == 1) {
                if (length($quote_content) > 0) {
                    $quote_content = $quote_content . "\n";
                }
                $quote_content = $quote_content . ::get_blockquote_content($lines[$i]);
                $i = $i + 1;
            }
            # Recursively process blockquote content
            my str $inner = Markdown::to_html($quote_content);
            $html = $html . "<blockquote>\n" . $inner . "</blockquote>\n";
            next;
        }

        # Unordered list
        if (::is_ul_item($line) == 1) {
            if ($in_paragraph == 1) {
                $html = $html . "<p>" . ::process_inline($paragraph) . "</p>\n";
                $in_paragraph = 0;
                $paragraph = "";
            }
            $html = $html . "<ul>\n";
            while ($i < $num_lines && ::is_ul_item($lines[$i]) == 1) {
                my str $item = ::get_list_content($lines[$i]);
                $html = $html . "  <li>" . ::process_inline($item) . "</li>\n";
                $i = $i + 1;
            }
            $html = $html . "</ul>\n";
            next;
        }

        # Ordered list
        if (::is_ol_item($line) == 1) {
            if ($in_paragraph == 1) {
                $html = $html . "<p>" . ::process_inline($paragraph) . "</p>\n";
                $in_paragraph = 0;
                $paragraph = "";
            }
            $html = $html . "<ol>\n";
            while ($i < $num_lines && ::is_ol_item($lines[$i]) == 1) {
                my str $item = ::get_list_content($lines[$i]);
                $html = $html . "  <li>" . ::process_inline($item) . "</li>\n";
                $i = $i + 1;
            }
            $html = $html . "</ol>\n";
            next;
        }

        # Regular paragraph text
        if ($in_paragraph == 1) {
            $paragraph = $paragraph . " " . $trimmed;
        } else {
            $in_paragraph = 1;
            $paragraph = $trimmed;
        }
        $i = $i + 1;
    }

    # Close any remaining paragraph
    if ($in_paragraph == 1) {
        $html = $html . "<p>" . ::process_inline($paragraph) . "</p>\n";
    }

    return $html;
}

# Extract title from first h1 in HTML
func extract_title(str $html) str {
    my int $h1_start = index($html, "<h1>");
    if ($h1_start >= 0) {
        my int $h1_end = index($html, "</h1>", $h1_start);
        if ($h1_end > $h1_start) {
            return substr($html, $h1_start + 4, $h1_end - $h1_start - 4);
        }
    }
    return "";
}
