/*
 Digest::SHA - SHA hash functions for Strada

 Copyright (c) 2026 Michael J. Flickinger

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, version 2.

 This program is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

=head1 NAME

Digest::SHA - SHA-1 and SHA-256 hash functions

=head1 SYNOPSIS

    use lib "lib";
    use Digest::SHA;

    # SHA-256 (recommended)
    my str $hex = Digest::SHA::sha256_hex("Hello, World!");
    my str $raw = Digest::SHA::sha256("Hello, World!");

    # SHA-1 (legacy, not recommended for security)
    my str $hex = Digest::SHA::sha1_hex("Hello, World!");

=head1 DESCRIPTION

This module provides SHA hash functions. SHA-256 is recommended for
security applications. SHA-1 is provided for compatibility but should
not be used for new security-critical applications.

=head1 FUNCTIONS

=head2 sha256($data)

Compute SHA-256 hash. Returns 32 bytes of raw binary data.

=head2 sha256_hex($data)

Compute SHA-256 hash. Returns 64-character lowercase hex string.

=head2 sha1($data)

Compute SHA-1 hash. Returns 20 bytes of raw binary data.

=head2 sha1_hex($data)

Compute SHA-1 hash. Returns 40-character lowercase hex string.

=head1 EXAMPLE

    use lib "lib";
    use Digest::SHA;

    my str $password = "secret123";
    my str $hash = Digest::SHA::sha256_hex($password);
    say("Password hash: " . $hash);

    # Verify
    if (Digest::SHA::sha256_hex($input) eq $hash) {
        say("Password matches!");
    }

=cut

package Digest_SHA;
version "1.0.0";

__C__ {
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

/* ============================================================
 * SHA-256 Implementation
 * ============================================================ */

typedef struct {
    uint32_t state[8];
    uint64_t count;
    uint8_t buffer[64];
} SHA256_CTX_IMPL;

#define SHA256_ROTR(x, n) (((x) >> (n)) | ((x) << (32 - (n))))
#define SHA256_CH(x, y, z) (((x) & (y)) ^ (~(x) & (z)))
#define SHA256_MAJ(x, y, z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
#define SHA256_EP0(x) (SHA256_ROTR(x, 2) ^ SHA256_ROTR(x, 13) ^ SHA256_ROTR(x, 22))
#define SHA256_EP1(x) (SHA256_ROTR(x, 6) ^ SHA256_ROTR(x, 11) ^ SHA256_ROTR(x, 25))
#define SHA256_SIG0(x) (SHA256_ROTR(x, 7) ^ SHA256_ROTR(x, 18) ^ ((x) >> 3))
#define SHA256_SIG1(x) (SHA256_ROTR(x, 17) ^ SHA256_ROTR(x, 19) ^ ((x) >> 10))

static const uint32_t sha256_k[64] = {
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
};

static void sha256_init_impl(SHA256_CTX_IMPL *ctx) {
    ctx->state[0] = 0x6a09e667;
    ctx->state[1] = 0xbb67ae85;
    ctx->state[2] = 0x3c6ef372;
    ctx->state[3] = 0xa54ff53a;
    ctx->state[4] = 0x510e527f;
    ctx->state[5] = 0x9b05688c;
    ctx->state[6] = 0x1f83d9ab;
    ctx->state[7] = 0x5be0cd19;
    ctx->count = 0;
}

static void sha256_transform_impl(SHA256_CTX_IMPL *ctx, const uint8_t data[64]) {
    uint32_t a, b, c, d, e, f, g, h, t1, t2, m[64];
    int i;

    for (i = 0; i < 16; i++) {
        m[i] = ((uint32_t)data[i*4] << 24) | ((uint32_t)data[i*4+1] << 16) |
               ((uint32_t)data[i*4+2] << 8) | ((uint32_t)data[i*4+3]);
    }
    for (; i < 64; i++) {
        m[i] = SHA256_SIG1(m[i-2]) + m[i-7] + SHA256_SIG0(m[i-15]) + m[i-16];
    }

    a = ctx->state[0]; b = ctx->state[1]; c = ctx->state[2]; d = ctx->state[3];
    e = ctx->state[4]; f = ctx->state[5]; g = ctx->state[6]; h = ctx->state[7];

    for (i = 0; i < 64; i++) {
        t1 = h + SHA256_EP1(e) + SHA256_CH(e, f, g) + sha256_k[i] + m[i];
        t2 = SHA256_EP0(a) + SHA256_MAJ(a, b, c);
        h = g; g = f; f = e; e = d + t1;
        d = c; c = b; b = a; a = t1 + t2;
    }

    ctx->state[0] += a; ctx->state[1] += b; ctx->state[2] += c; ctx->state[3] += d;
    ctx->state[4] += e; ctx->state[5] += f; ctx->state[6] += g; ctx->state[7] += h;
}

static void sha256_update_impl(SHA256_CTX_IMPL *ctx, const uint8_t *data, size_t len) {
    size_t i;
    uint32_t index = ctx->count & 63;
    ctx->count += len;

    for (i = 0; i < len; i++) {
        ctx->buffer[index++] = data[i];
        if (index == 64) {
            sha256_transform_impl(ctx, ctx->buffer);
            index = 0;
        }
    }
}

static void sha256_final_impl(SHA256_CTX_IMPL *ctx, uint8_t hash[32]) {
    uint32_t i, index = ctx->count & 63;
    uint8_t pad[64];
    uint64_t bits = ctx->count * 8;

    memset(pad, 0, sizeof(pad));
    pad[0] = 0x80;
    if (index < 56) {
        sha256_update_impl(ctx, pad, 56 - index);
    } else {
        sha256_update_impl(ctx, pad, 120 - index);
    }

    pad[0] = (bits >> 56) & 0xff;
    pad[1] = (bits >> 48) & 0xff;
    pad[2] = (bits >> 40) & 0xff;
    pad[3] = (bits >> 32) & 0xff;
    pad[4] = (bits >> 24) & 0xff;
    pad[5] = (bits >> 16) & 0xff;
    pad[6] = (bits >> 8) & 0xff;
    pad[7] = bits & 0xff;
    sha256_update_impl(ctx, pad, 8);

    for (i = 0; i < 8; i++) {
        hash[i*4] = (ctx->state[i] >> 24) & 0xff;
        hash[i*4+1] = (ctx->state[i] >> 16) & 0xff;
        hash[i*4+2] = (ctx->state[i] >> 8) & 0xff;
        hash[i*4+3] = ctx->state[i] & 0xff;
    }
}

/* ============================================================
 * SHA-1 Implementation (for legacy compatibility)
 * ============================================================ */

typedef struct {
    uint32_t state[5];
    uint64_t count;
    uint8_t buffer[64];
} SHA1_CTX_IMPL;

#define SHA1_ROL(x, n) (((x) << (n)) | ((x) >> (32 - (n))))

static void sha1_init_impl(SHA1_CTX_IMPL *ctx) {
    ctx->state[0] = 0x67452301;
    ctx->state[1] = 0xefcdab89;
    ctx->state[2] = 0x98badcfe;
    ctx->state[3] = 0x10325476;
    ctx->state[4] = 0xc3d2e1f0;
    ctx->count = 0;
}

static void sha1_transform_impl(SHA1_CTX_IMPL *ctx, const uint8_t data[64]) {
    uint32_t a, b, c, d, e, f, k, temp, w[80];
    int i;

    for (i = 0; i < 16; i++) {
        w[i] = ((uint32_t)data[i*4] << 24) | ((uint32_t)data[i*4+1] << 16) |
               ((uint32_t)data[i*4+2] << 8) | ((uint32_t)data[i*4+3]);
    }
    for (; i < 80; i++) {
        w[i] = SHA1_ROL(w[i-3] ^ w[i-8] ^ w[i-14] ^ w[i-16], 1);
    }

    a = ctx->state[0]; b = ctx->state[1]; c = ctx->state[2];
    d = ctx->state[3]; e = ctx->state[4];

    for (i = 0; i < 80; i++) {
        if (i < 20) {
            f = (b & c) | ((~b) & d);
            k = 0x5a827999;
        } else if (i < 40) {
            f = b ^ c ^ d;
            k = 0x6ed9eba1;
        } else if (i < 60) {
            f = (b & c) | (b & d) | (c & d);
            k = 0x8f1bbcdc;
        } else {
            f = b ^ c ^ d;
            k = 0xca62c1d6;
        }
        temp = SHA1_ROL(a, 5) + f + e + k + w[i];
        e = d; d = c; c = SHA1_ROL(b, 30); b = a; a = temp;
    }

    ctx->state[0] += a; ctx->state[1] += b; ctx->state[2] += c;
    ctx->state[3] += d; ctx->state[4] += e;
}

static void sha1_update_impl(SHA1_CTX_IMPL *ctx, const uint8_t *data, size_t len) {
    size_t i;
    uint32_t index = ctx->count & 63;
    ctx->count += len;

    for (i = 0; i < len; i++) {
        ctx->buffer[index++] = data[i];
        if (index == 64) {
            sha1_transform_impl(ctx, ctx->buffer);
            index = 0;
        }
    }
}

static void sha1_final_impl(SHA1_CTX_IMPL *ctx, uint8_t hash[20]) {
    uint32_t i, index = ctx->count & 63;
    uint8_t pad[64];
    uint64_t bits = ctx->count * 8;

    memset(pad, 0, sizeof(pad));
    pad[0] = 0x80;
    if (index < 56) {
        sha1_update_impl(ctx, pad, 56 - index);
    } else {
        sha1_update_impl(ctx, pad, 120 - index);
    }

    pad[0] = (bits >> 56) & 0xff;
    pad[1] = (bits >> 48) & 0xff;
    pad[2] = (bits >> 40) & 0xff;
    pad[3] = (bits >> 32) & 0xff;
    pad[4] = (bits >> 24) & 0xff;
    pad[5] = (bits >> 16) & 0xff;
    pad[6] = (bits >> 8) & 0xff;
    pad[7] = bits & 0xff;
    sha1_update_impl(ctx, pad, 8);

    for (i = 0; i < 5; i++) {
        hash[i*4] = (ctx->state[i] >> 24) & 0xff;
        hash[i*4+1] = (ctx->state[i] >> 16) & 0xff;
        hash[i*4+2] = (ctx->state[i] >> 8) & 0xff;
        hash[i*4+3] = ctx->state[i] & 0xff;
    }
}

/* Helper: convert bytes to hex string */
static void bytes_to_hex_impl(const uint8_t *bytes, size_t len, char *hex) {
    size_t i;
    for (i = 0; i < len; i++) {
        sprintf(&hex[i*2], "%02x", bytes[i]);
    }
    hex[len*2] = '\0';
}
}

# ============================================================
# SHA-256 Functions
# ============================================================

# Compute SHA-256 hash, return as raw 32 bytes
func sha256(str $data) str {
    my str $result = "";
    __C__ {
        char *input = strada_to_str(data);
        int len = strada_str_len(data);
        uint8_t hash[32];

        SHA256_CTX_IMPL ctx;
        sha256_init_impl(&ctx);
        sha256_update_impl(&ctx, (const uint8_t *)input, len);
        sha256_final_impl(&ctx, hash);

        free(input);
        strada_decref(result);
        result = strada_new_str_len((char *)hash, 32);
    }
    return $result;
}

# Compute SHA-256 hash, return as 64-char hex string
func sha256_hex(str $data) str {
    my str $result = "";
    __C__ {
        char *input = strada_to_str(data);
        int len = strada_str_len(data);
        uint8_t hash[32];
        char hex[65];

        SHA256_CTX_IMPL ctx;
        sha256_init_impl(&ctx);
        sha256_update_impl(&ctx, (const uint8_t *)input, len);
        sha256_final_impl(&ctx, hash);
        bytes_to_hex_impl(hash, 32, hex);

        free(input);
        strada_decref(result);
        result = strada_new_str(hex);
    }
    return $result;
}

# ============================================================
# SHA-1 Functions (legacy, not recommended for security)
# ============================================================

# Compute SHA-1 hash, return as raw 20 bytes
func sha1(str $data) str {
    my str $result = "";
    __C__ {
        char *input = strada_to_str(data);
        int len = strada_str_len(data);
        uint8_t hash[20];

        SHA1_CTX_IMPL ctx;
        sha1_init_impl(&ctx);
        sha1_update_impl(&ctx, (const uint8_t *)input, len);
        sha1_final_impl(&ctx, hash);

        free(input);
        strada_decref(result);
        result = strada_new_str_len((char *)hash, 20);
    }
    return $result;
}

# Compute SHA-1 hash, return as 40-char hex string
func sha1_hex(str $data) str {
    my str $result = "";
    __C__ {
        char *input = strada_to_str(data);
        int len = strada_str_len(data);
        uint8_t hash[20];
        char hex[41];

        SHA1_CTX_IMPL ctx;
        sha1_init_impl(&ctx);
        sha1_update_impl(&ctx, (const uint8_t *)input, len);
        sha1_final_impl(&ctx, hash);
        bytes_to_hex_impl(hash, 20, hex);

        free(input);
        strada_decref(result);
        result = strada_new_str(hex);
    }
    return $result;
}
