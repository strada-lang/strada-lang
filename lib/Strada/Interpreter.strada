=head1 NAME

Strada::Interpreter - Tree-walking interpreter for Strada

=head1 SYNOPSIS

    use lib "lib";
    use Strada::Interpreter;

    # --- Programmatic eval API (simple) ---

    # Initialize the interpreter engine
    Strada::Interpreter::init();

    # Evaluate Strada expressions and statements
    my scalar $result = Strada::Interpreter::eval_string("1 + 2");        # returns 3
    my scalar $s = Strada::Interpreter::eval_string("\"hi\" . \"!\"");    # returns "hi!"

    # Variables persist across eval_string calls
    Strada::Interpreter::eval_string("my int \$x = 10;");
    my scalar $v = Strada::Interpreter::eval_string("\$x * 5");           # returns 50

    # Function definitions persist
    Strada::Interpreter::eval_string("func square(int \$n) int { return \$n * \$n; }");
    my scalar $r = Strada::Interpreter::eval_string("square(7)");         # returns 49

    # Reset all state
    Strada::Interpreter::reset();

    # --- Full program execution API (advanced) ---

    # Create an interpreter instance
    my scalar $interp = Strada::Interpreter::interp_new();

    # Load a parsed program AST (registers functions, enums, constants, OOP, BEGIN/END)
    Strada::Interpreter::interp_load_program($interp, $program);

    # Run the main() function
    my int $exit_code = Strada::Interpreter::interp_run_main($interp, \@ARGV);

    # Execute END blocks (LIFO order)
    Strada::Interpreter::interp_run_end_blocks($interp);

=head1 DESCRIPTION

Strada::Interpreter is a tree-walking interpreter that evaluates Strada
AST nodes directly, without generating C code. It reuses the compiler's
Lexer and Parser for the front-end, then walks the resulting AST to
execute the program.

This provides an alternative execution mode to the standard
compile-to-C pipeline. No C compiler is needed at runtime, making it
suitable for:

=over

=item * Interactive REPLs (see C<interpreter/Main.strada>)

=item * Embedded scripting and eval (via C<eval_string()>)

=item * Environments where gcc/tcc are not available

=item * Rapid prototyping without compilation overhead

=back

The interpreter supports the full Strada language including OOP
(packages, inheritance, method modifiers, operator overloading,
AUTOLOAD), closures, try/catch exceptions, regex, BEGIN/END blocks,
C<import_lib> native function calls, C<local()> dynamic scoping,
BigInt/BigFloat arithmetic, and DateTime operations.

=head1 PUBLIC EVAL API

These functions provide a simple evaluate-a-string interface using a
shared interpreter instance. Suitable for embedding Strada evaluation
in a compiled Strada program.

=head2 Strada::Interpreter::init()

Initialize the shared interpreter instance. Called automatically by
C<eval_string()> if not already initialized. Calling it explicitly is
a no-op if the instance already exists.

=head2 Strada::Interpreter::eval_string(str $code) scalar

Parse and evaluate a string of Strada code. Returns the result of the
last expression. Statements ending with C<;> or C<}> and void calls
(C<say>, C<print>) return undef.

Variables and function definitions persist across calls via the shared
interpreter instance.

A trailing semicolon is appended automatically if the code does not
already end with C<;> or C<}>.

Throws an exception on parse or runtime errors.

    my scalar $r = Strada::Interpreter::eval_string("2 ** 10");  # 1024

=head2 Strada::Interpreter::reset()

Reset the shared interpreter instance, clearing all persisted variables,
functions, enums, constants, and OOP state. A subsequent C<eval_string()>
starts from a clean slate.

=head1 FULL PROGRAM API

These functions give full control over interpreter lifecycle and are
used by the interpreter driver (C<interpreter/Main.strada>) and the
REPL.

=head2 Strada::Interpreter::interp_new() scalar

Create and return a new interpreter state hash. The state includes:

=over

=item * C<functions> - Registered function table

=item * C<enums> - Enum constant registry

=item * C<constants> - C<const> declaration registry

=item * C<global_env> - Top-level lexical environment

=item * C<package> - Current package name (default C<"main">)

=item * C<inherits> - Inheritance table (package to parent list)

=item * C<overloads> - Operator overload table

=item * C<method_modifiers> - Before/after/around hooks

=item * C<autoloads> - AUTOLOAD function table

=item * C<end_blocks> - Accumulated END blocks

=item * C<native_funcs> - Native functions loaded via C<import_lib>

=item * C<max_call_depth> - Recursion limit (default 1000)

=back

=head2 Strada::Interpreter::interp_load_program(scalar $interp, scalar $program)

Load a parsed program AST into the interpreter. This:

=over

=item 1. Executes BEGIN blocks

=item 2. Stores END blocks for later execution

=item 3. Registers enums and constants

=item 4. Registers all function definitions

=item 5. Evaluates top-level global variable declarations

=item 6. Loads OOP metadata (inheritance, overloads, method modifiers, AUTOLOAD)

=item 7. Loads C<import_lib> shared libraries via dlopen/dlsym

=back

The C<$program> hash is the output of C<parse_program()> from the
Strada Parser.

=head2 Strada::Interpreter::interp_run_main(scalar $interp, scalar $argv) int

Look up and execute the C<main()> function. Sets C<@ARGV> in the global
environment from C<$argv>. Returns the integer exit code (0 if main
does not explicitly return).

Throws an exception if no C<main()> function is defined.

=head2 Strada::Interpreter::interp_run_end_blocks(scalar $interp)

Execute all accumulated END blocks in LIFO (last-in, first-out) order.
Errors in individual END blocks are caught and printed but do not
prevent subsequent END blocks from running.

=head2 Strada::Interpreter::interp_register_func(scalar $interp, str $name, scalar $params, int $param_count, scalar $body, scalar $closure_env)

Register a function in the interpreter's function table. Functions are
also registered under a sanitized name (C<::> replaced with C<_>) for
cross-package lookup.

=head2 Strada::Interpreter::interp_get_func(scalar $interp, str $name) scalar

Look up a function by name. Returns the function info hash or undef.
Tries both the original name and a sanitized form.

=head1 ENVIRONMENT AND SCOPING

=head2 Strada::Interpreter::env_new(scalar $parent) scalar

Create a new lexical scope environment. C<$parent> is the enclosing
scope (or undef for the top-level scope). Environments form a chain
that is walked during variable lookup.

=head2 Strada::Interpreter::env_get(scalar $env, str $name) scalar

Look up a variable by walking the scope chain from innermost to
outermost. Returns undef if not found.

=head2 Strada::Interpreter::env_set(scalar $env, str $name, scalar $value)

Set a variable in the current (innermost) scope.

=head2 Strada::Interpreter::env_update(scalar $env, str $name, scalar $value) int

Update a variable in the nearest enclosing scope that contains it.
Returns 1 if found and updated, 0 if the variable does not exist in
any scope.

=head2 Strada::Interpreter::env_exists(scalar $env, str $name) int

Returns 1 if the variable exists in any enclosing scope, 0 otherwise.

=head1 OOP SUPPORT

=head2 Strada::Interpreter::interp_resolve_method(scalar $interp, str $pkg, str $method) scalar

Resolve a method on a class by walking the inheritance chain
(depth-first). Returns the function info hash or undef.

=head2 Strada::Interpreter::interp_isa(scalar $interp, str $obj_class, str $target_class) int

Check whether C<$obj_class> is or inherits from C<$target_class>.
Walks the full inheritance tree. Returns 1 or 0.

=head2 Strada::Interpreter::interp_load_oop(scalar $interp, scalar $program)

Load OOP metadata from a parsed program: inheritance relationships,
operator overloads, before/after/around method modifiers, and AUTOLOAD
functions.

=head1 EVALUATION INTERNALS

=head2 Strada::Interpreter::eval_node(scalar $interp, scalar $node, scalar $env) scalar

The core evaluator. Dispatches on AST node type to evaluate literals,
variables, declarations, binary/unary operations, function calls,
control flow, OOP constructs, regex, and more.

=head2 Strada::Interpreter::eval_block(scalar $interp, scalar $block, scalar $env) scalar

Evaluate a block node (list of statements) in a new child scope.
Returns the result of the last statement.

=head2 Strada::Interpreter::eval_stmts_in_env(scalar $interp, scalar $stmts, int $count, scalar $env) scalar

Evaluate a list of statements in an existing environment (no new scope
created). Used by C<eval_string()> and BEGIN blocks.

=head2 Strada::Interpreter::call_builtin(scalar $interp, str $name, scalar $args, scalar $env) scalar

Dispatch a call to a built-in function. Handles I/O (say, print),
array/hash operations, string functions, type conversions, regex,
C<core::>/C<math::>/C<utf8::>/C<DateTime::>/C<BigInt::>/C<BigFloat::>
namespaces, OOP helpers, and more.

=head2 Strada::Interpreter::call_user_func(scalar $interp, scalar $func_info, scalar $args) scalar

Call a user-defined function. Creates a new scope from the function's
closure environment, binds parameters, evaluates the body, and handles
return signals. Enforces the recursion depth limit.

=head1 CONTROL FLOW SIGNALS

Loop control (C<next>, C<last>, C<redo>) and C<return> are implemented
via exception-based signals.

=head2 Strada::Interpreter::is_signal(scalar $e, str $sig_type) int

Check if an exception is a control flow signal of the given type
(C<"return">, C<"next">, C<"last">, C<"redo">).

=head2 Strada::Interpreter::is_loop_signal(scalar $e, str $sig_type, str $loop_label) int

Check if an exception is a labeled loop control signal matching both
the signal type and the loop label.

=head1 NATIVE FUNCTION SUPPORT

The interpreter can load and call functions from shared libraries
(C<.so> files) registered via C<import_lib> in the source.

=head2 Strada::Interpreter::call_native(scalar $interp, scalar $nf, scalar $args) scalar

Call a native (C-level) function. Handles variadic argument packing
to match the compiled calling convention.

=head1 SUPPORTED LANGUAGE FEATURES

=over

=item * Literals: int, num, str, undef, array refs, hash refs

=item * Variables: C<my>, C<our>, C<local>, C<const>, C<enum>

=item * Operators: arithmetic, string, comparison, logical, assignment, ternary

=item * Control flow: if/elsif/else, unless, while, until, for, foreach, do-while, loop labels, statement modifiers

=item * Functions: C<func>/C<fn>, closures, variadic (C<...@args>), spread operator

=item * OOP: packages, C<extends>, C<has ro|rw>, C<before>/C<after>/C<around>, C<isa>, C<can>, C<AUTOLOAD>, C<bless>, C<use overload>

=item * Exceptions: try/catch (typed and catch-all), throw, die

=item * Regex: C<=~>, C<!~>, C<s///>, C<tr///>, match, replace, captures, named captures

=item * I/O: say, print, printf, sprintf, core::open, core::close, diamond operator, core::slurp, core::spew

=item * Modules: C<use>, C<import_lib> (native shared libraries via dlopen)

=item * BEGIN/END blocks

=item * C<tie>/C<untie>/C<tied>

=item * BigInt and BigFloat arbitrary-precision arithmetic (C-backed)

=item * DateTime operations

=item * C<core::>, C<math::>, C<utf8::> built-in namespaces

=back

=head1 LIMITATIONS

=over

=item * C<__C__> blocks are not interpreted; they are skipped. Programs
that rely on inline C code for core logic will not work under the
interpreter.

=item * Performance is slower than compiled execution since every AST
node is walked at runtime.

=item * Async/await is not supported (requires the compiled thread pool
runtime).

=item * Some low-level C<c::> namespace functions (C<c::alloc>,
C<c::free>) are not available.

=back

=head1 SEE ALSO

=over

=item * C<interpreter/Main.strada> - Interpreter driver with REPL support

=item * L<Strada::JIT> - JIT eval via compile-to-C (requires gcc/tcc at runtime)

=item * C<compiler/Lexer.strada>, C<compiler/Parser.strada> - Front-end reused by the interpreter

=back

=cut

package Strada::Interpreter;

# Interpreter-local node type constants (compiled to #define, zero overhead)
enum NI {
    PROGRAM = 1, FUNC = 2, PARAM = 3, BLOCK = 4, VAR_DECL = 5,
    IF_STMT = 6, WHILE_STMT = 7, FOR_STMT = 8, RETURN_STMT = 9,
    EXPR_STMT = 10, BINARY_OP = 11, UNARY_OP = 12, CALL = 13,
    VARIABLE = 14, INT_LITERAL = 15, NUM_LITERAL = 16, STR_LITERAL = 17,
    ASSIGN = 18, SUBSCRIPT = 19, HASH_ACCESS = 20, REF = 21,
    DEREF_HASH = 22, DEREF_ARRAY = 23, DEREF_SCALAR = 24,
    ANON_HASH = 25, ANON_ARRAY = 26, EXTERN_FUNC = 27, USE = 29,
    FIELD_ACCESS = 30, FUNC_REF = 31, METHOD_CALL = 32,
    DUNDER_PACKAGE = 33, REGEX_MATCH = 34, REGEX_SUBST = 35,
    DUNDER_FILE = 36, DUNDER_LINE = 37,
    LAST = 100, NEXT = 101, UNDEF = 102, MAP = 103, SORT = 104,
    GREP = 105, TRY_CATCH = 106, THROW = 107, LABEL = 108,
    GOTO = 109, FOREACH_STMT = 110, ANON_FUNC = 111,
    CLOSURE_CALL = 112, TERNARY = 113, SWITCH = 114, RANGE = 115,
    SUPER_CALL = 116, INCREMENT = 117, ENUM_DECL = 118, C_BLOCK = 119,
    SPREAD = 120, CATCH_CLAUSE = 121, ASYNC_FUNC = 122, AWAIT = 123,
    READLINE = 124, DESTRUCTURE = 125, DO_WHILE_STMT = 126,
    CONST_DECL = 127, BEGIN_BLOCK = 128, END_BLOCK = 129,
    ARRAY_SLICE = 130, HASH_SLICE = 131, OUR_DECL = 132, REDO = 133,
    TR = 134, LOCAL_DECL = 135, CAPTURE_VAR = 136, DYN_METHOD_CALL = 137
}

enum TI { INT = 1, NUM = 2, STR = 3, ARRAY = 4, HASH = 5, SCALAR = 6, VOID = 7 }

# Signal codes for control flow (compiled to #define, zero overhead)
enum SIG { NONE = 0, RETURN = 1, LAST = 2, NEXT = 3, REDO = 4 }

# Operator IDs for fast dispatch in eval_binop (compiled to #define, zero overhead)
enum OP {
    ADD = 1, SUB = 2, MUL = 3, DIV = 4, MOD = 5, POW = 6,
    CONCAT = 7, REPEAT = 8,
    NUM_EQ = 10, NUM_NE = 11, NUM_LT = 12, NUM_GT = 13, NUM_LE = 14, NUM_GE = 15, SPACESHIP = 16,
    STR_EQ = 20, STR_NE = 21, STR_LT = 22, STR_GT = 23, STR_LE = 24, STR_GE = 25, CMP = 26,
    LOG_AND = 30, LOG_OR = 31, DEFOR = 32,
    BIT_AND = 40, BIT_OR = 41, BIT_XOR = 42, SHL = 43, SHR = 44,
    MATCH = 50, NOT_MATCH = 51,
    WORD_AND = 60, WORD_OR = 61
}

# Builtin IDs for fast numeric dispatch in call_builtin (compiled to #define, zero overhead)
enum BI {
    # I/O (1-9)
    SAY = 1, PRINT = 2, DUMPER = 3, PRINTF = 4, READLINE_FN = 5,
    SELECT_FN = 6, NAMED_CAPTURES = 7, CAPTURES = 8, DUMPER_STR = 9,
    # Array (10-19)
    PUSH = 10, POP = 11, SHIFT = 12, UNSHIFT = 13, SPLICE = 14,
    REVERSE = 15, SIZE = 16, SCALAR_FN = 17, NSORT = 18, SORT_FN = 19,
    # String (20-45)
    LENGTH = 20, BYTES = 21, SUBSTR = 22, INDEX_FN = 23, RINDEX = 24,
    JOIN = 25, SPLIT = 26, CHOMP = 27, CHOP = 28, CHR = 29,
    ORD = 30, CHAR_AT = 31, UC = 32, LC = 33, SPRINTF_FN = 34,
    MATCH_FN = 35, REPLACE = 36, REPLACE_ALL = 37, UPPER = 38, LOWER = 39,
    UCFIRST = 40, LCFIRST = 41, TRIM = 42, LTRIM = 43, RTRIM = 44, REPEAT = 45,
    # Type/Cast (50-59)
    TYPEOF = 50, CAST_INT = 51, CAST_NUM = 52, CAST_STR = 53,
    REF_FN = 54, DEFINED = 55, INT_FN = 56, ABS = 57,
    # Hash (60-64)
    KEYS = 60, VALUES_FN = 61, EXISTS_FN = 62, DELETE_FN = 63, EACH = 64,
    # Ref/Memory (70-79)
    REFTO = 70, REFCOUNT = 71, IS_REFTO = 72, REFTYPE = 73,
    DEREF = 74, DEREFTO = 75, BLESSED = 76, IS_REF = 77,
    # OOP (80-99)
    SET_PACKAGE = 80, INHERIT_FN = 81, HASH_NEW = 82,
    UNIVERSAL_ISA = 83, UNIVERSAL_CAN = 84, ISA = 85, CAN_FN = 86,
    BLESS = 87, TIE = 88, UNTIE = 89, TIED = 90,
    HASH_SET = 91, HASH_GET = 92, HASH_DELETE = 93, CAPTURE = 94,
    # Misc (95-99)
    DIE = 95, THROW_FN = 96, SLURP = 97, SPEW = 98, STRADA_NEW_UNDEF = 99,
    # sys::/core:: (100-260)
    SYS_EXIT = 100, SYS_GETENV = 101, SYS_SETENV = 102,
    SYS_TIME = 103, SYS_SLEEP = 104, SYS_HIRES_TIME = 105,
    SYS_OPEN = 110, SYS_CLOSE = 111, SYS_READLINE = 112,
    SYS_EOF = 113, SYS_FLUSH = 114, SYS_POPEN = 115,
    SYS_QX = 116, SYS_SYSTEM = 117, SYS_STACK_TRACE = 118,
    SYS_FWRITE = 120, SYS_FREAD = 121, SYS_FPUTS = 122, SYS_FGETS = 123,
    SYS_PCLOSE = 124, SYS_TRUNCATE = 125, SYS_OPEN_STR = 126, SYS_STR_FROM_FH = 127,
    SYS_SLURP = 128, SYS_SPEW = 129,
    SYS_UNLINK = 130, SYS_RENAME = 131, SYS_MKDIR = 132, SYS_RMDIR = 133,
    SYS_CHMOD = 134, SYS_LINK = 135, SYS_SYMLINK = 136, SYS_READLINK = 137,
    SYS_STAT = 138, SYS_LSTAT = 139, SYS_ACCESS = 140,
    SYS_IS_FILE = 141, SYS_IS_DIR = 142,
    SYS_READDIR = 143, SYS_READDIR_FULL = 144,
    SYS_GLOB = 145, SYS_FNMATCH = 146,
    SYS_DIRNAME = 147, SYS_BASENAME = 148, SYS_FILE_EXT = 149,
    SYS_REALPATH = 150, SYS_GETCWD = 151, SYS_PATH_JOIN = 152,
    SYS_GETPID = 153, SYS_GETPPID = 154, SYS_FORK = 155,
    SYS_WAIT = 156, SYS_USLEEP = 157,
    SYS_GETPROCNAME = 158, SYS_SETPROCNAME = 159,
    SYS_GETPROCTITLE = 160, SYS_SETPROCTITLE = 161,
    SYS_UNSETENV = 162,
    SYS_GETUID = 163, SYS_GETGID = 164, SYS_GETEUID = 165, SYS_GETEGID = 166,
    SYS_GETPWUID = 167, SYS_GETPWNAM = 168, SYS_GETGRGID = 169, SYS_GETGROUPS = 170,
    SYS_ISATTY = 171, SYS_STRERROR = 172, SYS_ERRNO = 173,
    SYS_UMASK = 174, SYS_UTIME = 175, SYS_FREE = 176, SYS_RELEASE = 177,
    SYS_GETHOSTNAME = 178, SYS_GETHOSTBYNAME = 179, SYS_GETHOSTBYNAME_ALL = 180,
    SYS_GETADDRINFO = 181, SYS_INET_ADDR = 182, SYS_INET_NTOA = 183,
    SYS_HTONS = 184, SYS_NTOHS = 185, SYS_HTONL = 186, SYS_NTOHL = 187,
    SYS_INET_PTON = 188, SYS_INET_NTOP = 189,
    SYS_SOCKET_SERVER = 190, SYS_SOCKET_FD = 191,
    SYS_SOCKET_CLOSE = 192, SYS_SOCKET_SELECT = 193,
    SYS_DL_OPEN = 194, SYS_DL_SYM = 195, SYS_DL_CLOSE = 196, SYS_DL_ERROR = 197,
    SYS_DL_CALL_NUM = 198, SYS_DL_CALL_INT = 199,
    SYS_INT_PTR = 200, SYS_NUM_PTR = 201,
    SYS_PTR_DEREF_INT = 202, SYS_PTR_DEREF_NUM = 203,
    SYS_PTR_SET_INT = 204, SYS_PTR_SET_NUM = 205,
    SYS_GETPGRP = 206, SYS_GETSID = 207, SYS_GETPGID = 208,
    SYS_NICE = 209, SYS_GETPRIORITY = 210,
    SYS_GETRUSAGE = 211, SYS_GETRLIMIT = 212,
    SYS_TIMES = 213, SYS_CLOCK = 214,
    SYS_MKSTEMP = 215, SYS_MKDTEMP = 216, SYS_STATVFS = 217,
    SYS_ATOI = 218, SYS_ATOF = 219, SYS_STRTOL = 220, SYS_DIFFTIME = 221,
    SYS_SRAND = 222, SYS_RAND = 223, SYS_SRANDOM = 224, SYS_RANDOM = 225,
    SYS_SEEK = 226, SYS_TELL = 227, SYS_REWIND = 228,
    SYS_WEAKEN = 229, SYS_ISWEAK = 230,
    SYS_WANTSCALAR = 231, SYS_WANTARRAY = 232, SYS_WANTHASH = 233,
    SYS_GLOBAL_SET = 234, SYS_GLOBAL_GET = 235, SYS_GLOBAL_EXISTS = 236,
    SYS_GLOBAL_DELETE = 237, SYS_GLOBAL_KEYS = 238,
    SYS_EXIT_NOCLEAN = 239, SYS_SIGNAL = 240,
    SYS_GET_RECURSION_LIMIT = 241, SYS_SET_RECURSION_LIMIT = 242,
    SYS_PACK = 243, SYS_UNPACK = 244,
    SYS_ORD_BYTE = 245, SYS_GET_BYTE = 246, SYS_BYTE_LENGTH = 247,
    SYS_BASE64_ENCODE = 248, SYS_BASE64_DECODE = 249,
    SYS_HEX_ENCODE = 250, SYS_HEX_DECODE = 251,
    SYS_CHROOT = 252, SYS_SETSID = 253, SYS_SETGID = 254, SYS_SETUID = 255,
    SYS_PIPE = 256, SYS_DUP2 = 257, SYS_SELECT_FD = 258,
    SYS_HASH_DEFAULT_CAPACITY = 259, SYS_ARRAY_RESERVE = 260,
    # math:: (300-340)
    MATH_SQRT = 300, MATH_SIN = 301, MATH_COS = 302, MATH_POW = 303,
    MATH_ABS = 304, MATH_FLOOR = 305, MATH_CEIL = 306,
    MATH_LOG = 307, MATH_EXP = 308, MATH_RAND = 309, MATH_SRAND = 310,
    MATH_ATAN2 = 311, MATH_TAN = 312, MATH_ASIN = 313, MATH_ACOS = 314,
    MATH_ATAN = 315, MATH_SINH = 316, MATH_COSH = 317, MATH_TANH = 318,
    MATH_LOG10 = 319, MATH_ROUND = 320, MATH_FABS = 321, MATH_FMOD = 322,
    MATH_HYPOT = 323, MATH_CBRT = 324, MATH_TRUNC = 325,
    MATH_ISNAN = 326, MATH_ISINF = 327, MATH_ISFINITE = 328,
    MATH_FMAX = 329, MATH_FMIN = 330, MATH_COPYSIGN = 331,
    MATH_REMAINDER = 332, MATH_LDEXP = 333, MATH_FREXP = 334,
    MATH_MODF = 335, MATH_SCALBN = 336,
    # utf8:: (350-360)
    UTF8_IS_UTF8 = 350, UTF8_VALID = 351, UTF8_ENCODE = 352, UTF8_DECODE = 353,
    UTF8_UPGRADE = 354, UTF8_DOWNGRADE = 355, UTF8_UNICODE_TO_NATIVE = 356,
    # DateTime:: (370-385)
    DT_NOW = 370, DT_NOW_UTC = 371, DT_MAKE = 372,
    DT_FROM_EPOCH = 373, DT_FROM_EPOCH_UTC = 374,
    DT_FORMAT = 375, DT_PARSE = 376,
    DT_DAY_OF_WEEK = 377, DT_DAY_OF_YEAR = 378,
    DT_TIMEZONE_OFFSET = 379, DT_TIMEZONE_NAME = 380,
    # BigInt:: (390-395)
    BIGINT_ADD = 390, BIGINT_SUB = 391, BIGINT_MUL = 392,
    BIGINT_CMP = 393, BIGINT_DIVMOD = 394, BIGINT_DIVMOD_REM = 395,
    # BigFloat:: (400-402)
    BIGFLOAT_PAD_RIGHT = 400, BIGFLOAT_NORMALIZE = 401, BIGFLOAT_NEW = 402,
    PLACEHOLDER_END = 999
}

# C helper functions for BigInt/BigFloat/DateTime support
__C__ {
#include <time.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

/* ---- BigInt C helpers ---- */
static int _bi_cmp(const char *a, const char *b) {
    size_t la = strlen(a), lb = strlen(b);
    if (la != lb) return (la > lb) ? 1 : -1;
    return strcmp(a, b);
}
static char *_bi_strip(const char *s) {
    while (*s == '0' && *(s + 1) != '\0') s++;
    return strdup(s);
}
static char *_bi_add(const char *a, const char *b) {
    size_t la = strlen(a), lb = strlen(b);
    size_t max = (la > lb) ? la : lb;
    char *result = (char *)malloc(max + 2);
    int carry = 0; size_t ri = 0, ia = la, ib = lb;
    while (ia > 0 || ib > 0 || carry) {
        int da = 0, db = 0;
        if (ia > 0) { ia--; da = a[ia] - '0'; }
        if (ib > 0) { ib--; db = b[ib] - '0'; }
        int sum = da + db + carry;
        carry = sum / 10;
        result[ri++] = '0' + (sum % 10);
    }
    for (size_t i = 0; i < ri / 2; i++) { char t = result[i]; result[i] = result[ri-1-i]; result[ri-1-i] = t; }
    result[ri] = '\0';
    return result;
}
static char *_bi_sub(const char *a, const char *b) {
    size_t la = strlen(a), lb = strlen(b);
    char *result = (char *)malloc(la + 1);
    int borrow = 0; size_t ri = 0, ia = la, ib = lb;
    while (ia > 0) {
        ia--;
        int da = a[ia] - '0' - borrow, db = 0;
        if (ib > 0) { ib--; db = b[ib] - '0'; }
        if (da < db) { da += 10; borrow = 1; } else { borrow = 0; }
        result[ri++] = '0' + (da - db);
    }
    for (size_t i = 0; i < ri / 2; i++) { char t = result[i]; result[i] = result[ri-1-i]; result[ri-1-i] = t; }
    result[ri] = '\0';
    char *s = _bi_strip(result); free(result); return s;
}
static char *_bi_mul(const char *a, const char *b) {
    size_t la = strlen(a), lb = strlen(b), rlen = la + lb;
    int *digits = (int *)calloc(rlen, sizeof(int));
    for (size_t i = 0; i < la; i++)
        for (size_t j = 0; j < lb; j++)
            digits[i + j] += (a[la-1-i] - '0') * (b[lb-1-j] - '0');
    for (size_t i = 0; i < rlen - 1; i++) { digits[i+1] += digits[i] / 10; digits[i] %= 10; }
    size_t top = rlen - 1;
    while (top > 0 && digits[top] == 0) top--;
    char *result = (char *)malloc(top + 2);
    for (size_t i = 0; i <= top; i++) result[i] = '0' + digits[top - i];
    result[top + 1] = '\0';
    free(digits);
    return result;
}
static char *_bi_divmod(const char *a, const char *b, char **rem) {
    if (_bi_cmp(a, b) < 0) { if (rem) *rem = strdup(a); return strdup("0"); }
    if (strcmp(b, "0") == 0) { if (rem) *rem = strdup("0"); return strdup("0"); }
    size_t la = strlen(a);
    char *quotient = (char *)malloc(la + 1);
    size_t qi = 0;
    char *current = strdup("0");
    for (size_t i = 0; i < la; i++) {
        size_t cl = strlen(current);
        char *next = (char *)malloc(cl + 2);
        memcpy(next, current, cl); next[cl] = a[i]; next[cl+1] = '\0';
        free(current); current = _bi_strip(next); free(next);
        int count = 0;
        while (_bi_cmp(current, b) >= 0) { char *tmp = _bi_sub(current, b); free(current); current = tmp; count++; }
        quotient[qi++] = '0' + count;
    }
    quotient[qi] = '\0';
    char *sq = _bi_strip(quotient); free(quotient);
    if (rem) *rem = current; else free(current);
    return sq;
}

/* ---- BigFloat C helpers ---- */
static char *_bf_pad_right(const char *s, size_t n) {
    size_t l = strlen(s);
    char *r = (char *)malloc(l + n + 1);
    memcpy(r, s, l);
    for (size_t i = 0; i < n; i++) r[l+i] = '0';
    r[l+n] = '\0';
    return r;
}
static char *_bf_normalize(const char *m, int64_t *scale) {
    size_t l = strlen(m);
    if (l == 0 || strcmp(m, "0") == 0) { *scale = 0; return strdup("0"); }
    size_t end = l;
    while (end > 1 && m[end-1] == '0' && *scale > 0) { end--; (*scale)--; }
    char *r = (char *)malloc(end + 1);
    memcpy(r, m, end); r[end] = '\0';
    return r;
}
}

# ============================================================
# Environment - Lexical scope chain
# ============================================================

func env_new(scalar $parent) scalar {
    my hash %e = ();
    my hash %vars = ();
    $e{"vars"} = \%vars;
    $e{"parent"} = $parent;
    return \%e;
}

func env_set(scalar $env, str $name, scalar $value) void {
    $env->{"vars"}->{$name} = $value;
}

func env_get(scalar $env, str $name) scalar {
    my scalar $cur = $env;
    while (defined($cur)) {
        my scalar $vars = $cur->{"vars"};
        if (exists($vars, $name)) {
            return $vars->{$name};
        }
        $cur = $cur->{"parent"};
    }
    return undef;
}

func env_exists(scalar $env, str $name) int {
    my scalar $cur = $env;
    while (defined($cur)) {
        if (exists($cur->{"vars"}, $name)) {
            return 1;
        }
        $cur = $cur->{"parent"};
    }
    return 0;
}

# Update variable in the nearest scope that has it
func env_update(scalar $env, str $name, scalar $value) int {
    my scalar $cur = $env;
    while (defined($cur)) {
        my scalar $vars = $cur->{"vars"};
        if (exists($vars, $name)) {
            $vars->{$name} = $value;
            return 1;
        }
        $cur = $cur->{"parent"};
    }
    return 0;
}

# ============================================================
# Builtin Function Registry (O(1) lookup via hash)
# ============================================================

func init_builtins(scalar $interp) void {
    my hash %b = ();
    # I/O
    $b{"say"} = BI::SAY; $b{"print"} = BI::PRINT; $b{"dumper"} = BI::DUMPER;
    $b{"printf"} = BI::PRINTF; $b{"readline"} = BI::READLINE_FN;
    # Array operations
    $b{"push"} = BI::PUSH; $b{"pop"} = BI::POP; $b{"shift"} = BI::SHIFT;
    $b{"unshift"} = BI::UNSHIFT; $b{"splice"} = BI::SPLICE;
    $b{"reverse"} = BI::REVERSE; $b{"size"} = BI::SIZE; $b{"scalar"} = BI::SCALAR_FN;
    $b{"nsort"} = BI::NSORT; $b{"sort"} = BI::SORT_FN;
    # String operations
    $b{"length"} = BI::LENGTH; $b{"bytes"} = BI::BYTES; $b{"substr"} = BI::SUBSTR;
    $b{"index"} = BI::INDEX_FN; $b{"rindex"} = BI::RINDEX;
    $b{"join"} = BI::JOIN; $b{"split"} = BI::SPLIT; $b{"chomp"} = BI::CHOMP;
    $b{"chop"} = BI::CHOP; $b{"chr"} = BI::CHR;
    $b{"ord"} = BI::ORD; $b{"char_at"} = BI::CHAR_AT; $b{"uc"} = BI::UC;
    $b{"lc"} = BI::LC; $b{"sprintf"} = BI::SPRINTF_FN;
    $b{"match"} = BI::MATCH_FN; $b{"replace"} = BI::REPLACE; $b{"replace_all"} = BI::REPLACE_ALL;
    $b{"upper"} = BI::UPPER; $b{"lower"} = BI::LOWER; $b{"ucfirst"} = BI::UCFIRST;
    $b{"lcfirst"} = BI::LCFIRST;
    $b{"trim"} = BI::TRIM; $b{"ltrim"} = BI::LTRIM; $b{"rtrim"} = BI::RTRIM;
    $b{"repeat"} = BI::REPEAT;
    $b{"typeof"} = BI::TYPEOF; $b{"cast_int"} = BI::CAST_INT;
    $b{"cast_num"} = BI::CAST_NUM; $b{"cast_str"} = BI::CAST_STR;
    # Hash operations
    $b{"keys"} = BI::KEYS; $b{"values"} = BI::VALUES_FN; $b{"exists"} = BI::EXISTS_FN;
    $b{"delete"} = BI::DELETE_FN; $b{"each"} = BI::EACH;
    # Type functions
    $b{"defined"} = BI::DEFINED; $b{"ref"} = BI::REF_FN; $b{"int"} = BI::INT_FN;
    # Misc
    $b{"die"} = BI::DIE; $b{"slurp"} = BI::SLURP; $b{"spew"} = BI::SPEW;
    $b{"abs"} = BI::ABS;
    $b{"dumper_str"} = BI::DUMPER_STR; $b{"strada_new_undef"} = BI::STRADA_NEW_UNDEF;
    # Ref/memory functions
    $b{"refto"} = BI::REFTO; $b{"refcount"} = BI::REFCOUNT;
    $b{"is_refto"} = BI::IS_REFTO; $b{"reftype"} = BI::REFTYPE;
    $b{"blessed"} = BI::BLESSED; $b{"deref"} = BI::DEREF;
    $b{"derefto"} = BI::DEREFTO; $b{"is_ref"} = BI::IS_REF;
    # OOP helpers
    $b{"set_package"} = BI::SET_PACKAGE; $b{"inherit"} = BI::INHERIT_FN;
    $b{"hash_new"} = BI::HASH_NEW;
    $b{"UNIVERSAL::isa"} = BI::UNIVERSAL_ISA; $b{"UNIVERSAL::can"} = BI::UNIVERSAL_CAN;
    $b{"isa"} = BI::ISA; $b{"can"} = BI::CAN_FN; $b{"capture"} = BI::CAPTURE;
    $b{"hash_set"} = BI::HASH_SET; $b{"hash_get"} = BI::HASH_GET;
    $b{"hash_delete"} = BI::HASH_DELETE;
    # OOP
    $b{"bless"} = BI::BLESS; $b{"tie"} = BI::TIE; $b{"untie"} = BI::UNTIE;
    $b{"tied"} = BI::TIED;
    # Additional
    $b{"select"} = BI::SELECT_FN; $b{"named_captures"} = BI::NAMED_CAPTURES;
    $b{"captures"} = BI::CAPTURES; $b{"throw"} = BI::THROW_FN;
    # BigInt/BigFloat helpers
    $b{"BigInt::_bi_add"} = BI::BIGINT_ADD; $b{"BigInt::_bi_sub"} = BI::BIGINT_SUB;
    $b{"BigInt::_bi_mul"} = BI::BIGINT_MUL; $b{"BigInt::_bi_cmp"} = BI::BIGINT_CMP;
    $b{"BigInt::_bi_divmod"} = BI::BIGINT_DIVMOD;
    $b{"BigInt::_bi_divmod_rem"} = BI::BIGINT_DIVMOD_REM;
    $b{"BigFloat::_bf_pad_right"} = BI::BIGFLOAT_PAD_RIGHT;
    $b{"BigFloat::_bf_normalize"} = BI::BIGFLOAT_NORMALIZE;
    $b{"BigFloat::new"} = BI::BIGFLOAT_NEW; $b{"BigFloat_new"} = BI::BIGFLOAT_NEW;
    # sys::/core:: functions (both prefixes map to same BI value)
    $b{"sys::exit"} = BI::SYS_EXIT; $b{"core::exit"} = BI::SYS_EXIT;
    $b{"sys::getenv"} = BI::SYS_GETENV; $b{"core::getenv"} = BI::SYS_GETENV;
    $b{"sys::setenv"} = BI::SYS_SETENV; $b{"core::setenv"} = BI::SYS_SETENV;
    $b{"sys::time"} = BI::SYS_TIME; $b{"core::time"} = BI::SYS_TIME;
    $b{"sys::sleep"} = BI::SYS_SLEEP; $b{"core::sleep"} = BI::SYS_SLEEP;
    $b{"sys::hires_time"} = BI::SYS_HIRES_TIME; $b{"core::hires_time"} = BI::SYS_HIRES_TIME;
    $b{"sys::open"} = BI::SYS_OPEN; $b{"core::open"} = BI::SYS_OPEN;
    $b{"sys::close"} = BI::SYS_CLOSE; $b{"core::close"} = BI::SYS_CLOSE;
    $b{"sys::readline"} = BI::SYS_READLINE; $b{"core::readline"} = BI::SYS_READLINE;
    $b{"sys::eof"} = BI::SYS_EOF; $b{"core::eof"} = BI::SYS_EOF;
    $b{"sys::flush"} = BI::SYS_FLUSH; $b{"core::flush"} = BI::SYS_FLUSH;
    $b{"sys::popen"} = BI::SYS_POPEN; $b{"core::popen"} = BI::SYS_POPEN;
    $b{"sys::qx"} = BI::SYS_QX; $b{"core::qx"} = BI::SYS_QX;
    $b{"sys::system"} = BI::SYS_SYSTEM; $b{"core::system"} = BI::SYS_SYSTEM;
    $b{"sys::stack_trace"} = BI::SYS_STACK_TRACE; $b{"core::stack_trace"} = BI::SYS_STACK_TRACE;
    $b{"sys::fwrite"} = BI::SYS_FWRITE; $b{"core::fwrite"} = BI::SYS_FWRITE;
    $b{"sys::fread"} = BI::SYS_FREAD; $b{"core::fread"} = BI::SYS_FREAD;
    $b{"sys::fputs"} = BI::SYS_FPUTS; $b{"core::fputs"} = BI::SYS_FPUTS;
    $b{"sys::fgets"} = BI::SYS_FGETS; $b{"core::fgets"} = BI::SYS_FGETS;
    $b{"sys::pclose"} = BI::SYS_PCLOSE; $b{"core::pclose"} = BI::SYS_PCLOSE;
    $b{"sys::truncate"} = BI::SYS_TRUNCATE; $b{"core::truncate"} = BI::SYS_TRUNCATE;
    $b{"sys::open_str"} = BI::SYS_OPEN_STR; $b{"core::open_str"} = BI::SYS_OPEN_STR;
    $b{"sys::str_from_fh"} = BI::SYS_STR_FROM_FH; $b{"core::str_from_fh"} = BI::SYS_STR_FROM_FH;
    $b{"sys::slurp"} = BI::SYS_SLURP; $b{"core::slurp"} = BI::SYS_SLURP;
    $b{"sys::spew"} = BI::SYS_SPEW; $b{"core::spew"} = BI::SYS_SPEW;
    $b{"sys::unlink"} = BI::SYS_UNLINK; $b{"core::unlink"} = BI::SYS_UNLINK;
    $b{"sys::rename"} = BI::SYS_RENAME; $b{"core::rename"} = BI::SYS_RENAME;
    $b{"sys::mkdir"} = BI::SYS_MKDIR; $b{"core::mkdir"} = BI::SYS_MKDIR;
    $b{"sys::rmdir"} = BI::SYS_RMDIR; $b{"core::rmdir"} = BI::SYS_RMDIR;
    $b{"sys::chmod"} = BI::SYS_CHMOD; $b{"core::chmod"} = BI::SYS_CHMOD;
    $b{"sys::link"} = BI::SYS_LINK; $b{"core::link"} = BI::SYS_LINK;
    $b{"sys::symlink"} = BI::SYS_SYMLINK; $b{"core::symlink"} = BI::SYS_SYMLINK;
    $b{"sys::readlink"} = BI::SYS_READLINK; $b{"core::readlink"} = BI::SYS_READLINK;
    $b{"sys::stat"} = BI::SYS_STAT; $b{"core::stat"} = BI::SYS_STAT;
    $b{"sys::lstat"} = BI::SYS_LSTAT; $b{"core::lstat"} = BI::SYS_LSTAT;
    $b{"sys::access"} = BI::SYS_ACCESS; $b{"core::access"} = BI::SYS_ACCESS;
    $b{"sys::is_file"} = BI::SYS_IS_FILE; $b{"core::is_file"} = BI::SYS_IS_FILE;
    $b{"sys::is_dir"} = BI::SYS_IS_DIR; $b{"core::is_dir"} = BI::SYS_IS_DIR;
    $b{"sys::readdir"} = BI::SYS_READDIR; $b{"core::readdir"} = BI::SYS_READDIR;
    $b{"sys::readdir_full"} = BI::SYS_READDIR_FULL; $b{"core::readdir_full"} = BI::SYS_READDIR_FULL;
    $b{"sys::glob"} = BI::SYS_GLOB; $b{"core::glob"} = BI::SYS_GLOB;
    $b{"sys::fnmatch"} = BI::SYS_FNMATCH; $b{"core::fnmatch"} = BI::SYS_FNMATCH;
    $b{"sys::dirname"} = BI::SYS_DIRNAME; $b{"core::dirname"} = BI::SYS_DIRNAME;
    $b{"sys::basename"} = BI::SYS_BASENAME; $b{"core::basename"} = BI::SYS_BASENAME;
    $b{"sys::file_ext"} = BI::SYS_FILE_EXT; $b{"core::file_ext"} = BI::SYS_FILE_EXT;
    $b{"sys::realpath"} = BI::SYS_REALPATH; $b{"core::realpath"} = BI::SYS_REALPATH;
    $b{"sys::getcwd"} = BI::SYS_GETCWD; $b{"core::getcwd"} = BI::SYS_GETCWD;
    $b{"sys::path_join"} = BI::SYS_PATH_JOIN; $b{"core::path_join"} = BI::SYS_PATH_JOIN;
    $b{"sys::getpid"} = BI::SYS_GETPID; $b{"core::getpid"} = BI::SYS_GETPID;
    $b{"sys::getppid"} = BI::SYS_GETPPID; $b{"core::getppid"} = BI::SYS_GETPPID;
    $b{"sys::fork"} = BI::SYS_FORK; $b{"core::fork"} = BI::SYS_FORK;
    $b{"sys::wait"} = BI::SYS_WAIT; $b{"core::wait"} = BI::SYS_WAIT;
    $b{"sys::usleep"} = BI::SYS_USLEEP; $b{"core::usleep"} = BI::SYS_USLEEP;
    $b{"sys::getprocname"} = BI::SYS_GETPROCNAME; $b{"core::getprocname"} = BI::SYS_GETPROCNAME;
    $b{"sys::setprocname"} = BI::SYS_SETPROCNAME; $b{"core::setprocname"} = BI::SYS_SETPROCNAME;
    $b{"sys::getproctitle"} = BI::SYS_GETPROCTITLE; $b{"core::getproctitle"} = BI::SYS_GETPROCTITLE;
    $b{"sys::setproctitle"} = BI::SYS_SETPROCTITLE; $b{"core::setproctitle"} = BI::SYS_SETPROCTITLE;
    $b{"sys::unsetenv"} = BI::SYS_UNSETENV; $b{"core::unsetenv"} = BI::SYS_UNSETENV;
    $b{"sys::getuid"} = BI::SYS_GETUID; $b{"core::getuid"} = BI::SYS_GETUID;
    $b{"sys::getgid"} = BI::SYS_GETGID; $b{"core::getgid"} = BI::SYS_GETGID;
    $b{"sys::geteuid"} = BI::SYS_GETEUID; $b{"core::geteuid"} = BI::SYS_GETEUID;
    $b{"sys::getegid"} = BI::SYS_GETEGID; $b{"core::getegid"} = BI::SYS_GETEGID;
    $b{"sys::getpwuid"} = BI::SYS_GETPWUID; $b{"core::getpwuid"} = BI::SYS_GETPWUID;
    $b{"sys::getpwnam"} = BI::SYS_GETPWNAM; $b{"core::getpwnam"} = BI::SYS_GETPWNAM;
    $b{"sys::getgrgid"} = BI::SYS_GETGRGID; $b{"core::getgrgid"} = BI::SYS_GETGRGID;
    $b{"sys::getgroups"} = BI::SYS_GETGROUPS; $b{"core::getgroups"} = BI::SYS_GETGROUPS;
    $b{"sys::isatty"} = BI::SYS_ISATTY; $b{"core::isatty"} = BI::SYS_ISATTY;
    $b{"sys::strerror"} = BI::SYS_STRERROR; $b{"core::strerror"} = BI::SYS_STRERROR;
    $b{"sys::errno"} = BI::SYS_ERRNO; $b{"core::errno"} = BI::SYS_ERRNO;
    $b{"sys::umask"} = BI::SYS_UMASK; $b{"core::umask"} = BI::SYS_UMASK;
    $b{"sys::utime"} = BI::SYS_UTIME; $b{"core::utime"} = BI::SYS_UTIME;
    $b{"sys::free"} = BI::SYS_FREE; $b{"core::free"} = BI::SYS_FREE;
    $b{"sys::release"} = BI::SYS_RELEASE; $b{"core::release"} = BI::SYS_RELEASE;
    $b{"sys::gethostname"} = BI::SYS_GETHOSTNAME; $b{"core::gethostname"} = BI::SYS_GETHOSTNAME;
    $b{"sys::gethostbyname"} = BI::SYS_GETHOSTBYNAME; $b{"core::gethostbyname"} = BI::SYS_GETHOSTBYNAME;
    $b{"sys::gethostbyname_all"} = BI::SYS_GETHOSTBYNAME_ALL; $b{"core::gethostbyname_all"} = BI::SYS_GETHOSTBYNAME_ALL;
    $b{"sys::getaddrinfo"} = BI::SYS_GETADDRINFO; $b{"core::getaddrinfo"} = BI::SYS_GETADDRINFO;
    $b{"sys::inet_addr"} = BI::SYS_INET_ADDR; $b{"core::inet_addr"} = BI::SYS_INET_ADDR;
    $b{"sys::inet_ntoa"} = BI::SYS_INET_NTOA; $b{"core::inet_ntoa"} = BI::SYS_INET_NTOA;
    $b{"sys::htons"} = BI::SYS_HTONS; $b{"core::htons"} = BI::SYS_HTONS;
    $b{"sys::ntohs"} = BI::SYS_NTOHS; $b{"core::ntohs"} = BI::SYS_NTOHS;
    $b{"sys::htonl"} = BI::SYS_HTONL; $b{"core::htonl"} = BI::SYS_HTONL;
    $b{"sys::ntohl"} = BI::SYS_NTOHL; $b{"core::ntohl"} = BI::SYS_NTOHL;
    $b{"sys::inet_pton"} = BI::SYS_INET_PTON; $b{"core::inet_pton"} = BI::SYS_INET_PTON;
    $b{"sys::inet_ntop"} = BI::SYS_INET_NTOP; $b{"core::inet_ntop"} = BI::SYS_INET_NTOP;
    $b{"sys::socket_server"} = BI::SYS_SOCKET_SERVER; $b{"core::socket_server"} = BI::SYS_SOCKET_SERVER;
    $b{"sys::socket_fd"} = BI::SYS_SOCKET_FD; $b{"core::socket_fd"} = BI::SYS_SOCKET_FD;
    $b{"sys::socket_close"} = BI::SYS_SOCKET_CLOSE; $b{"core::socket_close"} = BI::SYS_SOCKET_CLOSE;
    $b{"sys::socket_select"} = BI::SYS_SOCKET_SELECT; $b{"core::socket_select"} = BI::SYS_SOCKET_SELECT;
    $b{"sys::dl_open"} = BI::SYS_DL_OPEN; $b{"core::dl_open"} = BI::SYS_DL_OPEN;
    $b{"sys::dl_sym"} = BI::SYS_DL_SYM; $b{"core::dl_sym"} = BI::SYS_DL_SYM;
    $b{"sys::dl_close"} = BI::SYS_DL_CLOSE; $b{"core::dl_close"} = BI::SYS_DL_CLOSE;
    $b{"sys::dl_error"} = BI::SYS_DL_ERROR; $b{"core::dl_error"} = BI::SYS_DL_ERROR;
    $b{"sys::dl_call_num"} = BI::SYS_DL_CALL_NUM; $b{"core::dl_call_num"} = BI::SYS_DL_CALL_NUM;
    $b{"sys::dl_call_int"} = BI::SYS_DL_CALL_INT; $b{"core::dl_call_int"} = BI::SYS_DL_CALL_INT;
    $b{"sys::int_ptr"} = BI::SYS_INT_PTR; $b{"core::int_ptr"} = BI::SYS_INT_PTR;
    $b{"sys::num_ptr"} = BI::SYS_NUM_PTR; $b{"core::num_ptr"} = BI::SYS_NUM_PTR;
    $b{"sys::ptr_deref_int"} = BI::SYS_PTR_DEREF_INT; $b{"core::ptr_deref_int"} = BI::SYS_PTR_DEREF_INT;
    $b{"sys::ptr_deref_num"} = BI::SYS_PTR_DEREF_NUM; $b{"core::ptr_deref_num"} = BI::SYS_PTR_DEREF_NUM;
    $b{"sys::ptr_set_int"} = BI::SYS_PTR_SET_INT; $b{"core::ptr_set_int"} = BI::SYS_PTR_SET_INT;
    $b{"sys::ptr_set_num"} = BI::SYS_PTR_SET_NUM; $b{"core::ptr_set_num"} = BI::SYS_PTR_SET_NUM;
    $b{"sys::getpgrp"} = BI::SYS_GETPGRP; $b{"core::getpgrp"} = BI::SYS_GETPGRP;
    $b{"sys::getsid"} = BI::SYS_GETSID; $b{"core::getsid"} = BI::SYS_GETSID;
    $b{"sys::getpgid"} = BI::SYS_GETPGID; $b{"core::getpgid"} = BI::SYS_GETPGID;
    $b{"sys::nice"} = BI::SYS_NICE; $b{"core::nice"} = BI::SYS_NICE;
    $b{"sys::getpriority"} = BI::SYS_GETPRIORITY; $b{"core::getpriority"} = BI::SYS_GETPRIORITY;
    $b{"sys::getrusage"} = BI::SYS_GETRUSAGE; $b{"core::getrusage"} = BI::SYS_GETRUSAGE;
    $b{"sys::getrlimit"} = BI::SYS_GETRLIMIT; $b{"core::getrlimit"} = BI::SYS_GETRLIMIT;
    $b{"sys::times"} = BI::SYS_TIMES; $b{"core::times"} = BI::SYS_TIMES;
    $b{"sys::clock"} = BI::SYS_CLOCK; $b{"core::clock"} = BI::SYS_CLOCK;
    $b{"sys::mkstemp"} = BI::SYS_MKSTEMP; $b{"core::mkstemp"} = BI::SYS_MKSTEMP;
    $b{"sys::mkdtemp"} = BI::SYS_MKDTEMP; $b{"core::mkdtemp"} = BI::SYS_MKDTEMP;
    $b{"sys::statvfs"} = BI::SYS_STATVFS; $b{"core::statvfs"} = BI::SYS_STATVFS;
    $b{"sys::atoi"} = BI::SYS_ATOI; $b{"core::atoi"} = BI::SYS_ATOI;
    $b{"sys::atof"} = BI::SYS_ATOF; $b{"core::atof"} = BI::SYS_ATOF;
    $b{"sys::strtol"} = BI::SYS_STRTOL; $b{"core::strtol"} = BI::SYS_STRTOL;
    $b{"sys::difftime"} = BI::SYS_DIFFTIME; $b{"core::difftime"} = BI::SYS_DIFFTIME;
    $b{"sys::srand"} = BI::SYS_SRAND; $b{"core::srand"} = BI::SYS_SRAND;
    $b{"sys::rand"} = BI::SYS_RAND; $b{"core::rand"} = BI::SYS_RAND;
    $b{"sys::srandom"} = BI::SYS_SRANDOM; $b{"core::srandom"} = BI::SYS_SRANDOM;
    $b{"sys::random"} = BI::SYS_RANDOM; $b{"core::random"} = BI::SYS_RANDOM;
    $b{"sys::seek"} = BI::SYS_SEEK; $b{"core::seek"} = BI::SYS_SEEK;
    $b{"sys::tell"} = BI::SYS_TELL; $b{"core::tell"} = BI::SYS_TELL;
    $b{"sys::rewind"} = BI::SYS_REWIND; $b{"core::rewind"} = BI::SYS_REWIND;
    $b{"sys::weaken"} = BI::SYS_WEAKEN; $b{"core::weaken"} = BI::SYS_WEAKEN;
    $b{"sys::isweak"} = BI::SYS_ISWEAK; $b{"core::isweak"} = BI::SYS_ISWEAK;
    $b{"sys::wantscalar"} = BI::SYS_WANTSCALAR; $b{"core::wantscalar"} = BI::SYS_WANTSCALAR;
    $b{"sys::wantarray"} = BI::SYS_WANTARRAY; $b{"core::wantarray"} = BI::SYS_WANTARRAY;
    $b{"sys::wanthash"} = BI::SYS_WANTHASH; $b{"core::wanthash"} = BI::SYS_WANTHASH;
    $b{"sys::global_set"} = BI::SYS_GLOBAL_SET; $b{"core::global_set"} = BI::SYS_GLOBAL_SET;
    $b{"sys::global_get"} = BI::SYS_GLOBAL_GET; $b{"core::global_get"} = BI::SYS_GLOBAL_GET;
    $b{"sys::global_exists"} = BI::SYS_GLOBAL_EXISTS; $b{"core::global_exists"} = BI::SYS_GLOBAL_EXISTS;
    $b{"sys::global_delete"} = BI::SYS_GLOBAL_DELETE; $b{"core::global_delete"} = BI::SYS_GLOBAL_DELETE;
    $b{"sys::global_keys"} = BI::SYS_GLOBAL_KEYS; $b{"core::global_keys"} = BI::SYS_GLOBAL_KEYS;
    $b{"sys::_exit"} = BI::SYS_EXIT_NOCLEAN; $b{"core::_exit"} = BI::SYS_EXIT_NOCLEAN;
    $b{"sys::signal"} = BI::SYS_SIGNAL; $b{"core::signal"} = BI::SYS_SIGNAL;
    $b{"sys::get_recursion_limit"} = BI::SYS_GET_RECURSION_LIMIT; $b{"core::get_recursion_limit"} = BI::SYS_GET_RECURSION_LIMIT;
    $b{"sys::set_recursion_limit"} = BI::SYS_SET_RECURSION_LIMIT; $b{"core::set_recursion_limit"} = BI::SYS_SET_RECURSION_LIMIT;
    $b{"sys::pack"} = BI::SYS_PACK; $b{"core::pack"} = BI::SYS_PACK;
    $b{"sys::unpack"} = BI::SYS_UNPACK; $b{"core::unpack"} = BI::SYS_UNPACK;
    $b{"sys::ord_byte"} = BI::SYS_ORD_BYTE; $b{"core::ord_byte"} = BI::SYS_ORD_BYTE;
    $b{"sys::get_byte"} = BI::SYS_GET_BYTE; $b{"core::get_byte"} = BI::SYS_GET_BYTE;
    $b{"sys::byte_length"} = BI::SYS_BYTE_LENGTH; $b{"core::byte_length"} = BI::SYS_BYTE_LENGTH;
    $b{"sys::base64_encode"} = BI::SYS_BASE64_ENCODE; $b{"core::base64_encode"} = BI::SYS_BASE64_ENCODE;
    $b{"sys::base64_decode"} = BI::SYS_BASE64_DECODE; $b{"core::base64_decode"} = BI::SYS_BASE64_DECODE;
    $b{"sys::hex_encode"} = BI::SYS_HEX_ENCODE; $b{"core::hex_encode"} = BI::SYS_HEX_ENCODE;
    $b{"sys::hex_decode"} = BI::SYS_HEX_DECODE; $b{"core::hex_decode"} = BI::SYS_HEX_DECODE;
    $b{"sys::chroot"} = BI::SYS_CHROOT; $b{"core::chroot"} = BI::SYS_CHROOT;
    $b{"sys::setsid"} = BI::SYS_SETSID; $b{"core::setsid"} = BI::SYS_SETSID;
    $b{"sys::setgid"} = BI::SYS_SETGID; $b{"core::setgid"} = BI::SYS_SETGID;
    $b{"sys::setuid"} = BI::SYS_SETUID; $b{"core::setuid"} = BI::SYS_SETUID;
    $b{"sys::pipe"} = BI::SYS_PIPE; $b{"core::pipe"} = BI::SYS_PIPE;
    $b{"sys::dup2"} = BI::SYS_DUP2; $b{"core::dup2"} = BI::SYS_DUP2;
    $b{"sys::select_fd"} = BI::SYS_SELECT_FD; $b{"core::select_fd"} = BI::SYS_SELECT_FD;
    $b{"sys::hash_default_capacity"} = BI::SYS_HASH_DEFAULT_CAPACITY; $b{"core::hash_default_capacity"} = BI::SYS_HASH_DEFAULT_CAPACITY;
    $b{"sys::array_reserve"} = BI::SYS_ARRAY_RESERVE; $b{"core::array_reserve"} = BI::SYS_ARRAY_RESERVE;
    # math:: functions
    $b{"math::sqrt"} = BI::MATH_SQRT; $b{"math::sin"} = BI::MATH_SIN;
    $b{"math::cos"} = BI::MATH_COS; $b{"math::pow"} = BI::MATH_POW;
    $b{"math::abs"} = BI::MATH_ABS; $b{"math::floor"} = BI::MATH_FLOOR;
    $b{"math::ceil"} = BI::MATH_CEIL; $b{"math::log"} = BI::MATH_LOG;
    $b{"math::exp"} = BI::MATH_EXP; $b{"math::rand"} = BI::MATH_RAND;
    $b{"math::srand"} = BI::MATH_SRAND; $b{"math::atan2"} = BI::MATH_ATAN2;
    $b{"math::tan"} = BI::MATH_TAN; $b{"math::asin"} = BI::MATH_ASIN;
    $b{"math::acos"} = BI::MATH_ACOS; $b{"math::atan"} = BI::MATH_ATAN;
    $b{"math::sinh"} = BI::MATH_SINH; $b{"math::cosh"} = BI::MATH_COSH;
    $b{"math::tanh"} = BI::MATH_TANH; $b{"math::log10"} = BI::MATH_LOG10;
    $b{"math::round"} = BI::MATH_ROUND; $b{"math::fabs"} = BI::MATH_FABS;
    $b{"math::fmod"} = BI::MATH_FMOD; $b{"math::hypot"} = BI::MATH_HYPOT;
    $b{"math::cbrt"} = BI::MATH_CBRT; $b{"math::trunc"} = BI::MATH_TRUNC;
    $b{"math::isnan"} = BI::MATH_ISNAN; $b{"math::isinf"} = BI::MATH_ISINF;
    $b{"math::isfinite"} = BI::MATH_ISFINITE; $b{"math::fmax"} = BI::MATH_FMAX;
    $b{"math::fmin"} = BI::MATH_FMIN; $b{"math::copysign"} = BI::MATH_COPYSIGN;
    $b{"math::remainder"} = BI::MATH_REMAINDER; $b{"math::ldexp"} = BI::MATH_LDEXP;
    $b{"math::frexp"} = BI::MATH_FREXP; $b{"math::modf"} = BI::MATH_MODF;
    $b{"math::scalbn"} = BI::MATH_SCALBN;
    # utf8:: functions
    $b{"utf8::is_utf8"} = BI::UTF8_IS_UTF8; $b{"utf8::valid"} = BI::UTF8_VALID;
    $b{"utf8::encode"} = BI::UTF8_ENCODE; $b{"utf8::decode"} = BI::UTF8_DECODE;
    $b{"utf8::upgrade"} = BI::UTF8_UPGRADE; $b{"utf8::downgrade"} = BI::UTF8_DOWNGRADE;
    $b{"utf8::unicode_to_native"} = BI::UTF8_UNICODE_TO_NATIVE;
    # DateTime:: functions
    $b{"DateTime::now"} = BI::DT_NOW; $b{"DateTime_now"} = BI::DT_NOW;
    $b{"DateTime::now_utc"} = BI::DT_NOW_UTC; $b{"DateTime_now_utc"} = BI::DT_NOW_UTC;
    $b{"DateTime::make"} = BI::DT_MAKE; $b{"DateTime_make"} = BI::DT_MAKE;
    $b{"DateTime::from_epoch"} = BI::DT_FROM_EPOCH; $b{"DateTime_from_epoch"} = BI::DT_FROM_EPOCH;
    $b{"DateTime::from_epoch_utc"} = BI::DT_FROM_EPOCH_UTC; $b{"DateTime_from_epoch_utc"} = BI::DT_FROM_EPOCH_UTC;
    $b{"DateTime::format"} = BI::DT_FORMAT; $b{"DateTime_format"} = BI::DT_FORMAT;
    $b{"DateTime::parse"} = BI::DT_PARSE; $b{"DateTime_parse"} = BI::DT_PARSE;
    $b{"DateTime::day_of_week"} = BI::DT_DAY_OF_WEEK; $b{"DateTime_day_of_week"} = BI::DT_DAY_OF_WEEK;
    $b{"DateTime::day_of_year"} = BI::DT_DAY_OF_YEAR; $b{"DateTime_day_of_year"} = BI::DT_DAY_OF_YEAR;
    $b{"DateTime::timezone_offset"} = BI::DT_TIMEZONE_OFFSET; $b{"DateTime_timezone_offset"} = BI::DT_TIMEZONE_OFFSET;
    $b{"DateTime::timezone_name"} = BI::DT_TIMEZONE_NAME; $b{"DateTime_timezone_name"} = BI::DT_TIMEZONE_NAME;
    $interp->{"builtin_ids"} = \%b;
}

# ============================================================
# Interpreter State
# ============================================================

func interp_new() scalar {
    my hash %interp = ();
    my hash %functions = ();
    my hash %enums = ();
    my hash %constants = ();
    my scalar $global_env = env_new(undef);
    $interp{"functions"} = \%functions;
    $interp{"enums"} = \%enums;
    $interp{"constants"} = \%constants;
    $interp{"global_env"} = $global_env;
    $interp{"package"} = "main";
    $interp{"filename"} = "<input>";
    $interp{"call_depth"} = 0;
    $interp{"max_call_depth"} = 1000;
    # OOP state
    my hash %inherits = ();
    $interp{"inherits"} = \%inherits;
    my hash %overloads = ();
    $interp{"overloads"} = \%overloads;
    $interp{"has_overloads"} = 0;
    my array @method_modifiers = ();
    $interp{"method_modifiers"} = \@method_modifiers;
    my hash %autoloads = ();
    $interp{"autoloads"} = \%autoloads;
    my hash %method_cache = ();
    $interp{"method_cache"} = \%method_cache;
    # END blocks
    my array @end_blocks = ();
    $interp{"end_blocks"} = \@end_blocks;
    # local() dynamic scoping stack
    my array @local_stack = ();
    $interp{"local_stack"} = \@local_stack;
    # select() default output
    $interp{"select_fh"} = undef;
    # Signal-based control flow flags (numeric for performance)
    $interp{"signal"} = SIG::NONE;
    $interp{"signal_value"} = undef;
    $interp{"signal_label"} = "";
    $interp{"had_explicit_return"} = 0;
    # Native function support (import_lib)
    my hash %native_funcs = ();
    $interp{"native_funcs"} = \%native_funcs;
    my array @native_lib_handles = ();
    $interp{"native_lib_handles"} = \@native_lib_handles;
    # Builtin function lookup hash (O(1) instead of 88 string comparisons)
    init_builtins(\%interp);
    # Operator ID lookup hash (O(1) instead of 23+ string comparisons)
    my hash %op_ids = ();
    $op_ids{"+"} = OP::ADD; $op_ids{"-"} = OP::SUB; $op_ids{"*"} = OP::MUL;
    $op_ids{"/"} = OP::DIV; $op_ids{"%"} = OP::MOD; $op_ids{"**"} = OP::POW;
    $op_ids{"."} = OP::CONCAT; $op_ids{"x"} = OP::REPEAT;
    $op_ids{"=="} = OP::NUM_EQ; $op_ids{"!="} = OP::NUM_NE;
    $op_ids{"<"} = OP::NUM_LT; $op_ids{">"} = OP::NUM_GT;
    $op_ids{"<="} = OP::NUM_LE; $op_ids{">="} = OP::NUM_GE; $op_ids{"<=>"} = OP::SPACESHIP;
    $op_ids{"eq"} = OP::STR_EQ; $op_ids{"ne"} = OP::STR_NE;
    $op_ids{"lt"} = OP::STR_LT; $op_ids{"gt"} = OP::STR_GT;
    $op_ids{"le"} = OP::STR_LE; $op_ids{"ge"} = OP::STR_GE; $op_ids{"cmp"} = OP::CMP;
    $op_ids{"&&"} = OP::LOG_AND; $op_ids{"||"} = OP::LOG_OR; $op_ids{"//"} = OP::DEFOR;
    $op_ids{"and"} = OP::WORD_AND; $op_ids{"or"} = OP::WORD_OR;
    $op_ids{"&"} = OP::BIT_AND; $op_ids{"|"} = OP::BIT_OR; $op_ids{"^"} = OP::BIT_XOR;
    $op_ids{"<<"} = OP::SHL; $op_ids{">>"} = OP::SHR;
    $op_ids{"=~"} = OP::MATCH; $op_ids{"!~"} = OP::NOT_MATCH;
    $interp{"op_ids"} = \%op_ids;
    return \%interp;
}

# ============================================================
# Native Function Support (import_lib)
# ============================================================

# Call a native function, packing variadic args into an array if needed.
# For variadic native functions (is_variadic=1), the args from variadic_idx onward
# are packed into a single array argument, matching how the C code generator handles them.
func call_native(scalar $interp, scalar $nf, scalar $args) scalar {
    my int $is_variadic = $nf->{"is_variadic"};
    if ($is_variadic == 1) {
        # Pack args: fixed args stay, variadic args get packed into one array
        my int $param_count = $nf->{"param_count"};
        my int $variadic_idx = $param_count - 1;  # Last param is the variadic one
        my array @packed = ();
        my int $i = 0;

        # Copy fixed args before the variadic param
        while ($i < $variadic_idx && $i < size($args)) {
            push(@packed, $args->[$i]);
            $i = $i + 1;
        }

        # Pack remaining args into a single array for the variadic param
        my array @va_arr = ();
        while ($i < size($args)) {
            push(@va_arr, $args->[$i]);
            $i = $i + 1;
        }
        push(@packed, \@va_arr);

        return native_call($nf->{"fn_ptr"}, \@packed, size(\@packed), $nf->{"ret_is_void"});
    }

    return native_call($nf->{"fn_ptr"}, $args, size($args), $nf->{"ret_is_void"});
}

# Call a native function pointer with an array of StradaValue* arguments.
# $fn_ptr is an int (cast from void*), $args is an array of StradaValue*,
# $arg_count is the number of arguments, $ret_is_void is 1 if return type is void.
func native_call(scalar $fn_ptr, scalar $args, int $arg_count, int $ret_is_void) scalar {
    my scalar $result = undef;
    __C__ {
        typedef StradaValue* (*fn0_t)(void);
        typedef StradaValue* (*fn1_t)(StradaValue*);
        typedef StradaValue* (*fn2_t)(StradaValue*, StradaValue*);
        typedef StradaValue* (*fn3_t)(StradaValue*, StradaValue*, StradaValue*);
        typedef StradaValue* (*fn4_t)(StradaValue*, StradaValue*, StradaValue*, StradaValue*);
        typedef StradaValue* (*fn5_t)(StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*);
        typedef StradaValue* (*fn6_t)(StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*);
        typedef StradaValue* (*fn7_t)(StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*);
        typedef StradaValue* (*fn8_t)(StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*);
        typedef void (*vfn0_t)(void);
        typedef void (*vfn1_t)(StradaValue*);
        typedef void (*vfn2_t)(StradaValue*, StradaValue*);
        typedef void (*vfn3_t)(StradaValue*, StradaValue*, StradaValue*);
        typedef void (*vfn4_t)(StradaValue*, StradaValue*, StradaValue*, StradaValue*);
        typedef void (*vfn5_t)(StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*);
        typedef void (*vfn6_t)(StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*);
        typedef void (*vfn7_t)(StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*);
        typedef void (*vfn8_t)(StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*);

        void *fptr = (void*)(intptr_t)strada_to_int(fn_ptr);
        int64_t argc = strada_to_int(arg_count);
        int64_t is_void = strada_to_int(ret_is_void);
        /* Get the underlying array - args may be an array or array ref */
        StradaArray *av = NULL;
        if (args->type == STRADA_ARRAY) {
            av = args->value.av;
        } else if (args->type == STRADA_REF && args->value.rv && args->value.rv->type == STRADA_ARRAY) {
            av = args->value.rv->value.av;
        }

        /* Extract argument pointers */
        StradaValue *a[8] = {NULL};
        if (av) {
            for (int i = 0; i < argc && i < 8 && i < (int64_t)av->size; i++) {
                a[i] = av->elements[i];
            }
        }

        strada_decref(result);

        if (is_void) {
            switch (argc) {
                case 0: ((vfn0_t)fptr)(); break;
                case 1: ((vfn1_t)fptr)(a[0]); break;
                case 2: ((vfn2_t)fptr)(a[0], a[1]); break;
                case 3: ((vfn3_t)fptr)(a[0], a[1], a[2]); break;
                case 4: ((vfn4_t)fptr)(a[0], a[1], a[2], a[3]); break;
                case 5: ((vfn5_t)fptr)(a[0], a[1], a[2], a[3], a[4]); break;
                case 6: ((vfn6_t)fptr)(a[0], a[1], a[2], a[3], a[4], a[5]); break;
                case 7: ((vfn7_t)fptr)(a[0], a[1], a[2], a[3], a[4], a[5], a[6]); break;
                case 8: ((vfn8_t)fptr)(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7]); break;
                default:
                    fprintf(stderr, "native_call: too many arguments (%lld)\n", (long long)argc);
                    exit(1);
            }
            result = strada_new_undef();
        } else {
            switch (argc) {
                case 0: result = ((fn0_t)fptr)(); break;
                case 1: result = ((fn1_t)fptr)(a[0]); break;
                case 2: result = ((fn2_t)fptr)(a[0], a[1]); break;
                case 3: result = ((fn3_t)fptr)(a[0], a[1], a[2]); break;
                case 4: result = ((fn4_t)fptr)(a[0], a[1], a[2], a[3]); break;
                case 5: result = ((fn5_t)fptr)(a[0], a[1], a[2], a[3], a[4]); break;
                case 6: result = ((fn6_t)fptr)(a[0], a[1], a[2], a[3], a[4], a[5]); break;
                case 7: result = ((fn7_t)fptr)(a[0], a[1], a[2], a[3], a[4], a[5], a[6]); break;
                case 8: result = ((fn8_t)fptr)(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7]); break;
                default:
                    fprintf(stderr, "native_call: too many arguments (%lld)\n", (long long)argc);
                    exit(1);
            }
            if (!result) result = strada_new_undef();
        }
    }
    return $result;
}

# Load import_lib libraries: dlopen each .so, dlsym each function, register in native_funcs
func interp_load_import_libs(scalar $interp, scalar $program) void {
    my int $lib_count = $program->{"import_lib_count"};
    if ($lib_count == 0) { return; }

    my scalar $import_libs = $program->{"import_libs"};
    my int $li = 0;

    while ($li < $lib_count) {
        my scalar $lib_info = $import_libs->[$li];
        my str $so_path = $lib_info->{"so_path"};
        my str $lib_name = $lib_info->{"lib_name"};

        # dlopen the library
        my scalar $handle = strada_dl_open_raw($so_path);
        my int $handle_int = $handle;
        if ($handle_int == 0) {
            die("import_lib: failed to load shared library: " . $so_path);
        }

        # Keep handle alive so it doesn't get dlclose'd
        push($interp->{"native_lib_handles"}, $handle);

        # Call OOP init functions if present
        my scalar $oop_inits = $lib_info->{"oop_init_funcs"};
        if (defined($oop_inits)) {
            my int $oi = 0;
            my int $oop_count = size($oop_inits);
            while ($oi < $oop_count) {
                my str $oop_fn_name = $oop_inits->[$oi];
                my scalar $oop_fn = strada_dl_sym_raw($handle, $oop_fn_name);
                my int $oop_fn_int = $oop_fn;
                if ($oop_fn_int != 0) {
                    # Call void OOP init function
                    native_call($oop_fn, [], 0, 1);
                }
                $oi = $oi + 1;
            }
        }

        # dlsym each exported function
        my scalar $funcs = $lib_info->{"functions"};
        my int $fn_count = $lib_info->{"function_count"};
        my int $fi = 0;

        while ($fi < $fn_count) {
            my scalar $fn_info = $funcs->[$fi];
            my str $fn_name = $fn_info->{"name"};
            my int $param_count = $fn_info->{"param_count"};
            my int $ret_type = $fn_info->{"return_type"};

            my scalar $fn_ptr = strada_dl_sym_raw($handle, $fn_name);
            my int $fn_ptr_int = $fn_ptr;

            if ($fn_ptr_int == 0) {
                die("import_lib: symbol not found: " . $fn_name . " in " . $so_path);
            }

            # Register as native function
            my hash %nf = ();
            $nf{"fn_ptr"} = $fn_ptr;
            $nf{"param_count"} = $param_count;
            $nf{"ret_is_void"} = 0;
            if ($ret_type == TI::VOID) {
                $nf{"ret_is_void"} = 1;
            }
            $nf{"is_variadic"} = $fn_info->{"is_variadic"};
            $interp->{"native_funcs"}->{$fn_name} = \%nf;

            $fi = $fi + 1;
        }

        $li = $li + 1;
    }
}

func interp_register_func(scalar $interp, str $name, scalar $params, int $param_count, scalar $body, scalar $closure_env) void {
    my hash %fi = ();
    $fi{"params"} = $params;
    $fi{"param_count"} = $param_count;
    $fi{"body"} = $body;
    $fi{"closure_env"} = $closure_env;
    # Pre-compute variadic flag
    my int $is_variadic = 0;
    if ($param_count > 0) {
        my scalar $last_param = $params->[$param_count - 1];
        my str $ls = $last_param->{"sigil"};
        if ($ls eq "@" || $ls eq "...@") { $is_variadic = 1; }
    }
    $fi{"is_variadic"} = $is_variadic;
    $interp->{"functions"}->{$name} = \%fi;
    # Also register under sanitized name (:: -> _) for cross-lookup
    if (index($name, "::") >= 0) {
        my str $sanitized = sanitize_name($name);
        $interp->{"functions"}->{$sanitized} = \%fi;
    }
}

func interp_get_func(scalar $interp, str $name) scalar {
    if (exists($interp->{"functions"}, $name)) {
        return $interp->{"functions"}->{$name};
    }
    # Try sanitized name (:: -> _)
    if (index($name, "::") >= 0) {
        my str $sanitized = sanitize_name($name);
        if (exists($interp->{"functions"}, $sanitized)) {
            return $interp->{"functions"}->{$sanitized};
        }
    }
    return undef;
}

# ============================================================
# OOP Support
# ============================================================

# Resolve method on a class, walking inheritance chain
func interp_resolve_method(scalar $interp, str $pkg, str $method) scalar {
    my str $cache_key = $pkg . "::" . $method;
    if (exists($interp->{"method_cache"}, $cache_key)) {
        return $interp->{"method_cache"}->{$cache_key};
    }

    # Try pkg_method directly
    my scalar $fi = interp_get_func($interp, $pkg . "_" . $method);
    if (defined($fi)) {
        $interp->{"method_cache"}->{$cache_key} = $fi;
        return $fi;
    }

    # Walk inheritance chain (depth-first)
    if (exists($interp->{"inherits"}, $pkg)) {
        my scalar $parents = $interp->{"inherits"}->{$pkg};
        my int $pi = 0;
        while ($pi < size($parents)) {
            my scalar $found = interp_resolve_method($interp, $parents->[$pi], $method);
            if (defined($found)) {
                $interp->{"method_cache"}->{$cache_key} = $found;
                return $found;
            }
            $pi = $pi + 1;
        }
    }
    return undef;
}

# Check if an object isa given class (walks inheritance)
func interp_isa(scalar $interp, str $obj_class, str $target_class) int {
    if ($obj_class eq $target_class) { return 1; }
    if (exists($interp->{"inherits"}, $obj_class)) {
        my scalar $parents = $interp->{"inherits"}->{$obj_class};
        my int $pi = 0;
        while ($pi < size($parents)) {
            if (interp_isa($interp, $parents->[$pi], $target_class)) { return 1; }
            $pi = $pi + 1;
        }
    }
    return 0;
}

# Load OOP features from a parsed program (called from Main)
func interp_load_oop(scalar $interp, scalar $program) void {
    # Load inheritance
    my scalar $inherits = $program->{"inherits"};
    my int $inh_count = $program->{"inherit_count"};
    my int $i = 0;
    while ($i < $inh_count) {
        my scalar $entry = $inherits->[$i];
        my str $child = $entry->{"child"};
        my str $parent = $entry->{"parent"};
        if (!exists($interp->{"inherits"}, $child)) {
            my array @parents = ();
            $interp->{"inherits"}->{$child} = \@parents;
        }
        push($interp->{"inherits"}->{$child}, $parent);
        $i = $i + 1;
    }

    # Load overloads
    if ($program->{"has_overloads"} == 1) {
        my scalar $ovl = $program->{"overloads"};
        my scalar $ovl_keys = keys($ovl);
        my int $oi = 0;
        while ($oi < size($ovl_keys)) {
            my str $pkg = $ovl_keys->[$oi];
            $interp->{"overloads"}->{$pkg} = $ovl->{$pkg};
            $interp->{"has_overloads"} = 1;
            $oi = $oi + 1;
        }
    }

    # Load method modifiers
    my scalar $mods = $program->{"method_modifiers"};
    my int $mod_count = $program->{"method_modifier_count"};
    $i = 0;
    while ($i < $mod_count) {
        my scalar $mod = $mods->[$i];
        # Look up the modifier function by name (parser stores func_name, not func_node)
        my str $func_name = $mod->{"func_name"};
        my scalar $mod_fi = interp_get_func($interp, $func_name);
        if (defined($mod_fi)) {
            my hash %mod_entry = ();
            $mod_entry{"mod_type"} = $mod->{"mod_type"};
            $mod_entry{"method_name"} = $mod->{"method_name"};
            $mod_entry{"package"} = $mod->{"package"};
            $mod_entry{"func_info"} = $mod_fi;
            push($interp->{"method_modifiers"}, \%mod_entry);
        }
        $i = $i + 1;
    }

    # Detect AUTOLOAD functions
    my scalar $func_keys = keys($interp->{"functions"});
    my int $fki = 0;
    while ($fki < size($func_keys)) {
        my str $fname = $func_keys->[$fki];
        if (match($fname, "_AUTOLOAD$")) {
            my str $pkg = substr($fname, 0, length($fname) - 9);
            $interp->{"autoloads"}->{$pkg} = $interp->{"functions"}->{$fname};
        }
        $fki = $fki + 1;
    }
}

# Execute END blocks (LIFO order)
func interp_run_end_blocks(scalar $interp) void {
    my scalar $blocks = $interp->{"end_blocks"};
    my int $count = size($blocks);
    my int $i = $count - 1;
    while ($i >= 0) {
        try {
            eval_block($interp, $blocks->[$i], $interp->{"global_env"});
        } catch ($e) {
            if (is_signal($e, "return")) {
                # Ignore returns from END blocks
            } else {
                say("Error in END block: " . $e);
            }
        }
        $i = $i - 1;
    }
}

# ============================================================
# Control Flow Signals
# ============================================================

func make_signal(str $sig_type, scalar $value, str $label) scalar {
    my hash %sig = ();
    $sig{"__interp_sig__"} = 1;
    $sig{"sig_type"} = $sig_type;
    $sig{"value"} = $value;
    $sig{"label"} = $label;
    return \%sig;
}

func is_signal(scalar $e, str $sig_type) int {
    if (!defined($e)) { return 0; }
    if (ref($e) ne "HASH") { return 0; }
    if (!exists($e, "__interp_sig__")) { return 0; }
    if ($e->{"sig_type"} ne $sig_type) { return 0; }
    return 1;
}

func is_loop_signal(scalar $e, str $sig_type, str $loop_label) int {
    if (!is_signal($e, $sig_type)) { return 0; }
    my str $sig_label = $e->{"label"};
    # Match if signal has no label, or labels match
    if (length($sig_label) == 0) { return 1; }
    if (length($loop_label) > 0 && $sig_label eq $loop_label) { return 1; }
    return 0;
}

# ============================================================
# Load Program AST
# ============================================================

func interp_load_program(scalar $interp, scalar $program) void {
    # Execute BEGIN blocks first
    my scalar $begin_blocks = $program->{"begin_blocks"};
    my int $begin_count = $program->{"begin_block_count"};
    my int $bi = 0;
    while ($bi < $begin_count) {
        try {
            eval_block($interp, $begin_blocks->[$bi], $interp->{"global_env"});
        } catch ($e) {
            if (is_signal($e, "return")) {
                # Ignore returns from BEGIN blocks
            } else {
                throw($e);
            }
        }
        $bi = $bi + 1;
    }

    # Store END blocks for later execution
    my scalar $end_blocks = $program->{"end_blocks"};
    my int $end_count = $program->{"end_block_count"};
    my int $ei = 0;
    while ($ei < $end_count) {
        push($interp->{"end_blocks"}, $end_blocks->[$ei]);
        $ei = $ei + 1;
    }

    # Register enums first (they may be referenced in globals/functions)
    my scalar $enums = $program->{"enums"};
    my int $enum_count = $program->{"enum_count"};
    my int $i = 0;
    while ($i < $enum_count) {
        my scalar $en = $enums->[$i];
        my str $enum_name = $en->{"name"};
        my scalar $members = $en->{"members"};
        my int $member_count = $en->{"member_count"};
        my int $j = 0;
        while ($j < $member_count) {
            my scalar $member = $members->[$j];
            my str $key = $enum_name . "::" . $member->{"name"};
            $interp->{"enums"}->{$key} = $member->{"value"};
            $j = $j + 1;
        }
        $i = $i + 1;
    }

    # Register all functions
    my scalar $funcs = $program->{"functions"};
    my int $func_count = $program->{"function_count"};
    $i = 0;
    while ($i < $func_count) {
        my scalar $fn = $funcs->[$i];
        my str $name = $fn->{"name"};
        interp_register_func($interp, $name, $fn->{"params"}, $fn->{"param_count"}, $fn->{"body"}, $interp->{"global_env"});
        $i = $i + 1;
    }

    # Register globals (constants, our, my at top level)
    my scalar $globals = $program->{"globals"};
    my int $global_count = $program->{"global_count"};
    $i = 0;
    while ($i < $global_count) {
        my scalar $g = $globals->[$i];
        my int $gtype = $g->{"type"};
        if ($gtype == NI::CONST_DECL) {
            my str $cname = $g->{"name"};
            my scalar $init_val = eval_node($interp, $g->{"init"}, $interp->{"global_env"});
            $interp->{"constants"}->{$cname} = $init_val;
            env_set($interp->{"global_env"}, $cname, $init_val);
        } elsif ($gtype == NI::VAR_DECL || $gtype == NI::OUR_DECL) {
            eval_node($interp, $g, $interp->{"global_env"});
        }
        $i = $i + 1;
    }

    # Load OOP features (inherits, overloads, method modifiers)
    interp_load_oop($interp, $program);

    # Load import_lib native functions
    interp_load_import_libs($interp, $program);
}

# Run the main() function
func interp_run_main(scalar $interp, scalar $argv) int {
    my scalar $func_info = interp_get_func($interp, "main");
    # If main not found at top level, look for pkg_main (e.g., Math_Utils_main)
    if (!defined($func_info)) {
        my scalar $func_keys = keys($interp->{"functions"});
        my int $fki = 0;
        while ($fki < size($func_keys)) {
            my str $fname = $func_keys->[$fki];
            if (match($fname, "_main$") || $fname eq "main") {
                $func_info = $interp->{"functions"}->{$fname};
                last;
            }
            $fki = $fki + 1;
        }
    }
    if (!defined($func_info)) {
        die("Error: no main() function defined");
    }
    # Set @ARGV in global env
    env_set($interp->{"global_env"}, "ARGV", $argv);
    my array @args = ();
    $interp->{"had_explicit_return"} = 0;
    my scalar $result = call_user_func($interp, $func_info, \@args);
    # Only use the result if there was an explicit return statement
    if ($interp->{"had_explicit_return"} == 1 && defined($result)) {
        my int $exit_code = $result;
        return $exit_code;
    }
    return 0;
}

# ============================================================
# Assignment Target
# ============================================================

func assign_to(scalar $interp, scalar $target, scalar $value, scalar $env) void {
    my int $ttype = $target->{"type"};

    if ($ttype == NI::VARIABLE) {
        my str $name = $target->{"name"};
        if (!env_update($env, $name, $value)) {
            env_set($env, $name, $value);
        }
        return;
    }

    if ($ttype == NI::SUBSCRIPT) {
        my scalar $arr = eval_node($interp, $target->{"array"}, $env);
        my int $idx = eval_node($interp, $target->{"index"}, $env);
        $arr->[$idx] = $value;
        return;
    }

    if ($ttype == NI::HASH_ACCESS) {
        my scalar $hash_val = eval_node($interp, $target->{"hash"}, $env);
        my str $key = eval_node($interp, $target->{"key"}, $env);
        # Check for tied hash STORE
        if (ref($hash_val) eq "HASH" && exists($hash_val, "__tied__")) {
            my scalar $tie_obj = $hash_val->{"__tied__"};
            my str $tie_pkg = $tie_obj->{"__class__"};
            if (length($tie_pkg) > 0) {
                my scalar $store_fn = interp_resolve_method($interp, $tie_pkg, "STORE");
                if (defined($store_fn)) {
                    my array @store_args = ();
                    push(@store_args, $tie_obj);
                    push(@store_args, $key);
                    push(@store_args, $value);
                    call_user_func($interp, $store_fn, \@store_args);
                    return;
                }
            }
        }
        $hash_val->{$key} = $value;
        return;
    }

    if ($ttype == NI::DEREF_HASH) {
        my scalar $ref_val = eval_node($interp, $target->{"ref"}, $env);
        my str $key = eval_node($interp, $target->{"key"}, $env);
        $ref_val->{$key} = $value;
        return;
    }

    if ($ttype == NI::DEREF_ARRAY) {
        my scalar $ref_val = eval_node($interp, $target->{"ref"}, $env);
        my int $idx = eval_node($interp, $target->{"index"}, $env);
        $ref_val->[$idx] = $value;
        return;
    }

    if ($ttype == NI::DEREF_SCALAR) {
        # $$ref = value - in our interpreter model, update the variable the ref points to
        my scalar $ref_node = $target->{"ref"};
        if ($ref_node->{"type"} == NI::VARIABLE) {
            my str $vname = $ref_node->{"name"};
            env_update($env, $vname, $value);
        }
        return;
    }

    die("Cannot assign to node type: " . ast_type_name($ttype));
}

# ============================================================
# Block Evaluation
# ============================================================

func eval_block(scalar $interp, scalar $block, scalar $env) scalar {
    my scalar $stmts = $block->{"statements"};
    my int $count = $block->{"statement_count"};
    my scalar $result = undef;

    # Check if block contains labels (only then do we need goto try/catch)
    my int $has_labels = 0;
    my int $lci = 0;
    while ($lci < $count) {
        if ($stmts->[$lci]->{"type"} == NI::LABEL) {
            $has_labels = 1;
            last;
        }
        $lci = $lci + 1;
    }

    my int $ebi = 0;
    if ($has_labels) {
        # Slow path: wrap each statement in try/catch for goto support
        while ($ebi < $count) {
            try {
                $result = eval_node($interp, $stmts->[$ebi], $env);
            } catch ($eb_exc) {
                if (is_signal($eb_exc, "goto")) {
                    my str $eb_gl = $eb_exc->{"label"};
                    my int $eb_gf = 0;
                    my int $eb_gk = 0;
                    while ($eb_gk < $count) {
                        if ($stmts->[$eb_gk]->{"type"} == NI::LABEL && $stmts->[$eb_gk]->{"name"} eq $eb_gl) {
                            $ebi = $eb_gk + 1;
                            $eb_gf = 1;
                            last;
                        }
                        $eb_gk = $eb_gk + 1;
                    }
                    if ($eb_gf == 1) {
                        next;
                    }
                }
                throw($eb_exc);
            }
            # Check for signals (return, last, next, redo)
            if ($interp->{"signal"} != SIG::NONE) {
                return $result;
            }
            $ebi = $ebi + 1;
        }
    } else {
        # Fast path: no goto labels, direct eval without try/catch overhead
        while ($ebi < $count) {
            $result = eval_node($interp, $stmts->[$ebi], $env);
            # Check for signals (return, last, next, redo)
            if ($interp->{"signal"} != SIG::NONE) {
                return $result;
            }
            $ebi = $ebi + 1;
        }
    }
    return $result;
}

# Evaluate statements in an existing env (no new scope)
func eval_stmts_in_env(scalar $interp, scalar $stmts, int $count, scalar $env) scalar {
    my scalar $result = undef;
    my int $i = 0;
    while ($i < $count) {
        $result = eval_node($interp, $stmts->[$i], $env);
        $i = $i + 1;
    }
    return $result;
}

# ============================================================
# Binary Operations
# ============================================================

func get_obj_class(scalar $obj) str {
    if (ref($obj) eq "HASH" && exists($obj, "__class__")) {
        return $obj->{"__class__"};
    }
    return "";
}

func check_overload(scalar $interp, scalar $val, str $op) scalar {
    my str $pkg = get_obj_class($val);
    if (length($pkg) == 0) { return undef; }
    if (!exists($interp->{"overloads"}, $pkg)) { return undef; }
    my scalar $pkg_ovl = $interp->{"overloads"}->{$pkg};
    if (!exists($pkg_ovl, $op)) { return undef; }
    my str $method_name = $pkg_ovl->{$op};
    return interp_resolve_method($interp, $pkg, $method_name);
}

func eval_binop(scalar $interp, scalar $node, scalar $env) scalar {
    my str $op = $node->{"op"};
    my int $oid = $interp->{"op_ids"}->{$op};

    # Short-circuit operators (must check before evaluating both sides)
    if ($oid == OP::LOG_AND || $oid == OP::WORD_AND) {
        my scalar $left = eval_node($interp, $node->{"left"}, $env);
        if (!$left) { return $left; }
        return eval_node($interp, $node->{"right"}, $env);
    }
    if ($oid == OP::LOG_OR || $oid == OP::WORD_OR) {
        my scalar $left = eval_node($interp, $node->{"left"}, $env);
        if ($left) { return $left; }
        return eval_node($interp, $node->{"right"}, $env);
    }
    if ($oid == OP::DEFOR) {
        my scalar $left = eval_node($interp, $node->{"left"}, $env);
        if (defined($left)) { return $left; }
        return eval_node($interp, $node->{"right"}, $env);
    }

    # Evaluate both sides
    my scalar $left = eval_node($interp, $node->{"left"}, $env);
    my scalar $right = eval_node($interp, $node->{"right"}, $env);

    # Check for operator overloading (skip entirely when no overloads registered)
    if ($interp->{"has_overloads"} == 1) {
        my scalar $ovl_func = check_overload($interp, $left, $op);
        if (defined($ovl_func)) {
            my array @ovl_args = ();
            push(@ovl_args, $left);
            push(@ovl_args, $right);
            push(@ovl_args, 0);
            return call_user_func($interp, $ovl_func, \@ovl_args);
        }
        my scalar $ovl_func_r = check_overload($interp, $right, $op);
        if (defined($ovl_func_r)) {
            my array @ovl_args = ();
            push(@ovl_args, $right);
            push(@ovl_args, $left);
            push(@ovl_args, 1);
            return call_user_func($interp, $ovl_func_r, \@ovl_args);
        }
    }

    # Arithmetic
    if ($oid == OP::ADD) { return $left + $right; }
    if ($oid == OP::SUB) { return $left - $right; }
    if ($oid == OP::MUL) { return $left * $right; }
    if ($oid == OP::DIV) { return $left / $right; }
    if ($oid == OP::MOD) { return $left % $right; }
    if ($oid == OP::POW) {
        return math::pow($left, $right);
    }

    # String
    if ($oid == OP::CONCAT) {
        # Check for stringify overload on left/right
        if ($interp->{"has_overloads"} == 1) {
            my scalar $l_str_ovl = check_overload($interp, $left, "\"\"");
            my scalar $r_str_ovl = check_overload($interp, $right, "\"\"");
            my scalar $concat_left = $left;
            my scalar $concat_right = $right;
            if (defined($l_str_ovl)) {
                my array @sa = ();
                push(@sa, $left);
                $concat_left = call_user_func($interp, $l_str_ovl, \@sa);
            }
            if (defined($r_str_ovl)) {
                my array @sa = ();
                push(@sa, $right);
                $concat_right = call_user_func($interp, $r_str_ovl, \@sa);
            }
            return $concat_left . $concat_right;
        }
        return $left . $right;
    }
    if ($oid == OP::REPEAT) {
        my str $s = $left;
        my int $n = $right;
        my str $result = "";
        my int $xi = 0;
        while ($xi < $n) {
            $result = $result . $s;
            $xi = $xi + 1;
        }
        return $result;
    }

    # Numeric comparison
    if ($oid == OP::NUM_EQ) { return ($left == $right) ? 1 : 0; }
    if ($oid == OP::NUM_NE) { return ($left != $right) ? 1 : 0; }
    if ($oid == OP::NUM_LT) { return ($left < $right) ? 1 : 0; }
    if ($oid == OP::NUM_GT) { return ($left > $right) ? 1 : 0; }
    if ($oid == OP::NUM_LE) { return ($left <= $right) ? 1 : 0; }
    if ($oid == OP::NUM_GE) { return ($left >= $right) ? 1 : 0; }
    if ($oid == OP::SPACESHIP) {
        if ($left < $right) { return -1; }
        if ($left > $right) { return 1; }
        return 0;
    }

    # String comparison
    if ($oid == OP::STR_EQ) { return ($left eq $right) ? 1 : 0; }
    if ($oid == OP::STR_NE) { return ($left ne $right) ? 1 : 0; }
    if ($oid == OP::STR_LT) { return ($left lt $right) ? 1 : 0; }
    if ($oid == OP::STR_GT) { return ($left gt $right) ? 1 : 0; }
    if ($oid == OP::STR_LE) { return ($left le $right) ? 1 : 0; }
    if ($oid == OP::STR_GE) { return ($left ge $right) ? 1 : 0; }
    if ($oid == OP::CMP) {
        if ($left lt $right) { return -1; }
        if ($left gt $right) { return 1; }
        return 0;
    }

    # Bitwise operators
    if ($oid == OP::BIT_AND) {
        my int $li = $left;
        my int $ri = $right;
        my int $result = 0;
        __C__ {
            int64_t lv = strada_to_int(li);
            int64_t rv = strada_to_int(ri);
            strada_decref(result);
            result = strada_new_int(lv & rv);
        }
        return $result;
    }
    if ($oid == OP::BIT_OR) {
        my int $li = $left;
        my int $ri = $right;
        my int $result = 0;
        __C__ {
            int64_t lv = strada_to_int(li);
            int64_t rv = strada_to_int(ri);
            strada_decref(result);
            result = strada_new_int(lv | rv);
        }
        return $result;
    }
    if ($oid == OP::BIT_XOR) {
        my int $li = $left;
        my int $ri = $right;
        my int $result = 0;
        __C__ {
            int64_t lv = strada_to_int(li);
            int64_t rv = strada_to_int(ri);
            strada_decref(result);
            result = strada_new_int(lv ^ rv);
        }
        return $result;
    }
    if ($oid == OP::SHL) {
        my int $li = $left;
        my int $ri = $right;
        my int $result = 0;
        __C__ {
            int64_t lv = strada_to_int(li);
            int64_t rv = strada_to_int(ri);
            strada_decref(result);
            result = strada_new_int(lv << rv);
        }
        return $result;
    }
    if ($oid == OP::SHR) {
        my int $li = $left;
        my int $ri = $right;
        my int $result = 0;
        __C__ {
            int64_t lv = strada_to_int(li);
            int64_t rv = strada_to_int(ri);
            strada_decref(result);
            result = strada_new_int(lv >> rv);
        }
        return $result;
    }

    # Regex match as binary operator (=~ with string pattern)
    if ($oid == OP::MATCH) {
        my str $text = $left;
        my str $pattern = $right;
        return match($text, $pattern) ? 1 : 0;
    }
    if ($oid == OP::NOT_MATCH) {
        my str $text = $left;
        my str $pattern = $right;
        return (!match($text, $pattern)) ? 1 : 0;
    }

    die("Unknown binary operator: " . $op);
}

# ============================================================
# Built-in Function Detection and Dispatch
# ============================================================

func is_builtin(scalar $interp, str $name) int {
    if (exists($interp->{"builtin_ids"}, $name)) { return 1; }
    # Fallback: prefix matching for any unregistered namespace functions
    if (index($name, "sys::") == 0 || index($name, "core::") == 0) { return 1; }
    if (index($name, "math::") == 0) { return 1; }
    if (index($name, "utf8::") == 0) { return 1; }
    if (index($name, "DateTime::") == 0) { return 1; }
    return 0;
}

func call_builtin(scalar $interp, str $name, scalar $args, scalar $env) scalar {
    my int $argc = size($args);
    my int $bid = $interp->{"builtin_ids"}->{$name};

    # ---- I/O ----
    if ($bid == BI::SAY) {
        if ($argc == 0) {
            my scalar $sfh0 = $interp->{"select_fh"};
            if (defined($sfh0)) { say($sfh0, ""); }
            else { say(""); }
        } elsif ($argc == 1) {
            my scalar $v = $args->[0];
            # Check for stringify overload
            my scalar $str_ovl = check_overload($interp, $v, "\"\"");
            if (defined($str_ovl)) {
                my array @sargs = ();
                push(@sargs, $v);
                $v = call_user_func($interp, $str_ovl, \@sargs);
            }
            my scalar $sfh = $interp->{"select_fh"};
            if (defined($sfh)) { say($sfh, $v); }
            else { say($v); }
        } elsif ($argc == 2) {
            my scalar $v = $args->[1];
            my scalar $str_ovl = check_overload($interp, $v, "\"\"");
            if (defined($str_ovl)) {
                my array @sargs = ();
                push(@sargs, $v);
                $v = call_user_func($interp, $str_ovl, \@sargs);
            }
            say($args->[0], $v);
        }
        return undef;
    }
    if ($bid == BI::PRINT) {
        if ($argc == 0) {
            return undef;
        } elsif ($argc == 1) {
            my scalar $v = $args->[0];
            my scalar $str_ovl = check_overload($interp, $v, "\"\"");
            if (defined($str_ovl)) {
                my array @sargs = ();
                push(@sargs, $v);
                $v = call_user_func($interp, $str_ovl, \@sargs);
            }
            my scalar $sfh = $interp->{"select_fh"};
            if (defined($sfh)) { print($sfh, $v); }
            else { print($v); }
        } elsif ($argc == 2) {
            my scalar $v = $args->[1];
            my scalar $str_ovl = check_overload($interp, $v, "\"\"");
            if (defined($str_ovl)) {
                my array @sargs = ();
                push(@sargs, $v);
                $v = call_user_func($interp, $str_ovl, \@sargs);
            }
            print($args->[0], $v);
        }
        return undef;
    }
    if ($bid == BI::DUMPER) {
        if ($argc >= 1) {
            dumper($args->[0]);
        }
        return undef;
    }

    # ---- Array operations ----
    if ($bid == BI::PUSH) {
        my scalar $arr = $args->[0];
        my int $ai = 1;
        while ($ai < $argc) {
            push($arr, $args->[$ai]);
            $ai = $ai + 1;
        }
        return undef;
    }
    if ($bid == BI::POP) {
        return pop($args->[0]);
    }
    if ($bid == BI::SHIFT) {
        return shift($args->[0]);
    }
    if ($bid == BI::UNSHIFT) {
        unshift($args->[0], $args->[1]);
        return undef;
    }
    if ($bid == BI::SPLICE) {
        my scalar $sp_a = $args->[0];
        my int $sp_o = $args->[1];
        my int $sp_l = 0;
        if ($argc >= 3) {
            $sp_l = $args->[2];
        } else {
            # No length: splice from offset to end
            $sp_l = size($sp_a) - $sp_o;
        }
        my array @sp_r = ();
        my int $sp_i = 0;
        while ($sp_i < $sp_l && ($sp_o + $sp_i) < size($sp_a)) {
            push(@sp_r, $sp_a->[$sp_o + $sp_i]);
            $sp_i = $sp_i + 1;
        }
        if ($argc >= 4) {
            splice($sp_a, $sp_o, $sp_l, $args->[3]);
        } else {
            splice($sp_a, $sp_o, $sp_l);
        }
        return \@sp_r;
    }
    if ($bid == BI::REVERSE) {
        reverse($args->[0]);
        return undef;
    }
    if ($bid == BI::SIZE || $bid == BI::SCALAR_FN) {
        return size($args->[0]);
    }

    # ---- String operations ----
    if ($bid == BI::LENGTH) {
        return length($args->[0]);
    }
    if ($bid == BI::BYTES) {
        return bytes($args->[0]);
    }
    if ($bid == BI::SUBSTR) {
        if ($argc == 2) {
            return substr($args->[0], $args->[1], length($args->[0]) - $args->[1]);
        }
        return substr($args->[0], $args->[1], $args->[2]);
    }
    if ($bid == BI::INDEX_FN) {
        if ($argc == 2) {
            return index($args->[0], $args->[1]);
        }
        return index($args->[0], $args->[1], $args->[2]);
    }
    if ($bid == BI::RINDEX) {
        return rindex($args->[0], $args->[1]);
    }
    if ($bid == BI::JOIN) {
        return join($args->[0], $args->[1]);
    }
    if ($bid == BI::SPLIT) {
        return split($args->[0], $args->[1]);
    }
    if ($bid == BI::CHOMP) {
        return chomp($args->[0]);
    }
    if ($bid == BI::CHOP) {
        return chop($args->[0]);
    }
    if ($bid == BI::CHR) {
        return chr($args->[0]);
    }
    if ($bid == BI::ORD) {
        return ord($args->[0]);
    }
    if ($bid == BI::CHAR_AT) {
        return chr(char_at($args->[0], $args->[1]));
    }
    if ($bid == BI::UC) {
        return uc($args->[0]);
    }
    if ($bid == BI::LC) {
        return lc($args->[0]);
    }
    if ($bid == BI::SPRINTF_FN) {
        if ($argc == 1) { return sprintf($args->[0]); }
        if ($argc == 2) { return sprintf($args->[0], $args->[1]); }
        if ($argc == 3) { return sprintf($args->[0], $args->[1], $args->[2]); }
        if ($argc == 4) { return sprintf($args->[0], $args->[1], $args->[2], $args->[3]); }
        if ($argc == 5) { return sprintf($args->[0], $args->[1], $args->[2], $args->[3], $args->[4]); }
        if ($argc == 6) { return sprintf($args->[0], $args->[1], $args->[2], $args->[3], $args->[4], $args->[5]); }
        if ($argc == 7) { return sprintf($args->[0], $args->[1], $args->[2], $args->[3], $args->[4], $args->[5], $args->[6]); }
        if ($argc == 8) { return sprintf($args->[0], $args->[1], $args->[2], $args->[3], $args->[4], $args->[5], $args->[6], $args->[7]); }
        return sprintf($args->[0], $args->[1]);
    }
    if ($bid == BI::MATCH_FN) {
        return match($args->[0], $args->[1]);
    }
    if ($bid == BI::REPLACE) {
        if ($argc == 3) {
            return replace($args->[0], $args->[1], $args->[2]);
        }
        return replace($args->[0], $args->[1], $args->[2], $args->[3]);
    }
    if ($bid == BI::REPLACE_ALL) {
        my str $ra_str = $args->[0];
        my str $ra_pat = $args->[1];
        my str $ra_rep = $args->[2];
        my str $ra_result = "";
        __C__ {
            char *s = strada_to_str(ra_str);
            char *p = strada_to_str(ra_pat);
            char *r = strada_to_str(ra_rep);
            char *res = strada_regex_replace_all(s, p, r, NULL);
            strada_decref(ra_result);
            ra_result = strada_new_str(res);
            free(res);
            free(r);
            free(p);
            free(s);
        }
        return $ra_result;
    }
    if ($bid == BI::UPPER) {
        return uc($args->[0]);
    }
    if ($bid == BI::LOWER) {
        return lc($args->[0]);
    }
    if ($bid == BI::UCFIRST) {
        my str $s = $args->[0];
        if (length($s) == 0) { return ""; }
        return uc(substr($s, 0, 1)) . substr($s, 1, length($s) - 1);
    }
    if ($bid == BI::LCFIRST) {
        my str $s = $args->[0];
        if (length($s) == 0) { return ""; }
        return lc(substr($s, 0, 1)) . substr($s, 1, length($s) - 1);
    }
    if ($bid == BI::TRIM) {
        my str $s = $args->[0];
        $s =~ s/^\s+//;
        $s =~ s/\s+$//;
        return $s;
    }
    if ($bid == BI::LTRIM) {
        my str $s = $args->[0];
        $s =~ s/^\s+//;
        return $s;
    }
    if ($bid == BI::RTRIM) {
        my str $s = $args->[0];
        $s =~ s/\s+$//;
        return $s;
    }
    if ($bid == BI::REPEAT) {
        my str $s = $args->[0];
        my int $n = $args->[1];
        my str $result = "";
        my int $ri = 0;
        while ($ri < $n) {
            $result = $result . $s;
            $ri = $ri + 1;
        }
        return $result;
    }
    if ($bid == BI::TYPEOF) {
        my scalar $v = $args->[0];
        if (!defined($v)) { return "undef"; }
        my str $r = ref($v);
        if ($r eq "ARRAY") { return "array"; }
        if ($r eq "HASH") { return "hash"; }
        if (length($r) > 0) { return "ref"; }
        return "scalar";
    }
    if ($bid == BI::CAST_INT) {
        my int $v = $args->[0];
        return $v;
    }
    if ($bid == BI::CAST_NUM) {
        my num $v = $args->[0];
        return $v;
    }
    if ($bid == BI::CAST_STR) {
        my str $v = "" . $args->[0];
        return $v;
    }

    # ---- Hash operations ----
    if ($bid == BI::KEYS) {
        return keys($args->[0]);
    }
    if ($bid == BI::VALUES_FN) {
        return values($args->[0]);
    }
    if ($bid == BI::EXISTS_FN) {
        return exists($args->[0], $args->[1]);
    }
    if ($bid == BI::DELETE_FN) {
        delete($args->[0], $args->[1]);
        return undef;
    }
    if ($bid == BI::EACH) {
        return each($args->[0]);
    }

    # ---- Type functions ----
    if ($bid == BI::DEFINED) {
        return defined($args->[0]) ? 1 : 0;
    }
    if ($bid == BI::REF_FN) {
        return ref($args->[0]);
    }
    if ($bid == BI::INT_FN) {
        # Truncate to integer: use arithmetic to force int conversion
        my scalar $v = $args->[0];
        my int $iv = $v;
        return $iv;
    }

    # ---- Misc ----
    if ($bid == BI::DIE) {
        if ($argc >= 1) {
            die($args->[0]);
        }
        die("Died");
    }
    if ($bid == BI::SLURP || $bid == BI::SYS_SLURP) {
        return slurp($args->[0]);
    }
    if ($bid == BI::SPEW || $bid == BI::SYS_SPEW) {
        spew($args->[0], $args->[1]);
        return undef;
    }
    if ($bid == BI::ABS) {
        my scalar $v = $args->[0];
        if ($v < 0) { return 0 - $v; }
        return $v;
    }
    if ($bid == BI::NSORT) {
        my scalar $arr = $args->[0];
        my int $arr_len = size($arr);
        my array @sorted = ();
        my int $si = 0;
        while ($si < $arr_len) {
            push(@sorted, $arr->[$si]);
            $si = $si + 1;
        }
        # Insertion sort by numeric value
        my int $oi = 1;
        while ($oi < $arr_len) {
            my scalar $key_val = $sorted[$oi];
            my int $oj = $oi - 1;
            while ($oj >= 0 && $sorted[$oj] > $key_val) {
                $sorted[$oj + 1] = $sorted[$oj];
                $oj = $oj - 1;
            }
            $sorted[$oj + 1] = $key_val;
            $oi = $oi + 1;
        }
        return \@sorted;
    }
    if ($bid == BI::DUMPER_STR) {
        # Return string representation using dumper
        my scalar $v = $args->[0];
        if (!defined($v)) { return "undef"; }
        return "" . $v;
    }
    if ($bid == BI::STRADA_NEW_UNDEF) {
        return undef;
    }

    # ---- Ref/memory functions ----
    if ($bid == BI::REFTO) {
        my scalar $rv = $args->[0];
        my str $rvt = ref($rv);
        if ($rvt eq "HASH" || $rvt eq "ARRAY") {
            return $rv;
        }
        # Wrap scalar in a ref-like hash
        my hash %wrapper = ();
        $wrapper{"__scalar_ref__"} = 1;
        $wrapper{"value"} = $rv;
        return \%wrapper;
    }
    if ($bid == BI::REFCOUNT) {
        my scalar $v = $args->[0];
        my int $rc = 0;
        __C__ {
            if (v && v->type != STRADA_UNDEF) {
                strada_decref(rc);
                rc = strada_new_int((int64_t)v->refcount);
            } else {
                strada_decref(rc);
                rc = strada_new_int(0);
            }
        }
        return $rc;
    }
    if ($bid == BI::IS_REFTO) {
        my scalar $rv = $args->[0];
        if (ref($rv) eq "HASH" && exists($rv, "__scalar_ref__")) { return 1; }
        return (ref($rv) ne "" && ref($rv) ne "0") ? 1 : 0;
    }
    if ($bid == BI::REFTYPE) {
        my scalar $rv = $args->[0];
        if (ref($rv) eq "HASH" && exists($rv, "__scalar_ref__")) { return "SCALAR"; }
        return ref($rv);
    }
    if ($bid == BI::DEREF) {
        my scalar $rv = $args->[0];
        if (ref($rv) eq "HASH" && exists($rv, "__scalar_ref__")) { return $rv->{"value"}; }
        return $rv;
    }
    if ($bid == BI::DEREFTO) {
        my scalar $rv = $args->[0];
        if (ref($rv) eq "HASH" && exists($rv, "__scalar_ref__")) { return $rv->{"value"}; }
        return $rv;
    }
    if ($bid == BI::BLESSED) {
        my scalar $v = $args->[0];
        if (ref($v) eq "HASH" && exists($v, "__class__")) {
            return $v->{"__class__"};
        }
        my str $rt = ref($v);
        if ($rt ne "HASH" && $rt ne "ARRAY" && $rt ne "" && $rt ne "0") {
            return $rt;
        }
        return undef;
    }

    # ---- OOP helper functions ----
    if ($bid == BI::SET_PACKAGE) {
        if ($argc == 1) {
            # set_package("ClassName") - set current package context
            my str $pkg_name = $args->[0];
            $interp->{"package"} = $pkg_name;
            return undef;
        }
        my scalar $hash_ref = $args->[0];
        my str $pkg_name = $args->[1];
        if (ref($hash_ref) eq "HASH") {
            $hash_ref->{"__class__"} = $pkg_name;
        }
        return $hash_ref;
    }
    if ($bid == BI::INHERIT_FN) {
        my str $child_pkg = "";
        my str $parent_pkg = "";
        if ($argc >= 2) {
            $child_pkg = $args->[0];
            $parent_pkg = $args->[1];
        } else {
            # Single arg: inherit("Parent") - child is current package
            $child_pkg = $interp->{"package"};
            $parent_pkg = $args->[0];
        }
        if (!exists($interp->{"inherits"}, $child_pkg)) {
            my array @parents = ();
            $interp->{"inherits"}->{$child_pkg} = \@parents;
        }
        push($interp->{"inherits"}->{$child_pkg}, $parent_pkg);
        return undef;
    }
    if ($bid == BI::HASH_NEW) {
        my hash %h = ();
        return \%h;
    }
    if ($bid == BI::UNIVERSAL_ISA) {
        my scalar $obj = $args->[0];
        my str $target = $args->[1];
        my str $pkg = get_obj_class($obj);
        if (length($pkg) == 0) {
            my str $rt = ref($obj);
            if ($rt ne "HASH" && $rt ne "ARRAY" && $rt ne "" && $rt ne "0") {
                $pkg = $rt;
            }
        }
        if (length($pkg) > 0) {
            return interp_isa($interp, $pkg, $target) ? 1 : 0;
        }
        return 0;
    }
    if ($bid == BI::UNIVERSAL_CAN) {
        my scalar $obj = $args->[0];
        my str $method_name = $args->[1];
        my str $pkg = get_obj_class($obj);
        if (length($pkg) == 0) {
            my str $rt = ref($obj);
            if ($rt ne "HASH" && $rt ne "ARRAY" && $rt ne "" && $rt ne "0") {
                $pkg = $rt;
            }
        }
        if (length($pkg) > 0) {
            my scalar $fi = interp_resolve_method($interp, $pkg, $method_name);
            return defined($fi) ? 1 : 0;
        }
        return 0;
    }

    # ---- Additional bare builtins ----
    if ($bid == BI::ISA) {
        my scalar $obj = $args->[0];
        my str $target = $args->[1];
        my str $pkg = get_obj_class($obj);
        if (length($pkg) == 0) {
            my str $rt = ref($obj);
            if ($rt ne "HASH" && $rt ne "ARRAY" && $rt ne "" && $rt ne "0") {
                $pkg = $rt;
            }
        }
        if (length($pkg) > 0) {
            return interp_isa($interp, $pkg, $target) ? 1 : 0;
        }
        return 0;
    }
    if ($bid == BI::CAPTURE) {
        if ($argc >= 1) {
            my int $idx = $args->[0];
            return captures()[$idx];
        }
        return captures();
    }
    if ($bid == BI::HASH_SET) {
        my scalar $h = $args->[0];
        my str $k = $args->[1];
        my scalar $v = $args->[2];
        $h->{$k} = $v;
        return $v;
    }
    if ($bid == BI::HASH_GET) {
        my scalar $h = $args->[0];
        my str $k = $args->[1];
        if (exists($h, $k)) {
            return $h->{$k};
        }
        if ($argc >= 3) { return $args->[2]; }
        return undef;
    }
    if ($bid == BI::HASH_DELETE) {
        my scalar $h = $args->[0];
        my str $k = $args->[1];
        delete($h, $k);
        return undef;
    }
    if ($bid == BI::IS_REF) {
        my scalar $rv = $args->[0];
        if (ref($rv) eq "HASH" && exists($rv, "__scalar_ref__")) { return 1; }
        my str $rtype = ref($rv);
        return (length($rtype) > 0 && $rtype ne "0") ? 1 : 0;
    }
    if ($bid == BI::CAN_FN) {
        # Standalone can($obj, $method) - check if method exists
        if ($argc >= 2) {
            my scalar $obj = $args->[0];
            my str $method_name = $args->[1];
            my str $pkg = get_obj_class($obj);
            if (length($pkg) > 0) {
                my scalar $found = interp_resolve_method($interp, $pkg, $method_name);
                return defined($found) ? 1 : 0;
            }
        }
        return 0;
    }
    if ($bid == BI::PRINTF) {
        my str $fmt = $args->[0];
        if ($argc == 1) { print($fmt); }
        elsif ($argc == 2) { print(sprintf($fmt, $args->[1])); }
        elsif ($argc == 3) { print(sprintf($fmt, $args->[1], $args->[2])); }
        elsif ($argc == 4) { print(sprintf($fmt, $args->[1], $args->[2], $args->[3])); }
        return undef;
    }
    if ($bid == BI::READLINE_FN) {
        return sys::readline($args->[0]);
    }

    # ---- core::/sys:: functions ----
    if ($bid == BI::SYS_EXIT) {
        sys::exit($args->[0]);
    }
    if ($bid == BI::SYS_GETENV) {
        return sys::getenv($args->[0]);
    }
    if ($bid == BI::SYS_SETENV) {
        sys::setenv($args->[0], $args->[1]);
        return undef;
    }
    if ($bid == BI::SYS_TIME) {
        return sys::time();
    }
    if ($bid == BI::SYS_SLEEP) {
        sys::sleep($args->[0]);
        return undef;
    }
    if ($bid == BI::SYS_HIRES_TIME) {
        return sys::hires_time();
    }
    if ($bid == BI::SYS_OPEN) {
        return sys::open($args->[0], $args->[1]);
    }
    if ($bid == BI::SYS_CLOSE) {
        sys::close($args->[0]);
        return undef;
    }
    if ($bid == BI::SYS_READLINE) {
        return sys::readline($args->[0]);
    }
    if ($bid == BI::SYS_EOF) {
        return sys::eof($args->[0]);
    }
    if ($bid == BI::SYS_FLUSH) {
        sys::flush($args->[0]);
        return undef;
    }
    if ($bid == BI::SYS_POPEN) {
        return sys::popen($args->[0], $args->[1]);
    }
    if ($bid == BI::SYS_QX) {
        return sys::qx($args->[0]);
    }
    if ($bid == BI::SYS_SYSTEM) {
        return sys::system($args->[0]);
    }
    if ($bid == BI::SYS_STACK_TRACE) {
        return "(interpreter stack trace not available)";
    }

    # ---- sys:: file I/O ----
    if ($bid == BI::SYS_FWRITE) {
        sys::fwrite($args->[0], $args->[1]);
        return undef;
    }
    if ($bid == BI::SYS_FREAD) {
        return sys::fread($args->[0], $args->[1]);
    }
    if ($bid == BI::SYS_FPUTS) {
        sys::fputs($args->[0], $args->[1]);
        return undef;
    }
    if ($bid == BI::SYS_FGETS) {
        return sys::fgets($args->[0], $args->[1]);
    }
    if ($bid == BI::SYS_PCLOSE) {
        sys::close($args->[0]);
        return undef;
    }
    if ($bid == BI::SYS_TRUNCATE) {
        sys::truncate($args->[0], $args->[1]);
        return undef;
    }
    if ($bid == BI::SYS_OPEN_STR) {
        return sys::open_str($args->[0], $args->[1]);
    }
    if ($bid == BI::SYS_STR_FROM_FH) {
        return sys::str_from_fh($args->[0]);
    }

    # ---- sys:: filesystem ----
    if ($bid == BI::SYS_UNLINK) {
        sys::unlink($args->[0]);
        return undef;
    }
    if ($bid == BI::SYS_RENAME) {
        sys::rename($args->[0], $args->[1]);
        return undef;
    }
    if ($bid == BI::SYS_MKDIR) {
        sys::mkdir($args->[0], $args->[1]);
        return undef;
    }
    if ($bid == BI::SYS_RMDIR) {
        sys::rmdir($args->[0]);
        return undef;
    }
    if ($bid == BI::SYS_CHMOD) {
        sys::chmod($args->[0], $args->[1]);
        return undef;
    }
    if ($bid == BI::SYS_LINK) {
        sys::link($args->[0], $args->[1]);
        return undef;
    }
    if ($bid == BI::SYS_SYMLINK) {
        sys::symlink($args->[0], $args->[1]);
        return undef;
    }
    if ($bid == BI::SYS_READLINK) {
        return sys::readlink($args->[0]);
    }
    if ($bid == BI::SYS_STAT) {
        return sys::stat($args->[0]);
    }
    if ($bid == BI::SYS_LSTAT) {
        return sys::lstat($args->[0]);
    }
    if ($bid == BI::SYS_ACCESS) {
        return sys::access($args->[0], $args->[1]);
    }
    if ($bid == BI::SYS_IS_FILE) {
        return sys::is_file($args->[0]);
    }
    if ($bid == BI::SYS_IS_DIR) {
        return sys::is_dir($args->[0]);
    }
    if ($bid == BI::SYS_READDIR) {
        return sys::readdir($args->[0]);
    }
    if ($bid == BI::SYS_READDIR_FULL) {
        return sys::readdir_full($args->[0]);
    }
    if ($bid == BI::SYS_GLOB) {
        return sys::glob($args->[0]);
    }
    if ($bid == BI::SYS_FNMATCH) {
        return sys::fnmatch($args->[0], $args->[1]);
    }

    # ---- sys:: path ----
    if ($bid == BI::SYS_DIRNAME) {
        return sys::dirname($args->[0]);
    }
    if ($bid == BI::SYS_BASENAME) {
        return sys::basename($args->[0]);
    }
    if ($bid == BI::SYS_FILE_EXT) {
        return sys::file_ext($args->[0]);
    }
    if ($bid == BI::SYS_REALPATH) {
        return sys::realpath($args->[0]);
    }
    if ($bid == BI::SYS_GETCWD) {
        return sys::getcwd();
    }
    if ($bid == BI::SYS_PATH_JOIN) {
        return sys::path_join($args->[0], $args->[1]);
    }

    # ---- sys:: process ----
    if ($bid == BI::SYS_GETPID) {
        return sys::getpid();
    }
    if ($bid == BI::SYS_GETPPID) {
        return sys::getppid();
    }
    if ($bid == BI::SYS_FORK) {
        return sys::fork();
    }
    if ($bid == BI::SYS_WAIT) {
        return sys::wait();
    }
    if ($bid == BI::SYS_USLEEP) {
        sys::usleep($args->[0]);
        return undef;
    }
    if ($bid == BI::SYS_GETPROCNAME) {
        return sys::getprocname();
    }
    if ($bid == BI::SYS_SETPROCNAME) {
        sys::setprocname($args->[0]);
        return undef;
    }
    if ($bid == BI::SYS_GETPROCTITLE) {
        return sys::getprocname();
    }
    if ($bid == BI::SYS_SETPROCTITLE) {
        sys::setprocname($args->[0]);
        return undef;
    }

    # ---- sys:: environment ----
    if ($bid == BI::SYS_UNSETENV) {
        sys::unsetenv($args->[0]);
        return undef;
    }

    # ---- sys:: user/group ----
    if ($bid == BI::SYS_GETUID) {
        return sys::getuid();
    }
    if ($bid == BI::SYS_GETGID) {
        return sys::getgid();
    }
    if ($bid == BI::SYS_GETEUID) {
        return sys::geteuid();
    }
    if ($bid == BI::SYS_GETEGID) {
        return sys::getegid();
    }
    if ($bid == BI::SYS_GETPWUID) {
        return sys::getpwuid($args->[0]);
    }
    if ($bid == BI::SYS_GETPWNAM) {
        return sys::getpwnam($args->[0]);
    }
    if ($bid == BI::SYS_GETGRGID) {
        return sys::getgrgid($args->[0]);
    }
    if ($bid == BI::SYS_GETGROUPS) {
        return sys::getgroups();
    }

    # ---- sys:: misc ----
    if ($bid == BI::SYS_ISATTY) {
        return sys::isatty($args->[0]);
    }
    if ($bid == BI::SYS_STRERROR) {
        return sys::strerror($args->[0]);
    }
    if ($bid == BI::SYS_ERRNO) {
        return sys::errno();
    }
    if ($bid == BI::SYS_UMASK) {
        return sys::umask($args->[0]);
    }
    if ($bid == BI::SYS_UTIME) {
        sys::utime($args->[0], $args->[1], $args->[2]);
        return undef;
    }
    if ($bid == BI::SYS_FREE) {
        # No-op in interpreter (GC handles memory)
        return undef;
    }
    if ($bid == BI::SYS_RELEASE) {
        # No-op in interpreter
        return undef;
    }

    # ---- sys:: network ----
    if ($bid == BI::SYS_GETHOSTNAME) {
        return sys::gethostname();
    }
    if ($bid == BI::SYS_GETHOSTBYNAME) {
        return sys::gethostbyname($args->[0]);
    }
    if ($bid == BI::SYS_GETHOSTBYNAME_ALL) {
        return sys::gethostbyname_all($args->[0]);
    }
    if ($bid == BI::SYS_GETADDRINFO) {
        return sys::getaddrinfo($args->[0], $args->[1]);
    }
    if ($bid == BI::SYS_INET_ADDR) {
        return sys::inet_addr($args->[0]);
    }
    if ($bid == BI::SYS_INET_NTOA) {
        return sys::inet_ntoa($args->[0]);
    }
    if ($bid == BI::SYS_HTONS) {
        return sys::htons($args->[0]);
    }
    if ($bid == BI::SYS_NTOHS) {
        return sys::ntohs($args->[0]);
    }
    if ($bid == BI::SYS_HTONL) {
        return sys::htonl($args->[0]);
    }
    if ($bid == BI::SYS_NTOHL) {
        return sys::ntohl($args->[0]);
    }
    if ($bid == BI::SYS_INET_PTON) {
        return sys::inet_pton($args->[0], $args->[1]);
    }
    if ($bid == BI::SYS_INET_NTOP) {
        return sys::inet_ntop($args->[0], $args->[1]);
    }
    if ($bid == BI::SYS_SOCKET_SERVER) {
        if ($argc >= 3) { return sys::socket_server($args->[0], $args->[1], $args->[2]); }
        return sys::socket_server($args->[0]);
    }
    if ($bid == BI::SYS_SOCKET_FD) {
        return sys::socket_fd($args->[0]);
    }
    if ($bid == BI::SYS_SOCKET_CLOSE) {
        sys::socket_close($args->[0]);
        return undef;
    }
    if ($bid == BI::SYS_SOCKET_SELECT) {
        return sys::socket_select($args->[0], $args->[1]);
    }
    if ($bid == BI::SYS_DL_OPEN) {
        return sys::dl_open($args->[0]);
    }
    if ($bid == BI::SYS_DL_SYM) {
        return sys::dl_sym($args->[0], $args->[1]);
    }
    if ($bid == BI::SYS_DL_CLOSE) {
        sys::dl_close($args->[0]);
        return undef;
    }
    if ($bid == BI::SYS_DL_ERROR) {
        return sys::dl_error();
    }
    if ($bid == BI::SYS_DL_CALL_NUM) {
        my scalar $fn_ptr = $args->[0];
        my scalar $call_args = $args->[1];
        my int $nargs = size($call_args);
        my num $result = 0.0;
        if ($nargs == 0) {
            __C__ {
                typedef double (*fn0_t)(void);
                fn0_t fp = (fn0_t)(intptr_t)strada_to_int(fn_ptr);
                double r = fp();
                strada_decref(result);
                result = strada_new_num(r);
            }
        } elsif ($nargs == 1) {
            my num $a0 = $call_args->[0];
            __C__ {
                typedef double (*fn1_t)(double);
                fn1_t fp = (fn1_t)(intptr_t)strada_to_int(fn_ptr);
                double r = fp(strada_to_num(a0));
                strada_decref(result);
                result = strada_new_num(r);
            }
        } elsif ($nargs == 2) {
            my num $a0 = $call_args->[0];
            my num $a1 = $call_args->[1];
            __C__ {
                typedef double (*fn2_t)(double, double);
                fn2_t fp = (fn2_t)(intptr_t)strada_to_int(fn_ptr);
                double r = fp(strada_to_num(a0), strada_to_num(a1));
                strada_decref(result);
                result = strada_new_num(r);
            }
        }
        return $result;
    }
    if ($bid == BI::SYS_DL_CALL_INT) {
        my scalar $fn_ptr = $args->[0];
        my scalar $call_args = $args->[1];
        my int $nargs = size($call_args);
        my int $result = 0;
        if ($nargs == 0) {
            __C__ {
                typedef int64_t (*fn0_t)(void);
                fn0_t fp = (fn0_t)(intptr_t)strada_to_int(fn_ptr);
                int64_t r = fp();
                strada_decref(result);
                result = strada_new_int(r);
            }
        } elsif ($nargs == 1) {
            my int $a0 = $call_args->[0];
            __C__ {
                typedef int64_t (*fn1_t)(int64_t);
                fn1_t fp = (fn1_t)(intptr_t)strada_to_int(fn_ptr);
                int64_t r = fp(strada_to_int(a0));
                strada_decref(result);
                result = strada_new_int(r);
            }
        }
        return $result;
    }
    if ($bid == BI::SYS_INT_PTR) {
        # Return a dummy non-zero pointer (interpreter can't do real pointer ops)
        return 0;
    }
    if ($bid == BI::SYS_NUM_PTR) {
        return 0;
    }
    if ($bid == BI::SYS_PTR_DEREF_INT) {
        return 0;
    }
    if ($bid == BI::SYS_PTR_DEREF_NUM) {
        return 0.0;
    }
    if ($bid == BI::SYS_PTR_SET_INT) {
        return undef;
    }
    if ($bid == BI::SYS_PTR_SET_NUM) {
        return undef;
    }

    # ---- sys:: extended process ----
    if ($bid == BI::SYS_GETPGRP) {
        return sys::getpgrp();
    }
    if ($bid == BI::SYS_GETSID) {
        return sys::getsid($args->[0]);
    }
    if ($bid == BI::SYS_GETPGID) {
        return sys::getpgid($args->[0]);
    }
    if ($bid == BI::SYS_NICE) {
        return sys::nice($args->[0]);
    }
    if ($bid == BI::SYS_GETPRIORITY) {
        return sys::getpriority($args->[0], $args->[1]);
    }
    if ($bid == BI::SYS_GETRUSAGE) {
        return sys::getrusage($args->[0]);
    }
    if ($bid == BI::SYS_GETRLIMIT) {
        return sys::getrlimit($args->[0]);
    }
    if ($bid == BI::SYS_TIMES) {
        return sys::times();
    }
    if ($bid == BI::SYS_CLOCK) {
        return sys::clock();
    }

    # ---- sys:: temp/misc ----
    if ($bid == BI::SYS_MKSTEMP) {
        return sys::mkstemp($args->[0]);
    }
    if ($bid == BI::SYS_MKDTEMP) {
        return sys::mkdtemp($args->[0]);
    }
    if ($bid == BI::SYS_STATVFS) {
        return sys::statvfs($args->[0]);
    }
    if ($bid == BI::SYS_ATOI) {
        return sys::atoi($args->[0]);
    }
    if ($bid == BI::SYS_ATOF) {
        return sys::atof($args->[0]);
    }
    if ($bid == BI::SYS_STRTOL) {
        return sys::strtol($args->[0], $args->[1]);
    }
    if ($bid == BI::SYS_DIFFTIME) {
        return sys::difftime($args->[0], $args->[1]);
    }
    if ($bid == BI::SYS_SRAND) {
        __C__ {
            StradaValue *seed_v = ((StradaArray*)args->value.rv->value.av)->elements[0];
            srand((unsigned int)strada_to_int(seed_v));
        }
        return undef;
    }
    if ($bid == BI::SYS_RAND) {
        my int $r = 0;
        __C__ {
            strada_decref(r);
            r = strada_new_int((int64_t)rand());
        }
        return $r;
    }
    if ($bid == BI::SYS_SRANDOM) {
        __C__ {
            StradaValue *seed_v = ((StradaArray*)args->value.rv->value.av)->elements[0];
            srandom((unsigned int)strada_to_int(seed_v));
        }
        return undef;
    }
    if ($bid == BI::SYS_RANDOM) {
        my int $result = 0;
        __C__ {
            strada_decref(result);
            result = strada_new_int((int64_t)random());
        }
        return $result;
    }

    # ---- sys:: seek/tell ----
    if ($bid == BI::SYS_SEEK) {
        sys::seek($args->[0], $args->[1], $args->[2]);
        return undef;
    }
    if ($bid == BI::SYS_TELL) {
        return sys::tell($args->[0]);
    }
    if ($bid == BI::SYS_REWIND) {
        sys::rewind($args->[0]);
        return undef;
    }

    # ---- sys:: weak references ----
    if ($bid == BI::SYS_WEAKEN) {
        return undef;
    }
    if ($bid == BI::SYS_ISWEAK) {
        return 0;
    }

    # ---- sys:: global variable registry ----
    if ($bid == BI::SYS_GLOBAL_SET) {
        env_set($interp->{"global_env"}, $args->[0], $args->[1]);
        return undef;
    }
    if ($bid == BI::SYS_GLOBAL_GET) {
        return env_get($interp->{"global_env"}, $args->[0]);
    }
    if ($bid == BI::SYS_GLOBAL_EXISTS) {
        return env_exists($interp->{"global_env"}, $args->[0]) ? 1 : 0;
    }
    if ($bid == BI::SYS_GLOBAL_DELETE) {
        my scalar $gvars = $interp->{"global_env"}->{"vars"};
        if (exists($gvars, $args->[0])) {
            delete($gvars, $args->[0]);
        }
        return undef;
    }
    if ($bid == BI::SYS_GLOBAL_KEYS) {
        return keys($interp->{"global_env"}->{"vars"});
    }

    # ---- sys:: exit/signal ----
    if ($bid == BI::SYS_EXIT_NOCLEAN) {
        sys::exit($args->[0]);
    }
    if ($bid == BI::SYS_SIGNAL) {
        return undef;
    }

    # ---- sys:: context functions ----
    if ($bid == BI::SYS_WANTSCALAR) {
        return 1;
    }
    if ($bid == BI::SYS_WANTARRAY) {
        return 0;
    }
    if ($bid == BI::SYS_WANTHASH) {
        return 0;
    }
    if ($bid == BI::SYS_GET_RECURSION_LIMIT) {
        return $interp->{"max_call_depth"};
    }
    if ($bid == BI::SYS_SET_RECURSION_LIMIT) {
        $interp->{"max_call_depth"} = $args->[0];
        return undef;
    }

    # ---- math:: functions ----
    if ($bid == BI::MATH_SQRT) { return math::sqrt($args->[0]); }
    if ($bid == BI::MATH_SIN) { return math::sin($args->[0]); }
    if ($bid == BI::MATH_COS) { return math::cos($args->[0]); }
    if ($bid == BI::MATH_POW) { return math::pow($args->[0], $args->[1]); }
    if ($bid == BI::MATH_ABS) { my scalar $v = $args->[0]; if ($v < 0) { return 0 - $v; } return $v; }
    if ($bid == BI::MATH_FLOOR) { return math::floor($args->[0]); }
    if ($bid == BI::MATH_CEIL) { return math::ceil($args->[0]); }
    if ($bid == BI::MATH_LOG) { return math::log($args->[0]); }
    if ($bid == BI::MATH_EXP) { return math::exp($args->[0]); }
    if ($bid == BI::MATH_RAND) { return math::rand(); }
    if ($bid == BI::MATH_SRAND) {
        my scalar $seed = $args->[0];
        __C__ {
            srand((unsigned int)strada_to_int(seed));
        }
        return undef;
    }
    if ($bid == BI::MATH_ATAN2) { return math::atan2($args->[0], $args->[1]); }
    if ($bid == BI::MATH_TAN) { return math::tan($args->[0]); }
    if ($bid == BI::MATH_ASIN) { return math::asin($args->[0]); }
    if ($bid == BI::MATH_ACOS) { return math::acos($args->[0]); }
    if ($bid == BI::MATH_ATAN) { return math::atan($args->[0]); }
    if ($bid == BI::MATH_SINH) { return math::sinh($args->[0]); }
    if ($bid == BI::MATH_COSH) { return math::cosh($args->[0]); }
    if ($bid == BI::MATH_TANH) { return math::tanh($args->[0]); }
    if ($bid == BI::MATH_LOG10) { return math::log10($args->[0]); }
    if ($bid == BI::MATH_ROUND) { return math::round($args->[0]); }
    if ($bid == BI::MATH_FABS) { return math::fabs($args->[0]); }
    if ($bid == BI::MATH_FMOD) { return math::fmod($args->[0], $args->[1]); }
    if ($bid == BI::MATH_HYPOT) { return math::hypot($args->[0], $args->[1]); }
    if ($bid == BI::MATH_CBRT) { return math::cbrt($args->[0]); }
    if ($bid == BI::MATH_TRUNC) { return math::trunc($args->[0]); }
    if ($bid == BI::MATH_ISNAN) { return math::isnan($args->[0]); }
    if ($bid == BI::MATH_ISINF) { return math::isinf($args->[0]); }
    if ($bid == BI::MATH_ISFINITE) { return math::isfinite($args->[0]); }
    if ($bid == BI::MATH_FMAX) { return math::fmax($args->[0], $args->[1]); }
    if ($bid == BI::MATH_FMIN) { return math::fmin($args->[0], $args->[1]); }
    if ($bid == BI::MATH_COPYSIGN) { return math::copysign($args->[0], $args->[1]); }
    if ($bid == BI::MATH_REMAINDER) { return math::remainder($args->[0], $args->[1]); }
    if ($bid == BI::MATH_LDEXP) { return math::ldexp($args->[0], $args->[1]); }
    if ($bid == BI::MATH_FREXP) { return math::frexp($args->[0]); }
    if ($bid == BI::MATH_MODF) { return math::modf($args->[0]); }
    if ($bid == BI::MATH_SCALBN) { return math::scalbn($args->[0], $args->[1]); }

    # ---- utf8:: functions ----
    if ($bid == BI::UTF8_IS_UTF8) { return utf8::is_utf8($args->[0]); }
    if ($bid == BI::UTF8_VALID) { return utf8::valid($args->[0]); }
    if ($bid == BI::UTF8_ENCODE) { return utf8::encode($args->[0]); }
    if ($bid == BI::UTF8_DECODE) { return utf8::decode($args->[0]); }
    if ($bid == BI::UTF8_UPGRADE) { return utf8::upgrade($args->[0]); }
    if ($bid == BI::UTF8_DOWNGRADE) {
        if ($argc >= 2) {
            return utf8::downgrade($args->[0], $args->[1]);
        }
        return utf8::downgrade($args->[0]);
    }
    if ($bid == BI::UTF8_UNICODE_TO_NATIVE) { return utf8::unicode_to_native($args->[0]); }

    # ---- OOP functions ----
    if ($bid == BI::BLESS) {
        my scalar $ref_val = $args->[0];
        my str $class_name = $args->[1];
        if (ref($ref_val) eq "HASH") {
            $ref_val->{"__class__"} = $class_name;
        }
        return $ref_val;
    }
    if ($bid == BI::TIE) {
        # tie(%hash, "ClassName", @args) - call TIEHASH and store
        my scalar $hash_val = $args->[0];
        my str $class_name = $args->[1];
        # Call TIEHASH constructor
        my array @tie_args = ();
        my int $tai = 2;
        while ($tai < $argc) {
            push(@tie_args, $args->[$tai]);
            $tai = $tai + 1;
        }
        my scalar $tie_func = interp_resolve_method($interp, $class_name, "TIEHASH");
        if (defined($tie_func)) {
            my scalar $tie_obj = call_user_func($interp, $tie_func, \@tie_args);
            $hash_val->{"__tied__"} = $tie_obj;
            return $tie_obj;
        }
        return undef;
    }
    if ($bid == BI::UNTIE) {
        my scalar $hash_val = $args->[0];
        if (ref($hash_val) eq "HASH" && exists($hash_val, "__tied__")) {
            delete($hash_val, "__tied__");
        }
        return undef;
    }
    if ($bid == BI::TIED) {
        my scalar $hash_val = $args->[0];
        if (ref($hash_val) eq "HASH" && exists($hash_val, "__tied__")) {
            return $hash_val->{"__tied__"};
        }
        return undef;
    }

    # ---- Additional functions ----
    if ($bid == BI::SELECT_FN) {
        my scalar $old = $interp->{"select_fh"};
        $interp->{"select_fh"} = $args->[0];
        return $old;
    }
    if ($bid == BI::NAMED_CAPTURES) {
        return named_captures();
    }
    if ($bid == BI::CAPTURES) {
        return captures();
    }
    if ($bid == BI::THROW_FN) {
        throw($args->[0]);
    }

    # ---- DateTime:: builtins (C-backed time functions) ----
    if ($bid == BI::DT_NOW) {
        my int $epoch = 0;
        my int $year = 0;
        my int $month = 0;
        my int $day = 0;
        my int $hour = 0;
        my int $minute = 0;
        my int $second = 0;
        __C__ {
            time_t t = time(NULL);
            struct tm *tm_val = localtime(&t);
            strada_decref(epoch); epoch = strada_new_int((int64_t)t);
            strada_decref(year); year = strada_new_int(tm_val->tm_year + 1900);
            strada_decref(month); month = strada_new_int(tm_val->tm_mon + 1);
            strada_decref(day); day = strada_new_int(tm_val->tm_mday);
            strada_decref(hour); hour = strada_new_int(tm_val->tm_hour);
            strada_decref(minute); minute = strada_new_int(tm_val->tm_min);
            strada_decref(second); second = strada_new_int(tm_val->tm_sec);
        }
        my hash %dt = ();
        $dt{"year"} = $year; $dt{"month"} = $month; $dt{"day"} = $day;
        $dt{"hour"} = $hour; $dt{"minute"} = $minute; $dt{"second"} = $second;
        $dt{"epoch"} = $epoch;
        return \%dt;
    }
    if ($bid == BI::DT_NOW_UTC) {
        my int $epoch = 0;
        my int $year = 0; my int $month = 0; my int $day = 0;
        my int $hour = 0; my int $minute = 0; my int $second = 0;
        __C__ {
            time_t t = time(NULL);
            struct tm *tm_val = gmtime(&t);
            strada_decref(epoch); epoch = strada_new_int((int64_t)t);
            strada_decref(year); year = strada_new_int(tm_val->tm_year + 1900);
            strada_decref(month); month = strada_new_int(tm_val->tm_mon + 1);
            strada_decref(day); day = strada_new_int(tm_val->tm_mday);
            strada_decref(hour); hour = strada_new_int(tm_val->tm_hour);
            strada_decref(minute); minute = strada_new_int(tm_val->tm_min);
            strada_decref(second); second = strada_new_int(tm_val->tm_sec);
        }
        my hash %dt = ();
        $dt{"year"} = $year; $dt{"month"} = $month; $dt{"day"} = $day;
        $dt{"hour"} = $hour; $dt{"minute"} = $minute; $dt{"second"} = $second;
        $dt{"epoch"} = $epoch; $dt{"utc"} = 1;
        return \%dt;
    }
    if ($bid == BI::DT_MAKE) {
        my int $dt_y = $args->[0];
        my int $dt_m = $args->[1];
        my int $dt_d = $args->[2];
        my int $dt_h = $args->[3];
        my int $dt_mi = $args->[4];
        my int $dt_s = $args->[5];
        my int $epoch = 0;
        __C__ {
            struct tm tm_val = {0};
            tm_val.tm_year = strada_to_int(dt_y) - 1900;
            tm_val.tm_mon = strada_to_int(dt_m) - 1;
            tm_val.tm_mday = strada_to_int(dt_d);
            tm_val.tm_hour = strada_to_int(dt_h);
            tm_val.tm_min = strada_to_int(dt_mi);
            tm_val.tm_sec = strada_to_int(dt_s);
            tm_val.tm_isdst = -1;
            time_t t = mktime(&tm_val);
            strada_decref(epoch); epoch = strada_new_int((int64_t)t);
        }
        my hash %dt = ();
        $dt{"year"} = $dt_y; $dt{"month"} = $dt_m; $dt{"day"} = $dt_d;
        $dt{"hour"} = $dt_h; $dt{"minute"} = $dt_mi; $dt{"second"} = $dt_s;
        $dt{"epoch"} = $epoch;
        return \%dt;
    }
    if ($bid == BI::DT_FROM_EPOCH) {
        my int $ts = $args->[0];
        my int $year = 0; my int $month = 0; my int $day = 0;
        my int $hour = 0; my int $minute = 0; my int $second = 0;
        __C__ {
            time_t t = (time_t)strada_to_int(ts);
            struct tm *tm_val = localtime(&t);
            strada_decref(year); year = strada_new_int(tm_val->tm_year + 1900);
            strada_decref(month); month = strada_new_int(tm_val->tm_mon + 1);
            strada_decref(day); day = strada_new_int(tm_val->tm_mday);
            strada_decref(hour); hour = strada_new_int(tm_val->tm_hour);
            strada_decref(minute); minute = strada_new_int(tm_val->tm_min);
            strada_decref(second); second = strada_new_int(tm_val->tm_sec);
        }
        my hash %dt = ();
        $dt{"year"} = $year; $dt{"month"} = $month; $dt{"day"} = $day;
        $dt{"hour"} = $hour; $dt{"minute"} = $minute; $dt{"second"} = $second;
        $dt{"epoch"} = $ts;
        return \%dt;
    }
    if ($bid == BI::DT_FROM_EPOCH_UTC) {
        my int $ts = $args->[0];
        my int $year = 0; my int $month = 0; my int $day = 0;
        my int $hour = 0; my int $minute = 0; my int $second = 0;
        __C__ {
            time_t t = (time_t)strada_to_int(ts);
            struct tm *tm_val = gmtime(&t);
            strada_decref(year); year = strada_new_int(tm_val->tm_year + 1900);
            strada_decref(month); month = strada_new_int(tm_val->tm_mon + 1);
            strada_decref(day); day = strada_new_int(tm_val->tm_mday);
            strada_decref(hour); hour = strada_new_int(tm_val->tm_hour);
            strada_decref(minute); minute = strada_new_int(tm_val->tm_min);
            strada_decref(second); second = strada_new_int(tm_val->tm_sec);
        }
        my hash %dt = ();
        $dt{"year"} = $year; $dt{"month"} = $month; $dt{"day"} = $day;
        $dt{"hour"} = $hour; $dt{"minute"} = $minute; $dt{"second"} = $second;
        $dt{"epoch"} = $ts; $dt{"utc"} = 1;
        return \%dt;
    }
    if ($bid == BI::DT_FORMAT) {
        my scalar $dt = $args->[0];
        if (!defined($dt)) { return ""; }
        my int $dt_y = $dt->{"year"};
        my int $dt_m = $dt->{"month"};
        my int $dt_d = $dt->{"day"};
        my int $dt_h = $dt->{"hour"};
        my int $dt_mi = $dt->{"minute"};
        my int $dt_s = $dt->{"second"};
        my str $fmt = $args->[1];
        my str $result = "";
        __C__ {
            char *fmt_str = strada_to_str(fmt);
            struct tm tm_val = {0};
            tm_val.tm_year = strada_to_int(dt_y) - 1900;
            tm_val.tm_mon = strada_to_int(dt_m) - 1;
            tm_val.tm_mday = strada_to_int(dt_d);
            tm_val.tm_hour = strada_to_int(dt_h);
            tm_val.tm_min = strada_to_int(dt_mi);
            tm_val.tm_sec = strada_to_int(dt_s);
            tm_val.tm_isdst = -1;
            mktime(&tm_val);
            char buf[256];
            size_t len = strftime(buf, sizeof(buf), fmt_str, &tm_val);
            strada_decref(result);
            result = (len > 0) ? strada_new_str(buf) : strada_new_str("");
            free(fmt_str);
        }
        return $result;
    }
    if ($bid == BI::DT_PARSE) {
        my str $input = $args->[0];
        my str $fmt = $args->[1];
        my int $year = 0; my int $month = 0; my int $day = 0;
        my int $hour = 0; my int $minute = 0; my int $second = 0;
        my int $success = 0;
        __C__ {
            char *input_str = strada_to_str(input);
            char *fmt_str = strada_to_str(fmt);
            struct tm tm_val = {0};
            char *r = strptime(input_str, fmt_str, &tm_val);
            if (r != NULL) {
                strada_decref(success); success = strada_new_int(1);
                strada_decref(year); year = strada_new_int(tm_val.tm_year + 1900);
                strada_decref(month); month = strada_new_int(tm_val.tm_mon + 1);
                strada_decref(day); day = strada_new_int(tm_val.tm_mday);
                strada_decref(hour); hour = strada_new_int(tm_val.tm_hour);
                strada_decref(minute); minute = strada_new_int(tm_val.tm_min);
                strada_decref(second); second = strada_new_int(tm_val.tm_sec);
            }
            free(input_str); free(fmt_str);
        }
        if ($success == 0) { return undef; }
        return call_builtin($interp, "DateTime::make", [cast_int($year), cast_int($month), cast_int($day), cast_int($hour), cast_int($minute), cast_int($second)], $env);
    }
    if ($bid == BI::DT_DAY_OF_WEEK) {
        my scalar $dt = $args->[0];
        if (!defined($dt)) { return 0; }
        my int $dt_y = $dt->{"year"};
        my int $dt_m = $dt->{"month"};
        my int $dt_d = $dt->{"day"};
        my int $wday = 0;
        __C__ {
            struct tm tm_val = {0};
            tm_val.tm_year = strada_to_int(dt_y) - 1900;
            tm_val.tm_mon = strada_to_int(dt_m) - 1;
            tm_val.tm_mday = strada_to_int(dt_d);
            tm_val.tm_isdst = -1;
            mktime(&tm_val);
            strada_decref(wday); wday = strada_new_int(tm_val.tm_wday);
        }
        return $wday;
    }
    if ($bid == BI::DT_DAY_OF_YEAR) {
        my scalar $dt = $args->[0];
        if (!defined($dt)) { return 0; }
        my int $dt_y = $dt->{"year"};
        my int $dt_m = $dt->{"month"};
        my int $dt_d = $dt->{"day"};
        my int $yday = 0;
        __C__ {
            struct tm tm_val = {0};
            tm_val.tm_year = strada_to_int(dt_y) - 1900;
            tm_val.tm_mon = strada_to_int(dt_m) - 1;
            tm_val.tm_mday = strada_to_int(dt_d);
            tm_val.tm_isdst = -1;
            mktime(&tm_val);
            strada_decref(yday); yday = strada_new_int(tm_val.tm_yday + 1);
        }
        return $yday;
    }
    if ($bid == BI::DT_TIMEZONE_OFFSET) {
        my int $offset = 0;
        __C__ {
            time_t t = time(NULL);
            struct tm *local_tm = localtime(&t);
            time_t local_t = mktime(local_tm);
            struct tm *gm_tm = gmtime(&t);
            time_t gm_t = mktime(gm_tm);
            strada_decref(offset); offset = strada_new_int((int64_t)(local_t - gm_t));
        }
        return $offset;
    }
    if ($bid == BI::DT_TIMEZONE_NAME) {
        my str $tz_name = "";
        __C__ {
            time_t t = time(NULL);
            struct tm *tm_val = localtime(&t);
            char buf[64];
            strftime(buf, sizeof(buf), "%Z", tm_val);
            strada_decref(tz_name); tz_name = strada_new_str(buf);
        }
        return $tz_name;
    }
    # Pass through non-C DateTime functions to user-defined versions
    if (index($name, "DateTime::") == 0 || index($name, "DateTime_") == 0) {
        my scalar $func_info = interp_get_func($interp, $name);
        if (defined($func_info)) {
            return call_user_func($interp, $func_info, $args);
        }
        # Try alternate form
        my str $alt_name = $name;
        if (index($name, "DateTime::") == 0) {
            $alt_name = "DateTime_" . substr($name, 10, length($name) - 10);
        }
        $func_info = interp_get_func($interp, $alt_name);
        if (defined($func_info)) {
            return call_user_func($interp, $func_info, $args);
        }
        die("Undefined function: " . $name);
    }

    # ---- BigInt/BigFloat C helper builtins ----
    if ($bid == BI::BIGINT_ADD) {
        my str $a = $args->[0];
        my str $b = $args->[1];
        my str $r = "";
        __C__ {
            char *as = strada_to_str(a); char *bs = strada_to_str(b);
            char *res = _bi_add(as, bs);
            free(as); free(bs);
            strada_decref(r); r = strada_new_str(res); free(res);
        }
        return $r;
    }
    if ($bid == BI::BIGINT_SUB) {
        my str $a = $args->[0];
        my str $b = $args->[1];
        my str $r = "";
        __C__ {
            char *as = strada_to_str(a); char *bs = strada_to_str(b);
            char *res = _bi_sub(as, bs);
            free(as); free(bs);
            strada_decref(r); r = strada_new_str(res); free(res);
        }
        return $r;
    }
    if ($bid == BI::BIGINT_MUL) {
        my str $a = $args->[0];
        my str $b = $args->[1];
        my str $r = "";
        __C__ {
            char *as = strada_to_str(a); char *bs = strada_to_str(b);
            char *res = _bi_mul(as, bs);
            free(as); free(bs);
            strada_decref(r); r = strada_new_str(res); free(res);
        }
        return $r;
    }
    if ($bid == BI::BIGINT_CMP) {
        my str $a = $args->[0];
        my str $b = $args->[1];
        my int $r = 0;
        __C__ {
            char *as = strada_to_str(a); char *bs = strada_to_str(b);
            int c = _bi_cmp(as, bs);
            free(as); free(bs);
            strada_decref(r); r = strada_new_int((int64_t)c);
        }
        return $r;
    }
    if ($bid == BI::BIGINT_DIVMOD) {
        my str $a = $args->[0];
        my str $b = $args->[1];
        my str $q = "";
        __C__ {
            char *as = strada_to_str(a); char *bs = strada_to_str(b);
            char *res = _bi_divmod(as, bs, NULL);
            free(as); free(bs);
            strada_decref(q); q = strada_new_str(res); free(res);
        }
        return $q;
    }
    if ($bid == BI::BIGINT_DIVMOD_REM) {
        my str $a = $args->[0];
        my str $b = $args->[1];
        my str $q = "";
        my str $rem = "";
        __C__ {
            char *as = strada_to_str(a); char *bs = strada_to_str(b);
            char *rem_str = NULL;
            char *res = _bi_divmod(as, bs, &rem_str);
            free(as); free(bs);
            strada_decref(q); q = strada_new_str(res); free(res);
            strada_decref(rem); rem = strada_new_str(rem_str); free(rem_str);
        }
        my array @result = ($q, $rem);
        return \@result;
    }
    if ($bid == BI::BIGFLOAT_PAD_RIGHT) {
        my str $s = $args->[0];
        my int $n = $args->[1];
        my str $r = "";
        __C__ {
            char *ss = strada_to_str(s);
            char *res = _bf_pad_right(ss, (size_t)strada_to_int(n));
            free(ss);
            strada_decref(r); r = strada_new_str(res); free(res);
        }
        return $r;
    }
    if ($bid == BI::BIGFLOAT_NORMALIZE) {
        my str $m = $args->[0];
        my int $scale = $args->[1];
        my str $r = "";
        my int $new_scale = $scale;
        __C__ {
            char *ms = strada_to_str(m);
            int64_t sc = strada_to_int(scale);
            char *res = _bf_normalize(ms, &sc);
            free(ms);
            strada_decref(r); r = strada_new_str(res); free(res);
            strada_decref(new_scale); new_scale = strada_new_int(sc);
        }
        my array @result = ($r, $new_scale);
        return \@result;
    }

    # ---- BigFloat::new builtin (needs _bf_normalize) ----
    if ($bid == BI::BIGFLOAT_NEW) {
        my str $val = $args->[0];
        my int $sign = 1;
        my str $input = $val;
        if (length($input) > 0 && substr($input, 0, 1) eq "-") {
            $sign = -1;
            $input = substr($input, 1, length($input) - 1);
        } elsif (length($input) > 0 && substr($input, 0, 1) eq "+") {
            $input = substr($input, 1, length($input) - 1);
        }
        my int $dot_pos = index($input, ".");
        my str $mantissa = "";
        my int $scale = 0;
        if ($dot_pos >= 0) {
            my str $int_part = substr($input, 0, $dot_pos);
            my str $frac_part = substr($input, $dot_pos + 1, length($input) - $dot_pos - 1);
            $mantissa = $int_part . $frac_part;
            $scale = length($frac_part);
        } else {
            $mantissa = $input;
            $scale = 0;
        }
        while (length($mantissa) > 1 && substr($mantissa, 0, 1) eq "0") {
            $mantissa = substr($mantissa, 1, length($mantissa) - 1);
        }
        my scalar $norm = call_builtin($interp, "BigFloat::_bf_normalize", [$mantissa, $scale], $env);
        my str $norm_m = $norm->[0];
        my int $norm_e = $norm->[1];
        if ($norm_m eq "0") { $sign = 1; }
        my hash %self = ();
        $self{"s"} = $sign;
        $self{"m"} = $norm_m;
        $self{"e"} = $norm_e;
        return bless(\%self, "BigFloat");
    }

    # If we got here with a sys::/core::/math::/utf8:: prefix, it's genuinely undefined
    die("Undefined function: " . $name);
}

# ============================================================
# User Function Calls
# ============================================================

func call_user_func(scalar $interp, scalar $func_info, scalar $args) scalar {
    my scalar $params = $func_info->{"params"};
    my int $param_count = $func_info->{"param_count"};
    my scalar $body = $func_info->{"body"};
    my scalar $closure_env = $func_info->{"closure_env"};

    # Check recursion depth
    $interp->{"call_depth"} = $interp->{"call_depth"} + 1;
    if ($interp->{"call_depth"} > $interp->{"max_call_depth"}) {
        $interp->{"call_depth"} = $interp->{"call_depth"} - 1;
        die("Maximum recursion depth exceeded");
    }

    # Create function scope
    my scalar $func_env = env_new($closure_env);

    # Bind parameters (skip entirely for zero-param functions)
    if ($param_count > 0) {
    my int $arg_count = size($args);
    my int $pi = 0;

    # Use cached variadic flag
    my int $is_variadic = $func_info->{"is_variadic"};
    my str $variadic_name = "";
    if ($is_variadic == 1) {
        $variadic_name = $params->[$param_count - 1]->{"name"};
    }

    while ($pi < $param_count) {
        my scalar $param = $params->[$pi];
        my str $pname = $param->{"name"};
        my str $psigil = $param->{"sigil"};

        if ($is_variadic == 1 && $pi == $param_count - 1) {
            # Variadic: collect remaining args into array
            my array @rest = ();
            my int $ri = $pi;
            while ($ri < $arg_count) {
                push(@rest, $args->[$ri]);
                $ri = $ri + 1;
            }
            env_set($func_env, $pname, \@rest);
        } elsif ($pi < $arg_count) {
            env_set($func_env, $pname, $args->[$pi]);
        } else {
            # Default values
            if ($param->{"is_optional"} == 1 && defined($param->{"default_value"}) && $param->{"default_value"} != 0) {
                env_set($func_env, $pname, eval_node($interp, $param->{"default_value"}, $func_env));
            } else {
                my int $ptype = $param->{"param_type"};
                if ($ptype == TI::INT) { env_set($func_env, $pname, 0); }
                elsif ($ptype == TI::NUM) { env_set($func_env, $pname, 0.0); }
                elsif ($ptype == TI::STR) { env_set($func_env, $pname, ""); }
                elsif ($ptype == TI::ARRAY) {
                    my array @a = ();
                    env_set($func_env, $pname, \@a);
                }
                elsif ($ptype == TI::HASH) {
                    my hash %h = ();
                    env_set($func_env, $pname, \%h);
                }
                else { env_set($func_env, $pname, undef); }
            }
        }
        $pi = $pi + 1;
    }
    } # end if ($param_count > 0)

    # Execute body - save local stack depth for dynamic scope restore
    my int $local_depth = size($interp->{"local_stack"});

    my scalar $result = eval_block($interp, $body, $func_env);

    # Handle return signal (signal-based control flow)
    my int $sig = $interp->{"signal"};
    if ($sig == SIG::RETURN) {
        $result = $interp->{"signal_value"};
        $interp->{"signal"} = SIG::NONE;
        $interp->{"signal_value"} = undef;
        $interp->{"had_explicit_return"} = 1;
    }

    # Restore local variables from dynamic scope stack
    while (size($interp->{"local_stack"}) > $local_depth) {
        my scalar $save = pop($interp->{"local_stack"});
        env_set($interp->{"global_env"}, $save->{"name"}, $save->{"value"});
    }

    # Break env parent chain to allow GC
    $func_env->{"parent"} = undef;
    $interp->{"call_depth"} = $interp->{"call_depth"} - 1;
    return $result;
}

# ============================================================
# Transliteration Helper
# ============================================================

# Expand ranges like a-z into abcdefghijklmnopqrstuvwxyz
func expand_tr_range(str $spec) str {
    my str $result = "";
    my int $i = 0;
    my int $len = length($spec);
    while ($i < $len) {
        if ($i + 2 < $len && substr($spec, $i + 1, 1) eq "-") {
            my int $start = ord(substr($spec, $i, 1));
            my int $end = ord(substr($spec, $i + 2, 1));
            my int $c = $start;
            while ($c <= $end) {
                $result = $result . chr($c);
                $c = $c + 1;
            }
            $i = $i + 3;
        } else {
            $result = $result . substr($spec, $i, 1);
            $i = $i + 1;
        }
    }
    return $result;
}

# ============================================================
# Core Evaluator
# ============================================================

# Evaluate a node in boolean context - arrays/hashes evaluate to their size
func eval_bool(scalar $interp, scalar $node, scalar $env) scalar {
    if (!defined($node)) { return undef; }
    # If the condition is a bare @arr or %hash variable, return size
    if ($node->{"type"} == NI::VARIABLE) {
        my str $sigil = $node->{"sigil"};
        if ($sigil eq "@" || $sigil eq "%") {
            my scalar $val = eval_node($interp, $node, $env);
            if (ref($val) eq "ARRAY" || ref($val) eq "HASH") {
                return size($val);
            }
            return $val;
        }
    }
    # For unary ! on @arr or %hash
    if ($node->{"type"} == NI::UNARY_OP && $node->{"op"} eq "!") {
        my scalar $operand = $node->{"operand"};
        if (defined($operand) && $operand->{"type"} == NI::VARIABLE) {
            my str $sigil = $operand->{"sigil"};
            if ($sigil eq "@" || $sigil eq "%") {
                my scalar $val = eval_node($interp, $operand, $env);
                if (ref($val) eq "ARRAY" || ref($val) eq "HASH") {
                    return (size($val) == 0) ? 1 : 0;
                }
            }
        }
    }
    return eval_node($interp, $node, $env);
}

# ============================================================
# Extended Evaluator (sparse NI types > 37)
# ============================================================

func eval_node_extended(scalar $interp, scalar $node, scalar $env, int $type) scalar {

    # --- Undef ---
    if ($type == NI::UNDEF) {
        return undef;
    }

    # --- Our Declaration ---
    if ($type == NI::OUR_DECL) {
        my str $name = $node->{"name"};
        my int $var_type = $node->{"var_type"};
        my scalar $init = undef;

        if (defined($node->{"init"}) && $node->{"init"} != 0) {
            $init = eval_node($interp, $node->{"init"}, $env);
        } else {
            if ($var_type == TI::INT) { $init = 0; }
            elsif ($var_type == TI::NUM) { $init = 0.0; }
            elsif ($var_type == TI::STR) { $init = ""; }
            elsif ($var_type == TI::ARRAY) {
                my array @a = ();
                $init = \@a;
            }
            elsif ($var_type == TI::HASH) {
                my hash %h = ();
                $init = \%h;
            }
        }

        env_set($interp->{"global_env"}, $name, $init);
        env_set($env, $name, $init);
        return $init;
    }

    # --- Const Declaration ---
    if ($type == NI::CONST_DECL) {
        my str $name = $node->{"name"};
        my scalar $val = eval_node($interp, $node->{"init"}, $env);
        $interp->{"constants"}->{$name} = $val;
        env_set($env, $name, $val);
        return $val;
    }

    # --- Increment / Decrement ---
    if ($type == NI::INCREMENT) {
        my str $op = $node->{"op"};
        my int $is_prefix = $node->{"is_prefix"};
        my scalar $operand = $node->{"operand"};
        my scalar $cur = eval_node($interp, $operand, $env);
        my scalar $new_val = $cur;

        if ($op eq "++") { $new_val = $cur + 1; }
        elsif ($op eq "--") { $new_val = $cur - 1; }

        assign_to($interp, $operand, $new_val, $env);

        if ($is_prefix == 1) { return $new_val; }
        return $cur;
    }

    # --- Ternary ---
    if ($type == NI::TERNARY) {
        my scalar $cond = eval_node($interp, $node->{"condition"}, $env);
        if ($cond) {
            return eval_node($interp, $node->{"true_expr"}, $env);
        }
        return eval_node($interp, $node->{"false_expr"}, $env);
    }

    # --- Do-While Statement ---
    if ($type == NI::DO_WHILE_STMT) {
        my str $label = $node->{"label"};
        my scalar $result = undef;
        my scalar $body_env = env_new($env);

        while (1) {
            my int $should_break = 0;
            my int $should_redo = 1;
            while ($should_redo) {
                $should_redo = 0;
                $result = eval_block($interp, $node->{"body"}, $body_env);

                my int $sig = $interp->{"signal"};
                if ($sig != SIG::NONE) {
                    my str $sig_label = $interp->{"signal_label"};
                    if ($sig == SIG::LAST && (length($sig_label) == 0 || $sig_label eq $label)) {
                        $interp->{"signal"} = SIG::NONE;
                        $should_break = 1;
                    } elsif ($sig == SIG::NEXT && (length($sig_label) == 0 || $sig_label eq $label)) {
                        $interp->{"signal"} = SIG::NONE;
                    } elsif ($sig == SIG::REDO && (length($sig_label) == 0 || $sig_label eq $label)) {
                        $interp->{"signal"} = SIG::NONE;
                        $should_redo = 1;
                    } else {
                        $body_env->{"parent"} = undef;
                        return $result;
                    }
                }
            }
            if ($should_break) { last; }

            my scalar $cond = eval_bool($interp, $node->{"condition"}, $env);
            if (!$cond) { last; }
        }

        $body_env->{"parent"} = undef;
        return $result;
    }

    # --- Foreach Statement ---
    if ($type == NI::FOREACH_STMT) {
        my str $label = $node->{"label"};
        my scalar $result = undef;
        my scalar $arr = eval_node($interp, $node->{"array"}, $env);
        my int $arr_len = size($arr);

        # Determine iteration variable name
        my str $var_name = "";
        my scalar $var_decl = $node->{"var_decl"};
        if (defined($var_decl) && $var_decl != 0) {
            $var_name = $var_decl->{"name"};
        } else {
            $var_name = $node->{"var_name"};
            if (length($var_name) == 0) {
                $var_name = "_";
            }
        }

        my scalar $body_env = env_new($env);
        my int $fi = 0;
        while ($fi < $arr_len) {
            env_set($body_env, $var_name, $arr->[$fi]);
            env_set($body_env, "_", $arr->[$fi]);

            my int $should_break = 0;
            my int $should_redo = 1;
            while ($should_redo) {
                $should_redo = 0;
                $result = eval_block($interp, $node->{"body"}, $body_env);

                my int $sig = $interp->{"signal"};
                if ($sig != SIG::NONE) {
                    my str $sig_label = $interp->{"signal_label"};
                    if ($sig == SIG::LAST && (length($sig_label) == 0 || $sig_label eq $label)) {
                        $interp->{"signal"} = SIG::NONE;
                        $should_break = 1;
                    } elsif ($sig == SIG::NEXT && (length($sig_label) == 0 || $sig_label eq $label)) {
                        $interp->{"signal"} = SIG::NONE;
                    } elsif ($sig == SIG::REDO && (length($sig_label) == 0 || $sig_label eq $label)) {
                        $interp->{"signal"} = SIG::NONE;
                        $should_redo = 1;
                    } else {
                        $body_env->{"parent"} = undef;
                        return $result;
                    }
                }
            }
            if ($should_break) { last; }

            $fi = $fi + 1;
        }
        $body_env->{"parent"} = undef;

        return $result;
    }

    # --- Last (break) ---
    if ($type == NI::LAST) {
        $interp->{"signal"} = SIG::LAST;
        $interp->{"signal_value"} = undef;
        $interp->{"signal_label"} = $node->{"label"};
        return undef;
    }

    # --- Next (continue) ---
    if ($type == NI::NEXT) {
        $interp->{"signal"} = SIG::NEXT;
        $interp->{"signal_value"} = undef;
        $interp->{"signal_label"} = $node->{"label"};
        return undef;
    }

    # --- Redo ---
    if ($type == NI::REDO) {
        $interp->{"signal"} = SIG::REDO;
        $interp->{"signal_value"} = undef;
        $interp->{"signal_label"} = $node->{"label"};
        return undef;
    }

    # --- Closure Call ($ref->(args)) ---
    if ($type == NI::CLOSURE_CALL) {
        my scalar $closure = eval_node($interp, $node->{"closure"}, $env);
        my scalar $raw_args = $node->{"args"};
        my int $argc = $node->{"arg_count"};

        my array @args = ();
        my int $ai = 0;
        while ($ai < $argc) {
            push(@args, eval_node($interp, $raw_args->[$ai], $env));
            $ai = $ai + 1;
        }

        # Check for __orig_func__ wrapper (from around modifier)
        if (ref($closure) eq "HASH" && exists($closure, "__orig_func__")) {
            return call_user_func($interp, $closure->{"__orig_func__"}, \@args);
        }

        if (ref($closure) eq "HASH" && exists($closure, "params")) {
            # It's a function info hash (from anonymous func)
            return call_user_func($interp, $closure, \@args);
        }

        die("Cannot call non-function value");
    }

    # --- Anonymous Function ---
    if ($type == NI::ANON_FUNC) {
        my hash %fi = ();
        $fi{"params"} = $node->{"params"};
        my int $pc = $node->{"param_count"};
        $fi{"param_count"} = $pc;
        $fi{"body"} = $node->{"body"};
        $fi{"closure_env"} = $env;
        my int $is_va = 0;
        if ($pc > 0) {
            my scalar $lp = $node->{"params"}->[$pc - 1];
            my str $ls = $lp->{"sigil"};
            if ($ls eq "@" || $ls eq "...@") { $is_va = 1; }
        }
        $fi{"is_variadic"} = $is_va;
        return \%fi;
    }

    # --- Range (start..end) ---
    if ($type == NI::RANGE) {
        my int $start = eval_node($interp, $node->{"start"}, $env);
        my int $end = eval_node($interp, $node->{"end"}, $env);
        my array @result = ();
        if ($start <= $end) {
            my int $ri = $start;
            while ($ri <= $end) {
                push(@result, $ri);
                $ri = $ri + 1;
            }
        } else {
            # Descending range
            my int $ri = $start;
            while ($ri >= $end) {
                push(@result, $ri);
                $ri = $ri - 1;
            }
        }
        return \@result;
    }

    # --- Map ---
    if ($type == NI::MAP) {
        my scalar $arr = eval_node($interp, $node->{"array"}, $env);
        my scalar $block = $node->{"block"};
        my int $arr_len = size($arr);
        my array @result = ();
        my int $mi = 0;

        while ($mi < $arr_len) {
            my scalar $map_env = env_new($env);
            env_set($map_env, "_", $arr->[$mi]);
            my scalar $val = eval_block($interp, $block, $map_env);
            $map_env->{"parent"} = undef;
            push(@result, $val);
            $mi = $mi + 1;
        }

        return \@result;
    }

    # --- Grep ---
    if ($type == NI::GREP) {
        my scalar $arr = eval_node($interp, $node->{"array"}, $env);
        my scalar $block = $node->{"block"};
        my int $arr_len = size($arr);
        my array @result = ();
        my int $gi = 0;

        while ($gi < $arr_len) {
            my scalar $grep_env = env_new($env);
            env_set($grep_env, "_", $arr->[$gi]);
            my scalar $val = eval_block($interp, $block, $grep_env);
            $grep_env->{"parent"} = undef;
            if ($val) {
                push(@result, $arr->[$gi]);
            }
            $gi = $gi + 1;
        }

        return \@result;
    }

    # --- Sort ---
    if ($type == NI::SORT) {
        my scalar $arr = eval_node($interp, $node->{"array"}, $env);
        my scalar $block = $node->{"block"};
        my int $srt_has_blk = 0;
        if (defined($block) && $block != 0) { $srt_has_blk = 1; }
        my int $arr_len = size($arr);

        # Copy array for sorting
        my array @sorted = ();
        my int $si = 0;
        while ($si < $arr_len) {
            push(@sorted, $arr->[$si]);
            $si = $si + 1;
        }

        # Simple insertion sort with custom comparator
        my int $oi = 1;
        while ($oi < $arr_len) {
            my scalar $key_val = $sorted[$oi];
            my int $oj = $oi - 1;
            while ($oj >= 0) {
                my int $srt_do_swap = 0;
                if ($srt_has_blk == 1) {
                    my scalar $cmp_env = env_new($env);
                    env_set($cmp_env, "a", $sorted[$oj]);
                    env_set($cmp_env, "b", $key_val);
                    my scalar $cmp_result = eval_block($interp, $block, $cmp_env);
                    $cmp_env->{"parent"} = undef;
                    if ($cmp_result > 0) { $srt_do_swap = 1; }
                } else {
                    if ($sorted[$oj] . "" gt $key_val . "") { $srt_do_swap = 1; }
                }
                if ($srt_do_swap == 1) {
                    $sorted[$oj + 1] = $sorted[$oj];
                    $oj = $oj - 1;
                } else {
                    last;
                }
            }
            $sorted[$oj + 1] = $key_val;
            $oi = $oi + 1;
        }

        return \@sorted;
    }

    # --- Try/Catch ---
    if ($type == NI::TRY_CATCH) {
        my scalar $try_block = $node->{"try_block"};
        my scalar $catch_clauses = $node->{"catch_clauses"};
        my int $catch_count = $node->{"catch_count"};

        try {
            my scalar $try_env = env_new($env);
            return eval_block($interp, $try_block, $try_env);
        } catch ($e) {
            # Don't catch interpreter control flow signals
            if (is_signal($e, "return") || is_signal($e, "last") || is_signal($e, "next") || is_signal($e, "redo")) {
                throw($e);
            }

            # Try each catch clause
            my int $ci = 0;
            while ($ci < $catch_count) {
                my scalar $clause = $catch_clauses->[$ci];
                my str $catch_type = $clause->{"catch_type"};
                my str $catch_var = $clause->{"catch_var"};
                my scalar $catch_block = $clause->{"catch_block"};

                my int $matches = 0;
                if (length($catch_type) == 0) {
                    # Catch-all
                    $matches = 1;
                } elsif (ref($e) eq "HASH" && exists($e, "__class__")) {
                    # Typed catch: check isa (walks inheritance chain)
                    if (interp_isa($interp, $e->{"__class__"}, $catch_type)) {
                        $matches = 1;
                    }
                }

                if ($matches) {
                    my scalar $catch_env = env_new($env);
                    env_set($catch_env, $catch_var, $e);
                    return eval_block($interp, $catch_block, $catch_env);
                }

                $ci = $ci + 1;
            }

            # No catch matched - re-throw
            throw($e);
        }
    }

    # --- Throw ---
    if ($type == NI::THROW) {
        my scalar $val = eval_node($interp, $node->{"expr"}, $env);
        throw($val);
    }

    # --- Destructuring ---
    if ($type == NI::DESTRUCTURE) {
        my scalar $vars = $node->{"vars"};
        my int $var_count = $node->{"var_count"};
        my int $is_decl = $node->{"is_decl"};
        my scalar $init = eval_node($interp, $node->{"init"}, $env);

        my int $di = 0;
        while ($di < $var_count) {
            my scalar $var_info = $vars->[$di];
            my str $vname = $var_info->{"name"};
            my scalar $val = undef;
            if ($di < size($init)) {
                $val = $init->[$di];
            }

            if ($is_decl == 1) {
                env_set($env, $vname, $val);
            } else {
                if (!env_update($env, $vname, $val)) {
                    env_set($env, $vname, $val);
                }
            }
            $di = $di + 1;
        }

        return undef;
    }

    # --- Array Slice ---
    if ($type == NI::ARRAY_SLICE) {
        my scalar $source = eval_node($interp, $node->{"source"}, $env);
        my scalar $items = $node->{"items"};
        my int $item_count = $node->{"item_count"};
        my array @result = ();
        my int $si = 0;
        while ($si < $item_count) {
            my scalar $idx = eval_node($interp, $items->[$si], $env);
            if (ref($idx) eq "ARRAY") {
                # Range result
                my int $ri = 0;
                while ($ri < size($idx)) {
                    push(@result, $source->[$idx->[$ri]]);
                    $ri = $ri + 1;
                }
            } else {
                push(@result, $source->[$idx]);
            }
            $si = $si + 1;
        }
        return \@result;
    }

    # --- Hash Slice ---
    if ($type == NI::HASH_SLICE) {
        my scalar $source = eval_node($interp, $node->{"source"}, $env);
        my scalar $items = $node->{"items"};
        my int $item_count = $node->{"item_count"};
        my array @result = ();
        my int $si = 0;
        while ($si < $item_count) {
            my str $key = eval_node($interp, $items->[$si], $env);
            push(@result, $source->{$key});
            $si = $si + 1;
        }
        return \@result;
    }

    # --- Switch ---
    if ($type == NI::SWITCH) {
        my scalar $expr_val = eval_node($interp, $node->{"expr"}, $env);
        my scalar $cases = $node->{"cases"};
        my scalar $blocks = $node->{"blocks"};
        my int $case_count = $node->{"case_count"};

        my int $ci = 0;
        while ($ci < $case_count) {
            my scalar $case_val = eval_node($interp, $cases->[$ci], $env);
            if (("" . $expr_val) eq ("" . $case_val)) {
                my scalar $case_env = env_new($env);
                return eval_block($interp, $blocks->[$ci], $case_env);
            }
            $ci = $ci + 1;
        }

        if ($node->{"has_default"} == 1) {
            my scalar $def_env = env_new($env);
            return eval_block($interp, $node->{"default_block"}, $def_env);
        }

        return undef;
    }

    # --- Readline (<$fh>) ---
    if ($type == NI::READLINE) {
        my str $varname = $node->{"varname"};
        my scalar $fh = env_get($env, $varname);
        if (defined($fh)) {
            return sys::readline($fh);
        }
        return undef;
    }

    # --- Super Call (SUPER::method(args)) ---
    if ($type == NI::SUPER_CALL) {
        my str $method = $node->{"method"};
        my scalar $raw_args = $node->{"args"};
        my int $argc = $node->{"arg_count"};

        # Get $self from environment
        my scalar $self_obj = env_get($env, "self");
        my str $pkg = "";
        if (defined($self_obj)) {
            $pkg = get_obj_class($self_obj);
        }

        # Build args
        my array @args = [$self_obj];
        if ($argc > 0) {
            my int $ai = 0;
            while ($ai < $argc) {
                push(@args, eval_node($interp, $raw_args->[$ai], $env));
                $ai = $ai + 1;
            }
        }

        # Look up method in parent classes only
        if (length($pkg) > 0 && exists($interp->{"inherits"}, $pkg)) {
            my scalar $parents = $interp->{"inherits"}->{$pkg};
            my int $pi = 0;
            while ($pi < size($parents)) {
                my scalar $fi = interp_resolve_method($interp, $parents->[$pi], $method);
                if (defined($fi)) {
                    return call_user_func($interp, $fi, \@args);
                }
                $pi = $pi + 1;
            }
        }

        die("SUPER::" . $method . " - no parent method found");
    }

    # --- Dynamic Method Call ($obj->$method_var(args)) ---
    if ($type == NI::DYN_METHOD_CALL) {
        my scalar $dm_node = $node->{"base_object"};
        if (!defined($dm_node) || $dm_node == 0) {
            $dm_node = $node->{"object"};
        }
        my scalar $obj = eval_node($interp, $dm_node, $env);
        my str $method = eval_node($interp, $node->{"method_expr"}, $env);
        my scalar $raw_args = $node->{"args"};
        my int $argc = $node->{"arg_count"};

        my array @args = [$obj];
        if ($argc > 0) {
            my int $ai = 0;
            while ($ai < $argc) {
                push(@args, eval_node($interp, $raw_args->[$ai], $env));
                $ai = $ai + 1;
            }
        }

        my str $pkg = get_obj_class($obj);

        my scalar $func_info = undef;
        if (length($pkg) > 0) {
            $func_info = interp_resolve_method($interp, $pkg, $method);
        }
        if (!defined($func_info)) {
            $func_info = interp_get_func($interp, $method);
        }

        if (defined($func_info)) {
            return call_user_func($interp, $func_info, \@args);
        }

        die("Undefined dynamic method: " . $method);
    }

    # --- TR (transliteration $str =~ tr/from/to/) ---
    if ($type == NI::TR) {
        my scalar $target_node = $node->{"target"};
        my str $target_val = eval_node($interp, $target_node, $env);
        my str $search = $node->{"search"};
        my str $repl = $node->{"replace"};
        my str $tr_flags = "";
        if (defined($node->{"flags"})) {
            $tr_flags = $node->{"flags"};
        }

        # Expand ranges in search and replace (a-z -> abc...xyz)
        my str $search_exp = expand_tr_range($search);
        my str $repl_exp = expand_tr_range($repl);

        my int $is_delete = (index($tr_flags, "d") >= 0) ? 1 : 0;
        my int $is_squeeze = (index($tr_flags, "s") >= 0) ? 1 : 0;

        # Build translation: for each char in target, check if in search
        my str $result = "";
        my int $ti = 0;
        my int $tlen = length($target_val);
        my str $last_repl_char = "";
        while ($ti < $tlen) {
            my str $ch = substr($target_val, $ti, 1);
            my int $found_idx = index($search_exp, $ch);
            if ($found_idx >= 0) {
                if ($is_delete == 1 && length($repl_exp) == 0) {
                    # Delete mode: skip the character
                } elsif ($found_idx < length($repl_exp)) {
                    my str $new_ch = substr($repl_exp, $found_idx, 1);
                    if ($is_squeeze == 1 && $new_ch eq $last_repl_char) {
                        # Squeeze: skip consecutive duplicate replacement chars
                    } else {
                        $result = $result . $new_ch;
                        $last_repl_char = $new_ch;
                    }
                } else {
                    # If replacement is shorter, use last char
                    my str $new_ch = substr($repl_exp, length($repl_exp) - 1, 1);
                    if ($is_squeeze == 1 && $new_ch eq $last_repl_char) {
                        # Squeeze: skip consecutive duplicate replacement chars
                    } else {
                        $result = $result . $new_ch;
                        $last_repl_char = $new_ch;
                    }
                }
            } else {
                $result = $result . $ch;
                $last_repl_char = "";
            }
            $ti = $ti + 1;
        }

        assign_to($interp, $target_node, $result, $env);
        return $result;
    }

    # --- Local Declaration (dynamic scoping) ---
    if ($type == NI::LOCAL_DECL) {
        my str $lname = $node->{"name"};
        # Save current value on local stack
        my scalar $old_val = env_get($interp->{"global_env"}, $lname);
        my hash %save = ();
        $save{"name"} = $lname;
        $save{"value"} = $old_val;
        push($interp->{"local_stack"}, \%save);

        # Set new value
        my scalar $init = undef;
        if (defined($node->{"init"}) && $node->{"init"} != 0) {
            $init = eval_node($interp, $node->{"init"}, $env);
        }
        env_set($interp->{"global_env"}, $lname, $init);
        env_set($env, $lname, $init);
        return $init;
    }

    # --- BEGIN/END blocks (handled during load, skip in eval) ---
    if ($type == NI::BEGIN_BLOCK) {
        return undef;
    }
    if ($type == NI::END_BLOCK) {
        return undef;
    }

    # --- Label ---
    if ($type == NI::LABEL) {
        # Labels are handled by the loop constructs via label fields
        return undef;
    }

    # --- Goto ---
    if ($type == NI::GOTO) {
        my str $gt_dest = $node->{"target"};
        throw(make_signal("goto", undef, $gt_dest));
    }

    # --- Async func (treat as regular function in interpreter) ---
    if ($type == NI::ASYNC_FUNC) {
        my hash %fi = ();
        $fi{"params"} = $node->{"params"};
        $fi{"param_count"} = $node->{"param_count"};
        $fi{"body"} = $node->{"body"};
        $fi{"closure_env"} = $env;
        return \%fi;
    }

    # --- Await (in interpreter, just evaluate the expression) ---
    if ($type == NI::AWAIT) {
        return eval_node($interp, $node->{"expr"}, $env);
    }

    # --- C Block (skip in interpreter) ---
    if ($type == NI::C_BLOCK) {
        # __C__ blocks cannot be interpreted
        return undef;
    }

    # --- Capture Variables ($1, $2, ...) ---
    if ($type == NI::CAPTURE_VAR) {
        my int $num = $node->{"number"};
        return captures()[$num];
    }

    # --- Spread (handled by caller) ---
    if ($type == NI::SPREAD) {
        return eval_node($interp, $node->{"target"}, $env);
    }

    die("Unhandled AST node type: " . ast_type_name($type) . " (" . $type . ")");
}

func eval_node(scalar $interp, scalar $node, scalar $env) scalar {
    if (!defined($node)) {
        return undef;
    }

    my int $type = $node->{"type"};

    if ($type > 37) {
        return eval_node_extended($interp, $node, $env, $type);
    }

    # --- Literals ---
    if ($type == NI::INT_LITERAL) {
        return $node->{"value"};
    }
    if ($type == NI::NUM_LITERAL) {
        return $node->{"value"};
    }
    if ($type == NI::STR_LITERAL) {
        return $node->{"value"};
    }

    # --- Variables ---
    if ($type == NI::VARIABLE) {
        my str $name = $node->{"name"};
        # Check constants
        if (exists($interp->{"constants"}, $name)) {
            return $interp->{"constants"}->{$name};
        }
        # Check enums (e.g., "Status::ACTIVE")
        if (exists($interp->{"enums"}, $name)) {
            return $interp->{"enums"}->{$name};
        }
        return env_get($env, $name);
    }

    # --- Variable Declaration ---
    if ($type == NI::VAR_DECL) {
        my str $name = $node->{"name"};
        my int $var_type = $node->{"var_type"};
        my scalar $init = undef;

        if (defined($node->{"init"}) && $node->{"init"} != 0) {
            $init = eval_node($interp, $node->{"init"}, $env);
            # Array variable initialized with empty () produces empty hash from parser;
            # convert to empty array
            if ($var_type == TI::ARRAY && ref($init) eq "HASH" && size(keys($init)) == 0) {
                my array @empty_arr = ();
                $init = \@empty_arr;
            }
            # Convert key-value list/pairs to hash for hash variables
            if ($var_type == TI::HASH && ref($init) eq "ARRAY") {
                my hash %h = ();
                my int $arr_sz = size($init);
                if ($arr_sz > 0 && ref($init->[0]) eq "ARRAY") {
                    # Array of pairs: [["key","val"], ["key2","val2"]]
                    my int $hi = 0;
                    while ($hi < $arr_sz) {
                        my scalar $pair = $init->[$hi];
                        my str $k = $pair->[0];
                        my scalar $v = $pair->[1];
                        $h{$k} = $v;
                        $hi = $hi + 1;
                    }
                } else {
                    # Flat list: ("key", "val", "key2", "val2")
                    my int $hi = 0;
                    while ($hi + 1 < $arr_sz) {
                        my str $k = $init->[$hi];
                        my scalar $v = $init->[$hi + 1];
                        $h{$k} = $v;
                        $hi = $hi + 2;
                    }
                }
                $init = \%h;
            }
        } else {
            if ($var_type == TI::INT) { $init = 0; }
            elsif ($var_type == TI::NUM) { $init = 0.0; }
            elsif ($var_type == TI::STR) { $init = ""; }
            elsif ($var_type == TI::ARRAY) {
                my array @a = ();
                $init = \@a;
            }
            elsif ($var_type == TI::HASH) {
                my hash %h = ();
                $init = \%h;
            }
        }

        env_set($env, $name, $init);
        return $init;
    }

    # --- Block ---
    if ($type == NI::BLOCK) {
        my scalar $new_env = env_new($env);
        return eval_block($interp, $node, $new_env);
    }

    # --- Expression Statement ---
    if ($type == NI::EXPR_STMT) {
        return eval_node($interp, $node->{"expr"}, $env);
    }

    # --- Assignment ---
    if ($type == NI::ASSIGN) {
        my str $op = $node->{"op"};
        my scalar $target = $node->{"target"};
        my scalar $rhs = eval_node($interp, $node->{"value"}, $env);

        if ($op ne "=") {
            my scalar $cur = eval_node($interp, $target, $env);
            if ($op eq "+=") {
                my scalar $ovl = check_overload($interp, $cur, "+");
                if (defined($ovl)) {
                    my array @oa = (); push(@oa, $cur); push(@oa, $rhs); push(@oa, 0);
                    $rhs = call_user_func($interp, $ovl, \@oa);
                } else { $rhs = $cur + $rhs; }
            }
            elsif ($op eq "-=") {
                my scalar $ovl = check_overload($interp, $cur, "-");
                if (defined($ovl)) {
                    my array @oa = (); push(@oa, $cur); push(@oa, $rhs); push(@oa, 0);
                    $rhs = call_user_func($interp, $ovl, \@oa);
                } else { $rhs = $cur - $rhs; }
            }
            elsif ($op eq "*=") {
                my scalar $ovl = check_overload($interp, $cur, "*");
                if (defined($ovl)) {
                    my array @oa = (); push(@oa, $cur); push(@oa, $rhs); push(@oa, 0);
                    $rhs = call_user_func($interp, $ovl, \@oa);
                } else { $rhs = $cur * $rhs; }
            }
            elsif ($op eq "/=") { $rhs = $cur / $rhs; }
            elsif ($op eq "%=") { $rhs = $cur % $rhs; }
            elsif ($op eq ".=") { $rhs = $cur . $rhs; }
            elsif ($op eq "//=") {
                if (defined($cur)) { return $cur; }
            }
        }

        assign_to($interp, $target, $rhs, $env);
        return $rhs;
    }

    # --- Binary Operations ---
    if ($type == NI::BINARY_OP) {
        return eval_binop($interp, $node, $env);
    }

    # --- Unary Operations ---
    if ($type == NI::UNARY_OP) {
        my str $op = $node->{"op"};
        my scalar $val = eval_node($interp, $node->{"operand"}, $env);

        if ($op eq "-") {
            # Check for neg overload
            my scalar $neg_ovl = check_overload($interp, $val, "neg");
            if (defined($neg_ovl)) {
                my array @neg_args = ();
                push(@neg_args, $val);
                return call_user_func($interp, $neg_ovl, \@neg_args);
            }
            return 0 - $val;
        }
        if ($op eq "!") {
            my scalar $not_ovl = check_overload($interp, $val, "!");
            if (defined($not_ovl)) {
                my array @not_args = ();
                push(@not_args, $val);
                return call_user_func($interp, $not_ovl, \@not_args);
            }
            return (!$val) ? 1 : 0;
        }
        if ($op eq "not") { return (!$val) ? 1 : 0; }
        if ($op eq "~") { return ~$val; }
        die("Unknown unary operator: " . $op);
    }

    # --- If Statement ---
    if ($type == NI::IF_STMT) {
        my scalar $cond = eval_bool($interp, $node->{"condition"}, $env);
        if ($cond) {
            my scalar $new_env = env_new($env);
            return eval_block($interp, $node->{"then_block"}, $new_env);
        }

        my int $elsif_count = $node->{"elsif_count"};
        my int $ei = 0;
        while ($ei < $elsif_count) {
            my scalar $econd = eval_bool($interp, $node->{"elsif_conditions"}->[$ei], $env);
            if ($econd) {
                my scalar $new_env = env_new($env);
                return eval_block($interp, $node->{"elsif_blocks"}->[$ei], $new_env);
            }
            $ei = $ei + 1;
        }

        if (defined($node->{"else_block"}) && $node->{"else_block"} != 0) {
            my scalar $new_env = env_new($env);
            return eval_block($interp, $node->{"else_block"}, $new_env);
        }

        return undef;
    }

    # --- While Statement ---
    if ($type == NI::WHILE_STMT) {
        my str $label = $node->{"label"};
        my scalar $result = undef;
        my scalar $body_env = env_new($env);

        while (1) {
            my scalar $cond = eval_bool($interp, $node->{"condition"}, $env);
            if (!$cond) { last; }

            my int $should_break = 0;
            my int $should_redo = 1;
            while ($should_redo) {
                $should_redo = 0;
                $result = eval_block($interp, $node->{"body"}, $body_env);

                # Check for loop signals
                my int $sig = $interp->{"signal"};
                if ($sig != SIG::NONE) {
                    my str $sig_label = $interp->{"signal_label"};
                    if ($sig == SIG::LAST && (length($sig_label) == 0 || $sig_label eq $label)) {
                        $interp->{"signal"} = SIG::NONE;
                        $should_break = 1;
                    } elsif ($sig == SIG::NEXT && (length($sig_label) == 0 || $sig_label eq $label)) {
                        $interp->{"signal"} = SIG::NONE;
                    } elsif ($sig == SIG::REDO && (length($sig_label) == 0 || $sig_label eq $label)) {
                        $interp->{"signal"} = SIG::NONE;
                        $should_redo = 1;
                    } else {
                        # Signal not for us (return or labeled for outer loop) - propagate
                        $body_env->{"parent"} = undef;
                        return $result;
                    }
                }
            }
            if ($should_break) { last; }
        }

        $body_env->{"parent"} = undef;
        return $result;
    }

    # --- For Statement ---
    if ($type == NI::FOR_STMT) {
        my str $label = $node->{"label"};
        my scalar $result = undef;
        my scalar $for_env = env_new($env);

        # Init
        if (defined($node->{"init"}) && $node->{"init"} != 0) {
            eval_node($interp, $node->{"init"}, $for_env);
        }

        while (1) {
            # Condition
            if (defined($node->{"condition"}) && $node->{"condition"} != 0) {
                my scalar $cond = eval_node($interp, $node->{"condition"}, $for_env);
                if (!$cond) { last; }
            }

            # Body - reuse for_env for body (no separate body_env needed)
            my int $should_break = 0;
            my int $should_redo = 1;
            while ($should_redo) {
                $should_redo = 0;
                $result = eval_block($interp, $node->{"body"}, $for_env);

                my int $sig = $interp->{"signal"};
                if ($sig != SIG::NONE) {
                    my str $sig_label = $interp->{"signal_label"};
                    if ($sig == SIG::LAST && (length($sig_label) == 0 || $sig_label eq $label)) {
                        $interp->{"signal"} = SIG::NONE;
                        $should_break = 1;
                    } elsif ($sig == SIG::NEXT && (length($sig_label) == 0 || $sig_label eq $label)) {
                        $interp->{"signal"} = SIG::NONE;
                    } elsif ($sig == SIG::REDO && (length($sig_label) == 0 || $sig_label eq $label)) {
                        $interp->{"signal"} = SIG::NONE;
                        $should_redo = 1;
                    } else {
                        $for_env->{"parent"} = undef;
                        return $result;
                    }
                }
            }
            if ($should_break) { last; }

            # Update
            if (defined($node->{"update"}) && $node->{"update"} != 0) {
                eval_node($interp, $node->{"update"}, $for_env);
            }
        }

        $for_env->{"parent"} = undef;
        return $result;
    }

    # --- Return Statement ---
    if ($type == NI::RETURN_STMT) {
        my scalar $val = undef;
        if (defined($node->{"value"}) && $node->{"value"} != 0) {
            $val = eval_node($interp, $node->{"value"}, $env);
        }
        $interp->{"signal"} = SIG::RETURN;
        $interp->{"signal_value"} = $val;
        $interp->{"signal_label"} = "";
        return undef;
    }

    # --- Function Call ---
    if ($type == NI::CALL) {
        my str $name = $node->{"name"};
        my scalar $raw_args = $node->{"args"};
        my int $argc = $node->{"arg_count"};

        # Special handling for delete($hash{$key}) - single hash-access arg
        if ($name eq "delete" && $argc == 1) {
            my scalar $del_arg = $raw_args->[0];
            if (defined($del_arg)) {
                my int $del_type = $del_arg->{"type"};
                if ($del_type == NI::HASH_ACCESS) {
                    my scalar $del_hash = eval_node($interp, $del_arg->{"hash"}, $env);
                    my scalar $del_key = eval_node($interp, $del_arg->{"key"}, $env);
                    delete($del_hash, $del_key);
                    return undef;
                }
                if ($del_type == NI::DEREF_HASH) {
                    my scalar $del_hash = eval_node($interp, $del_arg->{"target"}, $env);
                    my scalar $del_key = eval_node($interp, $del_arg->{"key"}, $env);
                    delete($del_hash, $del_key);
                    return undef;
                }
            }
        }

        # Special handling for exists($hash{$key}) - single hash-access arg
        if ($name eq "exists" && $argc == 1) {
            my scalar $ex_arg = $raw_args->[0];
            if (defined($ex_arg)) {
                my int $ex_type = $ex_arg->{"type"};
                if ($ex_type == NI::HASH_ACCESS) {
                    my scalar $ex_hash = eval_node($interp, $ex_arg->{"hash"}, $env);
                    my scalar $ex_key = eval_node($interp, $ex_arg->{"key"}, $env);
                    return exists($ex_hash, $ex_key) ? 1 : 0;
                }
                if ($ex_type == NI::DEREF_HASH) {
                    my scalar $ex_hash = eval_node($interp, $ex_arg->{"target"}, $env);
                    my scalar $ex_key = eval_node($interp, $ex_arg->{"key"}, $env);
                    return exists($ex_hash, $ex_key) ? 1 : 0;
                }
            }
        }

        # Evaluate arguments (handle spread)
        my array @args = ();
        my int $ai = 0;
        while ($ai < $argc) {
            my scalar $arg_node = $raw_args->[$ai];
            if (defined($arg_node) && $arg_node->{"type"} == NI::SPREAD) {
                # Spread: expand array into args
                my scalar $spread_val = eval_node($interp, $arg_node->{"target"}, $env);
                my int $slen = size($spread_val);
                my int $si = 0;
                while ($si < $slen) {
                    push(@args, $spread_val->[$si]);
                    $si = $si + 1;
                }
            } else {
                push(@args, eval_node($interp, $arg_node, $env));
            }
            $ai = $ai + 1;
        }

        # Check enums (e.g., Color::RED)
        if (exists($interp->{"enums"}, $name)) {
            return $interp->{"enums"}->{$name};
        }

        # Check builtins
        if (is_builtin($interp, $name)) {
            return call_builtin($interp, $name, \@args, $env);
        }

        # Check user-defined functions
        my scalar $func_info = interp_get_func($interp, $name);
        if (defined($func_info)) {
            return call_user_func($interp, $func_info, \@args);
        }

        # Try Pkg::func -> Pkg_func (package-qualified calls)
        if (index($name, "::") >= 0) {
            my str $sanitized = sanitize_name($name);
            $func_info = interp_get_func($interp, $sanitized);
            if (defined($func_info)) {
                return call_user_func($interp, $func_info, \@args);
            }

            # Check native functions (import_lib)
            if (exists($interp->{"native_funcs"}, $sanitized)) {
                my scalar $nf = $interp->{"native_funcs"}->{$sanitized};
                return call_native($interp, $nf, \@args);
            }
        }

        # Check native functions by original name
        if (exists($interp->{"native_funcs"}, $name)) {
            my scalar $nf = $interp->{"native_funcs"}->{$name};
            return call_native($interp, $nf, \@args);
        }

        # Try finding function with package prefix (e.g., add -> Math_Utils_add)
        my str $suffix = "_" . $name;
        my scalar $fkeys = keys($interp->{"functions"});
        my int $fki = 0;
        while ($fki < size($fkeys)) {
            my str $fk = $fkeys->[$fki];
            if (length($fk) > length($suffix) && substr($fk, length($fk) - length($suffix), length($suffix)) eq $suffix) {
                return call_user_func($interp, $interp->{"functions"}->{$fk}, \@args);
            }
            $fki = $fki + 1;
        }

        die("Undefined function: " . $name);
    }

    # --- Method Call ($obj->method(args)) ---
    if ($type == NI::METHOD_CALL) {
        # Use base_object (the original receiver) instead of object (which may be FIELD_ACCESS)
        my scalar $obj_node = $node->{"base_object"};
        if (!defined($obj_node) || $obj_node == 0) {
            $obj_node = $node->{"object"};
        }
        my scalar $obj = eval_node($interp, $obj_node, $env);
        my str $method = $node->{"method"};
        my scalar $raw_args = $node->{"args"};
        my int $argc = $node->{"arg_count"};

        # Build args: $self + explicit args
        # Fast path for zero-arg method calls (e.g., $obj->x(), $obj->name())
        my array @args = [$obj];
        if ($argc > 0) {
            my int $ai = 0;
            while ($ai < $argc) {
                my scalar $arg_node = $raw_args->[$ai];
                if (defined($arg_node) && $arg_node->{"type"} == NI::SPREAD) {
                    my scalar $spread_val = eval_node($interp, $arg_node->{"target"}, $env);
                    my int $slen = size($spread_val);
                    my int $si = 0;
                    while ($si < $slen) {
                        push(@args, $spread_val->[$si]);
                        $si = $si + 1;
                    }
                } else {
                    push(@args, eval_node($interp, $arg_node, $env));
                }
                $ai = $ai + 1;
            }
        }

        # Get object's class
        my str $pkg = get_obj_class($obj);
        # Also check for C runtime blessing (from compiled .so objects)
        if (length($pkg) == 0) {
            my str $ref_type = ref($obj);
            if ($ref_type ne "HASH" && $ref_type ne "ARRAY" && $ref_type ne "" && $ref_type ne "0") {
                $pkg = $ref_type;
            }
        }

        # Handle isa() special method
        if ($method eq "isa") {
            if (length($pkg) > 0 && $argc >= 1) {
                my str $target_class = $args->[1];
                return interp_isa($interp, $pkg, $target_class) ? 1 : 0;
            }
            return 0;
        }

        # Handle can() special method
        if ($method eq "can") {
            if (length($pkg) > 0 && $argc >= 1) {
                my str $target_method = $args->[1];
                my scalar $found = interp_resolve_method($interp, $pkg, $target_method);
                return defined($found) ? 1 : 0;
            }
            return 0;
        }

        # ---- BigInt method overrides (C-backed) ----
        if ($pkg eq "BigInt") {
            if ($method eq "add") {
                my scalar $other = $args->[1];
                my int $sa = $obj->{"s"};
                my int $sb = $other->{"s"};
                my str $va = $obj->{"v"};
                my str $vb = $other->{"v"};
                my hash %r = ();
                if ($sa == $sb) {
                    $r{"s"} = $sa;
                    $r{"v"} = call_builtin($interp, "BigInt::_bi_add", [$va, $vb], $env);
                } else {
                    my int $mc = call_builtin($interp, "BigInt::_bi_cmp", [$va, $vb], $env);
                    if ($mc == 0) {
                        $r{"s"} = 1; $r{"v"} = "0";
                    } elsif ($mc > 0) {
                        $r{"s"} = $sa;
                        $r{"v"} = call_builtin($interp, "BigInt::_bi_sub", [$va, $vb], $env);
                    } else {
                        $r{"s"} = $sb;
                        $r{"v"} = call_builtin($interp, "BigInt::_bi_sub", [$vb, $va], $env);
                    }
                }
                if ($r{"v"} eq "0") { $r{"s"} = 1; }
                return bless(\%r, "BigInt");
            }
            # sub/neg/pow/etc. - fall through to user-defined functions
            # (sub calls neg+add, pow calls mul - all intercepted above)
            if ($method eq "compare") {
                my scalar $other = $args->[1];
                my int $sa = $obj->{"s"};
                my int $sb = $other->{"s"};
                if ($obj->{"v"} eq "0" && $other->{"v"} eq "0") { return 0; }
                if ($sa > 0 && $sb < 0) { return 1; }
                if ($sa < 0 && $sb > 0) { return -1; }
                my int $mc = call_builtin($interp, "BigInt::_bi_cmp", [$obj->{"v"}, $other->{"v"}], $env);
                if ($sa > 0) { return $mc; }
                return 0 - $mc;
            }
            if ($method eq "mul") {
                my scalar $other = $args->[1];
                my str $va = $obj->{"v"};
                my str $vb = $other->{"v"};
                my hash %r = ();
                if ($va eq "0" || $vb eq "0") {
                    $r{"s"} = 1; $r{"v"} = "0";
                } else {
                    $r{"v"} = call_builtin($interp, "BigInt::_bi_mul", [$va, $vb], $env);
                    $r{"s"} = ($obj->{"s"} != $other->{"s"}) ? -1 : 1;
                }
                return bless(\%r, "BigInt");
            }
            if ($method eq "div") {
                my scalar $other = $args->[1];
                my str $va = $obj->{"v"};
                my str $vb = $other->{"v"};
                if ($vb eq "0") { die("BigInt: division by zero"); }
                my hash %r = ();
                if ($va eq "0") { $r{"s"} = 1; $r{"v"} = "0"; }
                else {
                    $r{"v"} = call_builtin($interp, "BigInt::_bi_divmod", [$va, $vb], $env);
                    $r{"s"} = ($obj->{"s"} != $other->{"s"} && $r{"v"} ne "0") ? -1 : 1;
                }
                return bless(\%r, "BigInt");
            }
            if ($method eq "mod") {
                my scalar $other = $args->[1];
                my str $va = $obj->{"v"};
                my str $vb = $other->{"v"};
                if ($vb eq "0") { die("BigInt: modulo by zero"); }
                my hash %r = ();
                my scalar $dr = call_builtin($interp, "BigInt::_bi_divmod_rem", [$va, $vb], $env);
                $r{"v"} = $dr->[1];
                $r{"s"} = $obj->{"s"};
                if ($r{"v"} eq "0") { $r{"s"} = 1; }
                return bless(\%r, "BigInt");
            }
        }

        # ---- BigFloat method overrides (C-backed) ----
        if ($pkg eq "BigFloat") {
            if ($method eq "add") {
                my scalar $other = $args->[1];
                my int $sa = $obj->{"s"};
                my int $sb = $other->{"s"};
                my str $ma = $obj->{"m"};
                my str $mb = $other->{"m"};
                my int $sca = $obj->{"e"};
                my int $scb = $other->{"e"};
                # Align scales
                if ($sca > $scb) {
                    $mb = call_builtin($interp, "BigFloat::_bf_pad_right", [$mb, $sca - $scb], $env);
                    $scb = $sca;
                } elsif ($scb > $sca) {
                    $ma = call_builtin($interp, "BigFloat::_bf_pad_right", [$ma, $scb - $sca], $env);
                    $sca = $scb;
                }
                my hash %r = ();
                my int $rscale = $sca;
                if ($sa == $sb) {
                    $r{"s"} = $sa;
                    $r{"m"} = call_builtin($interp, "BigInt::_bi_add", [$ma, $mb], $env);
                } else {
                    my int $mc = call_builtin($interp, "BigInt::_bi_cmp", [$ma, $mb], $env);
                    if ($mc == 0) { $r{"s"} = 1; $r{"m"} = "0"; }
                    elsif ($mc > 0) {
                        $r{"s"} = $sa;
                        $r{"m"} = call_builtin($interp, "BigInt::_bi_sub", [$ma, $mb], $env);
                    } else {
                        $r{"s"} = $sb;
                        $r{"m"} = call_builtin($interp, "BigInt::_bi_sub", [$mb, $ma], $env);
                    }
                }
                # Normalize
                my scalar $norm = call_builtin($interp, "BigFloat::_bf_normalize", [$r{"m"}, $rscale], $env);
                $r{"m"} = $norm->[0];
                $r{"e"} = $norm->[1];
                if ($r{"m"} eq "0") { $r{"s"} = 1; }
                return bless(\%r, "BigFloat");
            }
            if ($method eq "mul") {
                my scalar $other = $args->[1];
                my str $ma = $obj->{"m"};
                my str $mb = $other->{"m"};
                my hash %r = ();
                if ($ma eq "0" || $mb eq "0") {
                    $r{"s"} = 1; $r{"m"} = "0"; $r{"e"} = 0;
                } else {
                    my str $rm = call_builtin($interp, "BigInt::_bi_mul", [$ma, $mb], $env);
                    my int $rscale = $obj->{"e"} + $other->{"e"};
                    my scalar $norm = call_builtin($interp, "BigFloat::_bf_normalize", [$rm, $rscale], $env);
                    $r{"m"} = $norm->[0];
                    $r{"e"} = $norm->[1];
                    $r{"s"} = ($obj->{"s"} != $other->{"s"}) ? -1 : 1;
                }
                return bless(\%r, "BigFloat");
            }
            if ($method eq "div" || $method eq "div_precision") {
                my scalar $other = $args->[1];
                my int $precision = 20;
                if ($method eq "div_precision" && size($args) > 2) {
                    $precision = $args->[2];
                }
                my str $ma = $obj->{"m"};
                my str $mb = $other->{"m"};
                if ($mb eq "0") { die("BigFloat: division by zero"); }
                my hash %r = ();
                if ($ma eq "0") {
                    $r{"s"} = 1; $r{"m"} = "0"; $r{"e"} = 0;
                } else {
                    # Scale dividend for precision
                    my int $extra = $precision + $other->{"e"} - $obj->{"e"};
                    my str $scaled_a = $ma;
                    if ($extra > 0) {
                        $scaled_a = call_builtin($interp, "BigFloat::_bf_pad_right", [$ma, $extra], $env);
                    }
                    my str $q = call_builtin($interp, "BigInt::_bi_divmod", [$scaled_a, $mb], $env);
                    my int $rscale = $precision;
                    my scalar $norm = call_builtin($interp, "BigFloat::_bf_normalize", [$q, $rscale], $env);
                    $r{"m"} = $norm->[0];
                    $r{"e"} = $norm->[1];
                    $r{"s"} = ($obj->{"s"} != $other->{"s"} && $r{"m"} ne "0") ? -1 : 1;
                }
                return bless(\%r, "BigFloat");
            }
            if ($method eq "compare") {
                my scalar $other = $args->[1];
                my int $sa = $obj->{"s"};
                my int $sb = $other->{"s"};
                if ($obj->{"m"} eq "0" && $other->{"m"} eq "0") { return 0; }
                if ($sa > 0 && $sb < 0) { return 1; }
                if ($sa < 0 && $sb > 0) { return -1; }
                # Align scales for comparison
                my str $ma = $obj->{"m"};
                my str $mb = $other->{"m"};
                my int $sca = $obj->{"e"};
                my int $scb = $other->{"e"};
                if ($sca > $scb) {
                    $mb = call_builtin($interp, "BigFloat::_bf_pad_right", [$mb, $sca - $scb], $env);
                } elsif ($scb > $sca) {
                    $ma = call_builtin($interp, "BigFloat::_bf_pad_right", [$ma, $scb - $sca], $env);
                }
                my int $mc = call_builtin($interp, "BigInt::_bi_cmp", [$ma, $mb], $env);
                if ($sa > 0) { return $mc; }
                return 0 - $mc;
            }
            if ($method eq "round") {
                my int $places = $args->[1];
                my str $m = $obj->{"m"};
                my int $scale = $obj->{"e"};
                if ($scale <= $places) {
                    # Clone
                    my hash %c = ();
                    $c{"s"} = $obj->{"s"}; $c{"m"} = "" . $m; $c{"e"} = $scale;
                    return bless(\%c, "BigFloat");
                }
                my int $trim = $scale - $places;
                my int $mlen = length($m);
                if ($trim >= $mlen) {
                    return call_builtin($interp, "BigFloat::new", ["0"], $env);
                }
                my str $kept = substr($m, 0, $mlen - $trim);
                my str $digit_str = substr($m, $mlen - $trim, 1);
                my int $round_digit = cast_int($digit_str);
                if ($round_digit >= 5) {
                    $kept = call_builtin($interp, "BigInt::_bi_add", [$kept, "1"], $env);
                }
                my scalar $norm = call_builtin($interp, "BigFloat::_bf_normalize", [$kept, $places], $env);
                my hash %r = ();
                $r{"s"} = $obj->{"s"};
                $r{"m"} = $norm->[0];
                $r{"e"} = $norm->[1];
                if ($r{"m"} eq "0") { $r{"s"} = 1; }
                return bless(\%r, "BigFloat");
            }
            # sub/neg/abs/etc. - fall through to user-defined functions
        }

        # Resolve method through inheritance chain
        my scalar $func_info = undef;
        if (length($pkg) > 0) {
            $func_info = interp_resolve_method($interp, $pkg, $method);
        }
        if (!defined($func_info)) {
            $func_info = interp_get_func($interp, $method);
        }

        # Try native functions (import_lib) as fallback
        if (!defined($func_info) && length($pkg) > 0) {
            my str $native_name = $pkg . "_" . $method;
            if (exists($interp->{"native_funcs"}, $native_name)) {
                my scalar $nf = $interp->{"native_funcs"}->{$native_name};
                return call_native($interp, $nf, \@args);
            }
        }

        # Try AUTOLOAD as fallback (walk inheritance chain)
        if (!defined($func_info) && length($pkg) > 0) {
            my scalar $al_func = undef;
            # Check own package
            if (exists($interp->{"autoloads"}, $pkg)) {
                $al_func = $interp->{"autoloads"}->{$pkg};
            }
            # Walk inheritance chain for AUTOLOAD
            if (!defined($al_func) && exists($interp->{"inherits"}, $pkg)) {
                my scalar $al_parents = $interp->{"inherits"}->{$pkg};
                my int $api = 0;
                while ($api < size($al_parents) && !defined($al_func)) {
                    my str $ap = $al_parents->[$api];
                    if (exists($interp->{"autoloads"}, $ap)) {
                        $al_func = $interp->{"autoloads"}->{$ap};
                    }
                    $api = $api + 1;
                }
            }
            if (defined($al_func)) {
                # AUTOLOAD receives method name as first additional arg
                my array @al_args = ();
                push(@al_args, $obj);
                push(@al_args, $method);
                my int $ali = 1;
                while ($ali < size(\@args)) {
                    push(@al_args, $args[$ali]);
                    $ali = $ali + 1;
                }
                return call_user_func($interp, $al_func, \@al_args);
            }
        }

        if (defined($func_info)) {
            # Check for before/after modifiers
            my int $mod_count = size($interp->{"method_modifiers"});

            # Fast path: no modifiers (common case), skip all modifier loops
            if ($mod_count == 0) {
                return call_user_func($interp, $func_info, \@args);
            }

            my scalar $mods = $interp->{"method_modifiers"};

            # Execute before modifiers
            my int $mi = 0;
            while ($mi < $mod_count) {
                my scalar $mod = $mods->[$mi];
                if ($mod->{"mod_type"} eq "before" && $mod->{"method_name"} eq $method && $mod->{"package"} eq $pkg) {
                    my scalar $mod_fi = $mod->{"func_info"};
                    if (defined($mod_fi)) {
                        call_user_func($interp, $mod_fi, \@args);
                    }
                }
                $mi = $mi + 1;
            }

            # Execute around modifiers (wraps the actual call)
            $mi = 0;
            while ($mi < $mod_count) {
                my scalar $mod = $mods->[$mi];
                if ($mod->{"mod_type"} eq "around" && $mod->{"method_name"} eq $method && $mod->{"package"} eq $pkg) {
                    my scalar $mod_fi = $mod->{"func_info"};
                    if (defined($mod_fi)) {
                        # Build a closure-like wrapper for $orig
                        my hash %orig = ();
                        $orig{"__orig_func__"} = $func_info;
                        my array @around_args = ();
                        push(@around_args, $args[0]);
                        push(@around_args, \%orig);
                        my int $aai = 1;
                        while ($aai < size(\@args)) {
                            push(@around_args, $args[$aai]);
                            $aai = $aai + 1;
                        }
                        return call_user_func($interp, $mod_fi, \@around_args);
                    }
                }
                $mi = $mi + 1;
            }

            # Call the actual method
            my scalar $result = call_user_func($interp, $func_info, \@args);

            # Execute after modifiers
            $mi = 0;
            while ($mi < $mod_count) {
                my scalar $mod = $mods->[$mi];
                if ($mod->{"mod_type"} eq "after" && $mod->{"method_name"} eq $method && $mod->{"package"} eq $pkg) {
                    my scalar $mod_fi = $mod->{"func_info"};
                    if (defined($mod_fi)) {
                        call_user_func($interp, $mod_fi, \@args);
                    }
                }
                $mi = $mi + 1;
            }

            return $result;
        }

        die("Undefined method: " . $method . " on " . (length($pkg) > 0 ? $pkg : "unblessed reference"));
    }

    # --- Array Subscript ---
    if ($type == NI::SUBSCRIPT) {
        my scalar $arr = eval_node($interp, $node->{"array"}, $env);
        my int $idx = eval_node($interp, $node->{"index"}, $env);
        if ($idx < 0) {
            $idx = size($arr) + $idx;
        }
        return $arr->[$idx];
    }

    # --- Hash Access ---
    if ($type == NI::HASH_ACCESS) {
        my scalar $hash_val = eval_node($interp, $node->{"hash"}, $env);
        my str $key = eval_node($interp, $node->{"key"}, $env);
        # Check for tied hash FETCH
        if (ref($hash_val) eq "HASH" && exists($hash_val, "__tied__")) {
            my scalar $tie_obj = $hash_val->{"__tied__"};
            my str $tie_pkg = $tie_obj->{"__class__"};
            if (length($tie_pkg) > 0) {
                my scalar $fetch_fn = interp_resolve_method($interp, $tie_pkg, "FETCH");
                if (defined($fetch_fn)) {
                    my array @fetch_args = ();
                    push(@fetch_args, $tie_obj);
                    push(@fetch_args, $key);
                    return call_user_func($interp, $fetch_fn, \@fetch_args);
                }
            }
        }
        return $hash_val->{$key};
    }

    # --- Deref Hash ($ref->{key}) ---
    if ($type == NI::DEREF_HASH) {
        my scalar $ref_val = eval_node($interp, $node->{"ref"}, $env);
        my str $key = eval_node($interp, $node->{"key"}, $env);
        return $ref_val->{$key};
    }

    # --- Deref Array ($ref->[idx]) ---
    if ($type == NI::DEREF_ARRAY) {
        my scalar $ref_val = eval_node($interp, $node->{"ref"}, $env);
        my int $idx = eval_node($interp, $node->{"index"}, $env);
        if ($idx < 0) {
            $idx = size($ref_val) + $idx;
        }
        return $ref_val->[$idx];
    }

    # --- Deref Scalar ($$ref, @$ref, %$ref) ---
    if ($type == NI::DEREF_SCALAR) {
        my scalar $ref_val = eval_node($interp, $node->{"ref"}, $env);
        return $ref_val;
    }

    # --- Reference (\$var, \@arr, \%hash) ---
    if ($type == NI::REF) {
        my scalar $target = $node->{"target"};
        my str $ref_type = $node->{"ref_type"};

        # For variable references, return the value (already a reference in our model)
        my scalar $val = eval_node($interp, $target, $env);
        if ($ref_type eq "scalar" || $ref_type eq "array" || $ref_type eq "hash") {
            return $val;
        }
        return $val;
    }

    # --- Anonymous Hash ---
    if ($type == NI::ANON_HASH) {
        my hash %result = ();
        my scalar $keys_arr = $node->{"keys"};
        my scalar $values_arr = $node->{"values"};
        my scalar $key_exprs = $node->{"key_exprs"};
        my int $pair_count = $node->{"pair_count"};
        my int $hi = 0;

        while ($hi < $pair_count) {
            my str $key = "";
            if (defined($key_exprs->[$hi]) && $key_exprs->[$hi] != 0) {
                $key = eval_node($interp, $key_exprs->[$hi], $env);
            } else {
                $key = $keys_arr->[$hi];
            }
            my scalar $val = eval_node($interp, $values_arr->[$hi], $env);
            $result{$key} = $val;
            $hi = $hi + 1;
        }

        return \%result;
    }

    # --- Anonymous Array ---
    if ($type == NI::ANON_ARRAY) {
        my array @result = ();
        my scalar $elems = $node->{"elements"};
        my int $elem_count = $node->{"element_count"};
        my int $ai = 0;

        while ($ai < $elem_count) {
            my scalar $elem = $elems->[$ai];
            if (defined($elem) && $elem->{"type"} == NI::SPREAD) {
                my scalar $spread_val = eval_node($interp, $elem->{"target"}, $env);
                my int $slen = size($spread_val);
                my int $si = 0;
                while ($si < $slen) {
                    push(@result, $spread_val->[$si]);
                    $si = $si + 1;
                }
            } else {
                push(@result, eval_node($interp, $elem, $env));
            }
            $ai = $ai + 1;
        }

        return \@result;
    }

    # --- Function Reference (\&func) ---
    if ($type == NI::FUNC_REF) {
        my str $fname = $node->{"name"};
        my scalar $func_info = interp_get_func($interp, $fname);
        if (defined($func_info)) {
            return $func_info;
        }
        die("Undefined function for reference: " . $fname);
    }

    # --- Regex Match ---
    if ($type == NI::REGEX_MATCH) {
        my scalar $target = eval_node($interp, $node->{"target"}, $env);
        my str $pattern = $node->{"pattern"};
        my str $flags = $node->{"flags"};
        my str $op = $node->{"op"};

        # Apply flags: build pattern with inline modifiers if flags present
        my str $effective_pattern = $pattern;
        if (length($flags) > 0) {
            $effective_pattern = "(?" . $flags . ")" . $pattern;
        }

        my int $result = match($target, $effective_pattern);
        if ($op eq "!~") {
            return (!$result) ? 1 : 0;
        }
        return $result ? 1 : 0;
    }

    # --- Regex Substitution ---
    if ($type == NI::REGEX_SUBST) {
        my scalar $target_node = $node->{"target"};
        my str $target_val = eval_node($interp, $target_node, $env);
        my str $pattern = $node->{"pattern"};
        my str $replacement = $node->{"replacement"};
        my str $flags = $node->{"flags"};

        my int $is_global = 0;
        my int $is_eval = 0;

        # Apply flags
        my str $effective_pattern = $pattern;
        if (length($flags) > 0) {
            my str $inline_flags = "";
            my int $fli = 0;
            while ($fli < length($flags)) {
                my str $fc = substr($flags, $fli, 1);
                if ($fc eq "g") {
                    $is_global = 1;
                } elsif ($fc eq "e") {
                    $is_eval = 1;
                } else {
                    $inline_flags = $inline_flags . $fc;
                }
                $fli = $fli + 1;
            }
            if (length($inline_flags) > 0) {
                $effective_pattern = "(?" . $inline_flags . ")" . $pattern;
            }
        }

        my str $result = $target_val;
        if ($is_eval) {
            # /e flag: evaluate replacement as expression for each match
            my scalar $repl_node = $node->{"replacement_node"};

            # Pre-parse replacement string into a callable function (if no AST node)
            my scalar $parsed_repl_fn = undef;
            if (!defined($repl_node)) {
                my str $repl_code = "func __repl__() scalar { return " . $replacement . "; }";
                my scalar $repl_tokens = lex_tokenize($repl_code);
                my scalar $repl_parser = parser_new($repl_tokens);
                my array @re = ();
                my scalar $repl_prog = parse_program($repl_parser, \@re, \@re);
                $parsed_repl_fn = $repl_prog->{"functions"}->[0];
            }

            if ($is_global) {
                # Global eval: match on remaining text, build result piece by piece
                my str $remaining = $result;
                my str $built = "";
                my int $safety = 0;
                while ($safety < 1000 && match($remaining, $effective_pattern)) {
                    my scalar $caps = captures();
                    my str $full_match = $caps->[0];
                    my int $match_len = length($full_match);
                    if ($match_len == 0) { last; }

                    my int $pos = index($remaining, $full_match);
                    if ($pos < 0) { last; }

                    # Add text before match
                    if ($pos > 0) {
                        $built = $built . substr($remaining, 0, $pos);
                    }

                    # Evaluate replacement expression
                    my scalar $eval_result = undef;
                    if (defined($repl_node)) {
                        $eval_result = eval_node($interp, $repl_node, $env);
                    } else {
                        my array @empty_args = ();
                        $eval_result = call_user_func($interp, {"params" => $parsed_repl_fn->{"params"}, "param_count" => $parsed_repl_fn->{"param_count"}, "body" => $parsed_repl_fn->{"body"}, "closure_env" => $env}, \@empty_args);
                    }
                    my str $eval_str = defined($eval_result) ? "" . $eval_result : "";
                    $built = $built . $eval_str;

                    # Advance past match
                    $remaining = substr($remaining, $pos + $match_len);
                    $safety = $safety + 1;
                }
                $result = $built . $remaining;
            } else {
                # Single eval replacement
                if (match($result, $effective_pattern)) {
                    my scalar $caps = captures();
                    my str $full_match = $caps->[0];
                    my int $match_len = length($full_match);

                    my scalar $eval_result = undef;
                    if (defined($repl_node)) {
                        $eval_result = eval_node($interp, $repl_node, $env);
                    } else {
                        my array @empty_args = ();
                        $eval_result = call_user_func($interp, {"params" => $parsed_repl_fn->{"params"}, "param_count" => $parsed_repl_fn->{"param_count"}, "body" => $parsed_repl_fn->{"body"}, "closure_env" => $env}, \@empty_args);
                    }
                    my str $eval_str = defined($eval_result) ? "" . $eval_result : "";

                    # Find position and replace just the matched text
                    my int $pos = index($result, $full_match);
                    if ($pos >= 0) {
                        $result = substr($result, 0, $pos) . $eval_str . substr($result, $pos + $match_len);
                    }
                }
            }
        } else {
            if ($is_global) {
                my str $sg_str = $target_val;
                my str $sg_pat = $effective_pattern;
                my str $sg_rep = $replacement;
                __C__ {
                    char *s = strada_to_str(sg_str);
                    char *p = strada_to_str(sg_pat);
                    char *r = strada_to_str(sg_rep);
                    char *res = strada_regex_replace_all(s, p, r, NULL);
                    strada_decref(result);
                    result = strada_new_str(res);
                    free(res);
                    free(r);
                    free(p);
                    free(s);
                }
            } else {
                $result = replace($target_val, $effective_pattern, $replacement);
            }
        }
        assign_to($interp, $target_node, $result, $env);
        return $result;
    }

    # --- __PACKAGE__ ---
    if ($type == NI::DUNDER_PACKAGE) {
        return $interp->{"package"};
    }

    # --- __FILE__ ---
    if ($type == NI::DUNDER_FILE) {
        return $interp->{"filename"};
    }

    # --- __LINE__ ---
    if ($type == NI::DUNDER_LINE) {
        return $node->{"line_value"};
    }

    # --- Field Access ($obj->field without parens, same as method call) ---
    if ($type == NI::FIELD_ACCESS) {
        my scalar $obj = eval_node($interp, $node->{"object"}, $env);
        my str $field = $node->{"field"};

        my str $pkg = get_obj_class($obj);

        # Try as method call with no args
        my scalar $func_info = undef;
        if (length($pkg) > 0) {
            $func_info = interp_resolve_method($interp, $pkg, $field);
        }
        if (!defined($func_info)) {
            $func_info = interp_get_func($interp, $field);
        }
        if (defined($func_info)) {
            my array @args = ();
            push(@args, $obj);
            return call_user_func($interp, $func_info, \@args);
        }

        # Fallback: try hash access
        if (ref($obj) eq "HASH" && exists($obj, $field)) {
            return $obj->{$field};
        }

        die("Undefined field/method: " . $field);
    }

    # --- Extern Func (skip in interpreter) ---
    if ($type == NI::EXTERN_FUNC) {
        return undef;
    }

    # --- Use (already handled during load) ---
    if ($type == NI::USE) {
        return undef;
    }

    die("Unhandled AST node type: " . ast_type_name($type) . " (" . $type . ")");
}

# ============================================================
# Public eval API (for use from compiled programs)
# Requires AST, Lexer, and Parser to be available in the build.
# ============================================================

# Shared interpreter instance for eval_string
my scalar $g_eval_interp = undef;

# Initialize the interpreter eval engine.
# Call before eval_string(). No-op if already initialized.
func init() void {
    if (!defined($g_eval_interp)) {
        $g_eval_interp = interp_new();
    }
}

# Evaluate a string of Strada code and return the result.
# Requires init() to have been called first.
func eval_string(str $code) scalar {
    if (!defined($g_eval_interp)) {
        init();
    }

    my str $trimmed = $code;
    $trimmed =~ s/^\s+//;
    $trimmed =~ s/\s+$//;

    if (length($trimmed) == 0) {
        return undef;
    }

    # Auto-append semicolon if needed
    my int $tlen = length($trimmed);
    my str $last_char = substr($trimmed, $tlen - 1, 1);
    if ($last_char ne ";" && $last_char ne "}") {
        $trimmed = $trimmed . ";";
    }

    # Wrap in eval function
    my str $source = "func __eval__() scalar {\n" . $trimmed . "\n}\n";

    # Parse
    my scalar $tokens = lex_tokenize($source);
    my scalar $parser = parser_new($tokens);
    parser_set_filename($parser, "<eval>");
    my array @empty = ();
    my scalar $program = parse_program($parser, \@empty, \@empty);

    # Find __eval__ function
    my scalar $funcs = $program->{"functions"};
    my int $func_count = $program->{"function_count"};
    my scalar $eval_func = undef;
    my int $i = 0;
    while ($i < $func_count) {
        my scalar $fn = $funcs->[$i];
        if ($fn->{"name"} eq "__eval__") {
            $eval_func = $fn;
        }
        $i = $i + 1;
    }

    if (!defined($eval_func)) {
        return undef;
    }

    # Execute in global env
    my scalar $body = $eval_func->{"body"};
    my scalar $stmts = $body->{"statements"};
    my int $stmt_count = $body->{"statement_count"};
    my scalar $result = undef;

    try {
        $result = eval_stmts_in_env($g_eval_interp, $stmts, $stmt_count, $g_eval_interp->{"global_env"});
    } catch ($e) {
        if (is_signal($e, "return")) {
            return $e->{"value"};
        }
        throw($e);
    }

    return $result;
}

# Reset the eval engine state
func reset() void {
    $g_eval_interp = interp_new();
}
