# Eval.strada - Tree-walking interpreter for Strada
# Evaluates AST nodes directly instead of generating C code.
# Reuses the compiler's Lexer and Parser for the front-end.

# ============================================================
# Stub functions required by Parser (normally in CodeGen)
# ============================================================

func sanitize_name(str $name) str {
    my str $result = "";
    my int $i = 0;
    my int $len = length($name);
    while ($i < $len) {
        my str $ch = substr($name, $i, 1);
        if ($ch eq ":") {
            if ($i + 1 < $len && substr($name, $i + 1, 1) eq ":") {
                $result = $result . "_";
                $i = $i + 1;
            } else {
                $result = $result . "_";
            }
        } else {
            $result = $result . $ch;
        }
        $i = $i + 1;
    }
    return $result;
}

# ============================================================
# Environment - Lexical scope chain
# ============================================================

func env_new(scalar $parent) scalar {
    my hash %e = ();
    my hash %vars = ();
    $e{"vars"} = \%vars;
    $e{"parent"} = $parent;
    return \%e;
}

func env_set(scalar $env, str $name, scalar $value) void {
    $env->{"vars"}->{$name} = $value;
}

func env_get(scalar $env, str $name) scalar {
    my scalar $cur = $env;
    while (defined($cur)) {
        if (exists($cur->{"vars"}, $name)) {
            return $cur->{"vars"}->{$name};
        }
        $cur = $cur->{"parent"};
    }
    return undef;
}

func env_exists(scalar $env, str $name) int {
    my scalar $cur = $env;
    while (defined($cur)) {
        if (exists($cur->{"vars"}, $name)) {
            return 1;
        }
        $cur = $cur->{"parent"};
    }
    return 0;
}

# Update variable in the nearest scope that has it
func env_update(scalar $env, str $name, scalar $value) int {
    my scalar $cur = $env;
    while (defined($cur)) {
        if (exists($cur->{"vars"}, $name)) {
            $cur->{"vars"}->{$name} = $value;
            return 1;
        }
        $cur = $cur->{"parent"};
    }
    return 0;
}

# ============================================================
# Interpreter State
# ============================================================

func interp_new() scalar {
    my hash %interp = ();
    my hash %functions = ();
    my hash %enums = ();
    my hash %constants = ();
    my scalar $global_env = env_new(undef);
    $interp{"functions"} = \%functions;
    $interp{"enums"} = \%enums;
    $interp{"constants"} = \%constants;
    $interp{"global_env"} = $global_env;
    $interp{"package"} = "main";
    $interp{"filename"} = "<input>";
    $interp{"call_depth"} = 0;
    $interp{"max_call_depth"} = 1000;
    # OOP state
    my hash %inherits = ();
    $interp{"inherits"} = \%inherits;
    my hash %overloads = ();
    $interp{"overloads"} = \%overloads;
    my array @method_modifiers = ();
    $interp{"method_modifiers"} = \@method_modifiers;
    my hash %autoloads = ();
    $interp{"autoloads"} = \%autoloads;
    # END blocks
    my array @end_blocks = ();
    $interp{"end_blocks"} = \@end_blocks;
    # local() dynamic scoping stack
    my array @local_stack = ();
    $interp{"local_stack"} = \@local_stack;
    # select() default output
    $interp{"select_fh"} = undef;
    # Signal-based control flow flags (for future use)
    $interp{"signal_type"} = "";
    $interp{"signal_value"} = undef;
    $interp{"signal_label"} = "";
    # Native function support (import_lib)
    my hash %native_funcs = ();
    $interp{"native_funcs"} = \%native_funcs;
    my array @native_lib_handles = ();
    $interp{"native_lib_handles"} = \@native_lib_handles;
    return \%interp;
}

# ============================================================
# Native Function Support (import_lib)
# ============================================================

# Call a native function, packing variadic args into an array if needed.
# For variadic native functions (is_variadic=1), the args from variadic_idx onward
# are packed into a single array argument, matching how the C code generator handles them.
func call_native(scalar $interp, scalar $nf, scalar $args) scalar {
    my int $is_variadic = $nf->{"is_variadic"};
    if ($is_variadic == 1) {
        # Pack args: fixed args stay, variadic args get packed into one array
        my int $param_count = $nf->{"param_count"};
        my int $variadic_idx = $param_count - 1;  # Last param is the variadic one
        my array @packed = ();
        my int $i = 0;

        # Copy fixed args before the variadic param
        while ($i < $variadic_idx && $i < size($args)) {
            push(@packed, $args->[$i]);
            $i = $i + 1;
        }

        # Pack remaining args into a single array for the variadic param
        my array @va_arr = ();
        while ($i < size($args)) {
            push(@va_arr, $args->[$i]);
            $i = $i + 1;
        }
        push(@packed, \@va_arr);

        return native_call($nf->{"fn_ptr"}, \@packed, size(\@packed), $nf->{"ret_is_void"});
    }

    return native_call($nf->{"fn_ptr"}, $args, size($args), $nf->{"ret_is_void"});
}

# Call a native function pointer with an array of StradaValue* arguments.
# $fn_ptr is an int (cast from void*), $args is an array of StradaValue*,
# $arg_count is the number of arguments, $ret_is_void is 1 if return type is void.
func native_call(scalar $fn_ptr, scalar $args, int $arg_count, int $ret_is_void) scalar {
    my scalar $result = undef;
    __C__ {
        typedef StradaValue* (*fn0_t)(void);
        typedef StradaValue* (*fn1_t)(StradaValue*);
        typedef StradaValue* (*fn2_t)(StradaValue*, StradaValue*);
        typedef StradaValue* (*fn3_t)(StradaValue*, StradaValue*, StradaValue*);
        typedef StradaValue* (*fn4_t)(StradaValue*, StradaValue*, StradaValue*, StradaValue*);
        typedef StradaValue* (*fn5_t)(StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*);
        typedef StradaValue* (*fn6_t)(StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*);
        typedef StradaValue* (*fn7_t)(StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*);
        typedef StradaValue* (*fn8_t)(StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*);
        typedef void (*vfn0_t)(void);
        typedef void (*vfn1_t)(StradaValue*);
        typedef void (*vfn2_t)(StradaValue*, StradaValue*);
        typedef void (*vfn3_t)(StradaValue*, StradaValue*, StradaValue*);
        typedef void (*vfn4_t)(StradaValue*, StradaValue*, StradaValue*, StradaValue*);
        typedef void (*vfn5_t)(StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*);
        typedef void (*vfn6_t)(StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*);
        typedef void (*vfn7_t)(StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*);
        typedef void (*vfn8_t)(StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*, StradaValue*);

        void *fptr = (void*)(intptr_t)strada_to_int(fn_ptr);
        int64_t argc = strada_to_int(arg_count);
        int64_t is_void = strada_to_int(ret_is_void);
        /* Get the underlying array - args may be an array or array ref */
        StradaArray *av = NULL;
        if (args->type == STRADA_ARRAY) {
            av = args->value.av;
        } else if (args->type == STRADA_REF && args->value.rv && args->value.rv->type == STRADA_ARRAY) {
            av = args->value.rv->value.av;
        }

        /* Extract argument pointers */
        StradaValue *a[8] = {NULL};
        if (av) {
            for (int i = 0; i < argc && i < 8 && i < (int64_t)av->size; i++) {
                a[i] = av->elements[i];
            }
        }

        strada_decref(result);

        if (is_void) {
            switch (argc) {
                case 0: ((vfn0_t)fptr)(); break;
                case 1: ((vfn1_t)fptr)(a[0]); break;
                case 2: ((vfn2_t)fptr)(a[0], a[1]); break;
                case 3: ((vfn3_t)fptr)(a[0], a[1], a[2]); break;
                case 4: ((vfn4_t)fptr)(a[0], a[1], a[2], a[3]); break;
                case 5: ((vfn5_t)fptr)(a[0], a[1], a[2], a[3], a[4]); break;
                case 6: ((vfn6_t)fptr)(a[0], a[1], a[2], a[3], a[4], a[5]); break;
                case 7: ((vfn7_t)fptr)(a[0], a[1], a[2], a[3], a[4], a[5], a[6]); break;
                case 8: ((vfn8_t)fptr)(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7]); break;
                default:
                    fprintf(stderr, "native_call: too many arguments (%lld)\n", (long long)argc);
                    exit(1);
            }
            result = strada_new_undef();
        } else {
            switch (argc) {
                case 0: result = ((fn0_t)fptr)(); break;
                case 1: result = ((fn1_t)fptr)(a[0]); break;
                case 2: result = ((fn2_t)fptr)(a[0], a[1]); break;
                case 3: result = ((fn3_t)fptr)(a[0], a[1], a[2]); break;
                case 4: result = ((fn4_t)fptr)(a[0], a[1], a[2], a[3]); break;
                case 5: result = ((fn5_t)fptr)(a[0], a[1], a[2], a[3], a[4]); break;
                case 6: result = ((fn6_t)fptr)(a[0], a[1], a[2], a[3], a[4], a[5]); break;
                case 7: result = ((fn7_t)fptr)(a[0], a[1], a[2], a[3], a[4], a[5], a[6]); break;
                case 8: result = ((fn8_t)fptr)(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7]); break;
                default:
                    fprintf(stderr, "native_call: too many arguments (%lld)\n", (long long)argc);
                    exit(1);
            }
            if (!result) result = strada_new_undef();
        }
    }
    return $result;
}

# Load import_lib libraries: dlopen each .so, dlsym each function, register in native_funcs
func interp_load_import_libs(scalar $interp, scalar $program) void {
    my int $lib_count = $program->{"import_lib_count"};
    if ($lib_count == 0) { return; }

    my scalar $import_libs = $program->{"import_libs"};
    my int $li = 0;

    while ($li < $lib_count) {
        my scalar $lib_info = $import_libs->[$li];
        my str $so_path = $lib_info->{"so_path"};
        my str $lib_name = $lib_info->{"lib_name"};

        # dlopen the library
        my scalar $handle = strada_dl_open_raw($so_path);
        my int $handle_int = $handle;
        if ($handle_int == 0) {
            die("import_lib: failed to load shared library: " . $so_path);
        }

        # Keep handle alive so it doesn't get dlclose'd
        push($interp->{"native_lib_handles"}, $handle);

        # Call OOP init functions if present
        my scalar $oop_inits = $lib_info->{"oop_init_funcs"};
        if (defined($oop_inits)) {
            my int $oi = 0;
            my int $oop_count = size($oop_inits);
            while ($oi < $oop_count) {
                my str $oop_fn_name = $oop_inits->[$oi];
                my scalar $oop_fn = strada_dl_sym_raw($handle, $oop_fn_name);
                my int $oop_fn_int = $oop_fn;
                if ($oop_fn_int != 0) {
                    # Call void OOP init function
                    native_call($oop_fn, [], 0, 1);
                }
                $oi = $oi + 1;
            }
        }

        # dlsym each exported function
        my scalar $funcs = $lib_info->{"functions"};
        my int $fn_count = $lib_info->{"function_count"};
        my int $fi = 0;

        while ($fi < $fn_count) {
            my scalar $fn_info = $funcs->[$fi];
            my str $fn_name = $fn_info->{"name"};
            my int $param_count = $fn_info->{"param_count"};
            my int $ret_type = $fn_info->{"return_type"};

            my scalar $fn_ptr = strada_dl_sym_raw($handle, $fn_name);
            my int $fn_ptr_int = $fn_ptr;

            if ($fn_ptr_int == 0) {
                die("import_lib: symbol not found: " . $fn_name . " in " . $so_path);
            }

            # Register as native function
            my hash %nf = ();
            $nf{"fn_ptr"} = $fn_ptr;
            $nf{"param_count"} = $param_count;
            $nf{"ret_is_void"} = 0;
            if ($ret_type == TYPE_VOID()) {
                $nf{"ret_is_void"} = 1;
            }
            $nf{"is_variadic"} = $fn_info->{"is_variadic"};
            $interp->{"native_funcs"}->{$fn_name} = \%nf;

            $fi = $fi + 1;
        }

        $li = $li + 1;
    }
}

func interp_register_func(scalar $interp, str $name, scalar $params, int $param_count, scalar $body, scalar $closure_env) void {
    my hash %fi = ();
    $fi{"params"} = $params;
    $fi{"param_count"} = $param_count;
    $fi{"body"} = $body;
    $fi{"closure_env"} = $closure_env;
    $interp->{"functions"}->{$name} = \%fi;
}

func interp_get_func(scalar $interp, str $name) scalar {
    if (exists($interp->{"functions"}, $name)) {
        return $interp->{"functions"}->{$name};
    }
    return undef;
}

# ============================================================
# OOP Support
# ============================================================

# Resolve method on a class, walking inheritance chain
func interp_resolve_method(scalar $interp, str $pkg, str $method) scalar {
    # Try pkg_method directly
    my scalar $fi = interp_get_func($interp, $pkg . "_" . $method);
    if (defined($fi)) { return $fi; }

    # Walk inheritance chain (depth-first)
    if (exists($interp->{"inherits"}, $pkg)) {
        my scalar $parents = $interp->{"inherits"}->{$pkg};
        my int $pi = 0;
        while ($pi < size($parents)) {
            my scalar $found = interp_resolve_method($interp, $parents->[$pi], $method);
            if (defined($found)) { return $found; }
            $pi = $pi + 1;
        }
    }
    return undef;
}

# Check if an object isa given class (walks inheritance)
func interp_isa(scalar $interp, str $obj_class, str $target_class) int {
    if ($obj_class eq $target_class) { return 1; }
    if (exists($interp->{"inherits"}, $obj_class)) {
        my scalar $parents = $interp->{"inherits"}->{$obj_class};
        my int $pi = 0;
        while ($pi < size($parents)) {
            if (interp_isa($interp, $parents->[$pi], $target_class)) { return 1; }
            $pi = $pi + 1;
        }
    }
    return 0;
}

# Load OOP features from a parsed program (called from Main)
func interp_load_oop(scalar $interp, scalar $program) void {
    # Load inheritance
    my scalar $inherits = $program->{"inherits"};
    my int $inh_count = $program->{"inherit_count"};
    my int $i = 0;
    while ($i < $inh_count) {
        my scalar $entry = $inherits->[$i];
        my str $child = $entry->{"child"};
        my str $parent = $entry->{"parent"};
        if (!exists($interp->{"inherits"}, $child)) {
            my array @parents = ();
            $interp->{"inherits"}->{$child} = \@parents;
        }
        push($interp->{"inherits"}->{$child}, $parent);
        $i = $i + 1;
    }

    # Load overloads
    if ($program->{"has_overloads"} == 1) {
        my scalar $ovl = $program->{"overloads"};
        my scalar $ovl_keys = keys($ovl);
        my int $oi = 0;
        while ($oi < size($ovl_keys)) {
            my str $pkg = $ovl_keys->[$oi];
            $interp->{"overloads"}->{$pkg} = $ovl->{$pkg};
            $oi = $oi + 1;
        }
    }

    # Load method modifiers
    my scalar $mods = $program->{"method_modifiers"};
    my int $mod_count = $program->{"method_modifier_count"};
    $i = 0;
    while ($i < $mod_count) {
        my scalar $mod = $mods->[$i];
        # Look up the modifier function by name (parser stores func_name, not func_node)
        my str $func_name = $mod->{"func_name"};
        my scalar $mod_fi = interp_get_func($interp, $func_name);
        if (defined($mod_fi)) {
            my hash %mod_entry = ();
            $mod_entry{"mod_type"} = $mod->{"mod_type"};
            $mod_entry{"method_name"} = $mod->{"method_name"};
            $mod_entry{"package"} = $mod->{"package"};
            $mod_entry{"func_info"} = $mod_fi;
            push($interp->{"method_modifiers"}, \%mod_entry);
        }
        $i = $i + 1;
    }

    # Detect AUTOLOAD functions
    my scalar $func_keys = keys($interp->{"functions"});
    my int $fki = 0;
    while ($fki < size($func_keys)) {
        my str $fname = $func_keys->[$fki];
        if (match($fname, "_AUTOLOAD$")) {
            my str $pkg = substr($fname, 0, length($fname) - 9);
            $interp->{"autoloads"}->{$pkg} = $interp->{"functions"}->{$fname};
        }
        $fki = $fki + 1;
    }
}

# Execute END blocks (LIFO order)
func interp_run_end_blocks(scalar $interp) void {
    my scalar $blocks = $interp->{"end_blocks"};
    my int $count = size($blocks);
    my int $i = $count - 1;
    while ($i >= 0) {
        try {
            eval_block($interp, $blocks->[$i], $interp->{"global_env"});
        } catch ($e) {
            if (is_signal($e, "return")) {
                # Ignore returns from END blocks
            } else {
                say("Error in END block: " . $e);
            }
        }
        $i = $i - 1;
    }
}

# ============================================================
# Control Flow Signals
# ============================================================

func make_signal(str $sig_type, scalar $value, str $label) scalar {
    my hash %sig = ();
    $sig{"__interp_sig__"} = 1;
    $sig{"sig_type"} = $sig_type;
    $sig{"value"} = $value;
    $sig{"label"} = $label;
    return \%sig;
}

func is_signal(scalar $e, str $sig_type) int {
    if (!defined($e)) { return 0; }
    if (ref($e) ne "HASH") { return 0; }
    if (!exists($e, "__interp_sig__")) { return 0; }
    if ($e->{"sig_type"} ne $sig_type) { return 0; }
    return 1;
}

func is_loop_signal(scalar $e, str $sig_type, str $loop_label) int {
    if (!is_signal($e, $sig_type)) { return 0; }
    my str $sig_label = $e->{"label"};
    # Match if signal has no label, or labels match
    if (length($sig_label) == 0) { return 1; }
    if (length($loop_label) > 0 && $sig_label eq $loop_label) { return 1; }
    return 0;
}

# ============================================================
# Load Program AST
# ============================================================

func interp_load_program(scalar $interp, scalar $program) void {
    # Execute BEGIN blocks first
    my scalar $begin_blocks = $program->{"begin_blocks"};
    my int $begin_count = $program->{"begin_block_count"};
    my int $bi = 0;
    while ($bi < $begin_count) {
        try {
            eval_block($interp, $begin_blocks->[$bi], $interp->{"global_env"});
        } catch ($e) {
            if (is_signal($e, "return")) {
                # Ignore returns from BEGIN blocks
            } else {
                throw($e);
            }
        }
        $bi = $bi + 1;
    }

    # Store END blocks for later execution
    my scalar $end_blocks = $program->{"end_blocks"};
    my int $end_count = $program->{"end_block_count"};
    my int $ei = 0;
    while ($ei < $end_count) {
        push($interp->{"end_blocks"}, $end_blocks->[$ei]);
        $ei = $ei + 1;
    }

    # Register enums first (they may be referenced in globals/functions)
    my scalar $enums = $program->{"enums"};
    my int $enum_count = $program->{"enum_count"};
    my int $i = 0;
    while ($i < $enum_count) {
        my scalar $en = $enums->[$i];
        my str $enum_name = $en->{"name"};
        my scalar $members = $en->{"members"};
        my int $member_count = $en->{"member_count"};
        my int $j = 0;
        while ($j < $member_count) {
            my scalar $member = $members->[$j];
            my str $key = $enum_name . "::" . $member->{"name"};
            $interp->{"enums"}->{$key} = $member->{"value"};
            $j = $j + 1;
        }
        $i = $i + 1;
    }

    # Register all functions
    my scalar $funcs = $program->{"functions"};
    my int $func_count = $program->{"function_count"};
    $i = 0;
    while ($i < $func_count) {
        my scalar $fn = $funcs->[$i];
        my str $name = $fn->{"name"};
        interp_register_func($interp, $name, $fn->{"params"}, $fn->{"param_count"}, $fn->{"body"}, $interp->{"global_env"});
        $i = $i + 1;
    }

    # Register globals (constants, our, my at top level)
    my scalar $globals = $program->{"globals"};
    my int $global_count = $program->{"global_count"};
    $i = 0;
    while ($i < $global_count) {
        my scalar $g = $globals->[$i];
        my int $gtype = $g->{"type"};
        if ($gtype == NODE_CONST_DECL()) {
            my str $cname = $g->{"name"};
            my scalar $init_val = eval_node($interp, $g->{"init"}, $interp->{"global_env"});
            $interp->{"constants"}->{$cname} = $init_val;
            env_set($interp->{"global_env"}, $cname, $init_val);
        } elsif ($gtype == NODE_VAR_DECL() || $gtype == NODE_OUR_DECL()) {
            eval_node($interp, $g, $interp->{"global_env"});
        }
        $i = $i + 1;
    }

    # Load OOP features (inherits, overloads, method modifiers)
    interp_load_oop($interp, $program);

    # Load import_lib native functions
    interp_load_import_libs($interp, $program);
}

# Run the main() function
func interp_run_main(scalar $interp, scalar $argv) int {
    my scalar $func_info = interp_get_func($interp, "main");
    if (!defined($func_info)) {
        die("Error: no main() function defined");
    }
    # Set @ARGV in global env
    env_set($interp->{"global_env"}, "ARGV", $argv);
    my array @args = ();
    my scalar $result = call_user_func($interp, $func_info, \@args);
    if (defined($result)) {
        return $result;
    }
    return 0;
}

# ============================================================
# Assignment Target
# ============================================================

func assign_to(scalar $interp, scalar $target, scalar $value, scalar $env) void {
    my int $ttype = $target->{"type"};

    if ($ttype == NODE_VARIABLE()) {
        my str $name = $target->{"name"};
        if (!env_update($env, $name, $value)) {
            env_set($env, $name, $value);
        }
        return;
    }

    if ($ttype == NODE_SUBSCRIPT()) {
        my scalar $arr = eval_node($interp, $target->{"array"}, $env);
        my int $idx = eval_node($interp, $target->{"index"}, $env);
        $arr->[$idx] = $value;
        return;
    }

    if ($ttype == NODE_HASH_ACCESS()) {
        my scalar $hash_val = eval_node($interp, $target->{"hash"}, $env);
        my str $key = eval_node($interp, $target->{"key"}, $env);
        $hash_val->{$key} = $value;
        return;
    }

    if ($ttype == NODE_DEREF_HASH()) {
        my scalar $ref_val = eval_node($interp, $target->{"ref"}, $env);
        my str $key = eval_node($interp, $target->{"key"}, $env);
        $ref_val->{$key} = $value;
        return;
    }

    if ($ttype == NODE_DEREF_ARRAY()) {
        my scalar $ref_val = eval_node($interp, $target->{"ref"}, $env);
        my int $idx = eval_node($interp, $target->{"index"}, $env);
        $ref_val->[$idx] = $value;
        return;
    }

    if ($ttype == NODE_DEREF_SCALAR()) {
        # $$ref = value - in our interpreter model, update the variable the ref points to
        my scalar $ref_node = $target->{"ref"};
        if ($ref_node->{"type"} == NODE_VARIABLE()) {
            my str $vname = $ref_node->{"name"};
            env_update($env, $vname, $value);
        }
        return;
    }

    die("Cannot assign to node type: " . ast_type_name($ttype));
}

# ============================================================
# Block Evaluation
# ============================================================

func eval_block(scalar $interp, scalar $block, scalar $env) scalar {
    my scalar $stmts = $block->{"statements"};
    my int $count = $block->{"statement_count"};
    my scalar $result = undef;

    # Check if block contains labels (only then do we need goto try/catch)
    my int $has_labels = 0;
    my int $lci = 0;
    while ($lci < $count) {
        if ($stmts->[$lci]->{"type"} == NODE_LABEL()) {
            $has_labels = 1;
            last;
        }
        $lci = $lci + 1;
    }

    my int $ebi = 0;
    if ($has_labels) {
        # Slow path: wrap each statement in try/catch for goto support
        while ($ebi < $count) {
            try {
                $result = eval_node($interp, $stmts->[$ebi], $env);
            } catch ($eb_exc) {
                if (is_signal($eb_exc, "goto")) {
                    my str $eb_gl = $eb_exc->{"label"};
                    my int $eb_gf = 0;
                    my int $eb_gk = 0;
                    while ($eb_gk < $count) {
                        if ($stmts->[$eb_gk]->{"type"} == NODE_LABEL() && $stmts->[$eb_gk]->{"name"} eq $eb_gl) {
                            $ebi = $eb_gk + 1;
                            $eb_gf = 1;
                            last;
                        }
                        $eb_gk = $eb_gk + 1;
                    }
                    if ($eb_gf == 1) {
                        next;
                    }
                }
                throw($eb_exc);
            }
            # Check for signals (return, last, next, redo)
            if (length($interp->{"signal_type"}) > 0) {
                return $result;
            }
            $ebi = $ebi + 1;
        }
    } else {
        # Fast path: no goto labels, direct eval without try/catch overhead
        while ($ebi < $count) {
            $result = eval_node($interp, $stmts->[$ebi], $env);
            # Check for signals (return, last, next, redo)
            if (length($interp->{"signal_type"}) > 0) {
                return $result;
            }
            $ebi = $ebi + 1;
        }
    }
    return $result;
}

# Evaluate statements in an existing env (no new scope)
func eval_stmts_in_env(scalar $interp, scalar $stmts, int $count, scalar $env) scalar {
    my scalar $result = undef;
    my int $i = 0;
    while ($i < $count) {
        $result = eval_node($interp, $stmts->[$i], $env);
        $i = $i + 1;
    }
    return $result;
}

# ============================================================
# Binary Operations
# ============================================================

func check_overload(scalar $interp, scalar $val, str $op) scalar {
    if (ref($val) ne "HASH") { return undef; }
    if (!exists($val, "__class__")) { return undef; }
    my str $pkg = $val->{"__class__"};
    if (!exists($interp->{"overloads"}, $pkg)) { return undef; }
    my scalar $pkg_ovl = $interp->{"overloads"}->{$pkg};
    if (!exists($pkg_ovl, $op)) { return undef; }
    my str $method_name = $pkg_ovl->{$op};
    return interp_resolve_method($interp, $pkg, $method_name);
}

func eval_binop(scalar $interp, scalar $node, scalar $env) scalar {
    my str $op = $node->{"op"};

    # Short-circuit operators
    if ($op eq "&&" || $op eq "and") {
        my scalar $left = eval_node($interp, $node->{"left"}, $env);
        if (!$left) { return $left; }
        return eval_node($interp, $node->{"right"}, $env);
    }
    if ($op eq "||" || $op eq "or") {
        my scalar $left = eval_node($interp, $node->{"left"}, $env);
        if ($left) { return $left; }
        return eval_node($interp, $node->{"right"}, $env);
    }
    if ($op eq "//") {
        my scalar $left = eval_node($interp, $node->{"left"}, $env);
        if (defined($left)) { return $left; }
        return eval_node($interp, $node->{"right"}, $env);
    }

    # Evaluate both sides
    my scalar $left = eval_node($interp, $node->{"left"}, $env);
    my scalar $right = eval_node($interp, $node->{"right"}, $env);

    # Check for operator overloading
    my scalar $ovl_func = check_overload($interp, $left, $op);
    if (defined($ovl_func)) {
        my array @ovl_args = ();
        push(@ovl_args, $left);
        push(@ovl_args, $right);
        push(@ovl_args, 0);
        return call_user_func($interp, $ovl_func, \@ovl_args);
    }
    my scalar $ovl_func_r = check_overload($interp, $right, $op);
    if (defined($ovl_func_r)) {
        my array @ovl_args = ();
        push(@ovl_args, $right);
        push(@ovl_args, $left);
        push(@ovl_args, 1);
        return call_user_func($interp, $ovl_func_r, \@ovl_args);
    }

    # Arithmetic
    if ($op eq "+") { return $left + $right; }
    if ($op eq "-") { return $left - $right; }
    if ($op eq "*") { return $left * $right; }
    if ($op eq "/") { return $left / $right; }
    if ($op eq "%") { return $left % $right; }
    if ($op eq "**") {
        return math::pow($left, $right);
    }

    # String
    if ($op eq ".") {
        # Check for stringify overload on left
        my scalar $l_str_ovl = check_overload($interp, $left, "\"\"");
        my scalar $r_str_ovl = check_overload($interp, $right, "\"\"");
        my scalar $concat_left = $left;
        my scalar $concat_right = $right;
        if (defined($l_str_ovl)) {
            my array @sa = ();
            push(@sa, $left);
            $concat_left = call_user_func($interp, $l_str_ovl, \@sa);
        }
        if (defined($r_str_ovl)) {
            my array @sa = ();
            push(@sa, $right);
            $concat_right = call_user_func($interp, $r_str_ovl, \@sa);
        }
        return $concat_left . $concat_right;
    }
    if ($op eq "x") {
        my str $s = $left;
        my int $n = $right;
        my str $result = "";
        my int $xi = 0;
        while ($xi < $n) {
            $result = $result . $s;
            $xi = $xi + 1;
        }
        return $result;
    }

    # Numeric comparison
    if ($op eq "==") { return ($left == $right) ? 1 : 0; }
    if ($op eq "!=") { return ($left != $right) ? 1 : 0; }
    if ($op eq "<") { return ($left < $right) ? 1 : 0; }
    if ($op eq ">") { return ($left > $right) ? 1 : 0; }
    if ($op eq "<=") { return ($left <= $right) ? 1 : 0; }
    if ($op eq ">=") { return ($left >= $right) ? 1 : 0; }
    if ($op eq "<=>") {
        if ($left < $right) { return -1; }
        if ($left > $right) { return 1; }
        return 0;
    }

    # String comparison
    if ($op eq "eq") { return ($left eq $right) ? 1 : 0; }
    if ($op eq "ne") { return ($left ne $right) ? 1 : 0; }
    if ($op eq "lt") { return ($left lt $right) ? 1 : 0; }
    if ($op eq "gt") { return ($left gt $right) ? 1 : 0; }
    if ($op eq "le") { return ($left le $right) ? 1 : 0; }
    if ($op eq "ge") { return ($left ge $right) ? 1 : 0; }
    if ($op eq "cmp") {
        if ($left lt $right) { return -1; }
        if ($left gt $right) { return 1; }
        return 0;
    }

    die("Unknown binary operator: " . $op);
}

# ============================================================
# Built-in Function Detection and Dispatch
# ============================================================

func is_builtin(str $name) int {
    # I/O
    if ($name eq "say") { return 1; }
    if ($name eq "print") { return 1; }
    if ($name eq "dumper") { return 1; }

    # Array operations
    if ($name eq "push") { return 1; }
    if ($name eq "pop") { return 1; }
    if ($name eq "shift") { return 1; }
    if ($name eq "unshift") { return 1; }
    if ($name eq "splice") { return 1; }
    if ($name eq "reverse") { return 1; }
    if ($name eq "size") { return 1; }
    if ($name eq "scalar") { return 1; }

    # String operations
    if ($name eq "length") { return 1; }
    if ($name eq "bytes") { return 1; }
    if ($name eq "substr") { return 1; }
    if ($name eq "index") { return 1; }
    if ($name eq "rindex") { return 1; }
    if ($name eq "join") { return 1; }
    if ($name eq "split") { return 1; }
    if ($name eq "chomp") { return 1; }
    if ($name eq "chop") { return 1; }
    if ($name eq "chr") { return 1; }
    if ($name eq "ord") { return 1; }
    if ($name eq "char_at") { return 1; }
    if ($name eq "uc") { return 1; }
    if ($name eq "lc") { return 1; }
    if ($name eq "sprintf") { return 1; }
    if ($name eq "match") { return 1; }
    if ($name eq "replace") { return 1; }

    # Hash operations
    if ($name eq "keys") { return 1; }
    if ($name eq "values") { return 1; }
    if ($name eq "exists") { return 1; }
    if ($name eq "delete") { return 1; }
    if ($name eq "each") { return 1; }

    # Type functions
    if ($name eq "defined") { return 1; }
    if ($name eq "ref") { return 1; }
    if ($name eq "int") { return 1; }

    # Misc
    if ($name eq "die") { return 1; }
    if ($name eq "slurp") { return 1; }
    if ($name eq "spew") { return 1; }
    if ($name eq "abs") { return 1; }

    # core::/sys:: functions
    if ($name eq "sys::exit" || $name eq "core::exit") { return 1; }
    if ($name eq "sys::getenv" || $name eq "core::getenv") { return 1; }
    if ($name eq "sys::setenv" || $name eq "core::setenv") { return 1; }
    if ($name eq "sys::time" || $name eq "core::time") { return 1; }
    if ($name eq "sys::sleep" || $name eq "core::sleep") { return 1; }
    if ($name eq "sys::open" || $name eq "core::open") { return 1; }
    if ($name eq "sys::close" || $name eq "core::close") { return 1; }
    if ($name eq "sys::readline" || $name eq "core::readline") { return 1; }
    if ($name eq "sys::eof" || $name eq "core::eof") { return 1; }
    if ($name eq "sys::slurp" || $name eq "core::slurp") { return 1; }
    if ($name eq "sys::spew" || $name eq "core::spew") { return 1; }
    if ($name eq "sys::flush" || $name eq "core::flush") { return 1; }
    if ($name eq "sys::popen" || $name eq "core::popen") { return 1; }
    if ($name eq "sys::qx" || $name eq "core::qx") { return 1; }
    if ($name eq "sys::system" || $name eq "core::system") { return 1; }
    if ($name eq "sys::hires_time" || $name eq "core::hires_time") { return 1; }
    if ($name eq "sys::stack_trace" || $name eq "core::stack_trace") { return 1; }

    # math:: functions
    if ($name eq "math::sqrt" || $name eq "math::sin" || $name eq "math::cos") { return 1; }
    if ($name eq "math::pow" || $name eq "math::abs" || $name eq "math::floor") { return 1; }
    if ($name eq "math::ceil" || $name eq "math::log" || $name eq "math::exp") { return 1; }
    if ($name eq "math::rand" || $name eq "math::srand") { return 1; }
    if ($name eq "math::atan2") { return 1; }

    # OOP functions
    if ($name eq "bless") { return 1; }
    if ($name eq "tie") { return 1; }
    if ($name eq "untie") { return 1; }
    if ($name eq "tied") { return 1; }

    # Additional core:: functions
    if ($name eq "sys::weaken" || $name eq "core::weaken") { return 1; }
    if ($name eq "sys::isweak" || $name eq "core::isweak") { return 1; }
    if ($name eq "sys::wantarray" || $name eq "core::wantarray") { return 1; }
    if ($name eq "sys::wanthash" || $name eq "core::wanthash") { return 1; }
    if ($name eq "sys::global_set" || $name eq "core::global_set") { return 1; }
    if ($name eq "sys::global_get" || $name eq "core::global_get") { return 1; }
    if ($name eq "sys::global_exists" || $name eq "core::global_exists") { return 1; }
    if ($name eq "sys::global_delete" || $name eq "core::global_delete") { return 1; }
    if ($name eq "sys::global_keys" || $name eq "core::global_keys") { return 1; }
    if ($name eq "sys::set_recursion_limit" || $name eq "core::set_recursion_limit") { return 1; }
    if ($name eq "sys::seek" || $name eq "core::seek") { return 1; }
    if ($name eq "sys::tell" || $name eq "core::tell") { return 1; }
    if ($name eq "sys::rewind" || $name eq "core::rewind") { return 1; }
    if ($name eq "sys::_exit" || $name eq "core::_exit") { return 1; }
    if ($name eq "sys::signal" || $name eq "core::signal") { return 1; }

    # Additional functions
    if ($name eq "select") { return 1; }
    if ($name eq "named_captures") { return 1; }
    if ($name eq "captures") { return 1; }
    if ($name eq "sort") { return 1; }
    if ($name eq "throw") { return 1; }
    if ($name eq "chomp") { return 1; }
    if ($name eq "chop") { return 1; }

    return 0;
}

func call_builtin(scalar $interp, str $name, scalar $args, scalar $env) scalar {
    my int $argc = size($args);

    # ---- I/O ----
    if ($name eq "say") {
        if ($argc == 0) {
            my scalar $sfh0 = $interp->{"select_fh"};
            if (defined($sfh0)) { say($sfh0, ""); }
            else { say(""); }
        } elsif ($argc == 1) {
            my scalar $v = $args->[0];
            # Check for stringify overload
            my scalar $str_ovl = check_overload($interp, $v, "\"\"");
            if (defined($str_ovl)) {
                my array @sargs = ();
                push(@sargs, $v);
                $v = call_user_func($interp, $str_ovl, \@sargs);
            }
            my scalar $sfh = $interp->{"select_fh"};
            if (defined($sfh)) { say($sfh, $v); }
            else { say($v); }
        } elsif ($argc == 2) {
            my scalar $v = $args->[1];
            my scalar $str_ovl = check_overload($interp, $v, "\"\"");
            if (defined($str_ovl)) {
                my array @sargs = ();
                push(@sargs, $v);
                $v = call_user_func($interp, $str_ovl, \@sargs);
            }
            say($args->[0], $v);
        }
        return undef;
    }
    if ($name eq "print") {
        if ($argc == 0) {
            return undef;
        } elsif ($argc == 1) {
            my scalar $v = $args->[0];
            my scalar $str_ovl = check_overload($interp, $v, "\"\"");
            if (defined($str_ovl)) {
                my array @sargs = ();
                push(@sargs, $v);
                $v = call_user_func($interp, $str_ovl, \@sargs);
            }
            my scalar $sfh = $interp->{"select_fh"};
            if (defined($sfh)) { print($sfh, $v); }
            else { print($v); }
        } elsif ($argc == 2) {
            my scalar $v = $args->[1];
            my scalar $str_ovl = check_overload($interp, $v, "\"\"");
            if (defined($str_ovl)) {
                my array @sargs = ();
                push(@sargs, $v);
                $v = call_user_func($interp, $str_ovl, \@sargs);
            }
            print($args->[0], $v);
        }
        return undef;
    }
    if ($name eq "dumper") {
        if ($argc >= 1) {
            dumper($args->[0]);
        }
        return undef;
    }

    # ---- Array operations ----
    if ($name eq "push") {
        my scalar $arr = $args->[0];
        my int $ai = 1;
        while ($ai < $argc) {
            push($arr, $args->[$ai]);
            $ai = $ai + 1;
        }
        return undef;
    }
    if ($name eq "pop") {
        return pop($args->[0]);
    }
    if ($name eq "shift") {
        return shift($args->[0]);
    }
    if ($name eq "unshift") {
        unshift($args->[0], $args->[1]);
        return undef;
    }
    if ($name eq "splice") {
        my scalar $sp_a = $args->[0];
        my int $sp_o = $args->[1];
        my int $sp_l = 0;
        if ($argc >= 3) { $sp_l = $args->[2]; }
        my array @sp_r = ();
        my int $sp_i = 0;
        while ($sp_i < $sp_l && ($sp_o + $sp_i) < size($sp_a)) {
            push(@sp_r, $sp_a->[$sp_o + $sp_i]);
            $sp_i = $sp_i + 1;
        }
        if ($argc == 3) {
            splice($sp_a, $sp_o, $sp_l);
        } elsif ($argc >= 4) {
            splice($sp_a, $sp_o, $sp_l, $args->[3]);
        }
        return \@sp_r;
    }
    if ($name eq "reverse") {
        reverse($args->[0]);
        return undef;
    }
    if ($name eq "size" || $name eq "scalar") {
        return size($args->[0]);
    }

    # ---- String operations ----
    if ($name eq "length") {
        return length($args->[0]);
    }
    if ($name eq "bytes") {
        return bytes($args->[0]);
    }
    if ($name eq "substr") {
        if ($argc == 2) {
            return substr($args->[0], $args->[1], length($args->[0]) - $args->[1]);
        }
        return substr($args->[0], $args->[1], $args->[2]);
    }
    if ($name eq "index") {
        if ($argc == 2) {
            return index($args->[0], $args->[1]);
        }
        return index($args->[0], $args->[1], $args->[2]);
    }
    if ($name eq "rindex") {
        return rindex($args->[0], $args->[1]);
    }
    if ($name eq "join") {
        return join($args->[0], $args->[1]);
    }
    if ($name eq "split") {
        return split($args->[0], $args->[1]);
    }
    if ($name eq "chomp") {
        return chomp($args->[0]);
    }
    if ($name eq "chop") {
        return chop($args->[0]);
    }
    if ($name eq "chr") {
        return chr($args->[0]);
    }
    if ($name eq "ord") {
        return ord($args->[0]);
    }
    if ($name eq "char_at") {
        return chr(char_at($args->[0], $args->[1]));
    }
    if ($name eq "uc") {
        return uc($args->[0]);
    }
    if ($name eq "lc") {
        return lc($args->[0]);
    }
    if ($name eq "sprintf") {
        if ($argc == 1) { return sprintf($args->[0]); }
        if ($argc == 2) { return sprintf($args->[0], $args->[1]); }
        if ($argc == 3) { return sprintf($args->[0], $args->[1], $args->[2]); }
        if ($argc == 4) { return sprintf($args->[0], $args->[1], $args->[2], $args->[3]); }
        if ($argc == 5) { return sprintf($args->[0], $args->[1], $args->[2], $args->[3], $args->[4]); }
        if ($argc == 6) { return sprintf($args->[0], $args->[1], $args->[2], $args->[3], $args->[4], $args->[5]); }
        if ($argc == 7) { return sprintf($args->[0], $args->[1], $args->[2], $args->[3], $args->[4], $args->[5], $args->[6]); }
        if ($argc == 8) { return sprintf($args->[0], $args->[1], $args->[2], $args->[3], $args->[4], $args->[5], $args->[6], $args->[7]); }
        return sprintf($args->[0], $args->[1]);
    }
    if ($name eq "match") {
        return match($args->[0], $args->[1]);
    }
    if ($name eq "replace") {
        if ($argc == 3) {
            return replace($args->[0], $args->[1], $args->[2]);
        }
        return replace($args->[0], $args->[1], $args->[2], $args->[3]);
    }

    # ---- Hash operations ----
    if ($name eq "keys") {
        return keys($args->[0]);
    }
    if ($name eq "values") {
        return values($args->[0]);
    }
    if ($name eq "exists") {
        return exists($args->[0], $args->[1]);
    }
    if ($name eq "delete") {
        delete($args->[0], $args->[1]);
        return undef;
    }
    if ($name eq "each") {
        return each($args->[0]);
    }

    # ---- Type functions ----
    if ($name eq "defined") {
        return defined($args->[0]) ? 1 : 0;
    }
    if ($name eq "ref") {
        return ref($args->[0]);
    }
    if ($name eq "int") {
        # Truncate to integer: use arithmetic to force int conversion
        my scalar $v = $args->[0];
        my int $iv = $v;
        return $iv;
    }

    # ---- Misc ----
    if ($name eq "die") {
        if ($argc >= 1) {
            die($args->[0]);
        }
        die("Died");
    }
    if ($name eq "slurp" || $name eq "sys::slurp" || $name eq "core::slurp") {
        return slurp($args->[0]);
    }
    if ($name eq "spew" || $name eq "sys::spew" || $name eq "core::spew") {
        spew($args->[0], $args->[1]);
        return undef;
    }
    if ($name eq "abs") {
        my scalar $v = $args->[0];
        if ($v < 0) { return 0 - $v; }
        return $v;
    }

    # ---- core::/sys:: functions ----
    if ($name eq "sys::exit" || $name eq "core::exit") {
        sys::exit($args->[0]);
    }
    if ($name eq "sys::getenv" || $name eq "core::getenv") {
        return sys::getenv($args->[0]);
    }
    if ($name eq "sys::setenv" || $name eq "core::setenv") {
        sys::setenv($args->[0], $args->[1]);
        return undef;
    }
    if ($name eq "sys::time" || $name eq "core::time") {
        return sys::time();
    }
    if ($name eq "sys::sleep" || $name eq "core::sleep") {
        sys::sleep($args->[0]);
        return undef;
    }
    if ($name eq "sys::hires_time" || $name eq "core::hires_time") {
        return sys::hires_time();
    }
    if ($name eq "sys::open" || $name eq "core::open") {
        return sys::open($args->[0], $args->[1]);
    }
    if ($name eq "sys::close" || $name eq "core::close") {
        sys::close($args->[0]);
        return undef;
    }
    if ($name eq "sys::readline" || $name eq "core::readline") {
        return sys::readline($args->[0]);
    }
    if ($name eq "sys::eof" || $name eq "core::eof") {
        return sys::eof($args->[0]);
    }
    if ($name eq "sys::flush" || $name eq "core::flush") {
        sys::flush($args->[0]);
        return undef;
    }
    if ($name eq "sys::popen" || $name eq "core::popen") {
        return sys::popen($args->[0], $args->[1]);
    }
    if ($name eq "sys::qx" || $name eq "core::qx") {
        return sys::qx($args->[0]);
    }
    if ($name eq "sys::system" || $name eq "core::system") {
        return sys::system($args->[0]);
    }
    if ($name eq "sys::stack_trace" || $name eq "core::stack_trace") {
        return "(interpreter stack trace not available)";
    }

    # ---- math:: functions ----
    if ($name eq "math::sqrt") { return math::sqrt($args->[0]); }
    if ($name eq "math::sin") { return math::sin($args->[0]); }
    if ($name eq "math::cos") { return math::cos($args->[0]); }
    if ($name eq "math::pow") { return math::pow($args->[0], $args->[1]); }
    if ($name eq "math::abs") { my scalar $v = $args->[0]; if ($v < 0) { return 0 - $v; } return $v; }
    if ($name eq "math::floor") { return math::floor($args->[0]); }
    if ($name eq "math::ceil") { return math::ceil($args->[0]); }
    if ($name eq "math::log") { return math::log($args->[0]); }
    if ($name eq "math::exp") { return math::exp($args->[0]); }
    if ($name eq "math::rand") { return math::rand(); }
    if ($name eq "math::srand") {
        my scalar $seed = $args->[0];
        __C__ {
            srand((unsigned int)strada_to_int(seed));
        }
        return undef;
    }
    if ($name eq "math::atan2") { return math::atan2($args->[0], $args->[1]); }

    # ---- OOP functions ----
    if ($name eq "bless") {
        my scalar $ref_val = $args->[0];
        my str $class_name = $args->[1];
        if (ref($ref_val) eq "HASH") {
            $ref_val->{"__class__"} = $class_name;
        }
        return $ref_val;
    }
    if ($name eq "tie") {
        # tie(%hash, "ClassName") - simplified: just mark as tied
        return undef;
    }
    if ($name eq "untie") {
        return undef;
    }
    if ($name eq "tied") {
        return undef;
    }

    # ---- Additional core:: ----
    if ($name eq "sys::weaken" || $name eq "core::weaken") {
        # No-op in interpreter (no refcounting)
        return undef;
    }
    if ($name eq "sys::isweak" || $name eq "core::isweak") {
        return 0;
    }
    if ($name eq "sys::wantarray" || $name eq "core::wantarray") {
        return 0;
    }
    if ($name eq "sys::wanthash" || $name eq "core::wanthash") {
        return 0;
    }
    if ($name eq "sys::global_set" || $name eq "core::global_set") {
        env_set($interp->{"global_env"}, $args->[0], $args->[1]);
        return undef;
    }
    if ($name eq "sys::global_get" || $name eq "core::global_get") {
        return env_get($interp->{"global_env"}, $args->[0]);
    }
    if ($name eq "sys::global_exists" || $name eq "core::global_exists") {
        return env_exists($interp->{"global_env"}, $args->[0]) ? 1 : 0;
    }
    if ($name eq "sys::global_delete" || $name eq "core::global_delete") {
        my scalar $gvars = $interp->{"global_env"}->{"vars"};
        if (exists($gvars, $args->[0])) {
            delete($gvars, $args->[0]);
        }
        return undef;
    }
    if ($name eq "sys::global_keys" || $name eq "core::global_keys") {
        return keys($interp->{"global_env"}->{"vars"});
    }
    if ($name eq "sys::set_recursion_limit" || $name eq "core::set_recursion_limit") {
        $interp->{"max_call_depth"} = $args->[0];
        return undef;
    }
    if ($name eq "sys::seek" || $name eq "core::seek") {
        sys::seek($args->[0], $args->[1], $args->[2]);
        return undef;
    }
    if ($name eq "sys::tell" || $name eq "core::tell") {
        return sys::tell($args->[0]);
    }
    if ($name eq "sys::rewind" || $name eq "core::rewind") {
        sys::rewind($args->[0]);
        return undef;
    }
    if ($name eq "sys::_exit" || $name eq "core::_exit") {
        sys::exit($args->[0]);
    }
    if ($name eq "sys::signal" || $name eq "core::signal") {
        # Signals not supported in interpreter
        return undef;
    }

    # ---- Additional functions ----
    if ($name eq "select") {
        my scalar $old = $interp->{"select_fh"};
        $interp->{"select_fh"} = $args->[0];
        return $old;
    }
    if ($name eq "named_captures") {
        return named_captures();
    }
    if ($name eq "captures") {
        return captures();
    }
    if ($name eq "throw") {
        throw($args->[0]);
    }

    die("Unknown built-in function: " . $name);
}

# ============================================================
# User Function Calls
# ============================================================

func call_user_func(scalar $interp, scalar $func_info, scalar $args) scalar {
    my scalar $params = $func_info->{"params"};
    my int $param_count = $func_info->{"param_count"};
    my scalar $body = $func_info->{"body"};
    my scalar $closure_env = $func_info->{"closure_env"};

    # Check recursion depth
    $interp->{"call_depth"} = $interp->{"call_depth"} + 1;
    if ($interp->{"call_depth"} > $interp->{"max_call_depth"}) {
        $interp->{"call_depth"} = $interp->{"call_depth"} - 1;
        die("Maximum recursion depth exceeded");
    }

    # Create function scope
    my scalar $func_env = env_new($closure_env);

    # Bind parameters
    my int $arg_count = size($args);
    my int $pi = 0;

    # Check for variadic parameter
    my int $is_variadic = 0;
    my str $variadic_name = "";
    if ($param_count > 0) {
        my scalar $last_param = $params->[$param_count - 1];
        my str $last_sigil = $last_param->{"sigil"};
        if ($last_sigil eq "@" || $last_sigil eq "...@") {
            $is_variadic = 1;
            $variadic_name = $last_param->{"name"};
        }
    }

    while ($pi < $param_count) {
        my scalar $param = $params->[$pi];
        my str $pname = $param->{"name"};
        my str $psigil = $param->{"sigil"};

        if ($is_variadic == 1 && $pi == $param_count - 1) {
            # Variadic: collect remaining args into array
            my array @rest = ();
            my int $ri = $pi;
            while ($ri < $arg_count) {
                push(@rest, $args->[$ri]);
                $ri = $ri + 1;
            }
            env_set($func_env, $pname, \@rest);
        } elsif ($pi < $arg_count) {
            env_set($func_env, $pname, $args->[$pi]);
        } else {
            # Default values
            if ($param->{"is_optional"} == 1 && defined($param->{"default_value"}) && $param->{"default_value"} != 0) {
                env_set($func_env, $pname, eval_node($interp, $param->{"default_value"}, $func_env));
            } else {
                my int $ptype = $param->{"param_type"};
                if ($ptype == TYPE_INT()) { env_set($func_env, $pname, 0); }
                elsif ($ptype == TYPE_NUM()) { env_set($func_env, $pname, 0.0); }
                elsif ($ptype == TYPE_STR()) { env_set($func_env, $pname, ""); }
                elsif ($ptype == TYPE_ARRAY()) {
                    my array @a = ();
                    env_set($func_env, $pname, \@a);
                }
                elsif ($ptype == TYPE_HASH()) {
                    my hash %h = ();
                    env_set($func_env, $pname, \%h);
                }
                else { env_set($func_env, $pname, undef); }
            }
        }
        $pi = $pi + 1;
    }

    # Execute body - save local stack depth for dynamic scope restore
    my int $local_depth = size($interp->{"local_stack"});

    my scalar $result = eval_block($interp, $body, $func_env);

    # Handle return signal (signal-based control flow)
    my str $sig = $interp->{"signal_type"};
    if ($sig eq "return") {
        $result = $interp->{"signal_value"};
        $interp->{"signal_type"} = "";
        $interp->{"signal_value"} = undef;
    }

    # Restore local variables from dynamic scope stack
    while (size($interp->{"local_stack"}) > $local_depth) {
        my scalar $save = pop($interp->{"local_stack"});
        env_set($interp->{"global_env"}, $save->{"name"}, $save->{"value"});
    }

    # Break env parent chain to allow GC
    $func_env->{"parent"} = undef;
    $interp->{"call_depth"} = $interp->{"call_depth"} - 1;
    return $result;
}

# ============================================================
# Transliteration Helper
# ============================================================

# Expand ranges like a-z into abcdefghijklmnopqrstuvwxyz
func expand_tr_range(str $spec) str {
    my str $result = "";
    my int $i = 0;
    my int $len = length($spec);
    while ($i < $len) {
        if ($i + 2 < $len && substr($spec, $i + 1, 1) eq "-") {
            my int $start = ord(substr($spec, $i, 1));
            my int $end = ord(substr($spec, $i + 2, 1));
            my int $c = $start;
            while ($c <= $end) {
                $result = $result . chr($c);
                $c = $c + 1;
            }
            $i = $i + 3;
        } else {
            $result = $result . substr($spec, $i, 1);
            $i = $i + 1;
        }
    }
    return $result;
}

# ============================================================
# Core Evaluator
# ============================================================

func eval_node(scalar $interp, scalar $node, scalar $env) scalar {
    if (!defined($node)) {
        return undef;
    }

    my int $type = $node->{"type"};

    # --- Literals ---
    if ($type == NODE_INT_LITERAL()) {
        return $node->{"value"};
    }
    if ($type == NODE_NUM_LITERAL()) {
        return $node->{"value"};
    }
    if ($type == NODE_STR_LITERAL()) {
        return $node->{"value"};
    }
    if ($type == NODE_UNDEF()) {
        return undef;
    }

    # --- Variables ---
    if ($type == NODE_VARIABLE()) {
        my str $name = $node->{"name"};
        # Check constants
        if (exists($interp->{"constants"}, $name)) {
            return $interp->{"constants"}->{$name};
        }
        # Check enums (e.g., "Status::ACTIVE")
        if (exists($interp->{"enums"}, $name)) {
            return $interp->{"enums"}->{$name};
        }
        return env_get($env, $name);
    }

    # --- Variable Declaration ---
    if ($type == NODE_VAR_DECL()) {
        my str $name = $node->{"name"};
        my int $var_type = $node->{"var_type"};
        my scalar $init = undef;

        if (defined($node->{"init"}) && $node->{"init"} != 0) {
            $init = eval_node($interp, $node->{"init"}, $env);
            # Convert key-value list/pairs to hash for hash variables
            if ($var_type == TYPE_HASH() && ref($init) eq "ARRAY") {
                my hash %h = ();
                my int $arr_sz = size($init);
                if ($arr_sz > 0 && ref($init->[0]) eq "ARRAY") {
                    # Array of pairs: [["key","val"], ["key2","val2"]]
                    my int $hi = 0;
                    while ($hi < $arr_sz) {
                        my scalar $pair = $init->[$hi];
                        my str $k = $pair->[0];
                        my scalar $v = $pair->[1];
                        $h{$k} = $v;
                        $hi = $hi + 1;
                    }
                } else {
                    # Flat list: ("key", "val", "key2", "val2")
                    my int $hi = 0;
                    while ($hi + 1 < $arr_sz) {
                        my str $k = $init->[$hi];
                        my scalar $v = $init->[$hi + 1];
                        $h{$k} = $v;
                        $hi = $hi + 2;
                    }
                }
                $init = \%h;
            }
        } else {
            if ($var_type == TYPE_INT()) { $init = 0; }
            elsif ($var_type == TYPE_NUM()) { $init = 0.0; }
            elsif ($var_type == TYPE_STR()) { $init = ""; }
            elsif ($var_type == TYPE_ARRAY()) {
                my array @a = ();
                $init = \@a;
            }
            elsif ($var_type == TYPE_HASH()) {
                my hash %h = ();
                $init = \%h;
            }
        }

        env_set($env, $name, $init);
        return $init;
    }

    # --- Our Declaration ---
    if ($type == NODE_OUR_DECL()) {
        my str $name = $node->{"name"};
        my int $var_type = $node->{"var_type"};
        my scalar $init = undef;

        if (defined($node->{"init"}) && $node->{"init"} != 0) {
            $init = eval_node($interp, $node->{"init"}, $env);
        } else {
            if ($var_type == TYPE_INT()) { $init = 0; }
            elsif ($var_type == TYPE_NUM()) { $init = 0.0; }
            elsif ($var_type == TYPE_STR()) { $init = ""; }
            elsif ($var_type == TYPE_ARRAY()) {
                my array @a = ();
                $init = \@a;
            }
            elsif ($var_type == TYPE_HASH()) {
                my hash %h = ();
                $init = \%h;
            }
        }

        env_set($interp->{"global_env"}, $name, $init);
        env_set($env, $name, $init);
        return $init;
    }

    # --- Const Declaration ---
    if ($type == NODE_CONST_DECL()) {
        my str $name = $node->{"name"};
        my scalar $val = eval_node($interp, $node->{"init"}, $env);
        $interp->{"constants"}->{$name} = $val;
        env_set($env, $name, $val);
        return $val;
    }

    # --- Block ---
    if ($type == NODE_BLOCK()) {
        my scalar $new_env = env_new($env);
        return eval_block($interp, $node, $new_env);
    }

    # --- Expression Statement ---
    if ($type == NODE_EXPR_STMT()) {
        return eval_node($interp, $node->{"expr"}, $env);
    }

    # --- Assignment ---
    if ($type == NODE_ASSIGN()) {
        my str $op = $node->{"op"};
        my scalar $target = $node->{"target"};
        my scalar $rhs = eval_node($interp, $node->{"value"}, $env);

        if ($op ne "=") {
            my scalar $cur = eval_node($interp, $target, $env);
            if ($op eq "+=") { $rhs = $cur + $rhs; }
            elsif ($op eq "-=") { $rhs = $cur - $rhs; }
            elsif ($op eq "*=") { $rhs = $cur * $rhs; }
            elsif ($op eq "/=") { $rhs = $cur / $rhs; }
            elsif ($op eq "%=") { $rhs = $cur % $rhs; }
            elsif ($op eq ".=") { $rhs = $cur . $rhs; }
            elsif ($op eq "//=") {
                if (defined($cur)) { return $cur; }
            }
        }

        assign_to($interp, $target, $rhs, $env);
        return $rhs;
    }

    # --- Binary Operations ---
    if ($type == NODE_BINARY_OP()) {
        return eval_binop($interp, $node, $env);
    }

    # --- Unary Operations ---
    if ($type == NODE_UNARY_OP()) {
        my str $op = $node->{"op"};
        my scalar $val = eval_node($interp, $node->{"operand"}, $env);

        if ($op eq "-") { return 0 - $val; }
        if ($op eq "!") { return (!$val) ? 1 : 0; }
        if ($op eq "not") { return (!$val) ? 1 : 0; }
        if ($op eq "~") { return ~$val; }
        die("Unknown unary operator: " . $op);
    }

    # --- Increment / Decrement ---
    if ($type == NODE_INCREMENT()) {
        my str $op = $node->{"op"};
        my int $is_prefix = $node->{"is_prefix"};
        my scalar $operand = $node->{"operand"};
        my scalar $cur = eval_node($interp, $operand, $env);
        my scalar $new_val = $cur;

        if ($op eq "++") { $new_val = $cur + 1; }
        elsif ($op eq "--") { $new_val = $cur - 1; }

        assign_to($interp, $operand, $new_val, $env);

        if ($is_prefix == 1) { return $new_val; }
        return $cur;
    }

    # --- Ternary ---
    if ($type == NODE_TERNARY()) {
        my scalar $cond = eval_node($interp, $node->{"condition"}, $env);
        if ($cond) {
            return eval_node($interp, $node->{"true_expr"}, $env);
        }
        return eval_node($interp, $node->{"false_expr"}, $env);
    }

    # --- If Statement ---
    if ($type == NODE_IF_STMT()) {
        my scalar $cond = eval_node($interp, $node->{"condition"}, $env);
        if ($cond) {
            my scalar $new_env = env_new($env);
            return eval_block($interp, $node->{"then_block"}, $new_env);
        }

        my int $elsif_count = $node->{"elsif_count"};
        my int $ei = 0;
        while ($ei < $elsif_count) {
            my scalar $econd = eval_node($interp, $node->{"elsif_conditions"}->[$ei], $env);
            if ($econd) {
                my scalar $new_env = env_new($env);
                return eval_block($interp, $node->{"elsif_blocks"}->[$ei], $new_env);
            }
            $ei = $ei + 1;
        }

        if (defined($node->{"else_block"}) && $node->{"else_block"} != 0) {
            my scalar $new_env = env_new($env);
            return eval_block($interp, $node->{"else_block"}, $new_env);
        }

        return undef;
    }

    # --- While Statement ---
    if ($type == NODE_WHILE_STMT()) {
        my str $label = $node->{"label"};
        my scalar $result = undef;
        my scalar $body_env = env_new($env);

        while (1) {
            my scalar $cond = eval_node($interp, $node->{"condition"}, $env);
            if (!$cond) { last; }

            my int $should_break = 0;
            my int $should_redo = 1;
            while ($should_redo) {
                $should_redo = 0;
                $result = eval_block($interp, $node->{"body"}, $body_env);

                # Check for loop signals
                my str $sig = $interp->{"signal_type"};
                if (length($sig) > 0) {
                    my str $sig_label = $interp->{"signal_label"};
                    if ($sig eq "last" && (length($sig_label) == 0 || $sig_label eq $label)) {
                        $interp->{"signal_type"} = "";
                        $should_break = 1;
                    } elsif ($sig eq "next" && (length($sig_label) == 0 || $sig_label eq $label)) {
                        $interp->{"signal_type"} = "";
                    } elsif ($sig eq "redo" && (length($sig_label) == 0 || $sig_label eq $label)) {
                        $interp->{"signal_type"} = "";
                        $should_redo = 1;
                    } else {
                        # Signal not for us (return or labeled for outer loop) - propagate
                        $body_env->{"parent"} = undef;
                        return $result;
                    }
                }
            }
            if ($should_break) { last; }
        }

        $body_env->{"parent"} = undef;
        return $result;
    }

    # --- Do-While Statement ---
    if ($type == NODE_DO_WHILE_STMT()) {
        my str $label = $node->{"label"};
        my scalar $result = undef;
        my scalar $body_env = env_new($env);

        while (1) {
            my int $should_break = 0;
            my int $should_redo = 1;
            while ($should_redo) {
                $should_redo = 0;
                $result = eval_block($interp, $node->{"body"}, $body_env);

                my str $sig = $interp->{"signal_type"};
                if (length($sig) > 0) {
                    my str $sig_label = $interp->{"signal_label"};
                    if ($sig eq "last" && (length($sig_label) == 0 || $sig_label eq $label)) {
                        $interp->{"signal_type"} = "";
                        $should_break = 1;
                    } elsif ($sig eq "next" && (length($sig_label) == 0 || $sig_label eq $label)) {
                        $interp->{"signal_type"} = "";
                    } elsif ($sig eq "redo" && (length($sig_label) == 0 || $sig_label eq $label)) {
                        $interp->{"signal_type"} = "";
                        $should_redo = 1;
                    } else {
                        $body_env->{"parent"} = undef;
                        return $result;
                    }
                }
            }
            if ($should_break) { last; }

            my scalar $cond = eval_node($interp, $node->{"condition"}, $env);
            if (!$cond) { last; }
        }

        $body_env->{"parent"} = undef;
        return $result;
    }

    # --- For Statement ---
    if ($type == NODE_FOR_STMT()) {
        my str $label = $node->{"label"};
        my scalar $result = undef;
        my scalar $for_env = env_new($env);

        # Init
        if (defined($node->{"init"}) && $node->{"init"} != 0) {
            eval_node($interp, $node->{"init"}, $for_env);
        }

        while (1) {
            # Condition
            if (defined($node->{"condition"}) && $node->{"condition"} != 0) {
                my scalar $cond = eval_node($interp, $node->{"condition"}, $for_env);
                if (!$cond) { last; }
            }

            # Body - reuse for_env for body (no separate body_env needed)
            my int $should_break = 0;
            my int $should_redo = 1;
            while ($should_redo) {
                $should_redo = 0;
                $result = eval_block($interp, $node->{"body"}, $for_env);

                my str $sig = $interp->{"signal_type"};
                if (length($sig) > 0) {
                    my str $sig_label = $interp->{"signal_label"};
                    if ($sig eq "last" && (length($sig_label) == 0 || $sig_label eq $label)) {
                        $interp->{"signal_type"} = "";
                        $should_break = 1;
                    } elsif ($sig eq "next" && (length($sig_label) == 0 || $sig_label eq $label)) {
                        $interp->{"signal_type"} = "";
                    } elsif ($sig eq "redo" && (length($sig_label) == 0 || $sig_label eq $label)) {
                        $interp->{"signal_type"} = "";
                        $should_redo = 1;
                    } else {
                        $for_env->{"parent"} = undef;
                        return $result;
                    }
                }
            }
            if ($should_break) { last; }

            # Update
            if (defined($node->{"update"}) && $node->{"update"} != 0) {
                eval_node($interp, $node->{"update"}, $for_env);
            }
        }

        $for_env->{"parent"} = undef;
        return $result;
    }

    # --- Foreach Statement ---
    if ($type == NODE_FOREACH_STMT()) {
        my str $label = $node->{"label"};
        my scalar $result = undef;
        my scalar $arr = eval_node($interp, $node->{"array"}, $env);
        my int $arr_len = size($arr);

        # Determine iteration variable name
        my str $var_name = "";
        my scalar $var_decl = $node->{"var_decl"};
        if (defined($var_decl) && $var_decl != 0) {
            $var_name = $var_decl->{"name"};
        } else {
            $var_name = $node->{"var_name"};
            if (length($var_name) == 0) {
                $var_name = "_";
            }
        }

        my scalar $body_env = env_new($env);
        my int $fi = 0;
        while ($fi < $arr_len) {
            env_set($body_env, $var_name, $arr->[$fi]);
            env_set($body_env, "_", $arr->[$fi]);

            my int $should_break = 0;
            my int $should_redo = 1;
            while ($should_redo) {
                $should_redo = 0;
                $result = eval_block($interp, $node->{"body"}, $body_env);

                my str $sig = $interp->{"signal_type"};
                if (length($sig) > 0) {
                    my str $sig_label = $interp->{"signal_label"};
                    if ($sig eq "last" && (length($sig_label) == 0 || $sig_label eq $label)) {
                        $interp->{"signal_type"} = "";
                        $should_break = 1;
                    } elsif ($sig eq "next" && (length($sig_label) == 0 || $sig_label eq $label)) {
                        $interp->{"signal_type"} = "";
                    } elsif ($sig eq "redo" && (length($sig_label) == 0 || $sig_label eq $label)) {
                        $interp->{"signal_type"} = "";
                        $should_redo = 1;
                    } else {
                        $body_env->{"parent"} = undef;
                        return $result;
                    }
                }
            }
            if ($should_break) { last; }

            $fi = $fi + 1;
        }
        $body_env->{"parent"} = undef;

        return $result;
    }

    # --- Return Statement ---
    if ($type == NODE_RETURN_STMT()) {
        my scalar $val = undef;
        if (defined($node->{"value"}) && $node->{"value"} != 0) {
            $val = eval_node($interp, $node->{"value"}, $env);
        }
        $interp->{"signal_type"} = "return";
        $interp->{"signal_value"} = $val;
        $interp->{"signal_label"} = "";
        return undef;
    }

    # --- Last (break) ---
    if ($type == NODE_LAST()) {
        $interp->{"signal_type"} = "last";
        $interp->{"signal_value"} = undef;
        $interp->{"signal_label"} = $node->{"label"};
        return undef;
    }

    # --- Next (continue) ---
    if ($type == NODE_NEXT()) {
        $interp->{"signal_type"} = "next";
        $interp->{"signal_value"} = undef;
        $interp->{"signal_label"} = $node->{"label"};
        return undef;
    }

    # --- Redo ---
    if ($type == NODE_REDO()) {
        $interp->{"signal_type"} = "redo";
        $interp->{"signal_value"} = undef;
        $interp->{"signal_label"} = $node->{"label"};
        return undef;
    }

    # --- Function Call ---
    if ($type == NODE_CALL()) {
        my str $name = $node->{"name"};
        my scalar $raw_args = $node->{"args"};
        my int $argc = $node->{"arg_count"};

        # Evaluate arguments (handle spread)
        my array @args = ();
        my int $ai = 0;
        while ($ai < $argc) {
            my scalar $arg_node = $raw_args->[$ai];
            if (defined($arg_node) && $arg_node->{"type"} == NODE_SPREAD()) {
                # Spread: expand array into args
                my scalar $spread_val = eval_node($interp, $arg_node->{"target"}, $env);
                my int $slen = size($spread_val);
                my int $si = 0;
                while ($si < $slen) {
                    push(@args, $spread_val->[$si]);
                    $si = $si + 1;
                }
            } else {
                push(@args, eval_node($interp, $arg_node, $env));
            }
            $ai = $ai + 1;
        }

        # Check builtins
        if (is_builtin($name)) {
            return call_builtin($interp, $name, \@args, $env);
        }

        # Check user-defined functions
        my scalar $func_info = interp_get_func($interp, $name);
        if (defined($func_info)) {
            return call_user_func($interp, $func_info, \@args);
        }

        # Try Pkg::func -> Pkg_func (package-qualified calls)
        if (index($name, "::") >= 0) {
            my str $sanitized = sanitize_name($name);
            $func_info = interp_get_func($interp, $sanitized);
            if (defined($func_info)) {
                return call_user_func($interp, $func_info, \@args);
            }

            # Check native functions (import_lib)
            if (exists($interp->{"native_funcs"}, $sanitized)) {
                my scalar $nf = $interp->{"native_funcs"}->{$sanitized};
                return call_native($interp, $nf, \@args);
            }
        }

        # Check native functions by original name
        if (exists($interp->{"native_funcs"}, $name)) {
            my scalar $nf = $interp->{"native_funcs"}->{$name};
            return call_native($interp, $nf, \@args);
        }

        die("Undefined function: " . $name);
    }

    # --- Closure Call ($ref->(args)) ---
    if ($type == NODE_CLOSURE_CALL()) {
        my scalar $closure = eval_node($interp, $node->{"closure"}, $env);
        my scalar $raw_args = $node->{"args"};
        my int $argc = $node->{"arg_count"};

        my array @args = ();
        my int $ai = 0;
        while ($ai < $argc) {
            push(@args, eval_node($interp, $raw_args->[$ai], $env));
            $ai = $ai + 1;
        }

        # Check for __orig_func__ wrapper (from around modifier)
        if (ref($closure) eq "HASH" && exists($closure, "__orig_func__")) {
            return call_user_func($interp, $closure->{"__orig_func__"}, \@args);
        }

        if (ref($closure) eq "HASH" && exists($closure, "params")) {
            # It's a function info hash (from anonymous func)
            return call_user_func($interp, $closure, \@args);
        }

        die("Cannot call non-function value");
    }

    # --- Method Call ($obj->method(args)) ---
    if ($type == NODE_METHOD_CALL()) {
        # Use base_object (the original receiver) instead of object (which may be FIELD_ACCESS)
        my scalar $obj_node = $node->{"base_object"};
        if (!defined($obj_node) || $obj_node == 0) {
            $obj_node = $node->{"object"};
        }
        my scalar $obj = eval_node($interp, $obj_node, $env);
        my str $method = $node->{"method"};
        my scalar $raw_args = $node->{"args"};
        my int $argc = $node->{"arg_count"};

        # Build args: $self + explicit args
        my array @args = ();
        push(@args, $obj);
        my int $ai = 0;
        while ($ai < $argc) {
            my scalar $arg_node = $raw_args->[$ai];
            if (defined($arg_node) && $arg_node->{"type"} == NODE_SPREAD()) {
                my scalar $spread_val = eval_node($interp, $arg_node->{"target"}, $env);
                my int $slen = size($spread_val);
                my int $si = 0;
                while ($si < $slen) {
                    push(@args, $spread_val->[$si]);
                    $si = $si + 1;
                }
            } else {
                push(@args, eval_node($interp, $arg_node, $env));
            }
            $ai = $ai + 1;
        }

        # Get object's class
        my str $pkg = "";
        if (ref($obj) eq "HASH" && exists($obj, "__class__")) {
            $pkg = $obj->{"__class__"};
        }
        # Also check for C runtime blessing (from compiled .so objects)
        if (length($pkg) == 0) {
            my str $ref_type = ref($obj);
            if ($ref_type ne "HASH" && $ref_type ne "ARRAY" && $ref_type ne "" && $ref_type ne "0") {
                $pkg = $ref_type;
            }
        }

        # Handle isa() special method
        if ($method eq "isa") {
            if (length($pkg) > 0 && $argc >= 1) {
                my str $target_class = $args->[1];
                return interp_isa($interp, $pkg, $target_class) ? 1 : 0;
            }
            return 0;
        }

        # Handle can() special method
        if ($method eq "can") {
            if (length($pkg) > 0 && $argc >= 1) {
                my str $target_method = $args->[1];
                my scalar $found = interp_resolve_method($interp, $pkg, $target_method);
                return defined($found) ? 1 : 0;
            }
            return 0;
        }

        # Resolve method through inheritance chain
        my scalar $func_info = undef;
        if (length($pkg) > 0) {
            $func_info = interp_resolve_method($interp, $pkg, $method);
        }
        if (!defined($func_info)) {
            $func_info = interp_get_func($interp, $method);
        }

        # Try native functions (import_lib) as fallback
        if (!defined($func_info) && length($pkg) > 0) {
            my str $native_name = $pkg . "_" . $method;
            if (exists($interp->{"native_funcs"}, $native_name)) {
                my scalar $nf = $interp->{"native_funcs"}->{$native_name};
                return call_native($interp, $nf, \@args);
            }
        }

        # Try AUTOLOAD as fallback
        if (!defined($func_info) && length($pkg) > 0) {
            if (exists($interp->{"autoloads"}, $pkg)) {
                my scalar $autoload = $interp->{"autoloads"}->{$pkg};
                # AUTOLOAD receives method name as first additional arg
                my array @al_args = ();
                push(@al_args, $obj);
                push(@al_args, $method);
                my int $ali = 1;
                while ($ali < size(\@args)) {
                    push(@al_args, $args[$ali]);
                    $ali = $ali + 1;
                }
                return call_user_func($interp, $autoload, \@al_args);
            }
        }

        if (defined($func_info)) {
            # Check for before/after modifiers
            my scalar $mods = $interp->{"method_modifiers"};
            my int $mod_count = size($mods);

            # Execute before modifiers
            my int $mi = 0;
            while ($mi < $mod_count) {
                my scalar $mod = $mods->[$mi];
                if ($mod->{"mod_type"} eq "before" && $mod->{"method_name"} eq $method && $mod->{"package"} eq $pkg) {
                    my scalar $mod_fi = $mod->{"func_info"};
                    if (defined($mod_fi)) {
                        call_user_func($interp, $mod_fi, \@args);
                    }
                }
                $mi = $mi + 1;
            }

            # Execute around modifiers (wraps the actual call)
            $mi = 0;
            while ($mi < $mod_count) {
                my scalar $mod = $mods->[$mi];
                if ($mod->{"mod_type"} eq "around" && $mod->{"method_name"} eq $method && $mod->{"package"} eq $pkg) {
                    my scalar $mod_fi = $mod->{"func_info"};
                    if (defined($mod_fi)) {
                        # Build a closure-like wrapper for $orig
                        my hash %orig = ();
                        $orig{"__orig_func__"} = $func_info;
                        my array @around_args = ();
                        push(@around_args, $args[0]);
                        push(@around_args, \%orig);
                        my int $aai = 1;
                        while ($aai < size(\@args)) {
                            push(@around_args, $args[$aai]);
                            $aai = $aai + 1;
                        }
                        return call_user_func($interp, $mod_fi, \@around_args);
                    }
                }
                $mi = $mi + 1;
            }

            # Call the actual method
            my scalar $result = call_user_func($interp, $func_info, \@args);

            # Execute after modifiers
            $mi = 0;
            while ($mi < $mod_count) {
                my scalar $mod = $mods->[$mi];
                if ($mod->{"mod_type"} eq "after" && $mod->{"method_name"} eq $method && $mod->{"package"} eq $pkg) {
                    my scalar $mod_fi = $mod->{"func_info"};
                    if (defined($mod_fi)) {
                        call_user_func($interp, $mod_fi, \@args);
                    }
                }
                $mi = $mi + 1;
            }

            return $result;
        }

        die("Undefined method: " . $method . " on " . (length($pkg) > 0 ? $pkg : "unblessed reference"));
    }

    # --- Anonymous Function ---
    if ($type == NODE_ANON_FUNC()) {
        my hash %fi = ();
        $fi{"params"} = $node->{"params"};
        $fi{"param_count"} = $node->{"param_count"};
        $fi{"body"} = $node->{"body"};
        $fi{"closure_env"} = $env;
        return \%fi;
    }

    # --- Array Subscript ---
    if ($type == NODE_SUBSCRIPT()) {
        my scalar $arr = eval_node($interp, $node->{"array"}, $env);
        my int $idx = eval_node($interp, $node->{"index"}, $env);
        if ($idx < 0) {
            $idx = size($arr) + $idx;
        }
        return $arr->[$idx];
    }

    # --- Hash Access ---
    if ($type == NODE_HASH_ACCESS()) {
        my scalar $hash_val = eval_node($interp, $node->{"hash"}, $env);
        my str $key = eval_node($interp, $node->{"key"}, $env);
        return $hash_val->{$key};
    }

    # --- Deref Hash ($ref->{key}) ---
    if ($type == NODE_DEREF_HASH()) {
        my scalar $ref_val = eval_node($interp, $node->{"ref"}, $env);
        my str $key = eval_node($interp, $node->{"key"}, $env);
        return $ref_val->{$key};
    }

    # --- Deref Array ($ref->[idx]) ---
    if ($type == NODE_DEREF_ARRAY()) {
        my scalar $ref_val = eval_node($interp, $node->{"ref"}, $env);
        my int $idx = eval_node($interp, $node->{"index"}, $env);
        if ($idx < 0) {
            $idx = size($ref_val) + $idx;
        }
        return $ref_val->[$idx];
    }

    # --- Deref Scalar ($$ref, @$ref, %$ref) ---
    if ($type == NODE_DEREF_SCALAR()) {
        my scalar $ref_val = eval_node($interp, $node->{"ref"}, $env);
        return $ref_val;
    }

    # --- Reference (\$var, \@arr, \%hash) ---
    if ($type == NODE_REF()) {
        my scalar $target = $node->{"target"};
        my str $ref_type = $node->{"ref_type"};

        # For variable references, return the value (already a reference in our model)
        my scalar $val = eval_node($interp, $target, $env);
        if ($ref_type eq "scalar" || $ref_type eq "array" || $ref_type eq "hash") {
            return $val;
        }
        return $val;
    }

    # --- Anonymous Hash ---
    if ($type == NODE_ANON_HASH()) {
        my hash %result = ();
        my scalar $keys_arr = $node->{"keys"};
        my scalar $values_arr = $node->{"values"};
        my scalar $key_exprs = $node->{"key_exprs"};
        my int $pair_count = $node->{"pair_count"};
        my int $hi = 0;

        while ($hi < $pair_count) {
            my str $key = "";
            if (defined($key_exprs->[$hi]) && $key_exprs->[$hi] != 0) {
                $key = eval_node($interp, $key_exprs->[$hi], $env);
            } else {
                $key = $keys_arr->[$hi];
            }
            my scalar $val = eval_node($interp, $values_arr->[$hi], $env);
            $result{$key} = $val;
            $hi = $hi + 1;
        }

        return \%result;
    }

    # --- Anonymous Array ---
    if ($type == NODE_ANON_ARRAY()) {
        my array @result = ();
        my scalar $elems = $node->{"elements"};
        my int $elem_count = $node->{"element_count"};
        my int $ai = 0;

        while ($ai < $elem_count) {
            my scalar $elem = $elems->[$ai];
            if (defined($elem) && $elem->{"type"} == NODE_SPREAD()) {
                my scalar $spread_val = eval_node($interp, $elem->{"target"}, $env);
                my int $slen = size($spread_val);
                my int $si = 0;
                while ($si < $slen) {
                    push(@result, $spread_val->[$si]);
                    $si = $si + 1;
                }
            } else {
                push(@result, eval_node($interp, $elem, $env));
            }
            $ai = $ai + 1;
        }

        return \@result;
    }

    # --- Range (start..end) ---
    if ($type == NODE_RANGE()) {
        my int $start = eval_node($interp, $node->{"start"}, $env);
        my int $end = eval_node($interp, $node->{"end"}, $env);
        my array @result = ();
        my int $ri = $start;
        while ($ri <= $end) {
            push(@result, $ri);
            $ri = $ri + 1;
        }
        return \@result;
    }

    # --- Map ---
    if ($type == NODE_MAP()) {
        my scalar $arr = eval_node($interp, $node->{"array"}, $env);
        my scalar $block = $node->{"block"};
        my int $arr_len = size($arr);
        my array @result = ();
        my int $mi = 0;

        while ($mi < $arr_len) {
            my scalar $map_env = env_new($env);
            env_set($map_env, "_", $arr->[$mi]);
            my scalar $val = eval_block($interp, $block, $map_env);
            $map_env->{"parent"} = undef;
            push(@result, $val);
            $mi = $mi + 1;
        }

        return \@result;
    }

    # --- Grep ---
    if ($type == NODE_GREP()) {
        my scalar $arr = eval_node($interp, $node->{"array"}, $env);
        my scalar $block = $node->{"block"};
        my int $arr_len = size($arr);
        my array @result = ();
        my int $gi = 0;

        while ($gi < $arr_len) {
            my scalar $grep_env = env_new($env);
            env_set($grep_env, "_", $arr->[$gi]);
            my scalar $val = eval_block($interp, $block, $grep_env);
            $grep_env->{"parent"} = undef;
            if ($val) {
                push(@result, $arr->[$gi]);
            }
            $gi = $gi + 1;
        }

        return \@result;
    }

    # --- Sort ---
    if ($type == NODE_SORT()) {
        my scalar $arr = eval_node($interp, $node->{"array"}, $env);
        my scalar $block = $node->{"block"};
        my int $srt_has_blk = 0;
        if (defined($block) && $block != 0) { $srt_has_blk = 1; }
        my int $arr_len = size($arr);

        # Copy array for sorting
        my array @sorted = ();
        my int $si = 0;
        while ($si < $arr_len) {
            push(@sorted, $arr->[$si]);
            $si = $si + 1;
        }

        # Simple insertion sort with custom comparator
        my int $oi = 1;
        while ($oi < $arr_len) {
            my scalar $key_val = $sorted[$oi];
            my int $oj = $oi - 1;
            while ($oj >= 0) {
                my int $srt_do_swap = 0;
                if ($srt_has_blk == 1) {
                    my scalar $cmp_env = env_new($env);
                    env_set($cmp_env, "a", $sorted[$oj]);
                    env_set($cmp_env, "b", $key_val);
                    my scalar $cmp_result = eval_block($interp, $block, $cmp_env);
                    $cmp_env->{"parent"} = undef;
                    if ($cmp_result > 0) { $srt_do_swap = 1; }
                } else {
                    if ($sorted[$oj] . "" gt $key_val . "") { $srt_do_swap = 1; }
                }
                if ($srt_do_swap == 1) {
                    $sorted[$oj + 1] = $sorted[$oj];
                    $oj = $oj - 1;
                } else {
                    last;
                }
            }
            $sorted[$oj + 1] = $key_val;
            $oi = $oi + 1;
        }

        return \@sorted;
    }

    # --- Try/Catch ---
    if ($type == NODE_TRY_CATCH()) {
        my scalar $try_block = $node->{"try_block"};
        my scalar $catch_clauses = $node->{"catch_clauses"};
        my int $catch_count = $node->{"catch_count"};

        try {
            my scalar $try_env = env_new($env);
            return eval_block($interp, $try_block, $try_env);
        } catch ($e) {
            # Don't catch interpreter control flow signals
            if (is_signal($e, "return") || is_signal($e, "last") || is_signal($e, "next") || is_signal($e, "redo")) {
                throw($e);
            }

            # Try each catch clause
            my int $ci = 0;
            while ($ci < $catch_count) {
                my scalar $clause = $catch_clauses->[$ci];
                my str $catch_type = $clause->{"catch_type"};
                my str $catch_var = $clause->{"catch_var"};
                my scalar $catch_block = $clause->{"catch_block"};

                my int $matches = 0;
                if (length($catch_type) == 0) {
                    # Catch-all
                    $matches = 1;
                } elsif (ref($e) eq "HASH" && exists($e, "__class__")) {
                    # Typed catch: check isa (walks inheritance chain)
                    if (interp_isa($interp, $e->{"__class__"}, $catch_type)) {
                        $matches = 1;
                    }
                }

                if ($matches) {
                    my scalar $catch_env = env_new($env);
                    env_set($catch_env, $catch_var, $e);
                    return eval_block($interp, $catch_block, $catch_env);
                }

                $ci = $ci + 1;
            }

            # No catch matched - re-throw
            throw($e);
        }
    }

    # --- Throw ---
    if ($type == NODE_THROW()) {
        my scalar $val = eval_node($interp, $node->{"expr"}, $env);
        throw($val);
    }

    # --- Destructuring ---
    if ($type == NODE_DESTRUCTURE()) {
        my scalar $vars = $node->{"vars"};
        my int $var_count = $node->{"var_count"};
        my int $is_decl = $node->{"is_decl"};
        my scalar $init = eval_node($interp, $node->{"init"}, $env);

        my int $di = 0;
        while ($di < $var_count) {
            my scalar $var_info = $vars->[$di];
            my str $vname = $var_info->{"name"};
            my scalar $val = undef;
            if ($di < size($init)) {
                $val = $init->[$di];
            }

            if ($is_decl == 1) {
                env_set($env, $vname, $val);
            } else {
                if (!env_update($env, $vname, $val)) {
                    env_set($env, $vname, $val);
                }
            }
            $di = $di + 1;
        }

        return undef;
    }

    # --- Array Slice ---
    if ($type == NODE_ARRAY_SLICE()) {
        my scalar $source = eval_node($interp, $node->{"source"}, $env);
        my scalar $items = $node->{"items"};
        my int $item_count = $node->{"item_count"};
        my array @result = ();
        my int $si = 0;
        while ($si < $item_count) {
            my scalar $idx = eval_node($interp, $items->[$si], $env);
            if (ref($idx) eq "ARRAY") {
                # Range result
                my int $ri = 0;
                while ($ri < size($idx)) {
                    push(@result, $source->[$idx->[$ri]]);
                    $ri = $ri + 1;
                }
            } else {
                push(@result, $source->[$idx]);
            }
            $si = $si + 1;
        }
        return \@result;
    }

    # --- Hash Slice ---
    if ($type == NODE_HASH_SLICE()) {
        my scalar $source = eval_node($interp, $node->{"source"}, $env);
        my scalar $items = $node->{"items"};
        my int $item_count = $node->{"item_count"};
        my array @result = ();
        my int $si = 0;
        while ($si < $item_count) {
            my str $key = eval_node($interp, $items->[$si], $env);
            push(@result, $source->{$key});
            $si = $si + 1;
        }
        return \@result;
    }

    # --- Function Reference (\&func) ---
    if ($type == NODE_FUNC_REF()) {
        my str $fname = $node->{"name"};
        my scalar $func_info = interp_get_func($interp, $fname);
        if (defined($func_info)) {
            return $func_info;
        }
        die("Undefined function for reference: " . $fname);
    }

    # --- Switch ---
    if ($type == NODE_SWITCH()) {
        my scalar $expr_val = eval_node($interp, $node->{"expr"}, $env);
        my scalar $cases = $node->{"cases"};
        my scalar $blocks = $node->{"blocks"};
        my int $case_count = $node->{"case_count"};

        my int $ci = 0;
        while ($ci < $case_count) {
            my scalar $case_val = eval_node($interp, $cases->[$ci], $env);
            if ($expr_val == $case_val || ($expr_val eq $case_val)) {
                my scalar $case_env = env_new($env);
                return eval_block($interp, $blocks->[$ci], $case_env);
            }
            $ci = $ci + 1;
        }

        if ($node->{"has_default"} == 1) {
            my scalar $def_env = env_new($env);
            return eval_block($interp, $node->{"default_block"}, $def_env);
        }

        return undef;
    }

    # --- Readline (<$fh>) ---
    if ($type == NODE_READLINE()) {
        my str $varname = $node->{"varname"};
        my scalar $fh = env_get($env, $varname);
        if (defined($fh)) {
            return sys::readline($fh);
        }
        return undef;
    }

    # --- Regex Match ---
    if ($type == NODE_REGEX_MATCH()) {
        my scalar $target = eval_node($interp, $node->{"target"}, $env);
        my str $pattern = $node->{"pattern"};
        my str $flags = $node->{"flags"};
        my str $op = $node->{"op"};

        # Apply flags: build pattern with inline modifiers if flags present
        my str $effective_pattern = $pattern;
        if (length($flags) > 0) {
            $effective_pattern = "(?" . $flags . ")" . $pattern;
        }

        my int $result = match($target, $effective_pattern);
        if ($op eq "!~") {
            return (!$result) ? 1 : 0;
        }
        return $result ? 1 : 0;
    }

    # --- Regex Substitution ---
    if ($type == NODE_REGEX_SUBST()) {
        my scalar $target_node = $node->{"target"};
        my str $target_val = eval_node($interp, $target_node, $env);
        my str $pattern = $node->{"pattern"};
        my str $replacement = $node->{"replacement"};
        my str $flags = $node->{"flags"};

        # Apply flags
        my str $effective_pattern = $pattern;
        if (length($flags) > 0) {
            my str $inline_flags = "";
            my int $fli = 0;
            while ($fli < length($flags)) {
                my str $fc = substr($flags, $fli, 1);
                if ($fc ne "g" && $fc ne "e") {
                    $inline_flags = $inline_flags . $fc;
                }
                $fli = $fli + 1;
            }
            if (length($inline_flags) > 0) {
                $effective_pattern = "(?" . $inline_flags . ")" . $pattern;
            }
        }

        my str $result = $target_val;
        if (length($flags) > 0 && index($flags, "g") >= 0) {
            $result = replace($target_val, $effective_pattern, $replacement, "g");
        } else {
            $result = replace($target_val, $effective_pattern, $replacement);
        }
        assign_to($interp, $target_node, $result, $env);
        return $result;
    }

    # --- __PACKAGE__ ---
    if ($type == NODE_DUNDER_PACKAGE()) {
        return $interp->{"package"};
    }

    # --- __FILE__ ---
    if ($type == NODE_DUNDER_FILE()) {
        return $interp->{"filename"};
    }

    # --- __LINE__ ---
    if ($type == NODE_DUNDER_LINE()) {
        return $node->{"line_value"};
    }

    # --- Super Call (SUPER::method(args)) ---
    if ($type == NODE_SUPER_CALL()) {
        my str $method = $node->{"method"};
        my scalar $raw_args = $node->{"args"};
        my int $argc = $node->{"arg_count"};

        # Get $self from environment
        my scalar $self_obj = env_get($env, "self");
        my str $pkg = "";
        if (defined($self_obj) && ref($self_obj) eq "HASH" && exists($self_obj, "__class__")) {
            $pkg = $self_obj->{"__class__"};
        }

        # Build args
        my array @args = ();
        push(@args, $self_obj);
        my int $ai = 0;
        while ($ai < $argc) {
            push(@args, eval_node($interp, $raw_args->[$ai], $env));
            $ai = $ai + 1;
        }

        # Look up method in parent classes only
        if (length($pkg) > 0 && exists($interp->{"inherits"}, $pkg)) {
            my scalar $parents = $interp->{"inherits"}->{$pkg};
            my int $pi = 0;
            while ($pi < size($parents)) {
                my scalar $fi = interp_resolve_method($interp, $parents->[$pi], $method);
                if (defined($fi)) {
                    return call_user_func($interp, $fi, \@args);
                }
                $pi = $pi + 1;
            }
        }

        die("SUPER::" . $method . " - no parent method found");
    }

    # --- Dynamic Method Call ($obj->$method_var(args)) ---
    if ($type == NODE_DYN_METHOD_CALL()) {
        my scalar $dm_node = $node->{"base_object"};
        if (!defined($dm_node) || $dm_node == 0) {
            $dm_node = $node->{"object"};
        }
        my scalar $obj = eval_node($interp, $dm_node, $env);
        my str $method = eval_node($interp, $node->{"method_expr"}, $env);
        my scalar $raw_args = $node->{"args"};
        my int $argc = $node->{"arg_count"};

        my array @args = ();
        push(@args, $obj);
        my int $ai = 0;
        while ($ai < $argc) {
            push(@args, eval_node($interp, $raw_args->[$ai], $env));
            $ai = $ai + 1;
        }

        my str $pkg = "";
        if (ref($obj) eq "HASH" && exists($obj, "__class__")) {
            $pkg = $obj->{"__class__"};
        }

        my scalar $func_info = undef;
        if (length($pkg) > 0) {
            $func_info = interp_resolve_method($interp, $pkg, $method);
        }
        if (!defined($func_info)) {
            $func_info = interp_get_func($interp, $method);
        }

        if (defined($func_info)) {
            return call_user_func($interp, $func_info, \@args);
        }

        die("Undefined dynamic method: " . $method);
    }

    # --- TR (transliteration $str =~ tr/from/to/) ---
    if ($type == NODE_TR()) {
        my scalar $target_node = $node->{"target"};
        my str $target_val = eval_node($interp, $target_node, $env);
        my str $search = $node->{"search"};
        my str $repl = $node->{"replace"};

        # Expand ranges in search and replace (a-z -> abc...xyz)
        my str $search_exp = expand_tr_range($search);
        my str $repl_exp = expand_tr_range($repl);

        # Build translation: for each char in target, check if in search
        my str $result = "";
        my int $ti = 0;
        my int $tlen = length($target_val);
        while ($ti < $tlen) {
            my str $ch = substr($target_val, $ti, 1);
            my int $found_idx = index($search_exp, $ch);
            if ($found_idx >= 0 && $found_idx < length($repl_exp)) {
                $result = $result . substr($repl_exp, $found_idx, 1);
            } elsif ($found_idx >= 0) {
                # If replacement is shorter, use last char
                $result = $result . substr($repl_exp, length($repl_exp) - 1, 1);
            } else {
                $result = $result . $ch;
            }
            $ti = $ti + 1;
        }

        assign_to($interp, $target_node, $result, $env);
        return $result;
    }

    # --- Local Declaration (dynamic scoping) ---
    if ($type == NODE_LOCAL_DECL()) {
        my str $lname = $node->{"name"};
        # Save current value on local stack
        my scalar $old_val = env_get($interp->{"global_env"}, $lname);
        my hash %save = ();
        $save{"name"} = $lname;
        $save{"value"} = $old_val;
        push($interp->{"local_stack"}, \%save);

        # Set new value
        my scalar $init = undef;
        if (defined($node->{"init"}) && $node->{"init"} != 0) {
            $init = eval_node($interp, $node->{"init"}, $env);
        }
        env_set($interp->{"global_env"}, $lname, $init);
        env_set($env, $lname, $init);
        return $init;
    }

    # --- BEGIN/END blocks (handled during load, skip in eval) ---
    if ($type == NODE_BEGIN_BLOCK()) {
        return undef;
    }
    if ($type == NODE_END_BLOCK()) {
        return undef;
    }

    # --- Label ---
    if ($type == NODE_LABEL()) {
        # Labels are handled by the loop constructs via label fields
        return undef;
    }

    # --- Goto ---
    if ($type == NODE_GOTO()) {
        my str $gt_dest = $node->{"target"};
        throw(make_signal("goto", undef, $gt_dest));
    }

    # --- Async func (treat as regular function in interpreter) ---
    if ($type == NODE_ASYNC_FUNC()) {
        my hash %fi = ();
        $fi{"params"} = $node->{"params"};
        $fi{"param_count"} = $node->{"param_count"};
        $fi{"body"} = $node->{"body"};
        $fi{"closure_env"} = $env;
        return \%fi;
    }

    # --- Await (in interpreter, just evaluate the expression) ---
    if ($type == NODE_AWAIT()) {
        return eval_node($interp, $node->{"expr"}, $env);
    }

    # --- Field Access ($obj->field without parens, same as method call) ---
    if ($type == NODE_FIELD_ACCESS()) {
        my scalar $obj = eval_node($interp, $node->{"object"}, $env);
        my str $field = $node->{"field"};

        my str $pkg = "";
        if (ref($obj) eq "HASH" && exists($obj, "__class__")) {
            $pkg = $obj->{"__class__"};
        }

        # Try as method call with no args
        my scalar $func_info = undef;
        if (length($pkg) > 0) {
            $func_info = interp_resolve_method($interp, $pkg, $field);
        }
        if (!defined($func_info)) {
            $func_info = interp_get_func($interp, $field);
        }
        if (defined($func_info)) {
            my array @args = ();
            push(@args, $obj);
            return call_user_func($interp, $func_info, \@args);
        }

        # Fallback: try hash access
        if (ref($obj) eq "HASH" && exists($obj, $field)) {
            return $obj->{$field};
        }

        die("Undefined field/method: " . $field);
    }

    # --- C Block (skip in interpreter) ---
    if ($type == NODE_C_BLOCK()) {
        # __C__ blocks cannot be interpreted
        return undef;
    }

    # --- Capture Variables ($1, $2, ...) ---
    if ($type == NODE_CAPTURE_VAR()) {
        my int $num = $node->{"number"};
        return captures()[$num];
    }

    # --- Spread (handled by caller) ---
    if ($type == NODE_SPREAD()) {
        return eval_node($interp, $node->{"target"}, $env);
    }

    # --- Extern Func (skip in interpreter) ---
    if ($type == NODE_EXTERN_FUNC()) {
        return undef;
    }

    # --- Use (already handled during load) ---
    if ($type == NODE_USE()) {
        return undef;
    }

    die("Unhandled AST node type: " . ast_type_name($type) . " (" . $type . ")");
}
